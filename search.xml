<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【测试人生】分享下自己对于平衡日常工作和学习提升的观点</title>
    <url>/2024/08/17/testlife/work_and_study/</url>
    <content><![CDATA[<p>日常工作总是琐碎的，尤其是技术岗，沉浸在日常的需求开发、需求测试和bugfix里，很容易对工作环境形成依赖，导致没有成长空间。那么这种情况下，怎么样去平衡日常工作和自我的学习提升呢？今天，笔者就通过这篇文章，分享下自己的观点。</p>
<p>核心的思想是：工作只是生活的一部分，要自己掌控自己的生活，不要让工作掌控自己的生活。要相信自己的直觉，不要过分消耗自己，坚持去做自我提升的事情，无论是不是通过工作去实现。</p>
<a id="more"></a>
<p>首先，我们需要知道自己真实的提升需求。赚钱、技术影响力，这些都是作为技术人可以自我提升的点。从工作的角度，赚钱是最终目的，但是技术上的成果和影响力，不仅是值得投入的中间产物，而且在社会生活当中也能够体现价值。这其中，就会涉及到两者之间的平衡。所以第一件事情是，先去思考自己真实需求是什么，是赚钱，是影响力，还是两手都要抓？决定一个大概的方向，然后再下手去决策。</p>
<p>然后，我们再去思考工作和生活的辩证关系。考虑工作这个事情，工作当中我们会遇到很多技术难题，我们一个个去解决了，这样可以提升我们的技术硬实力；遇到很多跨部门沟通的场景，我们出手去协调解决了，这样可以提升我们的社会生存能力；把一个技术成果做出来了，获得了高额的报酬，这样就可以赚更多的钱。所以整体来讲，工作这件事情，理论上是有自我学习提升以及社会价值提升的潜力的。</p>
<p>但是，从最终目的来讲，工作也是具有局限性的。抛开工作这个事情，如果想赚钱，那么不仅仅是通过技术的手段可以赚，还有很多其它的手段可以发掘，开网店、做直播、写小说，都可以成为赚钱的手段；技术影响力方面，单纯的工作很多场景下只能提升自己的内部影响力，只有主动去发博客、发教程，结合一些宣发手段，才能够更进一步提升自己的外部影响力。</p>
<p>这样看下来，工作之内和工作之外，都并不能直接说哪个事情对自己未来生活更好，但有一点可以确定的是，工作的很多事情是我们自己不可控的，而工作之外的事情，我们可以充分按照自己的意愿去投入。因此，我们需要重点关注工作之内的不可控的事情，这些事情的发展对我们未来的提升是有益的还是有害的。如果有益，工作可以带来自我技术提升、人脉升级，那么可以花时间投入；如果有害，直觉上令人内耗，那么应该考虑另寻他路，或者预备后手。</p>
<p>比如说，做测试，做质量，即便是在同一个领域，工作的内容、技术深度、职责scope等方面，都会有非常大的差异。最基础的工作是点点点软件测试，往上面就是去做测试工具，再往上面可能就会分成很多个方向，比如负责一块业务的产品和交付质量、负责部门级的工具平台架构建设、负责大业务线的GPT/代码分析技术建设等，再再往上也许是牵头做多条业务线的质量管理，或者是测试/质量/DevOps某个技术领域大方向的负责人。每个人都知道，往上的工作内容更加令人兴奋，更加利于成长，但是当下的工作，如果从职责上不是为下一个职级的工作做铺垫的话，那么就永远会框住自己。所以说，工作之余，一定要主动从更高维度，或者说旁观者/上帝视角，去评价自己的工作内容。这样才可以知道，工作这件事情能否为你的未来生活带来更多益处，能够在一段时间内抵消更多的生活风险，还是说在工作之外，主动寻求其他可能性，才是一条更合适的生存道路。</p>
<p>最后，还是一句话，比起平衡日常工作和学习提升，更上层的一个思路是，怎么平衡自己不可控的生活和自己可控的生活。解决方法是，自己可控的生活，以及不可控但为自己学习提升带来正反馈的生活，我们需要主动出击，让这两类事情去占据自己更多的时间！</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>教程</tag>
        <tag>测试开发</tag>
        <tag>质量管理</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】对低代码开发模式的一些思考和想法</title>
    <url>/2024/08/17/geekdaily/low_code_talk/</url>
    <content><![CDATA[<p>低代码这个名词说起来已经有些年头了，广义上来讲可以说是达到这么一种效果，即尽量减少通过编写代码的方式来完成研发任务，甚至部署交付整个技术产品。那么低代码模式到底值不值得弄，有什么优势和缺陷，本篇文章笔者就来聊一聊自己对于低代码的一些思考跟想法。</p>
<p>做技术的都知道，实际工作场合上，不能为了技术而技术。低代码也是一样，这门技术最重点解决的问题是，让不懂代码的人可以通过一套工具来完成自己开发的作品，所以从产品角度，低代码工具应当更加倾向于提升易用性，而非提升功能性。假设我要开发一个服务，我手写代码+手动部署需要3天，而学习低代码工具+完成服务搭建只需要1天，那么这种情境下，低代码工具就能够兑现自己的价值。</p>
<a id="more"></a>
<p>所以低代码模式值不值得弄，最先决的条件是，低代码所应用到的领域产品，是不是通过写代码的方式工作量非常大。好比说，我要渲染一些图形，那么就需要涉及复杂的数学计算，直接敲代码是非常困难的，但如果我有一些低代码工具，可以通过运算节点之间的关系描述计算过程，那么我就可以通过一些图形的拖拽，就可以达到渲染图形的目的。UE、Unity之类的游戏引擎都是这样做的，通过图形化的视图操作，减少了游戏开发者的工作成本。对于游戏、仿真领域而言，有时候不必做到非常严苛的效果，通过正向的运算流程意思一下即可，因此图形化的逻辑描述可能并不没有想象中那么复杂，反倒是正常的业务后端逻辑，充斥了很多防御性代码，并且可能链路比较长，这类场景就不适合用图形化的方式描述逻辑。</p>
<p>低代码模式要兑现价值，还有比较客观的因素是，所应用到的领域需要有一定的用户基础。低代码工具的维护量是非常大的，首先底层需要对代码本身以及业务流程之类的节点做封装，起到一个宏的作用，然后上层还需要做流程节点的图形化展现，并且还要做的美观易用，以尽力减少代码编写、节点配置以及领域理解成本，这些不是简单三五个人就很快做出来的，而且也得做的美观做的稳定才能够交付用户使用，否则用户也玩不转。如果说低代码工具所配合的产品用户量不大，那么即便做成了，时间成本也不一定能够被用户收益打平。从企业运营的角度来说，这一部分工作量还不如用来做更有价值的事情，比如对其他领域的产品创新，或者是已有产品的技术复用。</p>
<p>总的来说，低代码开发模式值不值得做，从技术上讲肯定是值得的，对于用户的收益是很明显的，但从企业运营还有研发团队发展角度来说成本会比较大，即便有用户收益也不一定能够抵消成本。所以如果要投入做低代码工具，最好产品本身有一定的用户基础和技术生态基础，这样才能锦上添花。</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>工具开发</tag>
        <tag>研发效能</tag>
        <tag>游戏开发</tag>
        <tag>低代码</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python随笔】比PyQt5更先进的pyside6安装和使用方法</title>
    <url>/2024/08/11/pythonnotes/pyside6_intro/</url>
    <content><![CDATA[<p>最近因为自研日常开发工具的需求，决定重新拾起PyQt5之类的桌面工具开发技术栈，为啥选用PyQt，一是因为笔者比较精通python，二是因为不需要在外观上做什么特别的东西。经过一番调研，发现当前的PyQt5版本已经过时，用pyside6会更加贴合现在的需求。因此笔者也简单部署了下pyside6的开发环境，通过这篇文章分享一下如何操作。</p>
<p>先强调一点是，所有的资料都可以在<span class="exturl" data-url="aHR0cHM6Ly9kb2MucXQuaW8vcXRmb3JweXRob24tNi9xdWlja3N0YXJ0Lmh0bWw=" title="https://doc.qt.io/qtforpython-6/quickstart.html">官网<i class="fa fa-external-link"></i></span>查到。如果有特别疑问的地方，参考官网，实在不行就stackoverflow或者gpt，也许可以更快解决问题。</p>
<a id="more"></a>
<p>首先是折腾项目工作区。从个人开发角度，笔者推荐所有的桌面开发项目都放在一个pyside6的工作区，并采用venv来安装pyside6相关库和工具。</p>
<p>pyside6的工具有很多，比如把ui文件转化为python代码的pyside6-uic，以及编辑ui的可视化工具pyside6-designer之类。如果是venv安pyside6的话，这些工具都集成到了<code>${project_dir}/.venv/bin</code>下面，有需要的话也可以export到path里，具体作用详细可以参考官网的<span class="exturl" data-url="aHR0cHM6Ly9kb2MucXQuaW8vcXRmb3JweXRob24tNi90b29scy9pbmRleC5odG1s" title="https://doc.qt.io/qtforpython-6/tools/index.html">这份资料<i class="fa fa-external-link"></i></span>。通过这些工具加上一些脚本，就能简单打通ui编辑-&gt;ui转码-&gt;代码编写-&gt;部署发布的开发链路（p.s. 部署发布相关的调研暂时不多）。</p>
<p>代码组织方面，推荐先是把工具类、业务逻辑和ui逻辑几个模块分离开，然后重要一点是，把ui生成代码和实际的window跟widget类给分开来，做到view和model的区分。这样一来是大小层次比较分明，不会出现循环引用的情况，二来是从ui生成的代码，也不会直接影响到已有代码的实现，做改动也是非常方便。以笔者的项目为例，笔者用一个app文件夹来存储所有业务逻辑，通过最外层的main.py驱动app运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
<p>然后在app的<strong>init</strong>.py启动整个项目</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">APP: Optional[QtWidgets.QApplication] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> APP</span><br><span class="line">    APP = QtWidgets.QApplication([])</span><br><span class="line"></span><br><span class="line">    window = MainWindow()</span><br><span class="line">    window.ensure_center()</span><br><span class="line">    window.show()</span><br><span class="line"></span><br><span class="line">    sys.exit(APP.exec())</span><br></pre></td></tr></table></figure>
<p>最后在每个ui类实现里面来初始化跟定义界面逻辑：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span><span class="params">(QMainWindow)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(MainWindow, self).__init__()</span><br><span class="line">        self.ui = Ui_MainWindow()</span><br><span class="line">        self.ui.setupUi(self)</span><br><span class="line"></span><br><span class="line">        self._init_actions()</span><br><span class="line">        self._init_widget()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_init_actions</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.ui.actionAbout.triggered.connect(self.show_about)</span><br><span class="line">        self.ui.actionExit.triggered.connect(self.close)</span><br><span class="line"></span><br><span class="line">        self.ui.actionSupport.triggered.connect(self.show_support)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_init_widget</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 主动set中心widget，后续可以通过配置化方式灵活设置不同的界面</span></span><br><span class="line">        self.setCentralWidget(ToolWidget())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closeEvent</span><span class="params">(self, event)</span>:</span>  <span class="comment"># 关闭窗口时触发</span></span><br><span class="line">        reply = QMessageBox.question(</span><br><span class="line">            self, <span class="string">'确认'</span>, <span class="string">'是否要退出程序？'</span>,</span><br><span class="line">            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,</span><br><span class="line">            QMessageBox.StandardButton.Yes)</span><br><span class="line">        <span class="keyword">if</span> reply == QMessageBox.StandardButton.Yes:</span><br><span class="line">            event.accept()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            event.ignore()</span><br></pre></td></tr></table></figure>
<p>以上便是一个简单的pyside6安装和使用方法。后面如果探索到一些新的东西，再拿出来分享～</p>
]]></content>
      <categories>
        <category>Python随笔</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>工具开发</tag>
        <tag>PyQt5</tag>
        <tag>Qt</tag>
        <tag>pyside6</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】Go语言学习干货——从零单排Golang系列合集</title>
    <url>/2024/08/11/geekdaily/gofromzero_collection/</url>
    <content><![CDATA[<p>在后端开发领域，Golang已经成为非常流行的编程语言之一，并且生态也非常成熟。虽然在应用规模上离Java还有一段距离，但其中很多编程技巧跟思路还是值得学习的，一是没有什么太多的coding约束，二是实际工作中也有可能用的上。</p>
<p>在近一两年，笔者的工作也逐渐从主python转为主go语言，对于Golang也有一些简单的学习心得。借助今天这个机会，也将《从零单排Golang》系列做了精编，整合成电子书对外发布。这个系列其实拖了比较久的时间才搞定，一开始因为做运维平台开发的需要，前几篇文章主要举了docker、k8s相关的一些实战案例，没有对Golang的基础原理做太多的深挖，然后也因为个人原因搁置了一段时间。但几年后因为转行，需要主Golang，于是也抽空把Golang的一些基本机制给深入探索了些。</p>
<p>总的来说，这个系列沉淀的都是自己的想法，没什么形而上学的东西，更多是从一个coding经验者转Golang的视角来撰写内容。不论你是初学Golang，还是从其他语言转过来，都可以参考这个系列，帮助你在学习Golang的过程中找到一些思路和灵感。</p>
<p>以下是相关资料：</p>
<a id="more"></a>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC91MDEzODQyNTAxLzg5NjI4NDM2" title="https://download.csdn.net/download/u013842501/89628436">《从零单排Golang》精编PDF<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9nb2Zyb216ZXJv" title="https://github.com/utmhikari/gofromzero">《从零单排Golang》GitHub源码<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wL2NhdGVnb3JpZXMvJUU0JUJCJThFJUU5JTlCJUI2JUU1JThEJTk1JUU2JThFJTkyR29sYW5nLw==" title="https://utmhikari.top/categories/%E4%BB%8E%E9%9B%B6%E5%8D%95%E6%8E%92Golang/">《从零单排Golang》原文系列<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vY29sdW1uLzcyOTcxNDQ1NjYyNTEwNDQ5MDI=" title="https://juejin.cn/column/7297144566251044902">《从零单排Golang》掘金专栏<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>后端开发</tag>
        <tag>编程</tag>
        <tag>教程</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】Golang一个的slice数据替换的bug排查</title>
    <url>/2024/07/20/geekdaily/golang_slice_bug/</url>
    <content><![CDATA[<p>上周某天下班前，接到同事转来一个bug要排查，症状是代码重构之后某些业务效果不符合预期，由于代码重构人是笔者，于是blame到笔者这边。经过10min左右的排查和尝试后，解决了这个问题：既往逻辑没有改动，重构时候出笔误了。</p>
<p>简单来讲，重构之前的代码大概是这个样子：</p>
<a id="more"></a>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">beforeRefactor</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> configListExpr = fetchConfigListExpr()</span><br><span class="line">    </span><br><span class="line">    newConfigListExpr := replaceConfigVariables(configListExpr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> configList []Config</span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal([]<span class="keyword">byte</span>(newConfigListExpr), &amp;configList); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"unmarshal configList err: "</span> + err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> configList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而改造业务逻辑时，因为类似于replaceVariables这类对configList批量处理的流程更多，所以定义了很多函数节点去对configList做批量的替换以及内部属性的修改。因此重构时候，就把replaceConfigVariables做了更细粒度的转换，然后同时把整个configList替换逻辑也顺带修改了下。大概改成了这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">afterRefactor</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> configList []Config = fetchConfigList()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, config := <span class="keyword">range</span> configList &#123;</span><br><span class="line">        urlList := config.URLList</span><br><span class="line">        newURLList = replaceURLListVariables(urlList)</span><br><span class="line">        config.URLList = newURLList</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> configList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是存在问题的。由于这次重构提的代码很多，cr时候没有发现；然后一开始排查以为是重构引起的业务逻辑变更，所以忽略了Golang本身机制导致的问题。这里的问题是，遍历slice的时候，要想改动原来slice里成员的属性，不应该用config这个复制品，而得用configList取下标这种方式来取到原始的成员实例，或者干脆把configList整个全新替换，这样才可以达到效果。</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>重构</tag>
        <tag>slice</tag>
        <tag>bug</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>【架构艺术】大规模业务逻辑迁移实践</title>
    <url>/2024/07/20/archiart/large_scale_migration/</url>
    <content><![CDATA[<p>对于一个成熟的工程项目而言，因为项目未来发展或是和企业内部更深度融合的需要，我们可能需要对既有业务逻辑做很大规模的改动，涉及到多方面的逻辑迁移和代码重构，才能够达到下一代产品所需要的效果。</p>
<p>今天这篇文章，就来剖析一下如何做好这件事情，尤其是在历史积淀非常厚重的场景，需要通过怎么样的手段，把这个问题解决好。</p>
<a id="more"></a>
<p>首先第一件事情是，了解背景。为什么要做这件事情，它对于团队和公司的业务价值以及技术层面的价值在哪里？从一个打工人的视角，一个大规模的业务逻辑迁移，背后一定是有大团队甚至公司层面的底层逻辑在牵引，如果作为负责人不去了解底层逻辑，那也就不好把握业务迁移的方向，最终就有满足不了技术跟产品效果的风险。</p>
<p>好比说，从业务角度，通过优化性能和线上表现问题，明确历史遗留潜规则，提升用户使用体验，减少用户适应成本，提升工程项目在公司内部的影响力，成为更加统一化的标准。这些都可能是这个项目做大规模迁移的理由。然后，从技术角度上，比如通过重构代码，整个项目能够呈现更加干净简洁的代码实现，更加统一的关系结构和逻辑思路，更高内聚，更易扩展，提升项目代码和服务架构的可扩展潜力。这些也都是业务迁移工作可以随之带来的技术价值。充分了解完这件事情的背景之后，我们就可以更加精确地下手。</p>
<p>做业务逻辑迁移，最重要的一点是，要维持原先的产品表现。为了达到这个效果，我们可以考虑很多种技术手段，比如代码重构就是一种最直接的方式。但是，除了代码重构之外，有没有更好的方式？比如重新写一个工程，或者把某些模块作为单独的服务拆分出来？或者说，在当前这个场景下，为什么重构既有代码是最好的解决方式？有什么理由可以论证这一点？这些，都是在准备工作过程中需要思考的问题。</p>
<p>有些时候，为了满足咱们负责人自身的技术信仰和控制欲，重写工程就是一种最完美的手段。但是，重写工程耗时耗人力非常大，并且会改变用户习惯，所以现实上不一定是最好的方法。但如果说，既往工程和某些特定的场景耦合度太高，但代码质量太差，导致代码无法拆分，技术层面上完全不满足要求。这个时候，就可以考虑重写，不仅可以实现效果，也可以解决很多以往的技术问题，一举两得。</p>
<p>拆分服务，也是一个可以选择的举措，但前提是要重构的部分是独立的模块，容易被单独提出来。如果说既往的代码关系繁杂，存在很多潜规则，内部之间存在很多一时半会不能厘清的依赖，那么在业务逻辑升级期间，同时盲目拆分服务，也是具有风险的，所以一个合适的举措是先重构既有代码，再在重构的基础上去拆。此外，拆分服务本身也会引入额外的服务架构复杂度，所以一定要明确拆分服务可以解决的问题，比如说加快部署速度，减少非核心模块对L0服务带来的影响，都可以成为拆分服务带来的价值。</p>
<p>所以最终，业务逻辑迁移，还是必然会走到代码重构环节。那么重构要怎么做？怎么样能够保证重构先后，用户体验不受影响？有一个合适的思路是，通过配置开关，控制业务逻辑走到既往的链路，还是升级后的链路。当然在此之前，我们需要了解整个代码的脉络，业务链上每一个环节的职责，然后需要对每个环节构造测试用例，什么场景测什么，以便在重构时候可以随时验证。对于配置的开关，也不单纯是一个true-or-false的粒度，粒度可以设置的更细，更加倾向于一个灰度filter的设计——在业务逻辑的前置判断中，如果灰度则走新的逻辑，没有被白就是走老的逻辑。通过开关机制，我们可以兼容业务迁移过程的各类中间态，从而满足用户无感的需要。</p>
<p>这里需要注意的一点是，由于中间态的存在，那么在内测和灰度过程中，势必有很多需求需要双写到老的逻辑和新的逻辑。多人开发场景下，如果团队内部没有对齐这个口径，那么就会有新老逻辑效果不一致的风险。要解决这个问题，就需要保证团队内部对这件事情也能达成一些共识，尤其是需要同步这次迁移对于团队内成员做开发工作的影响。通过减少口头上的信息差，从而减少代码上的信息差。</p>
<p>之后是迁移的执行。大规模的业务逻辑迁移总是有风险的，因此从产品角度，对核心用户同步风险，做公告周知，对所有用户同步迁移事项以及需要改变的用户习惯，都是一个责任人需要做的事情。在迁移实操方面，也需要做到有内测、灰度放量、全量放量的过程，好比说涉及到数据迁移，放量可以遵循10%-&gt;30%-&gt;60%的原则，策略方面可以根据用户的体量和不同业务的数据存储量来决定具体放量的内容，这样就兼顾数据迁移的效率和安全性。</p>
<p>当然，比起对外周知风险，对内也需要做好稳定性保障，保障业务逻辑迁移过程中风险尽量减少。首先，我们可以通过一系列业务监控和服务监控来做一个大致的把握，比如业务指标方面观察事务成功/错误率，事务/结果量级的变化，服务监控关注latency、错误日志、错误请求、panic崩溃以及cpu/memory之类通用容器的监控。其次，对于业务效果，我们也可以在某些走新业务逻辑的case里，同时灰度一些用户无感的老业务逻辑流程，做一下abdiff，从而直观对比最终的迁移效果。通过这些手段，就可以在线上迁移之前，尽可能在线下发现更多的问题，减少线上风险。</p>
<p>最后一点，就是大规模的迁移，最好是和原来的效果保持一致，原则上尽量不要引入其他业务机制层面的的革新。用户对于产品的玩法是丰富多样的，甚至比产品更了解产品，比如游戏，玩家的攻略能力永远领先于游戏策划，玩家发现bug的能力永远领先于游戏测试。迁移过程本身就可能会改变很多用户习惯，所以如果迁移之后，还顺带做一些机制上的革新，那就有违背用户习惯的风险，最终就会导致产品表现不符合预期。如果一定要在迁移期间做一些机制上的变动，那么在线下就需要做充分的用户行为调研，否则建议是在迁移之后，根据用户具体的反馈，再选择性下手。</p>
]]></content>
      <categories>
        <category>架构艺术</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>架构</tag>
        <tag>重构</tag>
        <tag>数据迁移</tag>
        <tag>稳定性</tag>
      </tags>
  </entry>
  <entry>
    <title>【架构艺术】代码架构治理之四层境界</title>
    <url>/2024/06/02/archiart/code_architecture_thinkings/</url>
    <content><![CDATA[<p>最近逐渐开始写一些简单且稍微务虚的文章。原因有挺多，其一是，自己的工作内容和企业的内部情况绑定的更加深入了，许多信息如果要在互联网上分享，需要考虑在很多地方做加工；其二是，过分拘泥于非常深度的技术挖掘，可能只能涉及到一些特定的领域，不利于技术博客的持续运营，并且从读者的视角，形式简单但内容富有思考的干货，才是真正有价值的产出。</p>
<p>因此，今天这篇文章，就从笔者自己的角度，谈一下代码架构治理的四层境界，把读者自己最深层的思考内容给解剖出来。希望这篇文章能够帮助到一些在代码架构治理工作方面，感受到痛点的同行们，让大家可以通过文章提到的一些思维工具，去解决实际工作中代码架构治理方面的问题。</p>
<p>这四层境界分别是：</p>
<ol>
<li>套设计模式</li>
<li>自上而下需求拆解</li>
<li>自底向上模块抽象</li>
<li>网状概念聚类分层</li>
</ol>
<a id="more"></a>
<p>第一层境界是套设计模式。犹记得刚开始接触代码工程架构的时候，我们都被灌输了很多设计模式相关的概念，小到工厂、责任链，大到DDD、BDD。这些看起来很高大上的名字，它们的实质是什么？是工具，是最为基础的代码架构思维工具。一个工具要有用武之地，必然有其背后合适的业务场景。理论上来讲，大多数的代码架构问题，通过套设计模式，遵循基本的重构原则，都是可以解决的。</p>
<p>设计模式不能解决的问题是什么呢？答案是：未知的领域。通俗地理解，设计模式就是前人已有的经验，在某类业务或者技术场景之下，沉淀出来的一套代码范式。但面对未知的领域，以前的设计模式是否可以起作用，哪些设计模式最为适合，都不是能够直接无脑确定的。未知的领域背后，本质上是未知的概念联系，如果直接套用某类设计模式，那么将来如果引入新的需求场景，既往的设计模式不适用，就会出现重构成本。</p>
<p>现今有很多技术同行的简历或者PPT上，都可能写通过DDD、BDD的思想，解决了某类技术问题。从笔者的角度认为，不同领域的概念模型其实是五花八门的，如果真的某类场景用了经典方法解决，要么是这类场景已经被研究透了，架构层面缺乏创新潜质，要么是自身实力不足，对技术缺乏独立思考，没有能力去灵活调配代码的架构，只能通过既有的思维去生搬硬套。如果有意识在简历或PPT重突出这类信息，这样的人才，假使面对未知的业务或技术领域，一定很难有能力去cover住代码架构。套设计模式的是一类人，如今，套GPT的也是这一类人。</p>
<p>第二层境界是自上而下需求拆解。需求拆解可以解决未知领域代码建模的问题，弥补纯设计模式的不足。做代码架构，本身即是对某类业务或技术场景的建模，当我们需要解决某些具体的问题时，一个最简便的办法是对需求本身做拆解，比如用金字塔模型，把大的问题划分为小的问题，然后分而治之。这样的一个好处是，我们很容易去构建出模块化、低耦合的代码架构模型，因为每一个需求的子问题都可以用单独的一套代码去解决。并且，在协同开发场景下，还能够保证各司其职，互不干扰，形成一套很完善的开发体系。</p>
<p>自上而下需求拆解，解决不了的问题是什么？答案是：认知的一致性。在<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjQvMDIvMTUvYXJjaGlhcnQvc3VzdGFpbmFibGVfYXJjaGl0ZWN0dXJlLw==" title="https://utmhikari.top/2024/02/15/archiart/sustainable_architecture/">先前的一篇文章<i class="fa fa-external-link"></i></span>里，通过一个自动化框架的例子就说明了这个道理，需求拆解是自上而下的，但技术实现是自底向上的。为什么要自底向上，其本质诉求就是在工程初始化环节，把最基础的认知概念给统一抽象起来，认知的一致性越多，代码需要受迫维护的内容就会越少。如果在工程代码开发方面，无脑通过需求拆解的方式构建不同的模块，那么必然会出现很多具备重复意义的代码。久而久之，就会形成技术债。</p>
<p>因此，要解决这个问题，我们需要踏入第三层境界，自底向上模块抽象。当需求自上而下拆解完成后，还有一个重要步骤是，把最底层需求涉及的共性概念给抽象出来，构建成一套公用基架。这套基架不仅是提升了代码的易维护性，而且更重要的，是决定了这个领域的基本概念认知。以游戏开发为例子，一个客户端研发团队，除了业务Gameplay研发的成员之外，一定还有部分成员会专攻游戏引擎的研发，去做好整块客户端代码的基架。有了这个基架，就不容易出现你实现一套，我实现一套的问题，从而让整个工程架构的底层逻辑都通顺起来。</p>
<p>对于一些小的研发团队，或者是个人开发者，在工程代码的呈现方面，很容易出现踏入第二层境界，但无法踏入第三层境界的情况，导致工程能力不能长久迭代。解决这个问题的方法就是，下手慢一拍。如果是在时间紧张的情况下，需要注意在写完demo期代码之后，顺便构思好代码重构的路径，留有后手。做出10分，交付7分，这样就能够保证工作产出的弹性。</p>
<p>当然，自底向上模块抽象，也有解决不了的问题，那就是概念分层。如果一味陷入共性抽象，一味通过【加一层】的方法解决技术问题，就容易出现层次冗余，难以重构的情况。一套抽象下来，看起来代码可读性不错，但整个工程的内在结构太复杂，就会导致可读性不高。虽然每块代码的责任是分明了，但不同模块之间的关系很不清晰。A调了B，B调了C，C又调了A，从而导致代码之间出现循环依赖的风险。然后，哪天项目需要升级了，要么就是弄个V2，要么还往原来的层次上加，这样就会降低整个项目的可迁移可复用能力。</p>
<p>要解决这个问题，我们就需要踏入第四层境界，网状概念聚类分层。我们需要了解一个本质是，不论是那种业务或技术领域，底层概念之间的关系，都是网状结构的。通过纯代码的方式，不可能模拟网状结构的概念，但是我们可以通过聚类分层的方式，把一些同质的概念放到相同的层次，并且同时保证层次的数量尽量少，从而在尽可能简明工程架构的同时，达到需求预期的效果。</p>
<p>那么，如何去把聚类分层这个事情给做好呢？一个重要的关键点就是，根据不同的视角，来划分不同的层次。举个例子，一个后端服务，从服务框架的视角，可以分出来handler/service/dal/util几个层次；从业务视角，可以在service内部，分出来app/core/3rd等几个层次（当然，微服务的话，可以把3rd提到外面，app跟core都不要）。基本上一个后端项目，代码最多3～4层就可以解决问题，如果还存在需要加一层的情况，就从更高的服务架构维度去解决，而不是再拘泥于已有的代码项目。</p>
<p>分清每块代码的责任很重要，但如何构建每块代码的层次梯度也很重要。解决了低耦合问题，也要解决高内聚问题，这样才能让整个代码的架构变得游刃有余。</p>
]]></content>
      <categories>
        <category>架构艺术</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>架构</tag>
        <tag>重构</tag>
        <tag>设计模式</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>【DIY小记】深圳万象天地餐馆探店点评</title>
    <url>/2024/05/12/diymemo/sz_wxtd/</url>
    <content><![CDATA[<p>第一次在技术博客里面写生活日记，也算是破了个小天荒。个人以为，博客是个人生活思考的载体，而技术只占生活的一部分，那么博客里为什么一定要限制只能够写技术内容，不能写点其它生活上的东西呢？思来想去，近几年在<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQjglODclRTglQjElQTElRTUlQTQlQTklRTUlOUMlQjAvMTA2Nzg1OTg=" title="https://baike.baidu.com/item/%E4%B8%87%E8%B1%A1%E5%A4%A9%E5%9C%B0/10678598">深圳万象天地<i class="fa fa-external-link"></i></span>和她一起探过不少餐馆，吃过不少东西。于是乎，决定写一篇万象天地餐馆探店点评，给没来过或者想来深圳万象天地的人一些参考，少点踩坑。</p>
<p>本文评价纯粹综合她和自己的主观意见，胃口分布于北京、江南跟广东，稍偏咸口。有些店可能很长时间没去了，所以只能基于主观印象给分。满分5星，4星以上推荐在线下做多刷。详细评分内容如下:</p>
<a id="more"></a>
<p><img src="/uploads/diymemo/sz_wxtd/wxtd_score.png" alt="评分表格"></p>
]]></content>
      <categories>
        <category>DIY小记</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>生活</tag>
        <tag>用户</tag>
      </tags>
  </entry>
  <entry>
    <title>【DIY小记】用爬虫+clean-mark+zhihu-on-vscode搬运技术博客到知乎</title>
    <url>/2024/05/01/diymemo/zhihu_blog_migrate/</url>
    <content><![CDATA[<p>今天灵光一闪，决定调研一下自己的技术博客，可以怎样方便迁移到其它社媒平台。想要达到的效果是，把自己在掘金的专栏：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vY29sdW1uLzcyNDAzMzM3NzkyMjMzMzA4NzI=" title="https://juejin.cn/column/7240333779223330872">从1到∞精通Python<i class="fa fa-external-link"></i></span>，迁移到知乎上面去。</p>
<p>简单花了两三小时时间，找到一个比较快捷的方法，就是结合python爬虫、clean-mark工具和zhihu-on-vscode插件，实现从掘金到知乎的文章搬运。</p>
<a id="more"></a>
<p>首先是爬虫，给定一个掘金专栏的url，直接get就能拿到整个网页信息，包括这个专栏的标题、描述还有所有文章的标题跟URL。用BeautifulSoup写个50行左右解析一下，就能够把所有信息给拿出来。</p>
<p>然后是用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nyb3Fhei9jbGVhbi1tYXJr" title="https://github.com/croqaz/clean-mark">clean-mark<i class="fa fa-external-link"></i></span>，遍历所有的文章url，就能够把所有文章的markdown给拿出来。</p>
<p>最后是用zhihu-on-vscode插件，把markdown文件直接上传到知乎。知乎平台本身不支持复制markdown文本，但支持导入markdown文件。这个插件把知乎的平台交互收敛到了vscode里，并且能直接上传markdown到专栏，非常方便。</p>
<p>通过这三个工具的结合，笔者花了一个上午，就实现了所有Python专栏文章的搬运。新专栏的链接在<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL2NvbHVtbi9jXzE3NjkwMzY5NTI2ODUzNzk1ODU=" title="https://www.zhihu.com/column/c_1769036952685379585">这里<i class="fa fa-external-link"></i></span>，如果你想彻底拿捏Python，那这个就是你的菜。</p>
]]></content>
      <categories>
        <category>DIY小记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>BeautifulSoup</tag>
        <tag>clean-mark</tag>
        <tag>zhihu-on-vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】读2023美团技术年货的一些笔记</title>
    <url>/2024/05/01/geekdaily/meituan_tech_notes/</url>
    <content><![CDATA[<p>正直劳动节，翻了下2023年美团的<span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjQvMDIvMDEvMjAyMy1zcHJpbmctZmVzdGl2YWwtcHJlc2VudC5odG1s" title="https://tech.meituan.com/2024/02/01/2023-spring-festival-present.html">技术年货<i class="fa fa-external-link"></i></span>，挑选了一些和变更风险防控和稳定性建设相关主题的文章做了下浅读。本文仅简单记一下阅读笔记。</p>
<p>总共选读了3篇文章，分别是《基于AI+数据驱动的慢查询索引推荐》、《代码变更风险可视化系统建设与实践》，以及《AIOps在美团的探索与实践——事件管理篇》。</p>
<a id="more"></a>
<p>第一篇是AI推荐慢查询索引。实现推荐主要的方式是，收集大量线上SQL的索引引用数据，作为训练集，再根据线上慢查询的实际情况，去推断补充哪一组索引比较合适。这个方案可以作为慢查询治理的一个环节，并且通过相似库表的索引分析，甚至在慢查询没有出现的情况下“治未病”，而不是等到慢查询实际出现后再做紧急修复。从这个角度来看是挺有价值的。</p>
<p>第二篇是代码风险可视化建设。实际阅读的时候，比起代码分析的技术，会更加关注这套可视化能力所赋能的场景。从变更风险防控角度，变更影响面分析一直是一类难点，这套方案则从代码工程类型、风险特征识别、可定制化风险、单服务/跨服务影响等层面做了多维度的分析，并且这些分析内容可以额外辅助到配置变更影响判断和接口自动化用例推荐上，整体来看可应用的场景比较广泛。</p>
<p>同时，在代码风险可读性方面，提供了上下游跳转和实时链路拓扑的试图，从CR的角度来说也是非常及时的，而不是等到变更上线的时候再给一个血缘分析的影响面视图。</p>
<p>第三篇是AIOps在美团的探索与实践，主要侧重于事件管理部分。变更事件是理解变更过程的核心信息来源，但存在数据复杂多样化、领域知识强等复杂的问题。从事件管理角度，美团给出了风险预防、故障发现、事件处理和事件运营等几个维度的能力。</p>
<p>在风险识别方面，主要依赖配置文本/结构合法性检查以及灰度&amp;未变更&amp;历史变更的ABDiff去探测指标异常。在故障发现和事件处理方面，主要通过异常链路拓展视图、相似事件推荐，帮助变更人及时看清线上问题，找到可借鉴的解决方案。在事件运营方面，则提供了一套复盘系统。整体来看，能够满足变更风险管理的基本诉求。</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>变更风险</tag>
        <tag>AI</tag>
        <tag>质量管理</tag>
        <tag>慢查询</tag>
        <tag>AIOps</tag>
      </tags>
  </entry>
  <entry>
    <title>【DIY小记】用OCR和大模型GPT生成的《软件研发效能权威指南》读书笔记</title>
    <url>/2024/04/21/diymemo/devops_ai_memo/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8zNjExNjM3NS8=" title="https://book.douban.com/subject/36116375/">《软件研发效能权威指南》<i class="fa fa-external-link"></i></span>一书，对于软件研发效能DevOps领域做什么事情，解决什么问题，给出了非常全面详尽的说明。这本书的精华，基本全部都浓缩在一张附属的海报上，海报讲述了每个章节的精简摘要，可以说是现成的读书笔记。</p>
<p>2024年，相对于古早的纸质载体，用电子作为载体的文献在维护上成本更为低廉，并且也逐渐成为了最优的文献阅读方案。因此，顺带借着AI的东风，笔者决定用AI技术，将这份海报转化成一份电子版的读书笔记，通过OCR识别+GPT润色+人工校对，把这本书所有的精华给摘录下来。</p>
<p>以下，便是读书笔记的正文。</p>
<a id="more"></a>
<h2 id="第1章-研发效能概述"><a href="#第1章-研发效能概述" class="headerlink" title="第1章 研发效能概述"></a>第1章 研发效能概述</h2><h3 id="1-1-研发效能的定义、目标及解决的问题"><a href="#1-1-研发效能的定义、目标及解决的问题" class="headerlink" title="1.1 研发效能的定义、目标及解决的问题"></a>1.1 研发效能的定义、目标及解决的问题</h3><p>研发效能，指的是在研发过程中实现高效、高质量、可靠和可持续的业务价值交付的能力。这既涉及确保“做正确的事情”，也强调“正确地做事情并追求速度”。在组织层面，研发效能的核心在于通过优化流程和工具，提升团队的产出效率和质量。而在个人层面，它更注重个人的能力成长和聪明地工作，而非仅仅是投入的努力。随着软件规模和复杂性的提升，研发效能需要解决如何保持高效并减缓效能恶化的挑战。</p>
<h3 id="1-2-研发效能的实践框架"><a href="#1-2-研发效能的实践框架" class="headerlink" title="1.2 研发效能的实践框架"></a>1.2 研发效能的实践框架</h3><p>构建研发效能的“黄金三角”，涵盖效能实践、效能平台和效能度量三个关键部分，三者相互促进，共同提升研发效能。坚持正确的价值主张，确保在做正确的事情的同时，也追求正确的工作方式。效能实践应因地制宜，以解决瓶颈为目标，持续改进。效能平台应满足研发场景需求，注重工具间的连通性。效能度量则应指导并驱动有效的效能提升，基于数据驱动和实验思维进行。</p>
<h3 id="1-3-研发效能的实施策略"><a href="#1-3-研发效能的实施策略" class="headerlink" title="1.3 研发效能的实施策略"></a>1.3 研发效能的实施策略</h3><p>实施研发效能提升时，应注重解决实际的研发“痛点”和问题，避免形式主义或虚假繁荣。这需要业务研发团队、工具平台团队、效能专家或教练团队以及组织级研效管理团队共同协作。明确各自的角色和职责，确保策略在不同场景下的灵活性和实用性。同时，研发效能应服务于业务，而非让业务迁就效能。</p>
<h3 id="1-4-研发效能的核心价值观和常见误区"><a href="#1-4-研发效能的核心价值观和常见误区" class="headerlink" title="1.4 研发效能的核心价值观和常见误区"></a>1.4 研发效能的核心价值观和常见误区</h3><p>研发效能的核心价值观包括以业务价值为导向、优化全局流动、追求工程卓越和善用数据思维。在实施过程中，应避免的常见误区包括缺乏系统化规划、盲目推行一致性、形式主义工程实践、忽视上下文差异照搬方案、忽视开发者体验以及不恰当使用度量等。</p>
<h2 id="第2章-需求及敏捷协作领域实践"><a href="#第2章-需求及敏捷协作领域实践" class="headerlink" title="第2章 需求及敏捷协作领域实践"></a>第2章 需求及敏捷协作领域实践</h2><h3 id="2-1-业务探索"><a href="#2-1-业务探索" class="headerlink" title="2.1 业务探索"></a>2.1 业务探索</h3><p>通过商业模式画布明确目标客户，提出合理解决方案，并探索差异化竞争优势。运用设计思维与用户共情，定义用户问题并探索创新点子。利用影响地图连接业务目标与实现方式，明确行动计划和所需特性。规划产品路线图，确保产品目标与特性开发的时间表和努力相匹配。以最小化可行产品（MVP）为起点，通过“构建-衡量-学习”循环进行快速迭代和优化。利用精益数据分析驱动产品决策，持续改进并满足用户需求。</p>
<h3 id="2-2-精益需求"><a href="#2-2-精益需求" class="headerlink" title="2.2 精益需求"></a>2.2 精益需求</h3><p>采用条目化的用户故事表达精益需求，确保需求具有3C特征和INVEST原则。通过故事树结构管理产品全量和不同层级的需求，保持需求的层次结构和清晰性。精益需求通常采用2~3层结构，如业务需求-产品需求-工作任务，以确保需求的明确性和可管理性。</p>
<h3 id="2-3-实例化需求"><a href="#2-3-实例化需求" class="headerlink" title="2.3 实例化需求"></a>2.3 实例化需求</h3><p>使用“假定（Given）-当（When）-那么（Then）”的语言将需求描述为实例，确保需求真实可测且包含非功能性需求。在需求说明中结合实例和领域建模，提高需求的理解和实现效率。</p>
<h3 id="2-4-敏捷协作"><a href="#2-4-敏捷协作" class="headerlink" title="2.4 敏捷协作"></a>2.4 敏捷协作</h3><p>基于敏捷宣言的价值观和原则进行协作，促进团队高效沟通和协作。敏捷协作在规模为10人左右的小规模敏捷团队中最为有效，有助于提升团队的响应速度和创新能力。</p>
<h3 id="2-5-可视化管理"><a href="#2-5-可视化管理" class="headerlink" title="2.5 可视化管理"></a>2.5 可视化管理</h3><p>运用波特价值链分析方法，深入剖析研发过程中的基础性与支持性活动。通过价值流图，映射并展示研发过程中价值的流动路径。借助看板，实现产研全流程的直观可视化，便于团队成员快速了解进度和状态。同时，运用累积流图等统计分析工具，深入挖掘看板中的关键信息，为决策和优化提供依据。</p>
<h3 id="2-6-规模化敏捷交付"><a href="#2-6-规模化敏捷交付" class="headerlink" title="2.6 规模化敏捷交付"></a>2.6 规模化敏捷交付</h3><p>围绕价值流，我们组建了一支由多个小规模敏捷团队构成的大规模敏捷团队。规模化敏捷架构的核心任务是解耦，力求去除不必要的规模化元素。对于不频繁、影响大、实施时间长的举措，我们会在管理层决策后，将其拆解成更小、更易于管理的需求。在规模化的敏捷流程中，我们强调节奏的一致性，确保全员同步启动、计划和迭代交付。同时，我们需要一个端到端的敏捷DevOps平台，以支持多个小规模敏捷团队的协作体验，以及大型解决方案的持续交付。</p>
<h2 id="第3章-开发领域实践"><a href="#第3章-开发领域实践" class="headerlink" title="第3章 开发领域实践"></a>第3章 开发领域实践</h2><h3 id="3-1-分支模型"><a href="#3-1-分支模型" class="headerlink" title="3.1 分支模型"></a>3.1 分支模型</h3><p>分支模型是配置管理的核心组成部分，对于团队协作管理至关重要。常见的分支模型包括主干分支开发模型和特性分支开发模型。团队应根据业务特点、团队规模及当前阶段选择最适合的分支模型，形成符合自身的最佳实践。没有绝对理想的分支模型，只有最适合团队现状和上下文环境的模型。</p>
<h3 id="3-2-本地开发"><a href="#3-2-本地开发" class="headerlink" title="3.2 本地开发"></a>3.2 本地开发</h3><p>高效本地开发的宗旨在于提升开发者的编码效能，减少阻碍和不必要的干扰。建立规范化和自动化的研发流程是实现高效开发的关键，也是持续优化和投入的重点。在构建高效开发环境时，我们遵循以下原则：建立符合团队特点的研发规范；利用资源换取时间；实现服务化、自助式的环境获取；确保环境的一体化和一致性。</p>
<h3 id="3-3-云开发"><a href="#3-3-云开发" class="headerlink" title="3.3 云开发"></a>3.3 云开发</h3><p>云开发是解决本地资源不足、开发环境差异以及云原生环境下开发挑战的有效手段。云开发涉及共享云端环境、基于K8s Namespace的隔离开发环境和基于Istio Mesh的逻辑隔离开发环境。此外，通过容器应用热加载，我们可以实现云端开发编码的实时生效，进一步提高开发效率。</p>
<h3 id="3-4-代码平审"><a href="#3-4-代码平审" class="headerlink" title="3.4 代码平审"></a>3.4 代码平审</h3><p>代码评审是质量内建的核心实践之一，体现了工程师文化的基石。不同类型的代码评审实践具有各自的特点，适用于不同的上下文环境。在进行代码讲审时，我们既要关注业务价值的正确交付，也要考虑代码的长期可维护性。</p>
<h3 id="3-5-单元测试"><a href="#3-5-单元测试" class="headerlink" title="3.5 单元测试"></a>3.5 单元测试</h3><p>单元测试是测试左移的关键实践之一，为高质量测试策略奠定了基础。我们应同等对待单元测试代码与业务代码，关注其可维护性、测试有效性、执行时间和稳定性。单元测试的推进是一项长期投资，需要结合团队现状，循序渐进地持续提升。</p>
<h3 id="3-6-代码扫描"><a href="#3-6-代码扫描" class="headerlink" title="3.6 代码扫描"></a>3.6 代码扫描</h3><p>代码扫描能够在早期发现代码问题，从而降低解决成本。修正代码扫描发现的问题与修复代码缺陷类似，都需要通过回归测试来验证。在实施代码扫描时，我们应保持灵活和因地制宜的态度，避免盲目引入导致团队负担增加。</p>
<h3 id="3-7-编译构建"><a href="#3-7-编译构建" class="headerlink" title="3.7 编译构建"></a>3.7 编译构建</h3><p>优秀的团队应每天自动化完成最新的代码构建并发布到测试平台。针对传统本地编译构建的问题，业界已发展出分布式构建、编译缓存和云端构建等技术。在选择编译构建平台时，我们应关注其接入成本，尽量实现无侵入式接入。编译构建的优化是一个不断迭代的过程，而编译过程的可视化则为持续优化提供了数据支持。</p>
<h3 id="3-8-架构设计"><a href="#3-8-架构设计" class="headerlink" title="3.8 架构设计"></a>3.8 架构设计</h3><p>架构设计的质量对需求、开发、测试和运维等大部分研发效能领域的提升起着决定性作用。架构设计的初衷不是为了满足模式和原则，而是在深入理解和分析业务目标后，设计或选取与目标高度关联的最优解。</p>
<h3 id="3-9-低代码应用"><a href="#3-9-低代码应用" class="headerlink" title="3.9 低代码应用"></a>3.9 低代码应用</h3><p>低代码，作为一种可视化的软件开发方式，有效缩短了研发周期，并显著降低了研发成本。这种方法中，可视化流程和可视化改丰机是常用的技术手段。在国机代配程节点中，植入与配置质量卡点，是推动质量左移和右移的关键实践。</p>
<h3 id="3-10测试驱动开发"><a href="#3-10测试驱动开发" class="headerlink" title="3.10测试驱动开发"></a>3.10测试驱动开发</h3><p>测试驱动开发是一种强调测试在先、编码在后的开发实践。它确保了代码的微观质量，真正实现了质量内建的目标。测试驱动开发原则包括：先写测试代码，再写产品代码；只允许编写能够导致失败的单元测试；以及只允许编写刚好能够导致一个失败的单元测试过的产品代码。</p>
<h2 id="第4章-测试领域实践"><a href="#第4章-测试领域实践" class="headerlink" title="第4章 测试领域实践"></a>第4章 测试领域实践</h2><h3 id="4-1-测试环境管理"><a href="#4-1-测试环境管理" class="headerlink" title="4.1 测试环境管理"></a>4.1 测试环境管理</h3><p>稳定且完备的测试环境是自动化任务执行的重要保障。测试环境管理不仅是某个部门或角色的责任，每个人都既是测试环境的使用者，也是其建设者。通过基准环境和功能环境的配合使用，一套微服务环境可以满足多个需求并行测试的场景。同时，测试环境需要全生命周期的完整管理手段，包括环境的创建、更新、访问、销毁、校验、度量等。</p>
<h3 id="4-2-自动化验收测试"><a href="#4-2-自动化验收测试" class="headerlink" title="4.2 自动化验收测试"></a>4.2 自动化验收测试</h3><p>在选择自动化框架时，除了考虑框架的技术特性外，还需充分考虑团队的人员能力。自动化验收测试用例需持续维护，以确保其高稳定性和可用性。尽管自动化验收测试在现阶段不能完全替代手工测试，但它仍然是提升测试效率和质量的重要手段。</p>
<h3 id="4-3-自动化接口测试"><a href="#4-3-自动化接口测试" class="headerlink" title="4.3 自动化接口测试"></a>4.3 自动化接口测试</h3><p>在当前的测试体系中，接口测试的重要性不言而喻。自动化接口测试涵盖了协议客户端模拟、接口逻辑模拟、数据驱动、自动化执行、断言操作、关键字驱动、测试替身等关键技术。同时，关注缺陷自动提交和误报缺陷自动过滤是提高测试效率和准确性的关键方向。</p>
<h3 id="4-4-测试数据管理"><a href="#4-4-测试数据管理" class="headerlink" title="4.4 测试数据管理"></a>4.4 测试数据管理</h3><p>测试数据管理需要在评估投入产出比的基础上进行，不是所有测试数据都需要提前准备，也不是所有测试数据都无法准备。测试数据管理需要与测试工作紧密结合，按需建设，并及时维护和更新。测试数据产生的价值是衡量测试数据管理效果的唯一标准。</p>
<h3 id="4-5-性能测试"><a href="#4-5-性能测试" class="headerlink" title="4.5 性能测试"></a>4.5 性能测试</h3><p>性能测试是评估系统容量大小、响应速度和并发能力的重要手段。性能测试实践包括测试环境、测试数据、测试策略、测试工具、测试结果五个要素。性能测试可以按照单机评估、集群评估、扩缩容对比三种方式开展。</p>
<h3 id="4-6-全链路测试"><a href="#4-6-全链路测试" class="headerlink" title="4.6 全链路测试"></a>4.6 全链路测试</h3><p>全链路压测中的链路可分为调用链路和业务链路两种形式。调用链路的压测主要应用于单个系统或业务场景的容量评估；而业务链路压测则是对多个有业务关联的场景所产生的调用链路集合进行评估。全链路压测是一种工程实践，而非单指平台建设。流量录制回放技术丰富了全链路压测实践的手段，可在此基础上根据业务场景对录制的数据进行修正和验证。</p>
<h3 id="4-7-安全测试"><a href="#4-7-安全测试" class="headerlink" title="4.7 安全测试"></a>4.7 安全测试</h3><p>安全风险把控是全体参与方的共同责任，而非某个部门或角色的专属任务。安全测试需要融入研发流程的各个环节，以一种潜移默化的方式发挥作用。通过安全测试，我们可以及时发现和修复潜在的安全风险，从而确保产品的稳定性和可靠性。</p>
<h3 id="4-8-精准测试"><a href="#4-8-精准测试" class="headerlink" title="4.8 精准测试"></a>4.8 精准测试</h3><p>传统黑盒测试存在诸多挑战，如测试过程不可靠、测试范围不明确、效果评估模糊且滞后等。而精准测试则从软件系统的逻辑、变更、覆盖三个底层关注点进行分析和度量。通过精准测试，我们可以更准确地找到发生变更的代码段，监控测试执行过程中的覆盖率，从而指导测试用例的选取，实现变更代码的最大覆盖度。</p>
<h3 id="4-9-测试中台"><a href="#4-9-测试中台" class="headerlink" title="4.9 测试中台"></a>4.9 测试中台</h3><p>测试中台旨在赋能开发人员开展高效率、高质量的测试工作。通过全局架构设计，测试中台为提升测试效率提供了更清晰、更直观的全局视野。测试中台包括测试执行服务、测试数据服务、测试执行环境等关键组件，为开发人员提供全面、高效的测试支持。</p>
<h2 id="第5章-CI-CD-领域实践"><a href="#第5章-CI-CD-领域实践" class="headerlink" title="第5章 CI / CD 领域实践"></a>第5章 CI / CD 领域实践</h2><h3 id="5-1-持续集成"><a href="#5-1-持续集成" class="headerlink" title="5.1 持续集成"></a>5.1 持续集成</h3><p>持续集成强调频繁地将代码改动集成到共享分支，并进行自动化测试。通过构建流水线的引入，确保各步骤迅速完成，及时发现并修复集成问题。实施持续集成时，需避免教条主义，因地制宜，以满足团队需求。</p>
<h3 id="5-2-持续交付"><a href="#5-2-持续交付" class="headerlink" title="5.2 持续交付"></a>5.2 持续交付</h3><p>持续交付旨在以安全、快速、可持续的方式将变更交付至生产环境或用户手中。它是持续集成的延伸，强调版本控制、自动化、快速执行和及时修复。其核心目标是缩短开发到发布的时间，提高发布的可靠性。逐特性发布的集成方式，是对特性发布速度极致追求的体现。</p>
<h3 id="5-3-变更管理"><a href="#5-3-变更管理" class="headerlink" title="5.3 变更管理"></a>5.3 变更管理</h3><p>变更管理确保软件开发中的所有变更均被记录和追溯。遵循可灰度、可监控、可回滚的三大原则，对基础设施、代码基线、配置项、依赖项、数据库及生产发布等变更进行有效管理。最佳实践包括自动化变更过程、建立评审机制、确保可追溯性、灰度发布和回滚能力。</p>
<h3 id="5-4-部署自动化"><a href="#5-4-部署自动化" class="headerlink" title="5.4 部署自动化"></a>5.4 部署自动化</h3><p>部署自动化允许用户通过一键式操作将软件部署至测试和生产环境，全程自动化，无需手工干预。每个环境使用相同的部署流程，确保软件包的一致性。利用版本控制的代码仓库，便于创建特定状态的环境。</p>
<h3 id="5-5-制品管理"><a href="#5-5-制品管理" class="headerlink" title="5.5 制品管理"></a>5.5 制品管理</h3><p>制品是软件资产的关键部分，存放在制品库中以防损坏或丢失，同时便于查找和追溯。除了制品本身，还需管理其元数据，如质量等级和与源代码的关联关系。制品仓库是企业软件资产管理平台，为合规、安全使用第三方组件提供保障。</p>
<h3 id="5-6-发布策略"><a href="#5-6-发布策略" class="headerlink" title="5.6 发布策略"></a>5.6 发布策略</h3><p>理解和制定发布策略的前提是明确部署与发布的差异。没有通用的最佳策略，只有最适合场景的策略。选择发布策略时，需综合考虑技术和业务因素。常见的策略包括停机部署、滚动更新、蓝绿部署等。实现这些策略需关注负载均衡、不可变基础设施等技术要点。</p>
<h3 id="5-7-数据库变更"><a href="#5-7-数据库变更" class="headerlink" title="5.7 数据库变更"></a>5.7 数据库变更</h3><p>数据开发人员应像应用开发人员一样管理数据库资产，确保数据库架构具备演进能力。重视数据库Schema脚本的变更管理，实施版本控制和发布流程。在生产环境中进行变更时，确保升级迁移的安全可靠以及数据的保护和隐私。</p>
<h3 id="5-8-配置参数管理"><a href="#5-8-配置参数管理" class="headerlink" title="5.8 配置参数管理"></a>5.8 配置参数管理</h3><p>系统配置参数和业务配置参数均应得到妥善管理。根据配置参数的性质和适用场景，选择合适的管理方法。若配置参数随源代码演进，建议与源代码一同纳入集成发布流程；若配置参数值随环境变化，则无需与源代码同步。</p>
<h2 id="第6章-运维领域实践"><a href="#第6章-运维领域实践" class="headerlink" title="第6章 运维领域实践"></a>第6章 运维领域实践</h2><h3 id="6-1-云原生基础设施"><a href="#6-1-云原生基础设施" class="headerlink" title="6.1 云原生基础设施"></a>6.1 云原生基础设施</h3><p>云原生不仅是一种技术，更是一种思想，融合了技术与企业管理方法。它为技术创新和流程改进提供了坚实的支撑平台，具备容器化的一致性运行环境、声明式API系统和统一的可观测性方案等核心能力。</p>
<h3 id="6-2-可观测性"><a href="#6-2-可观测性" class="headerlink" title="6.2 可观测性"></a>6.2 可观测性</h3><p>可观测性涵盖事件日志、链路追踪和聚合指标三个方向。它帮助企业实时监控、分析并诊断复杂系统的运行状态，确保系统的高可用性和稳定性。通过实施可观测性策略，企业能够及时发现问题、快速响应，从而提升系统运维的效率和质量。</p>
<h3 id="6-3-全景监控"><a href="#6-3-全景监控" class="headerlink" title="6.3 全景监控"></a>6.3 全景监控</h3><p>全景监控，作为一种全面的可观测性解决方案，能够深入洞察系统的运行状况，从而助力企业实现业务的透明化、提升对问题的响应速度，并加强对全局的把控。它涵盖了监控数据采集、传输、存储、可视化、警情评估、监控告警和数据分析等多个关键环节。有效的全景监控不仅能够降低运维风险，还能帮助开发工程师在软件开发和交付过程中提升效能，确保基于监控数据做出正确的决策。</p>
<h3 id="6-4-智能运维"><a href="#6-4-智能运维" class="headerlink" title="6.4 智能运维"></a>6.4 智能运维</h3><p>结合人工智能技术与传统自动化运维，AIOps（智能运维）大幅提升了运维的效能。其核心关键技术包括数据采集、处理、存储、分析和AIOps算法。在运营保障、成本优化和效率提升三大应用场景中，AIOps展现出了巨大的潜力。常见的算法技术有指标趋势预测、指标聚类、多指标联动关联挖掘等，它们共同为企业的运维工作提供强有力的支持。</p>
<h3 id="6-5-混沌工程"><a href="#6-5-混沌工程" class="headerlink" title="6.5 混沌工程"></a>6.5 混沌工程</h3><p>混沌工程是一项旨在提升复杂系统稳定性的赋能活动。通过故障注入实验，它增强了各角色之间的协作，从而提高了系统的稳定性。混沌工程不仅分析系统运行和失效模式以了解复杂系统，还通过改进系统稳定性和可观测机制，增强了系统的韧性和故障响应速度。</p>
<h3 id="6-6-ChatOps"><a href="#6-6-ChatOps" class="headerlink" title="6.6 ChatOps"></a>6.6 ChatOps</h3><p>ChatOps，一种新型智能工作方式，巧妙地连接了人、机器人和工具。它以在线沟通平台为核心，通过机器人与后端服务的无缝对接，实现了高效的工作流程。ChatOps由自动化的流程、聊天室（控制中心）、机器人（连接中心）和基础设施四个主要部分构成。随着技术的发展，ChatOps正逐渐从简单的指令驱动向数据和流程驱动转变。</p>
<h2 id="第7章-运营领域实践"><a href="#第7章-运营领域实践" class="headerlink" title="第7章 运营领域实践"></a>第7章 运营领域实践</h2><p>运营领域的范畴广泛，通常涵盖了To B、To C、To E和To G四大类。产品上线后，通过精心设计的增长模型，我们可以实现从0-1和1-N两个阶段的有效运营。结合Who、What、When和Where的维度，我们可以制定和推广有针对性的增长策略。一种普适且效果显著的运营策略是采用产品研发官方宣传和业务用户KOL站台相结合的方式，以传递产品的独特价值。在减少人工运营方面，有三个实用的方法：制定详细的产品操作SOP（标准作业程序）、使用产品小助手公用账号进行问题解答，以及设置使用门槛，确保用户通过考试后才能开启账号。</p>
<h2 id="第8章-组织和文化领域实践"><a href="#第8章-组织和文化领域实践" class="headerlink" title="第8章 组织和文化领域实践"></a>第8章 组织和文化领域实践</h2><h3 id="8-1-敏捷组织"><a href="#8-1-敏捷组织" class="headerlink" title="8.1 敏捷组织"></a>8.1 敏捷组织</h3><p>敏捷组织致力于将传统的固化等级官僚性结构转变为充满生命力的有机体。它不仅关乎单点能力，而是涉及到战略、架构、流程、人员和技术等多个层面的系统工程。实现敏捷组织的落地需要遵循一个核心原则、两个必要支柱、三种协作模式以及四类团队类型。</p>
<h3 id="8-2-故障复盘"><a href="#8-2-故障复盘" class="headerlink" title="8.2 故障复盘"></a>8.2 故障复盘</h3><p>团队的复盘能力直接决定了其进步空间的大小。在复杂系统中，由于高网络密度和强耦合性，故障往往难以完全避免。然而，关键在于认识到故障只是表象，背后的技术和管理问题才是根本所在。我们需要包容失败，但绝不允许犯错。在复盘过程中，应避免仅关注唯一根因。</p>
<h3 id="8-3-工程师文化"><a href="#8-3-工程师文化" class="headerlink" title="8.3 工程师文化"></a>8.3 工程师文化</h3><p>文化对于企业的成败至关重要。建立符合公司特点和文化体系的核心价值观，对于公司的健康发展具有重大意义。优秀工程师文化通常具备平等、高效和创新等共性特征。而这些价值观的塑造和传承，是实现工程师文化的基石和核心。工程师文化，虽重要，却非企业成功的唯一因素，我们不应过度神化。实际上，工程师文化同样需要持续的“维护”与滋养。</p>
<h3 id="第9章-研发效能平台的“双流”模型"><a href="#第9章-研发效能平台的“双流”模型" class="headerlink" title="第9章 研发效能平台的“双流”模型"></a>第9章 研发效能平台的“双流”模型</h3><p>在多个工具平台间频繁切换，为研发人员带来研发流程上的巨大挑战。而“一站式”与“一键式”的研发效能平台则能有效降低这种认知负荷，让研发人员得以更专注于创造真正的价值，而非陷入琐碎的事务性工作。这种“双流”模型确保了需求价值流与研发工作流之间的高效协同与自动化的流畅联动。</p>
<h2 id="第10章-自研工具体系"><a href="#第10章-自研工具体系" class="headerlink" title="第10章 自研工具体系"></a>第10章 自研工具体系</h2><h3 id="10-1敏捷协作域工具"><a href="#10-1敏捷协作域工具" class="headerlink" title="10.1敏捷协作域工具"></a>10.1敏捷协作域工具</h3><p>敏捷协作域工具旨在满足企业的敏捷协作需求，推动敏捷文化的生长，使敏捷实践得以真正落地。其中，涵盖了规划与过程管理、需求管理、测试管理、文档协同与知识库，以及度量与持续改进等关键环节，共同构成了敏捷协作的全景图。而产业研发需求工作流的灵活协同，则确保了需求的逐层拆解与自动化的紧密关联。迭代管理则支持产品制和项目制两大模式，满足不同发布节奏的需求。</p>
<h3 id="10-2-代码域工具"><a href="#10-2-代码域工具" class="headerlink" title="10.2 代码域工具"></a>10.2 代码域工具</h3><p>代码域工具是软件开发工程师的核心装备，其能力水平直接反映了公司的软件工程实力与工程影响力。这些工具不仅限于开发工具（DevTools），更应朝着研发基础设施（Devlnfra）的方向迈进。</p>
<h3 id="10-3-测试域工具"><a href="#10-3-测试域工具" class="headerlink" title="10.3 测试域工具"></a>10.3 测试域工具</h3><p>测试域工具涵盖了测试过程管理与测试资产管理两大维度，需要独立设计。测试流水线与研发流水线的紧密协同，通过测试左移和右移的实践，实现了全链路的测试能力。而自动化测试执行体系，则是提升研发效能的关键。</p>
<h3 id="10-4-CI-CD域工具"><a href="#10-4-CI-CD域工具" class="headerlink" title="10.4 CI/CD域工具"></a>10.4 CI/CD域工具</h3><p>软件交付效率的提升来源于领域内的执行效率和领域间的协同效率，实现了从人驱动工具到工具驱动人的转变。CI/CD域工具的价值体现在过程协同、信息协同和组织协同三个方面，尤其在规模越大的情况下，其效果越为显著。而其六大通用设计原则，可以说是必不可少的。对于CI/CD域工具来说，其未来的发展方向是云原生和价值流交付平台，这是不可逆转的趋势。</p>
<h3 id="10-5-运维域工具"><a href="#10-5-运维域工具" class="headerlink" title="10.5 运维域工具"></a>10.5 运维域工具</h3><p>在构建运维平台时，我们需要考虑其通用性，同时兼顾可靠性、可重用性和可重复性，以降低自动化技术的门槛和减少重复建设的成本。而X-Ops理念，已在DevOps、DataOps、AlOps、MLOps、GitOps和CloudOps等实践中得到广泛认可并落地。对于运维域工具的发展，我们有五大趋势可以期待：云原生化、低代码化、移动端能力、开发和运维的深度融合，以及运维服务化与智能化。</p>
<h3 id="10-6-移动研发平台"><a href="#10-6-移动研发平台" class="headerlink" title="10.6 移动研发平台"></a>10.6 移动研发平台</h3><p>移动研发平台的宗旨在于加速端到端的研发交付效率，提升App的线上品质，并降低代码开发成本。从用户场景出发，移动研发平台涵盖了移动研发、质量、应用性能监控、低代码、Web研发、项目管理等六大建设方向。而未来，我们可以期待移动研发平台的三大发展方向：云IDE化、跨端开发、测试左移。</p>
<h3 id="10-7-一体化协同平台"><a href="#10-7-一体化协同平台" class="headerlink" title="10.7 一体化协同平台"></a>10.7 一体化协同平台</h3><p>单点工具的串联无法有效解决研发效能的“痛点”，因此，企业需要通过一体化协同平台来提高端到端的价值流动效率。一体化协同平台的价值在于最大化软件工程理念的落地，实现数字化研发管理，以及提供沉浸式的研发体验。在集成一体化协同平台时，我们需要评估闭环效率杠杆，明确集成的边界和深度。</p>
<h3 id="10-8-代码智能化工具"><a href="#10-8-代码智能化工具" class="headerlink" title="10.8 代码智能化工具"></a>10.8 代码智能化工具</h3><p>代码智能化工具主要依赖代码静态分析、编译器的前端技术等手段，并结合AI、机器学习和深度学习等技术。在使用这些工具时，我们需要考虑代码的语法和语义特征，如AST、定义-引用关系、函数调用关系、控制流、数据流等。通过智能语言服务通用框架SLSCF，我们可以在代码提交前、提交中和提交后各环节实现代码智能化的实践。其中，代码补全、搜索和推荐是智能化辅助研发效率提升的三大场景。</p>
<h2 id="第11章-开源工具集成"><a href="#第11章-开源工具集成" class="headerlink" title="第11章 开源工具集成"></a>第11章 开源工具集成</h2><p>合理采用开源工具，企业内部能够避免重复造轮，但这也可能引发工具孤岛和碎片化研发的问题。开源DevOps工具的选型和导入，不仅涉及学习调研成本，还涉及工具间的集成和切换问题。因此，针对开源工具的选型与导入，需要具体问题具体分析，难以给出一刀切、适合所有场景的建议。为了有效地解决这些问题，我们可以借鉴分层“松耦合”的方式，包括能力底座、工具适配层和工具集成，这样的设计方案有助于实现更高效的工具集成。</p>
<h2 id="第12章-研发效能度量"><a href="#第12章-研发效能度量" class="headerlink" title="第12章 研发效能度量"></a>第12章 研发效能度量</h2><h3 id="12-1-度量框架"><a href="#12-1-度量框架" class="headerlink" title="12.1 度量框架"></a>12.1 度量框架</h3><p>研发效能度量框架可以概括为E3I框架。虽然软件研发效能度量的内涵和外延丰富多样，但我们可以提纲挈领地概括其要义。其内涵主要归结为效果（Effectiveness）、效率（Efficiency）和卓越能力（Excellence）这三个“E”。外延则主要归类为交付价值、交付速率、交付质量、交付成本和交付能力这五个认知域。为了提升软件研发效能，我们可以采用度量（Measure）-分析（Analyze）-回顾（Review）-改进（Improve）的MARI循环。</p>
<h3 id="12-2-指标体系"><a href="#12-2-指标体系" class="headerlink" title="12.2 指标体系"></a>12.2 指标体系</h3><p>度量指标体系的设计必须紧密围绕团队研发效能度量的目标。它是一系列可量化研发效能水平的指标集合，需要使用多个指标从不同维度来综合评估与分析。合理的指标体系设计，必须能够准确反映出研发过程中的问题或待改进点。效能指标和效能度量应该引导研发团队做出真正能解决问题的行为，而不仅仅是追求数据上的好看。</p>
<h3 id="12-3效能分析"><a href="#12-3效能分析" class="headerlink" title="12.3效能分析"></a>12.3效能分析</h3><p>效能分析是通过科学的方法，深入分析数据与研发活动的因果和关联关系，进而找到研发”痛点”、可改进项和值得总结的经验效能诊断分析可以使用判定表、趋势分析等方法，效能优化、问题分析可以使用逻辑树、下钻分析、相关性分析等方法要进行系统性的效能分析，不能陷入局部思维，避免陷于”数字游戏””反映部分事实”等困境要注重效能分析的持续性，持续反思与优化，以确保在向效能提升目标靠近。</p>
<h3 id="12-4-度量平台"><a href="#12-4-度量平台" class="headerlink" title="12.4 度量平台"></a>12.4 度量平台</h3><p>度量平台的设计可以拆分成数据采集、数据计算、数据分析和展现几层组件为满足不同数据源的采集和计算分析，在数据接入之前就需要设计统一的数据抽象和关联映射机制以面向对象的思路来设计画像数据和指标体系，避免单纯的指标堆积通过多维度数据分析挖掘对象以及指标之间的变化规律，从而找到影响效能的关键因素。</p>
<h3 id="12-5-专项度量分析"><a href="#12-5-专项度量分析" class="headerlink" title="12.5 专项度量分析"></a>12.5 专项度量分析</h3><h4 id="12-5-1-需求价值流分析"><a href="#12-5-1-需求价值流分析" class="headerlink" title="12.5.1 需求价值流分析"></a>12.5.1 需求价值流分析</h4><p>需求价值流分析的五个核心度量指标分别是流动时间、流动速率、流动负载、流动效率、流动分布将五个核心度量指标结合在一起可以刻画需求交付的完整过程，回答关于交付效率的本质问题通过价值流分析，可以发现研发过程隐藏的问题和瓶颈点，采取针对性的行动可以有效促进效能提升需求价值流分析的前提是数据的准确性，需要通过管理或者自动化技术手段给予保障，这样分析的结果才能反应实际情况。</p>
<h4 id="12-5-2-代码的度量分析"><a href="#12-5-2-代码的度量分析" class="headerlink" title="12.5.2 代码的度量分析"></a>12.5.2 代码的度量分析</h4><p>代码分析可以补足对研发产出侧而非过程侧的度量，极大提升度量体系的完整性和有效性。作为代码度量的典型代表，”开发当量”可以反映研发产出的复杂度，在交付速率、交付质量和交付成本等领域都有重要应用缺陷密度、缺陷修复工作量、函数复杂度、函数影响力、代码重复度等其他代码度量指标，对改进工程质量也有重要作用开发者的代码贡献、代码质量、技术经验都能在代码中体现，也能通过代码分析进行度量。</p>
<h4 id="12-5-3-代码评审度量分析"><a href="#12-5-3-代码评审度量分析" class="headerlink" title="12.5.3 代码评审度量分析"></a>12.5.3 代码评审度量分析</h4><p>从CR发起、CR评论、CR颗粒、评审状态以及评审投入等量化指标设计中，可以发现代码评审流程中的问题并改善其活动的开展在进行代码评审数据分析时，可以采用趋势分析、对比分析、分布分析、结构分析、漏斗分析等方法。Python自动化数据分析是一个成本比较低，适用于需要大批量复制的一个不错的数据分析实施工具。</p>
<h3 id="12-6-度量的成功要素"><a href="#12-6-度量的成功要素" class="headerlink" title="12.6 度量的成功要素"></a>12.6 度量的成功要素</h3><p>研发效能度量要坚持数据驱动和实验精神，让研发效能可量化、可分析、可提升模式，避免”踩坑”才能走得更远 “成功大都相似，失败各有不同”，认清效能度量的十大反度量体系建设需要综合考虑度量的用户场景、度量的指标体系、度量的模型设计、度量的产品建设、度量的运作模式研发效能度量是复杂的系统性工程，顶层规划很重要，需要把度量引导到正确的方向上来。</p>
]]></content>
      <categories>
        <category>DIY小记</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>OCR</tag>
        <tag>AI</tag>
        <tag>大模型</tag>
        <tag>GPT</tag>
      </tags>
  </entry>
  <entry>
    <title>【从零单排Golang】第十六话：channel的用法和基本原则</title>
    <url>/2024/04/13/gofromzero/16_channel/</url>
    <content><![CDATA[<p>在基于Golang的后端开发中，channel是一个必须要掌握的并发编程概念。和python的queue一样，channel在不同的goroutine里承担着传递信息的作用，使得业务逻辑的状态上下文可以在不同的goroutine中共享。今天，我们就来看一下channel的用法还有一些使用上的基本原则。</p>
<p>首先，我们需要知道什么场景下会用到channel。一个简单的例子是，在主流程里，我们希望启动一个方便处理panic的goroutine，异步跑一个任务，然后主流程等待这个goroutine给join进来。解决这个问题，就可以用到channel，代码这样写：</p>
<a id="more"></a>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAsyncTask</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    joiner := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">"[main] start async task..."</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Printf(<span class="string">"[goroutine] panic: %v"</span>, r)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">close</span>(joiner)</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        log.Printf(<span class="string">"[goroutine] start async task..."</span>)</span><br><span class="line">        time.Sleep(<span class="number">5</span> * time.Second) <span class="comment">// task logic</span></span><br><span class="line">        log.Printf(<span class="string">"[goroutine] end async task!"</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">"[main] wait for join..."</span>)</span><br><span class="line">    &lt;-joiner</span><br><span class="line">    log.Printf(<span class="string">"[main] async task joined!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义一个channel，发起异步任务，并在主流程阻塞地去接收这个channel的事件。在异步任务执行完成后，把channel给close掉，这样主流程可以接收到channel给close掉的事件，就能继续后面的逻辑。这样，就达到了任务线程join的效果。</p>
<p>在上述的场景下，我们用到的channel相对于消息发送方是阻塞的，如果发送方给这个channel发送一条消息，而接收方的逻辑还没有跑到的话，那么发送方就会一直阻塞在发送逻辑。假使我们需要实现一个类dispatcher（多consumer）的调度模型，不断地去根据消息内容把消息分发到不同consumer-worker上，那么采用对于发送方阻塞的channel的话，就有可能因为dispatcher在处理过程中产生瓶颈，造成发送方等待超时。在这种情况下，我们就需要用到非阻塞的channel，也就是在定义channel时，也去声明这个channel的buffer大小，这样我们就可以有足够的缓冲区去缓存消息，解决发送方的无限等待问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// channel chan instance</span></span><br><span class="line"><span class="keyword">var</span> channel <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bufSize for non-blocking channel</span></span><br><span class="line"><span class="keyword">const</span> bufSize = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initBlockingChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initNonBlockingChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, bufSize)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exampleProduceMsg</span><span class="params">()</span></span> &#123;</span><br><span class="line">    msg := <span class="number">1</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> channel &lt;- msg:</span><br><span class="line">        log.Printf(<span class="string">"sent msg: %v"</span>, msg)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        log.Printf(<span class="string">"send msg failed!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而消费一个channel，我们可以构建一个loop，来循环处理channel发送过来的内容。比如一个dispatcher，就需要一个for循环，不断拿消息，把消息发给下游的任务handler：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">launchConsumer</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    numMsgs := <span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log.Printf(<span class="string">"[Consumer] overall received %d msgs!"</span>, numMsgs)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123; <span class="comment">// 其它写法：for msg := range c</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> msg, ok := &lt;-c:</span><br><span class="line">            <span class="keyword">if</span> ok &#123; <span class="comment">// 收到了消息</span></span><br><span class="line">                log.Printf(<span class="string">"[Consumer] received msg: %v"</span>, msg)</span><br><span class="line">                numMsgs++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// channel closed</span></span><br><span class="line">                log.Printf(<span class="string">"[Consumer] channel closed!"</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>channel使用的基本原则是，从producer端去close掉channel。produce端触发close后，consumer端就能够知道channel被close掉，进而结束掉自己的chunk。而如果是consumer端主动close，producer端在不知情的情况下，往channel发送消息，就会panic。</p>
<p>因此，为了规避这个风险，一是要从producer去关channel，而是不论是怎样的生产消费模型，都需要保证channel仅被close一次。简单来讲，close掉channel的操作，放到producer最外层函数的defer里面，就能解决问题。</p>
<p>对于单个producer的模拟，我们可以简单做一个for循环，去不断发送消息。中途打断的方式采用可cancel的context，当循环过程中检测到context被cancel掉，就停止发送消息。整个代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">launchSingleProducer</span><span class="params">(c <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log.Printf(<span class="string">"[SingleProducer] close channel..."</span>)</span><br><span class="line">        <span class="built_in">close</span>(channel)</span><br><span class="line">    &#125;()</span><br><span class="line">    numMsgs := <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numMsgs; i++ &#123;</span><br><span class="line">        log.Printf(<span class="string">"[SingleProducer] start send msg: %v"</span>, i)</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- i:</span><br><span class="line">            log.Printf(<span class="string">"[SingleProducer] finish send msg: %v"</span>, i)</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            log.Printf(<span class="string">"[SingleProducer] context done!"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            log.Printf(<span class="string">"[SingleProducer] send msg failed..."</span>)</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>golang中ctx的上下文信息，也可以在不同的goroutine中共享，可以参考<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjMvMDQvMDEvZ29mcm9temVyby8xMF9jb250ZXh0Lw==" title="https://utmhikari.top/2023/04/01/gofromzero/10_context/">这篇文章<i class="fa fa-external-link"></i></span>对于context模块的介绍。在单个producer场景下，每次循环，我们可以select不同的信道，看当刻是可以给channel发送一条消息，还是收到了ctx上下文结束的事件。如果上下文结束掉，就终止整个producer。close操作，放到defer里执行即可。</p>
<p>consumer端处理多个channel的发送/接收事件，我们可以通过循环+select的通用模版去实现。每轮循环，就select单个channel的单个事件来处理，代码写起来也简洁明了。</p>
<p>对于多个producer的模拟，我们可以创建一个waitGroup去管理多个producer的进度，可以参考<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjMvMDgvMDYvZ29mcm9temVyby8xM193YWl0Z3JvdXAv" title="https://utmhikari.top/2023/08/06/gofromzero/13_waitgroup/">这篇文章<i class="fa fa-external-link"></i></span>来了解waitGroup的用法。与此同时，每个producer的行为则是在for循环里发消息，直到消息发完或者context结束掉，才结束单个producer的进度。在主goroutine中，只需要wait这个waitGroup，然后在defer中close掉channel即可。代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">launchMultiProducers</span><span class="params">(c <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log.Printf(<span class="string">"[SingleProducer] close channel..."</span>)</span><br><span class="line">        <span class="built_in">close</span>(channel)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    produce := <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>, numMsgs <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numMsgs; i++ &#123;</span><br><span class="line">            msg := id*<span class="number">10000</span> + i</span><br><span class="line">            log.Printf(<span class="string">"[MultiProducers] [%d] start send msg: %v"</span>, id, msg)</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> c &lt;- i:</span><br><span class="line">                log.Printf(<span class="string">"[MultiProducers] [%d] finish send msg: %v"</span>, id, msg)</span><br><span class="line">                time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">            <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">                log.Printf(<span class="string">"[MultiProducers] [%d] context done, break!"</span>, id)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                log.Printf(<span class="string">"[SingleProducer] send msg failed..."</span>)</span><br><span class="line">                time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.Printf(<span class="string">"[MultiProducers] [%d] finish send all msgs!"</span>, id)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    numIDs := <span class="number">10</span></span><br><span class="line">    numMsgsEach := <span class="number">10</span></span><br><span class="line">    waitGroup := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">"[MultiProducers] launch producers..."</span>)</span><br><span class="line">    <span class="keyword">for</span> x := <span class="number">1</span>; x &lt;= numIDs; x++ &#123;</span><br><span class="line">        waitGroup.Add(<span class="number">1</span>)</span><br><span class="line">        id := x</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> waitGroup.Done()</span><br><span class="line">            produce(id, numMsgsEach)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    waitGroup.Wait()</span><br><span class="line">    log.Printf(<span class="string">"[MultiProducers] finish all producers!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>从零单排Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>后端开发</tag>
        <tag>并发</tag>
        <tag>channel</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>【架构艺术】变更元信息分析框架设计</title>
    <url>/2024/04/04/archiart/change_analysis_framework/</url>
    <content><![CDATA[<p>在变更风险防控领域，对于线上变更元信息的分析是非常重要的一部分，这是因为，只有理解了变更元信息，结合自主定制的变更规范，才能够知道具体的变更风险在哪里。不同的变更风险防御能力，实现的思路可能是不同的，因此很有可能出现对于一次变更，在信息的理解上有所不一致，从而导致检测结果不够置信。基于此，我们需要一个独立的变更元信息分析框架，把所有的变更元信息分析过程和结果都归到一个独立的系统当中。这样，从变更风险防御能力的视角，变更分析的结果都是共享的、全局的、一致的，从而能最大限度提升变更风险防御能力可挖掘的潜力。</p>
<p>本文，就简单聊一下，变更元信息分析框架设计的部分重点。</p>
<a id="more"></a>
<p>首先第一个问题是，变更元信息的来源是什么？简而言之，如果要获取到变更元信息，一个变更平台需要在发起变更、变更期间和变更结束之后，都上报和当次变更相关的元信息给到分析框架。如果把一个企业内部所有的变更平台都考虑到一起，那么变更上报次数量级是非常大的，因此一个比较好的方法是，通过一个变更事件MQ去承载变更元信息的上报和消费，从而起到均衡性能的作用。在这样的基础上，变更元信息分析工作，就可以是异步的，基于变更事件驱动的模式。</p>
<p>其次问题是，分析的对象是什么？可以简单划分成三类。第一类是变更的对象本身，比如我们需要了解到，某个服务的上下游链路如何，重要度如何，是否涉及资损风险，这些都是服务本身的属性，并且也是在变更过程中需要考虑的；第二类是变更工单过程，这个是核心的变更对象，我们需要判断某次变更是否存在风险，就需要对一次变更工单进行分析，比如是否在高峰期发布，是否通过管控赦免，变更的需求背景等等，都是变更工单维度的分析信息；第三类是变更阶段，这是在变更工单维度上，向下拆解出来的一类分析对象，描述变更过程每一个阶段的实际情况，尤其是小批次灰度阶段的变更元信息，是变更风险防御需要着重去关注的。</p>
<p>变更事件上报的信息，一般是变更工单或者变更阶段维度的，而变更服务实体这个维度，在事件内容里，不一定会有标准化的体现。因此，如果要将变更事件和变更元信息分析结果做映射，就需要标准化三类变更分析的对象的数据结构和元信息提取逻辑。</p>
<p>然后一个问题是，分析结果会怎么出来？这里有多种可能性，一种可能性是框架本身在接收到变更事件后，把事件dispatch给符合事件过滤条件的变更元信息分析器；另一种可能性是，分析器离线（定时）运行，上传结果给到变更分析框架。为了兼容这两种可能性，我们就需要标准化分析结果的存储接口，以及分析对象的生成逻辑。尤其是，有了后者以后，不论是受控被调度的分析器，还是离线分析器，都能通过某种方式，将分析结果映射到具体的分析对象，这样就满足了兼容的需要。</p>
<p>最后一个问题是，如何支持分析器的运作？不论是离线还是受控的分析器，有可能实质也是一个变更事件消费者，是一个多节点运行的服务，这样就会产生分析缓存数据共享的问题。因此，分析框架在研发的过程中，也需要考虑建设一些工具或者分析器框架，去提升分析器的开发效率。就和游戏引擎一样，通过工具插件，为游戏开发赋能。</p>
<p>以上便是变更元信息分析框架设计的一些重点思路和考量。解决了以上问题，一个简约的变更元信息分析框架则呼之欲出。</p>
]]></content>
      <categories>
        <category>架构艺术</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>架构</tag>
        <tag>变更风险</tag>
        <tag>系统设计</tag>
        <tag>事件循环</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】提升发布风险检查准确率的一些思路</title>
    <url>/2024/03/03/geekdaily/release_check_optimization/</url>
    <content><![CDATA[<p>在服务或者其它线上资源发布新版本的时候，我们都有必要为发布信息本身和上线的资源做风险检查，以确认发布内容不会对线上造成影响。通常来说，在检查能力铺垫时，一个主旨的思路是保证问题的召回率，即检查能力本身必须理论上可以拦截更多的风险，这样才能够基本限度保证发布过程的安全。但随着检查能力集合变得成熟，业务也肯定会有对检查能力优化的需求，需要提升检查的准确率，不至于出现太多无用的噪音，这也成为了风险检查提升可靠性的一项挑战。</p>
<p>因此，本文就浅谈一下，提升发布风险检查准确率的一些思路。</p>
<a id="more"></a>
<p>首先，我们需要寻找提升准确率的抓手，也就是说从哪些点入手，可以比较有效提升数据。对于一次发布过程，我们可能会应用多种检查能力，而每种检查能力每次运行可能会检查多个检查项。因此，我们需要了解到每个检查能力判定为失败时，发布人回滚发布或是跳过检查的情况，以及这些情况下，每个检查项具体的判定结果为多少。这样就能够了解哪些检查项的逻辑比较靠谱，哪些检查项的逻辑需要做优化。如果可以找到一些典型的案例，那么就能够成为突破口。</p>
<p>举个例子，一个Web-Service发布过程中，我们可能会检查服务的性能和业务监控指标。针对单个业务指标，可能存在不同的告警等级，比如超过某个阈值是Warning，然后再超过一个更高的阈值则是Fatal。在开发检查能力的时候，为了方便交付，我们可能判定如果某个指标为Fatal，则整个检查都失败。但事实上，如果这个指标实际表征的风险程度不高，即便在告警上是Fatal，但发布过程可能还是会被人为强制跳过。这样的监控指标，就是需要优化的典型案例。</p>
<p>然后，才是看如何实施优化手段。比如，上面提到的监控指标严重程度不能很好反映风险度的问题，就有两种优化方向：一种是调整指标本身的设定阈值，一种是在检查过程做风险评分，并为这种指标给一个相对较低的风险权重值。或者，从大的角度，在监测到一个Fatal告警之后，先和变更前线上环境的监控告警情况做对比，如果情况和变更前类似，那么也无需给一个非常严重的检查失败告警。如果是持续性地做检测，那么也需要考虑异常告警的持续性，防止因为部分毛刺导致最终判定结果不置信。</p>
<p>假设我们检查的结果，也分为Fatal和Warning两个级别，在数据上也有一个很基础的优化点，就是将Fatal结果和Warning结果的准确率做区分。如果一个检查项存在不置信的情况，但检查项是基础的必须的，就需要做风险降级。一般而言，Fatal结果的可靠性是需要非常高的，而Warning可是相对可容忍噪音的。因此，需要对各检查能力也做结果优先级划分，对于相对更有置信度的检查能力或检查项，应当考虑做更加严格的风险判定，对于整体的风险评定优先级更高，而置信度较小的，则在风险评定中，优先级放低。</p>
<p>最后，需要注意的是，虽然我们的最终目的是为了提升检查准确率，但召回率是不能丢的，不能因为提升了准确性，导致可拦截的风险面变小。检查准确率提升主要是基于用户体验的优化，而召回率才是真正面向检查能力的SLA。</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>变更风险</tag>
        <tag>稳定性</tag>
        <tag>DevOps</tag>
        <tag>持续集成</tag>
        <tag>研发效能</tag>
      </tags>
  </entry>
  <entry>
    <title>【架构艺术】可持续性架构设计的秘诀</title>
    <url>/2024/02/15/archiart/sustainable_architecture/</url>
    <content><![CDATA[<p>今天闲聊一下可持续性架构设计的秘诀，总共八个字：概念拆解，重组改造。</p>
<p>说到新开发一个技术工程，很多同学会引用需求拆解的思路，自顶向下拆解子需求，做对应的层次模块设计，然后直接按照拆解结果分模块编码。依照这样的思路，虽然最终架构形态比较符合预期，但不一定能够保障长线迭代。这是因为，技术实现始终是自底向上，而不是自顶向下的，如果说在拆解过程中，思考深度不够，没有触及到底层概念的粒度，那么技术实现的结果，必然是失去可扩展性——上层隐含的底层概念跟需求强绑定，导致底层功能无法拆分出来，不能适配更多场景，最终不断堆积，就产生了技术债。</p>
<p>这个问题需要如何解决？举一个游戏领域的例子。以客户端自动化测试为例，我们期望的一个效果，是要通过客户端自动化测试工具，可以代替人力做游戏场景遍历，解决遍历冒烟测试耗时的问题。为了解决这个问题，可以简单做子问题拆解：</p>
<a id="more"></a>
<ul>
<li>自动化的设备？安卓设备。</li>
<li>自动化的驱动方式？UI+Lua脚本驱动。</li>
<li>要做自动化的业务模块？副本、大世界寻宝和寻路系统。</li>
<li>用例的触发方式？本地PC上人工执行。</li>
</ul>
<p>因此，我们不难设计一个简单的自动化测试框架，里面包含设备连接、UI/脚本驱动、用例管理以及CMD执行四个模块。框架层实现这些就完事，之后就可以专注编写每个场景的流程逻辑了。游戏测试业界，也基本止步于此。</p>
<p>这样的一个框架，能够支撑的了更多自动化用例的维护么？答案是不能。究其原因，就是框架在设计时，仅仅考虑了需求效果，做了浅层的问题拆解，而没有考虑技术实现的依赖关系，做深层次的基础概念拆解。如果框架只有这些功能，那么写出来的自动化用例代码必然是又臭又长，难以维护。</p>
<p>代码冗长的问题怎么解决？需要抽取共性，做更细粒度的模块化。共性在哪里？有两个点。首先是玩家操作，比如传送到世界的某个坐标，和某个物件交互，进入退出某个UI状态，这些操作是很多自动化用例都共有的，所以可以单独提出来。其次是行为模式，比如打主线任务和支线副本，都遵循一套行为模式——接一个任务，完成一个任务，再判断整个任务流程是否结束。这些行为模式可以抽象成单独的类，实际执行只需要关注特定入参，不需要每次都编码整个流程，这样就能够有效减少用例代码量。</p>
<p>通过抽象玩家操作和行为模式，不仅可以有效提升编码效率，而且也能够降低维护成本。这便是自动化测试框架提升品质的要点。</p>
<p>概念拆解，重组改造，其核心要思考的便是，如何在自顶向下的需求拆解和自底向上的技术实现之间，不断优化这个“最大公约数”。需求是不可控的，技术实现是可控的，就和打麻将一样，我们永远无法确认下一个进张一定是什么牌，但组牌的权利一定永远掌握在我们自己手中。因此，为了让技术实现能够更具备可持续性，我们才需要把所有概念打碎，理顺概念之间的依赖和层次关系，再根据灵活组合不同的概念体系，以达到不同需求预期的效果。除了向着预期的牌型组牌之外，也要兼顾其它牌型的可能性，把牌打活。这样做技术设计，就可以应对频繁的需求变更，不至于积重难返。</p>
]]></content>
      <categories>
        <category>架构艺术</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>架构</tag>
        <tag>系统设计</tag>
        <tag>游戏自动化</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>【GitHub探索】蚂蚁变更管控平台AlterShield设计分析</title>
    <url>/2024/02/04/githubdiscovery/altershield_design/</url>
    <content><![CDATA[<p>技术风险，作为质量保障领域的重要的一环，主要研究如何通过解决方案和技术手段，解决企业内业务在基础运维、日常运营和变更上线过程中的稳定性问题，保证业务风险得到收敛。在国内，蚂蚁金服在这个方向上有沉淀很多方法论和实践经验。变更管控是技术风险地一个子领域，主要的目标是在变更过程中，通过对变更流程的管控介入，提前发现变更过程存在的事故风险，或者阻止变更过程的错误进一步扩大影响面。在这个子领域，蚂蚁开源了<span class="exturl" data-url="aHR0cHM6Ly9hbHRlcnNoaWVsZC5pby96aC1DTi9kb2NzL2ludHJvZHVjdGlvbi93aGF0LWlzLWFsdGVyc2hpZWxkLw==" title="https://altershield.io/zh-CN/docs/introduction/what-is-altershield/">AlterShield变更管控平台<i class="fa fa-external-link"></i></span>，提供了一套变更风险防御的解决方案。今天，本文就浅析下AlterShield平台整体的设计，适用的场景以及局限性。</p>
<p>AlterShield的源码可以参考这个<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RyYWFzLXN0YWNrL2FsdGVyc2hpZWxk" title="https://github.com/traas-stack/altershield">GitHub-Repo<i class="fa fa-external-link"></i></span>。整体的<span class="exturl" data-url="aHR0cHM6Ly9hbHRlcnNoaWVsZC5pby96aC1DTi9ibG9nL3dlbGNvbWUtYWx0ZXJzaGllbGQtdjAuMQ==" title="https://altershield.io/zh-CN/blog/welcome-altershield-v0.1">技术架构<i class="fa fa-external-link"></i></span>，主要包含几块部分：</p>
<a id="more"></a>
<ul>
<li>OCMS-SDK：面向变更渠道和K8S运维平台的接入层，约定了统一的变更信息协议和变更技术协议的定义</li>
<li>Defender-Framework：变更防御框架，提供异常检测、发布窗口封禁等变更防御能力，用于检测变更风险</li>
<li>Analyzer-Framework：变更分析框架，提供影响面分析、变更分级等变更过程分析能力，用于提前分析变更内容，为变更防御能力提供上下文信息输入</li>
</ul>
<p>最底层的核心概念，是变更信息协议和变更技术协议。首先是变更信息协议，整个协议描述了一次变更最基础的5W1H信息：</p>
<ul>
<li>Who：变更人</li>
<li>When：变更时间</li>
<li>Why：变更背景</li>
<li>Where：变更渠道</li>
<li>How：变更操作</li>
<li>What：变更对象</li>
</ul>
<p>任何渠道任意变更操作，其中的上下文信息都可以用这个5W1H表示法描述，简洁方便，利于定位和回溯。</p>
<p>其次是变更技术协议。变更技术协议提出了变更代际的概念，用于描述变更防控能力可介入变更过程的不同方式。变更代际这个概念粗看很有阿里味，比较难以理解，但我们如果分变更渠道和AlterShield视角来看的话，不难发现不同的变更代际实际代表着变更渠道可选接入AlterShield的不同方式。一些变更渠道可选只提供事件信息，另一些变更渠道也可以选择在变更不同阶段引用AlterShield的拦截卡口，从变更渠道方视角，不需要非常关注具体有什么变更防御能力启用，只需要注册自身的接入方式，给定几个可应用防控能力的切点即可；而从AlterShield角度，只需要给业务开放能力，让业务可针对不同平台发布，配置不同切面能力，从而达到变更防控的效果。</p>
<p>变更代际这样的模式，需要依赖AlterShield的开发方和主流的变更渠道做到深度密切的配合，也需要企业内部为所有变更渠道约定一套变更流程的规范作为代际概念的支撑。因此，如果变更管控平台不是和变更渠道深度共建，以及对于变更渠道的变更流程规范约束不强烈的话，引用变更代际的模式可能不够灵活，但需要保证至少有G0（变更事件）的接入方案。对于高发布频次，与业务核心链路强相关的发布渠道，需要有粒度更高（代际更大）的接入方案，去尽可能在更多的时间点发现更多的变更风险。</p>
<p>最后简单看一下变更防御能力。当前在文档中，介绍了4种变更防御能力：</p>
<ul>
<li>时序指标异常检测：给定一批检测指标，对比变更期间这批指标跟变更前、历史变更的相似度，来推断本次变更是否有指标异常</li>
<li>日志异常检测：检测错误日志中，是否有错误或者异常堆栈信息</li>
<li>链路异常检测：检测一条上下链路上，变更期间是否有某个节点突然发生异常</li>
<li>配置值自适应校验：训练既往的变更内容，推断更新的KV是否可能有人工填写错误问题</li>
</ul>
<p>变更防御能力的方案基本是通用的，而且像日志异常、配置校验等能力，在能力基础上，需要支持业务自定义。指标、日志和链路异常检测，如果能够结合企业内部对于性能打点、日志收集、链路打标等基础架构能力进行建设，是更加合适且具备远见的方式。</p>
]]></content>
      <categories>
        <category>GitHub探索</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>变更风险</tag>
        <tag>DevOps</tag>
        <tag>AlterShield</tag>
        <tag>质量保障</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】慢查询的风险治理思路</title>
    <url>/2024/01/07/testlife/slow_query_risk/</url>
    <content><![CDATA[<p>在线上环境运维过程中，我们通常需要治理慢查询的风险。慢查询会引起DB性能问题，并且当线上环境流量较大的情况下，就会出现因大量慢查询堆积导致DB被打挂的情况。因此，本篇文章分享一下慢查询的风险治理思路。</p>
<p>首先，我们需要知道什么情况下会出现慢查询。通常对于大表，未正确引用索引导致全表扫描，就会出现慢查询。慢查询出现也会经历从无到有的过程，而为何从无到有，就涉及到业务变更。以下几种业务变更场景就有可能导致慢查询的产生：</p>
<a id="more"></a>
<ul>
<li>业务代码变更：代码逻辑没有正确引用索引</li>
<li>DML变更：WHERE条件没有正确引用索引</li>
<li>DDL索引变更：线上代码还引用原来的索引，导致实际索引未引用正确</li>
</ul>
<p>慢查询的特征，从业务视角是DB响应速度变慢，而从DB视角是性能占用变大。从事后排查的角度，以MySQL为例，当变更后疑似发生慢查询时，我们可以结合<span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL3Nsb3ctcXVlcnktbG9nLmh0bWw=" title="https://dev.mysql.com/doc/refman/8.0/en/slow-query-log.html">Slow Query Log<i class="fa fa-external-link"></i></span>与<span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL215c3FsZHVtcHNsb3cuaHRtbA==" title="https://dev.mysql.com/doc/refman/8.0/en/mysqldumpslow.html">mysqldumpslow<i class="fa fa-external-link"></i></span>来查看具体是哪些查询语句出现了慢查询。</p>
<p>之后，我们才需要针对可能出现慢查询的场景，设定预防的手段，尽可能避免事后止损。针对上述几种变更风险，我们可以各个击破：</p>
<ul>
<li>业务代码变更：代码引用DB扫描、线下查询治理</li>
<li>DML变更：EXPLAIN</li>
<li>DDL索引变更：代码引用DB扫描、线下查询治理</li>
</ul>
<p>DML变更的情况比较好解。我们可以通过<span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL2V4cGxhaW4uaHRtbA==" title="https://dev.mysql.com/doc/refman/8.0/en/explain.html">EXPLAIN<i class="fa fa-external-link"></i></span>的手段解析DML（查询逻辑）预期会使用到的索引、扫描行数和影响行数。如果查询的是大表，并且没有引用索引，或者扫描/影响行数过高，则需要注意真实执行时候，可能会造成慢查影响。</p>
<p>业务代码或DDL索引变更的情况，则需要把变更内容扫描和线下治理关联上，来确定当次变更是否有风险。在业务代码线下测试的过程中，我们可以通过比如提取ORM-Log的方式解析一些先下代码生成的SQL，然后放到线上库EXPLAIN，从而发现线下变更可能导致线上慢查的一些case。在代码变更发布到线上的时候，一方面可以通过分析代码引用来判断代码是否正确引用索引，另一方面也可以再次确认线下发现的SQL风险是否已经确认修复，从而避免风险夹带到线上。DDL索引变更同理，在执行DDL前，也可以通过血缘关系找到上游的服务，根据服务代码历史的分析结果以及线下提取SQL的记录，来判断变更后会否出现索引未正确引用的情况。</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>变更风险</tag>
        <tag>慢查询</tag>
        <tag>SQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】数据同步和迁移的变更注意事项</title>
    <url>/2023/12/09/testlife/data_sync_warn/</url>
    <content><![CDATA[<p>数据同步或者迁移操作也算是线上数据变更的一种类型。由于涉及的数据量非常大，一旦发生故障，会直接影响线上业务，并且较难止损。从变更风险管控的角度考虑，数据同步或迁移操作也需要走合理的发布窗口，并且在操作前也需要做足够的影响分析。本文就来聊一下数据同步和迁移的变更期间注意事项。</p>
<p>数据同步按照持续状态的不同可以分为一次性同步跟持续性同步。从质量保障的角度，要降低持续性同步的风险，需要额外考虑数据跟组件性能的监控，其它方面的考虑两者没有太大的差别。数据同步的操作手法也有很多种，既可以通过搭建中间件，实现一个导入binlog到MQ然后再导到其它存储的通路，也可以通过自建业务服务，通过批量刷数的方式主动导入大量数据。对于后者，在<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjMvMDcvMDkvdGVzdGxpZmUvZGF0YV93YXNoX3Jpc2sv" title="https://utmhikari.top/2023/07/09/testlife/data_wash_risk/">以前的文章<i class="fa fa-external-link"></i></span>当中已经提到了一些通用的风险点，但如果考虑到数据同步的需要，还会有一些额外的考量。</p>
<a id="more"></a>
<p>第一块是压力，数据同步的压力相比于一般修数是更加大的，源存储有读的压力，而目标存储有写的压力，并且由于一般读操作可能会分散到多个存储节点，写压力对于单点存储的影响会更大，因此需要重点考虑目标节点当前的QPS情况，选择一个相对合适的数字。</p>
<p>第二块的考量点是同步数据的筛选和转化。通常如果涉及到异构数据存储，同步链路上需要执行数据转化的服务节点，这些节点也会承受一定的压力。如果服务节点的QPS过高，可能会影响服务节点连带的一些服务，或者也有可能导致服务节点注册的网关触发限流，这样就有业务不可用的风险。同时，数据转化本身的代码逻辑也需要保证健壮性，如果触发了corner-case导致服务报错，也有可能影响甚至阻塞数据同步。</p>
<p>第三块的考量点是数据校验。尤其针对批量调用服务接口导入数据的情况，需要通过一定的机制去验证数据的正确性，保证同步的数据生效并对符合业务需求表现。校验方面，需要补上小时级、日级的数据对账；发布过程本身，也需要保证有阶段性的灰度过程，并尽可能随机遴选数据，确保全量发布前数据验证无误。</p>
<p>最后再回到压力。这块讨论的是数据同步已经在线上稳定运行时，其它变更需要考虑到线上已有的数据同步链路。好比说DB数据的增量持续性同步，如果线上有大批量的修改数据，那么就会有可能导致潜在的数据同步链路因为突然的压力发生阻塞，影响某些业务可用性。要解决这个问题，需要梳理变更操作涉及的DB，以及DB涉及的数据同步链路，通过小流量灰度的方式初步检测压力状况如何，再逐步地修改并发参数，找到最合适的变更方式。</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>变更风险</tag>
        <tag>数据迁移</tag>
        <tag>质量保障</tag>
        <tag>质量管理</tag>
        <tag>数据变更</tag>
      </tags>
  </entry>
  <entry>
    <title>【架构艺术】一些通用的代码优化治理经验</title>
    <url>/2023/11/04/archiart/code_optimization_ways/</url>
    <content><![CDATA[<p>在接手以前的项目做开发的过程中，我们经常会遇到因为既有代码理解困难，导致代码难以删改，问题难以排查的情况。一份富含技术债的代码，不论对于当下的问题解决，还是未来的需求开发，都会形成累赘。因此，本文就分享一些通用的代码优化和治理经验。</p>
<p>首先我们需要从工作的角度去看待代码优化这件事情。需要捋清楚几件事情：</p>
<ul>
<li>当前工作需要研发什么内容？未来可能研发什么内容？</li>
<li>历史的代码存在什么问题？有哪些优化的方法？</li>
<li>从历史代码到研发的内容，中间我们需要补充什么？是否确实有必要优化历史的代码？</li>
</ul>
<p>比起为技术而技术地去做代码重构甚至重写，锚定当前的目标，按需优化才是最好的选择。如果历史代码存在比较严重的问题，影响了核心的业务，那么必须强行去做修复，不论代码实现是否符合自己的审美。如果历史代码写的不那么美观，但线上跑的还比较稳定，那么也不建议直接做优化，更多的优先级应该放在新研发的内容上面。</p>
<a id="more"></a>
<p>一般我们觉得写的不好的代码，可能存在以下几类问题：</p>
<ul>
<li>命名不规范，没有明确表示代码背后的业务/领域含义</li>
<li>没有按最小的粒度做条件判断，理论上无法覆盖所有的corner-case</li>
<li>业务流程缺乏拆分，缺乏模块化</li>
<li>没有按照语言特性做目录或文件组织</li>
</ul>
<p>这几类问题都有对应的优化方法。首先命名问题，这个较为好解，了解一段功能的代码实现之前，自己心中要对预期的实现逻辑有数，这样碰到疑似没有说清楚的逻辑，也可以较好推断这些逻辑具体要做什么，当然如果是改命名的话还是建议慢慢改；其次是判断不清问题，主要的关注点是未覆盖的corner-case在线上什么情况下可能复现，风险怎么样，排个优先级去修，不建议一次性全部修完；再者是逻辑拆分问题，推荐是仅当在需要扩充内容的情况下才动既有逻辑，否则如果自己熟悉整个流程的逻辑，不拆也可以；最后是文件组织问题，笔者也经历过一个Golang项目，里面按照python写法来组织go代码，这个问题的解法只能是把新的逻辑放到新的目录，非必要不动旧逻辑。</p>
<p>虽然说代码本身存在问题，理论上必须要优化，但结合项目排期，工作的优先级，不可能说一个项目的代码要每时每刻都尽善尽美。在多人协作的研发场景下，比起写出最美的代码，不如写出足够稳的代码。治理代码问题也是如此，要结合具体的工作情况和代码稳定性做好平衡。</p>
]]></content>
      <categories>
        <category>架构艺术</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>后端开发</tag>
        <tag>架构</tag>
        <tag>重构</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】游戏业务测试落地精准测试专项的一些思路</title>
    <url>/2023/10/02/testlife/game_precise_test/</url>
    <content><![CDATA[<p>精准测试在互联网领域有广泛的应用。以变更为出发点，通过对变更内容进行分析，可以确定单次变更具体涉及到哪些模块和功能点，以及是否存在夹带风险，从而从QA的视角，可以知道哪些功能模块需要做测试，以及哪些变更内容不符合预期。相比于互联网QA，游戏QA接入业务项目研发过程并没有那么深入，比如项目代码权限基本上游戏QA不会拥有，但即便如此，要在游戏测试领域应用精准测试专项技术，还是有一定思路可循。</p>
<p>因此，本篇文章，笔者以自身经验为出发点，讲述一下在游戏业务测试落地精准测试专项的一些思路。</p>
<a id="more"></a>
<p>首先来看，游戏业务测试场景，精准测试要分析什么以及测什么。精准测试一般会采用代码覆盖技术来分析单次变更所影响的范围，也包括分析变更对上下游服务跟DB的影响。但是，游戏服务架构相比于互联网微服务架构，上下游业务链路不会非常深。因此，从游戏测试角度，代码变更内容可以更加精确定位到具体哪个系统哪个功能点有所改动，理论上会更容易评估哪些测试点需要测试。</p>
<p>如果游戏QA不具有项目代码权限的话，那么可以退而求其次，可以从业务配置或者协议定义变更的角度，来推断哪些系统哪些模块需要做回归测试。虽然这类变更的信息粒度不及代码变更，不一定非常精准，但至少也可以发现夹带的变更风险。游戏本身作为一个微缩的世界模拟，各类玩法系统在实现上，逻辑耦合的可能性是很高的。因此，在日常迭代期间，如果能够确认更多的夹带风险，对于游戏大版本发布的质量防控是有所收益的。</p>
<p>然后来看，要在游戏业务测试场景落地精准测试，需要做些什么。从游戏业务测试视角，要把精准测试专项落起来的话，一期的待测系统选型是非常关键的。对于强客户端类型的系统玩法，比如时装（展示）、载具、枪械等，更重的逻辑会落在客户端用于仿真模拟的代码，或是Actor状态同步的代码，业务属性并不高，因此做变更分析会比较困难，并不适合做精准测试的初步推广。反之，类似副本任务、运营活动、成就收集、商城交易等类型的系统，一是代码更能体现业务属性，二是实现机制可能和其它系统玩法有所交集，因此比较适合做初步推广。</p>
<p>精准测试的整体落地方面，不建议做比较激进地做推动。这是因为，精准测试本身属于专项范畴，从实操角度，会存在额外的工作量，并不能完全替代日常地功能测试工作。因此，推荐仅圈定特定范围做整体落地，方式比如：对于整个项目测试组，以双周或者月为周期做一轮变更扫描，下发到各系统owner做变更内容确认；仅针对特定系统模块的测试小组，单独做变更对应测试点的标注，以及实时监控变更内容，做更细粒度更日常的精准测试。目标收益层面，都可以通过【专项发现Bug数】这一指标来衡量，这是因为，项目日常迭代期间，由Bug数可以直接反映精准测试所能发现的问题。</p>
<p>最后，需要强调的是，精准测试本身也是游戏业务测试锦上添花的一部分。从宏观的角度看，精准测试可以发现夹带风险，可以通过精准定位测试点提升测试能效，但专项落地本身也会耗费一定的时间人力，以及理解专项知识跟目的的成本。从游戏项目整体质量保障角度看，具体是否要投入做精准测试，收益能否达到预期，还需要谨慎斟酌决策。</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>游戏测试</tag>
        <tag>专项测试</tag>
        <tag>功能测试</tag>
        <tag>精准测试</tag>
        <tag>业务测试</tag>
      </tags>
  </entry>
  <entry>
    <title>【DIY小记】修复Win10启动出现蓝屏0xc0000185错误的一些方法</title>
    <url>/2023/09/17/diymemo/win10_0xc0000185/</url>
    <content><![CDATA[<p>近些日子想到自己尘封已久的笔记本电脑没有开机了，很多软件驱动之类的没有更新，就打算把电脑开起来做一轮批量升级。但开电脑的时候很久没有进入Win10桌面，等了很长一段时间蓝屏提示0xc0000185错误，说系统需要恢复。经历了一番折腾之后，笔者解决了这个问题。虽然不明确这个问题的根因在哪里，但还是分享一下自己收集到的一些解决方式。</p>
<p>首先，重装系统肯定是能解决这个问题，但不一定需要真的重装，这个成本太大了。反之，我们可以用重装系统所需要的东西，一个自带WinPE系统的U盘，把U盘插到电脑里，重启电脑，在自己电脑的BIOS里选择优先引导U盘的WinPE系统，这样下次启动电脑时候就能进去。市面上做装机服务，基本上都会用到这种系统，而这样的U盘也很好做，有一个空的U盘，然后在老毛桃之类的网站找一个一键制作的软件操作就可以。</p>
<a id="more"></a>
<p>由于0xc0000185错误的原因之一，可能是<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3RhcmRpcy96bS9hcnQvMzU5OTkxMDk1P3NvdXJjZV9pZD0xMDA1" title="https://www.zhihu.com/tardis/zm/art/359991095?source_id=1005">Win10操作系统引导文件损坏<i class="fa fa-external-link"></i></span>，因此进入WinPE系统，假设你用老毛桃制作U盘的话，会自带BCD引导修复工具。可以用这个工具给Win10操作系统所在的硬盘做引导文件修复操作试试看。</p>
<p>其次是可以用删除注册表某个键值的方式。具体可以看<span class="exturl" data-url="aHR0cHM6Ly93d3cuamI1MS5uZXQvb3Mvd2luMTAvNzMzMjI5Lmh0bWw=" title="https://www.jb51.net/os/win10/733229.html">这篇文章<i class="fa fa-external-link"></i></span>。但这里会存在一个问题是，进不了桌面，怎么删注册表？这里，我们优先考虑看能否进入Win10的安全模式，既然正常桌面进不去，可以进简化的安全模式看行不行，行的话就可以操作，不行的话再想其它办法，比如在WinPE里操作。如果能够成功进入安全模式，和笔者一样，那么也记得清理一下系统，修复一下注册表，假设你有一些安全软件或者系统清理软件的话。要尽可能让系统恢复到一个比较干净的状态。</p>
<p>最后，如果是尘封已久的笔记本的话，也需要尽量把电充到一个比较足的状态。这里YY一种可能是，系统用了比较高性能的模式，但笔记本本身电量少，导致系统无法正常启动。虽然这一点不是很经得起推敲，但实际解决这个问题时，可以尝试排除一下这个变量。</p>
]]></content>
      <categories>
        <category>DIY小记</category>
      </categories>
      <tags>
        <tag>Win10</tag>
        <tag>BIOS</tag>
        <tag>WinPE</tag>
        <tag>操作系统</tag>
        <tag>系统设置</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】浅谈游戏策划配置表检查的技术设计</title>
    <url>/2023/09/17/testlife/game_table_check/</url>
    <content><![CDATA[<p>近期在<span class="exturl" data-url="aHR0cHM6Ly90ZXN0ZXJob21lLmNvbS8=" title="https://testerhome.com/">testerhome<i class="fa fa-external-link"></i></span>的游戏测试节点里，看到一个很有趣的<span class="exturl" data-url="aHR0cHM6Ly90ZXN0ZXJob21lLmNvbS90b3BpY3MvMzc2NDk=" title="https://testerhome.com/topics/37649">帖子<i class="fa fa-external-link"></i></span>：针对游戏策划的配置表测试，是否有开源的框架可以用？除了问题本身之外，帖子的楼主也附了一张整个配置表测试工具的设计图，由SVN变更监控、发起检查最后到消息通知，组成了一个持续集成的配置表测试专项工程。为此，针对这个场景，笔者也希望输出一些自己对于配置表检查测试技术的一些思考。</p>
<p>本篇文章讲述两块内容，第一块讲下测试框架的开源，第二块讲下专项技术的设计。首先，看一下配置表测试框架开源这块的问题。</p>
<a id="more"></a>
<p>开源的技术产品有很多种，可以是日常的玩具，可以是为了解决特定问题的工具，也可以是提升影响力的筹码。如果单纯只是针对配置表测试框架而言，不考虑业务方面的需要，这类框架如果开源出来，形态则相对类似日常玩具或者工具的类型，但能不能直接用上，就值得商榷了。不同的工作室，用的策划配置表可能文件格式不同，表格排版不同，数据结构不同，因此不一定说一个项目的配置表检查工具，就一定可以通用到另外一个项目里。而且，如果开源的框架需要为我所用，那么必须保证框架本身是具备较高防御性的，不能说实际用的时候要排查一堆框架本身的bug。从这一点考虑，大多数业务测试团队内部开发出来的检查工具，很大概率只是跑通了基础流程，而并非一个很具备防御性的技术产品。因此如果把这类框架拿出来开源，那使用起来也会相当麻烦。</p>
<p>因此第一个问题，是否要使用开源的测试框架，笔者的建议是如果需要快速交付是可以考虑，github跟gitee上肯定有类似的repo，但如果要打持久战，开源的肯定不如自家的好。</p>
<p>第二个问题是配置表测试专项技术的设计。为什么把话题扯得这么大？是因为如果做配置表检查，不结合游戏业务来做是无意义的，尤其是我们需要做到持续交付、持续反馈，提升整个项目团队的交付质量，不只是要考虑检查本身，对哪些配置表做检查，检查什么，用什么方式展现出来，这些都是整个专项所需要考虑的。我们所要解决的最终问题，是提升配置表的质量，所用到的手段，是配置表检查框架，还有一套CI测试流水线。</p>
<p>首先再回到配置表检查框架。表格类型的数据，我们可以简单划分为key-value两个部分，其中key可能包含id类型的主键。而针对value，除了基础的数值、字符串类型之外，在转表过程中，也有可能被转化成json类型的数据。因此我们在写检查逻辑时，不仅要考虑到简单的kv映射，还要考虑到异构化的数据值，内部应该如何解析。如果从通用化的层面考虑，用mongodb或者es存储表格数据是不错的形式，这样我们只需要组合一些特定的检索规则查询”错账”数据即可达到数据检查的目的。当然，如果在内存里面做数据查询也可以，但需要你的主机具有足够的内存空间。</p>
<p>然后来到检查什么数据。通常不论是用SVN还是用Git来存储配置数据，我们都可以实时监听repo的变化，来决定需要检查哪些表格的数据。从持续集成的角度来说，流程搭建起来并不难，但难点在于性能跟效率方面的优化。</p>
<p>如果一个游戏项目涉及到多渠道多国家发布，那么必须要处理多版本共存的问题，也就是说在同一个时间窗口，可能要检查不同分支不同提交的表格数据。要做到这一点，就必须有一套检查任务调度+数据归档的机制，不论什么分支有变化，都可以最终收敛到一次检查任务，保证每一次检查过程都是相互独立的。同时，工具开发者也需要根据自己主机资源的多少，决定一个时间窗口里，有多少任务可以并行。考虑了这些点，就能解决多版本共存的问题。</p>
<p>然后是检查任务本身。对于业务，最理想的情况是能够每一次提交配置时候都做一次检查，但如果提交的内容和配置本身无关，或者不在业务希望检查的配置里，那么就会产生一次无效检查。因此为了提升效率，就需要做预检查，看提交的内容和自己标记的需要检查的内容是否相关，如果相关才做检查。除此之外，还有一点是变更的配置文件可能只有很小一部分，那么如果在技术设计方面是全量下载数据的话，可能下载本身会比做规则检查费时很多。因此在数据更新方面，如果能做到调度不同分支的repo，能够做到按需更新数据，那整个检查过程的效率就会非常快。</p>
<p>总体来说，配置表测试专项技术，做小了可以做成日常测试的工具，做大了也可以成为一个庞大的工程。具体做多少，做成怎样的形式，最终还是需要衡量业务具体需求如何，以及交付时间是否紧张。</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>工具开发</tag>
        <tag>表格检查</tag>
        <tag>持续集成</tag>
        <tag>游戏测试</tag>
        <tag>测试开发</tag>
      </tags>
  </entry>
  <entry>
    <title>【从零单排Golang】第十五话：用sync.Once实现懒加载的用法和坑点</title>
    <url>/2023/09/03/gofromzero/15_sync_once/</url>
    <content><![CDATA[<p>在使用Golang做后端开发的工程中，我们通常需要声明一些一些配置类或服务单例等在业务逻辑层面较为底层的实例。为了节省内存或是冷启动开销，我们通常采用lazy-load懒加载的方式去初始化这些实例。初始化单例这个行为是一个非常经典的并发处理的案例，比如在java当中，我们可能用到建立双重锁+volatile的方式保证初始化逻辑只被访问一次，并且所有线程最终都可以读取到初始化完成的实例产物。这段经典的代码可以按如下的方式编写：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考：https://blog.csdn.net/qq_27489007/article/details/84966680</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == uniqueSingleton) &#123;</span><br><span class="line">                    uniqueSingleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但在Golang里面，实现懒加载的方式可以简单的多，用内置的sync.Once就能满足。假设我们有一个user单例，需要被1000个线程读取并打印，就可以这样子写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">    Age  <span class="keyword">int</span>    <span class="string">`json:"age"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user *User</span><br><span class="line"><span class="keyword">var</span> userOnce sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initUser</span><span class="params">()</span></span> &#123;</span><br><span class="line">    user = &amp;User&#123;&#125;</span><br><span class="line">    cfgStr := <span class="string">`&#123;"name":"foobar","age":18&#125;`</span></span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal([]<span class="keyword">byte</span>(cfgStr), user); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"load user err: "</span> + err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getUser</span><span class="params">()</span> *<span class="title">User</span></span> &#123;</span><br><span class="line">    userOnce.Do(initUser)</span><br><span class="line">    <span class="keyword">return</span> user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSyncOnce</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            curUser := getUser()</span><br><span class="line">            t.Logf(<span class="string">"[%d] got user: %+v"</span>, n, curUser)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码里，首先是通过<code>var userOnce sync.Once</code>声明了一个<code>sync.Once</code>实例，然后在<code>getUser</code>当中，我们声明了<code>userOnce.Do(initUser)</code>这个操作。假设一个goroutine最先到达这个操作，就会上锁并执行<code>initUser</code>，其它goroutine到达之后，得等第一个goroutine执行完<code>initUser</code>之后，才会继续<code>return user</code>。这样，就能一来保证<code>initUser</code>只会执行一次，二来所有goroutine都能够最终读到初始化完成的user单例。</p>
<p><code>sync.Once</code>的工作机理也很简单，通过一个锁和一个flag就能够实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123; <span class="comment">// 如果是1表示已经完成了，跳过</span></span><br><span class="line">		o.doSlow(f)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">doSlow</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	o.m.Lock() <span class="comment">// 只有1个goroutine能拿到锁，其它的等待</span></span><br><span class="line">	<span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">	<span class="keyword">if</span> o.done == <span class="number">0</span> &#123; <span class="comment">// 如果还是0表示第一个来的，不是0就表示已经有goroutine做完了</span></span><br><span class="line">		<span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">		f()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后也需要注意，<code>sync.Once</code>使用上面有一个坑点，不能也不需要像java一样为单例提前做nil判断。比如下面一段代码是有问题的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initUser</span><span class="params">()</span></span> &#123;</span><br><span class="line">    user = &amp;User&#123;&#125; <span class="comment">// 先给一个zero-value实例</span></span><br><span class="line">    cfgStr := <span class="string">`&#123;"name":"foobar","age":18&#125;`</span> <span class="comment">// 然后加载json内容，完成初始化</span></span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal([]<span class="keyword">byte</span>(cfgStr), user); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"load user err: "</span> + err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getUser</span><span class="params">()</span> *<span class="title">User</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> user == <span class="literal">nil</span> &#123;</span><br><span class="line">        userOnce.Do(initUser)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Golang没有volatile关键字，不能控制单例在内存的可见性，那么多goroutine并发时，就有可能出现这样的执行时序：</p>
<ul>
<li><code>goroutine-A</code>过了<code>getUser</code>的<code>user == nil</code>判断，进入到了<code>initUser</code>逻辑，走到了<code>cfgStr := XXX</code>一行</li>
<li>此时切换到<code>goroutine-B</code>，因为<code>goroutine-A</code>在<code>initUser</code>已经走过了<code>user = &amp;User{}</code>一行，所以跳过了<code>user == nil</code>判断，直接返回没有完全初始化的<code>user</code>实例，然后一直往下运行，就没切回给<code>goroutine-A</code></li>
</ul>
<p>这样的结果，就导致有goroutine拿到未初始化完成的实例往后运行，后面就出问题了。所以实战当中需要留意，用<code>sync.Once</code>时，不能也不需要加这些nil判断，就能满足懒加载单例/配置之类的逻辑。</p>
]]></content>
      <categories>
        <category>从零单排Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>后端开发</tag>
        <tag>并发</tag>
        <tag>Once</tag>
        <tag>懒加载</tag>
      </tags>
  </entry>
  <entry>
    <title>【从零单排Golang】第十四话：使用rate和ratelimit实现限流限速</title>
    <url>/2023/08/26/gofromzero/14_ratelimit/</url>
    <content><![CDATA[<p>在研发中，我们经常会面对到处理并发逻辑的场景，尤其是有时候在与第三方平台对接的场景下，会遇到请求限流限QPS的要求。对于限流或者限速，我们通常会用两种算法来满足需要：</p>
<ul>
<li>令牌桶算法：在特定容量的桶里面装令牌，当令牌数量小于桶的容量时，会持续以我们预期的限流速率生产令牌；不管桶里面是不是空的，业务都得等到拿到令牌，才能继续执行业务逻辑</li>
<li>漏桶算法：业务先统一进入桶里，桶满了之后，会以我们预期的限流速率，一个个把在等待的业务漏出去，然后各个业务才开始执行业务逻辑</li>
</ul>
<p>这两种算法，虽然实际QPS数值可能都会有波动，但都能把速率限制在一个合理的水位。在Golang里面，这两种算法都有现成的实现可以直接用。咱们今天，就来看看这块的例子。</p>
<a id="more"></a>
<p>首先来看看令牌桶算法，在Golang自带的rate库中，就有了一份令牌桶算法的实现。我们上一下代码的例子，来看一下rate库的基本用法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"golang.org/x/time/rate"</span> <span class="comment">// 需要import的rate库，其它import暂时忽略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成0-&gt;X的数据集</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateData</span><span class="params">(num <span class="keyword">int</span>)</span> []<span class="title">any</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data []any</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">        data = <span class="built_in">append</span>(data, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理数据，数字*10</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(obj any)</span> <span class="params">(any, error)</span></span> &#123;</span><br><span class="line">    integer, ok := obj.(<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"invalid integer"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">1</span>)</span><br><span class="line">    nextInteger := integer * <span class="number">10</span></span><br><span class="line">    <span class="keyword">if</span> integer%<span class="number">99</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextInteger, errors.New(<span class="string">"not a happy number"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextInteger, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRate</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    limit := rate.Limit(<span class="number">50</span>) <span class="comment">// QPS：50</span></span><br><span class="line">    burst := <span class="number">25</span> <span class="comment">// 桶容量25</span></span><br><span class="line">    limiter := rate.NewLimiter(limit, burst)</span><br><span class="line">    size := <span class="number">500</span> <span class="comment">// 数据量500</span></span><br><span class="line"></span><br><span class="line">    data := generateData(size)</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    startTime := time.Now()</span><br><span class="line">    <span class="keyword">for</span> i, item := <span class="keyword">range</span> data &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>, obj any)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="comment">// 拿到令牌</span></span><br><span class="line">            <span class="keyword">if</span> err := limiter.Wait(context.Background()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                t.Logf(<span class="string">"[%d] [EXCEPTION] wait err: %v"</span>, idx, err)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行业务逻辑</span></span><br><span class="line">            processed, err := process(obj)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                t.Logf(<span class="string">"[%d] [ERROR] processed: %v, err: %v"</span>, idx, processed, err)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t.Logf(<span class="string">"[%d] [OK] processed: %v"</span>, idx, processed)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i, item)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    endTime := time.Now()</span><br><span class="line">    t.Logf(<span class="string">"start: %v, end: %v, seconds: %v"</span>, startTime, endTime, endTime.Sub(startTime).Seconds())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>limiter := rate.NewLimiter(limit, burst)</code>的形式，我们可以初始化一个令牌生成速率为limit，容量为burst的令牌桶。在业务里，则通过<code>limiter.Wait(ctx)</code>的方式拿到一个令牌，执行逻辑。结合先前讲过的<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjMvMDgvMDYvZ29mcm9temVyby8xM193YWl0Z3JvdXAv" title="https://utmhikari.top/2023/08/06/gofromzero/13_waitgroup/">WaitGroup<i class="fa fa-external-link"></i></span>，我们就能够实现开多个goroutine异步执行任务，并配合limiter来做业务逻辑的限速。</p>
<p>这里需要注意，从长线来看，limit的大小是能够决定一个基础的限速速率，但从短线角度来看，burst这个桶具备了缓冲作用，在冷启动时，由于burst的存在，初始的QPS会比实际预估的较大。因此，业务通过令牌桶方式限速时，如果需要限制冷启动时的瞬时速率，需要留意把burst的值设置小一些。</p>
<p>然后我们再来看通过漏桶算法来限速的例子，这回需要用到一个开源库<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ViZXItZ28vcmF0ZWxpbWl0" title="https://github.com/uber-go/ratelimit">uber-go/ratelimit<i class="fa fa-external-link"></i></span>来实现。例子也非常简单，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRateLimit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    limiter := ratelimit.New(<span class="number">50</span>) <span class="comment">// 漏桶速率50</span></span><br><span class="line">    size := <span class="number">500</span></span><br><span class="line"></span><br><span class="line">    data := generateData(size)</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    startTime := time.Now()</span><br><span class="line">    <span class="keyword">for</span> i, item := <span class="keyword">range</span> data &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>, obj any)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            limiter.Take() <span class="comment">// 入桶待漏</span></span><br><span class="line">            processed, err := process(obj)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                t.Logf(<span class="string">"[%d] [ERROR] processed: %v, err: %v"</span>, idx, processed, err)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t.Logf(<span class="string">"[%d] [OK] processed: %v"</span>, idx, processed)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i, item)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    endTime := time.Now()</span><br><span class="line">    t.Logf(<span class="string">"start: %v, end: %v, seconds: %v"</span>, startTime, endTime, endTime.Sub(startTime).Seconds())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ratelimit</code>库速率的单位可以类比为QPS，通过<code>ratelimit.New</code>，可以初始化一个指定QPS限制的限流器。执行业务逻辑前，需要通过<code>limiter.Take()</code>逻辑等待漏出来后，才能执行后续的逻辑。这样便实现了限流的效果。</p>
]]></content>
      <categories>
        <category>从零单排Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>限速</tag>
        <tag>限流</tag>
        <tag>令牌桶算法</tag>
        <tag>漏桶算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【从零单排Golang】第十三话：使用WaitGroup等待多路并行的异步任务</title>
    <url>/2023/08/06/gofromzero/13_waitgroup/</url>
    <content><![CDATA[<p>在后端开发当中，经常会遇到这样的场景：请求给了批量的输入，对于每一个输入，我们都要给外部发请求等待返回，然后才能继续其它自己的业务逻辑。在这样的case下，如果每一个输入串行处理的话，那么很大一部分时间都会损耗在给外部发请求这个环节，因此我们会希望把这些请求放到各个goroutine里异步执行，等待批量执行完成之后再继续后面的逻辑。这个时候，我们就可以用到这个东西：sync.WaitGroup</p>
<p>WaitGroup提供了增减计数以及阻塞等待计数归零的线程安全接口。当主goroutine增加计数并等待的时候，子goroutine的逻辑中若引用了一个WaitGroup实例的话，也可以在结束（defer）的时候去减少计数，这样当主goroutine自旋等待计数归零时，等待的逻辑就返回了，就继续后面的内容。整体上，就达到了等待多路并行的异步任务这一效果。</p>
<p>一个典型的代码案例如下：</p>
<a id="more"></a>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestWaitGroup</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    startTime := time.Now()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        n := i + <span class="number">1</span></span><br><span class="line">        sleepTime := time.Duration(n) * time.Second</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">            t.Logf(<span class="string">"task %d started"</span>, n)</span><br><span class="line">            time.Sleep(sleepTime)</span><br><span class="line">            t.Logf(<span class="string">"task %d ended"</span>, n)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    t.Logf(<span class="string">"waiting for all tasks done..."</span>)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    endTime := time.Now()</span><br><span class="line">    t.Logf(<span class="string">"all tasks done! elapsed time: %v"</span>, endTime.Sub(startTime))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个逻辑很简单，我们起了5个任务，每个任务分别sleep上1到5秒。主goroutine此时在每个任务开始前，给WaitGroup实例wg加上1个计数，而在子goroutine里，defer地调用wg.Done减少计数。主goroutine起完任务之后，直接调用wg.Wait自选等待。这样5s后等所有任务Done，主goroutine就会接下来打印消耗时间的日志信息了。</p>
<p>打印的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">=== RUN   TestWaitGroup</span><br><span class="line">    wg_test.go:26: waiting for all tasks done...</span><br><span class="line">    wg_test.go:21: task 5 started</span><br><span class="line">    wg_test.go:21: task 1 started</span><br><span class="line">    wg_test.go:21: task 2 started</span><br><span class="line">    wg_test.go:21: task 3 started</span><br><span class="line">    wg_test.go:21: task 4 started</span><br><span class="line">    wg_test.go:23: task 1 ended</span><br><span class="line">    wg_test.go:23: task 2 ended</span><br><span class="line">    wg_test.go:23: task 3 ended</span><br><span class="line">    wg_test.go:23: task 4 ended</span><br><span class="line">    wg_test.go:23: task 5 ended</span><br><span class="line">    wg_test.go:29: all tasks done! elapsed time: 5.0015089s</span><br><span class="line">--- PASS: TestWaitGroup (5.00s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure>
<p>WaitGroup的用法非常简单，但这里注意的是，实际遇到这种编程场景，一般会涉及到多任务运行结果收集还有程序异常处理相关的内容。因此，像recover或者select超时等一些子goroutine任务异常处理的逻辑，可能视实际情况都得配合加上。</p>
]]></content>
      <categories>
        <category>从零单排Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>后端开发</tag>
        <tag>异步</tag>
        <tag>并行</tag>
        <tag>WaitGroup</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】批量刷数的发布流程与风险点</title>
    <url>/2023/07/09/testlife/data_wash_risk/</url>
    <content><![CDATA[<p>在项目日常开发过程中，批量刷数也是有一定频率的变更场景之一，同时也是容易产生风险的一种变更操作。本文就来聊下，批量刷数的发布需要经历哪些流程，以及流程中每个环节中有什么风险点需要考虑。</p>
<p>首先需要了解批量刷数这个操作是个什么意义。无论是新增/删除一些数据也好，还是UPDATE某些已有线上数据也好，其背后要么对应着一个新业务开发，要么对应着一个bugfix。因此，批量刷数的本质其实就是一个业务需求，需要有完整的一套需求评审 -&gt; 技术评审 -&gt; 线下测试 -&gt; 线上发布 -&gt; 发布验证的过程。</p>
<p>第一个环节是需求评审。需求评审的主要的目的，一是为了做刷数的可行性评估，二是做刷数记录归档。</p>
<a id="more"></a>
<p>由于刷数的时间长&amp;难以回滚的特性，不到万不得已的情况下，修复问题或是开发新需求，一般是不需要刷数操作的。如果需要做刷数操作，那么就需要提供需求背景信息，以及为什么一定需要刷数操作来达到需求目的，这样，从PM和TL角度，可以初步评估刷数的必要性，以及是否有更好的workaround。如果需要做刷数，那么这个需求就可以被归档到特定的业务模块里，以方便做进度跟踪和方案回溯。更甚者，如果需求管理平台自带流程管理和审批功能，那么在发布过程中，许多review跟审批操作都可以统一收敛到需求管理平台当中，这也是符合业务习惯的一种落地方式。</p>
<p>之后第二个环节便是技术评审。技术评审是整个批量刷数过程中最为重要的一环，因为在这一阶段，就必须考虑到整个刷数过程需要如何操作，上线分怎样的步骤，以及出现问题如何止损，刷数正确性如何验证。就规避风险而言，具体有需要考量以下点：</p>
<ul>
<li>上下游关系：厘清刷数DB/服务涉及的上下游业务链路，尤其留意刷数操作触发下游数据同步/消费任务的场景时，引发过高并发/QPS的问题。除了确认上下游链路的完整性跟合理性外，还需要通过历史运行数据，估算一个合理的并发度。</li>
<li>SQL影响面：DML场景下需要有EXPLAIN分析影响行数/命中索引情况，DDL场景下留意主从同步延迟给业务带来的影响。必要时，拉DBA做性能跟风险评估。</li>
<li>结果验证：在业务层面，需要如何验证刷数的效果，需要周知哪些负责人，如何确认数据有效性。这里尤其建议，测试/对账方案的评估过程，以及实际上线/刷数后验证的过程，强制QA介入，防止产生业务质量风险。</li>
<li>操作手法：刷数是一次性操作还是分批操作，选取的case覆盖哪些，分批和观察的节奏如何，如何验证刷数的正确性</li>
<li>过程监控：刷数期间，需要关注哪些业务和性能监控指标，监控告警需要知会到谁，级别如何</li>
<li>回滚止损：如果刷数操作不符合预期，怎样快速回滚，避免出错后因为缺失回滚方案导致二次犯错风险</li>
</ul>
<p>技术评审之后是线下测试。线下测试最基础的保障是业务功能正常，但这里有一个风险是，线上刷数的量，相对于线下测试的量，实际是多得多的。像是SQL未命中索引、以及下游MQ堆积消费之类的操作，在线下测试时期，大概率没有办法暴露出来。而考虑到刷数需求的紧急程度，一般也很难紧急构造很重量级的数据跟上下文来还原线上场景。因此业务层面，规避这类风险的一个方法是，在技术评审环节去评估哪些问题是小数据量测试时无法暴露的，并在线下测试环节中给予一个复查checklist兜底。</p>
<p>线下测试完毕之后，就到了线上发布环节，这其中有几点需要考虑。首先是选择发布的时段，一般而言需要在上下游业务的非高峰期发布，以及非节假日发布，会比较保险。其次是发布的上线审批环节，除了选定合适的审批人操作外，操作的信息以及后续发布过程的信息，需要周知到上下游关联人。之后是发布的节奏，一般采取分批次发布的方式，比如先按业务用例最小集刷10个以内的数据量，然后刷20%左右，最后刷剩下80%。分批发布过程中，需要有足够的观察时间，防止发布过程中出现异常但来不及回滚。</p>
<p>线上发布的风险，除了来源于方案设计层面，操作层面的风险也不可避免。如果数据量大，刷数并发QPS过高，那么很容易引发下游的问题。因此建议每一批次发布操作实际发起时，有另一人知会或者review操作细节。如果出现不符合技术方案的操作，也可以及时阻止。同时，发布过程中的业务/性能监控信息，上下游/DBA负责人也有义务一起关注，要关注的信息点，也需要在发布前的方案里，做好详细分工。</p>
<p>线上发布过后，就是最终的测试验证跟对账了。这里尤其注意的是，验证和对账操作，在小批次发布的时候，就可以进行操作，或者是做成实时化巡检的形式，便于及时验证发布可靠性，也能够满足某些定时刷数任务的需求。</p>
<p>总的来说，刷数操作，从需求提出到发布完成，整个过程是非常紧凑跟紧张的。但最重要的一点，还是得保证刷数的稳定性，即便可能会有时间层面的损失。沉淀一套刷数流程SOP，归纳可能的风险点跟处理方案，能够有效提升刷数操作的规范性跟稳定性。以刷数流程为指导，同样也能保证发布的效率，也能规避到中途出现意外的情况下，不知如何处理，导致发布脏数据或者更大的事故影响。</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>变更风险</tag>
        <tag>DevOps</tag>
        <tag>持续集成</tag>
        <tag>数据变更</tag>
        <tag>批量刷数</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】SQL变更的问题拦截手段</title>
    <url>/2023/07/08/testlife/sql_change_block/</url>
    <content><![CDATA[<p>在DB做变更发布的各类场景当中，通过SQL更改DB数据内容，是最为常见的场景。既然是最为常见的场景，那么可能产生线上问题的概率也就越大。本篇文章就来探讨一下，要尽量减少SQL发布产生线上问题的可能性，需要采取什么样的手段。</p>
<p>首先是针对SQL语句本身而言，需要做积累检查。假设用的是MySQL，那么SQL类型大体可能分为以下几种：</p>
<ul>
<li>新增类：CREATE表/列/索引、INSERT数据</li>
<li>更改类：UPDATE数据</li>
<li>删除类：DELETE数据、DROP表/列/索引（包含替换场景）、TRUNCATE</li>
</ul>
<p>针对这些SQL类型，其产生线上风险的概率也不尽相同，需要分别进行治理。</p>
<a id="more"></a>
<p>针对删除类SQL，本身就需要直接拦截告警。从变更管控的视角，删除类的变更建议需要二次确认目的以及回滚的方式。针对DELETE数据的操作一般不推荐，从业务视角来看，通过软删除的方式一般相对更加合理，一来回滚方便，二来不会破坏自增主键的连续性；针对DROP类，需要确认删除的表、列、索引是否在用，是否有上下级依赖。如果存在的话，需要确认依赖是否在用，防止业务逻辑不可用的情况。</p>
<p>针对UPDATE类操作，由于容易回滚，建议二次确认回滚SQL。此外，UPDATE的扫描行数和影响行数不宜过长，通过EXPLAIN的方式，可以直到UPDATE操作具体用到了哪个索引，扫描行数和影响行数是多少。如果扫描行数/影响行数过高，势必会引起慢查询的问题；而如果更新量级不高的情况下，影响行数比扫描行数低很多，也需要确认下是否有误圈选数据的问题。针对后者，如果DB集群是master写slave读的情况下，建议先SELECT圈选出数据，统计主键，再依照主键做正式UPDATE发布。</p>
<p>针对CREATE/INSERT类操作，这类操作风险相对于UPDATE/DELETE较低，但也有一些需要注意的点。INSERT类操作，需要确认未被声明字段的默认值具体的业务含义，如果存在业务含义，需要确认是否符合预期；CREATE类操作，针对表主要确认索引、列是否加全，针对索引主要确认是否存在重复前缀导致冗余的情况。</p>
<p>然后是针对DB本身而言。DB的性能监控，包括请求延时、QPS、主从同步延时、慢查等内容，以及上下游服务的性能监控，业务对账，都需要确保完整可用。这里尤其针对DDL类操作，如果是对大表的索引/列做新增或删改，容易导致同步延时，进而导致DB性能出现开销，或者业务不可用。因此这种情况，建议需要在非高峰期操作，减小变更的影响面。</p>
<p>整体来看，SQL发布是业务变更中比较频繁的一部分。要做到拦截问题，减少线上问题影响面，上述的策略可以做一个总体参考。</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>变更风险</tag>
        <tag>DevOps</tag>
        <tag>MySQL</tag>
        <tag>SQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>【从零单排Golang】第十二话：用singleflight解决单服务处理高并发任务的问题</title>
    <url>/2023/07/01/gofromzero/12_singleflight/</url>
    <content><![CDATA[<p>在后端开发场景，我们经常会遇到高并发的事务处理逻辑。虽然在微服务治理的机制下，能够实现多个无状态服务节点+负载均衡高并发处理请求，但对于单个服务节点来讲，如果存在某些耗时的任务需要被高并发访问，那么如果没有一套妥善的机制处理，就很容易出现大量这类任务实例堆积，导致任务返回延迟，或者节点内存暴涨的情况。今天，就来介绍Golang内部处理这种场景的一套方案：singleflight。</p>
<h2 id="singleflight的应用场景"><a href="#singleflight的应用场景" class="headerlink" title="singleflight的应用场景"></a>singleflight的应用场景</h2><p>singleflight主要解决单服务处理高并发任务问题，尤其是服务冷启动时候没有足够请求hit到缓存的场景。假设业务有一个【获取Token】的场景，存在如下的实际约束：</p>
<ul>
<li>访问方式：一个业务（Business），获取一个特定区域（Region）的Token</li>
<li>Token区域：分为欧亚美非四个区域，每个区域获取Token的时间不一样，但无论怎么输入，都需要【几秒】后才能得到结果</li>
<li>访问量级：单个业务下可能存在很多需要获取Token的服务，总的访问这个接口的QPS可能达到【百级或千级】</li>
<li>服务数量：你只有【1】个服务节点实例处理这些请求</li>
</ul>
<p>为了解决这个问题，你可能会考虑通过以下的方式：</p>
<a id="more"></a>
<ul>
<li>对于一类任务，用一个独特的Key标识：Business+Region</li>
<li>当一类任务被触发时，用一个mutex加锁，直到任务完成之后，才解锁</li>
<li>用一个map来存储所有任务Key和任务锁</li>
<li>如果某类任务在运行时，又被其它来源触发一次，那么这些触发只需要自己做轮询，等任务完成拿结果就行</li>
<li>缓存这些任务执行的结果，短期内生效</li>
</ul>
<p>但这样的方式，实现起来，也是非常麻烦的。而通过singleflight，就可以解决掉除了缓存之外的其它问题。</p>
<h2 id="singleflight的写法"><a href="#singleflight的写法" class="headerlink" title="singleflight的写法"></a>singleflight的写法</h2><p>让我们把上面的场景转化为实际代码来看看。首先，是获取Token的逻辑。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    RegionAmerica = <span class="string">"America"</span></span><br><span class="line">    RegionEurope  = <span class="string">"Europe"</span></span><br><span class="line">    RegionAsia    = <span class="string">"Asia"</span></span><br><span class="line">    RegionAfrica  = <span class="string">"Africa"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mpRegionWaitTime = <span class="keyword">map</span>[<span class="keyword">string</span>]time.Duration&#123;</span><br><span class="line">    RegionAmerica: <span class="number">5</span> * time.Second,</span><br><span class="line">    RegionEurope:  <span class="number">3</span> * time.Second,</span><br><span class="line">    RegionAfrica:  <span class="number">4</span> * time.Second,</span><br><span class="line">    RegionAsia:    <span class="number">2</span> * time.Second,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getToken</span><span class="params">(region <span class="keyword">string</span>, business <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    waitTime, ok := mpRegionWaitTime[region]</span><br><span class="line">    <span class="keyword">if</span> !ok || waitTime == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"unsupported region: "</span> + region)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"[getToken] region: %s, business: %s, wait-time: %v"</span>, region, business, waitTime)</span><br><span class="line">    time.Sleep(waitTime)</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s|%s|%d"</span>, region, business, time.Now().UnixMilli()), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码含义里，每个region的token，都至少等待2秒钟才能拿到结果。</p>
<p>然后就是用singleflight来解决这个事情了。我们需要把获取token封装成一个Task的形式，通过singleflight的机制来按标识批量处理：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getTokenGroup singleflight.Group</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetTokenTask <span class="keyword">struct</span> &#123;</span><br><span class="line">    Region   <span class="keyword">string</span></span><br><span class="line">    Business <span class="keyword">string</span></span><br><span class="line">    callback <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(t *GetTokenTask)</span> <span class="title">key</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s|%s"</span>, t.Region, t.Business)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *GetTokenTask)</span> <span class="title">Do</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    key := t.key()</span><br><span class="line">    v, err, _ := getTokenGroup.Do(key, t.callback)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">"[GetTokenTask] [%s] get token err: %v"</span>, key, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    token, ok := v.(<span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        log.Printf(<span class="string">"[GetTokenTask] [%s] convert token to string err"</span>, key)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"[GetTokenTask] [%s] got token: %s"</span>, key, token)</span><br><span class="line">    <span class="keyword">return</span> token</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newGetTokenTask</span><span class="params">(region <span class="keyword">string</span>, business <span class="keyword">string</span>)</span> *<span class="title">GetTokenTask</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;GetTokenTask&#123;</span><br><span class="line">        Region:   region,</span><br><span class="line">        Business: business,</span><br><span class="line">        callback: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getToken(region, business)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，每一个GetTokenTask，会有一个对应的任务标识key。我们需要新建一个singleflight.Group实例，并通过实例的Do方法，来封装处理对应key的任务。</p>
<p>通过这样的封装，当某个任务已经在运行的时候，如果其它相同key的任务刚被触发，那么这些任务不会实际运行，而是等待已经运行的任务的有了结果，就直接返回。这样，就节省了任务实际运行的次数了。</p>
<p>我们可以通过一段测试代码来看：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetToken</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    numTasks := <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 business, random region</span></span><br><span class="line">    business := <span class="string">"gofromzero"</span></span><br><span class="line">    regions := []<span class="keyword">string</span>&#123;RegionAmerica, RegionEurope, RegionAsia, RegionAfrica&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run multiple tasks</span></span><br><span class="line">    t.Logf(<span class="string">"start %d tasks..."</span>, numTasks)</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numTasks; i++ &#123;</span><br><span class="line">        num := i + <span class="number">1</span></span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            idx := n % <span class="built_in">len</span>(regions)</span><br><span class="line">            region := regions[idx]</span><br><span class="line">            token := GetToken(region, business)</span><br><span class="line">            <span class="keyword">if</span> token == <span class="string">""</span> &#123;</span><br><span class="line">                t.Logf(<span class="string">"[task:%d] get token failed!"</span>, n)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t.Logf(<span class="string">"[task:%d] got token -&gt; %s"</span>, n, token)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(num)</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Millisecond)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    t.Logf(<span class="string">"finish!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任务总共有1000个，但实际运行到<code>getToken</code>函数的次数，仅仅只有4次。这样，就达到了预期的效果。</p>
<p>最后需要注意的是，考虑到一般获取Token的逻辑，Token本身一般会有生效时间。因此最好在<code>getToken</code>逻辑中，增加一个缓存结果的逻辑，这样后续的获取Token任务就不必再多等几秒钟才能拿到结果了，可以优先走缓存。</p>
<h2 id="singleflight的源码分析"><a href="#singleflight的源码分析" class="headerlink" title="singleflight的源码分析"></a>singleflight的源码分析</h2><p>singleflight的用法明白了，进阶地，我们可以看一下singleflight源码怎么实现的。</p>
<p>首先是singleflight.Group的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu sync.Mutex       <span class="comment">// protects m</span></span><br><span class="line">	m  <span class="keyword">map</span>[<span class="keyword">string</span>]*call <span class="comment">// lazily initialized</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">	wg sync.WaitGroup</span><br><span class="line">	val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	err error</span><br><span class="line">	dups  <span class="keyword">int</span></span><br><span class="line">	chans []<span class="keyword">chan</span>&lt;- Result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个singleflight.Group中，会通过一个map来维护任务标识key和任务实例call的关系。</p>
<p>在每个call中，包含以下内容：</p>
<ul>
<li>val、err：任务返回的结果</li>
<li>chans：在通过chan接收返回结果场景下，所有任务的channels（本文未举例，读者有兴趣可自行了解）</li>
<li>wg：当任务已经在运行时，往后的触发为了等待任务完成需要用的WaitGroup</li>
<li>dup：这个任务的实际并发量（任务触发+运行过程中总共被触发的次数之和）</li>
</ul>
<p>通过Do运行任务的逻辑如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Do</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(v <span class="keyword">interface</span>&#123;&#125;, err error, shared <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	g.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">		g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*call)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">		c.dups++</span><br><span class="line">		g.mu.Unlock()</span><br><span class="line">		c.wg.Wait()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> e, ok := c.err.(*panicError); ok &#123;</span><br><span class="line">			<span class="built_in">panic</span>(e)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> c.err == errGoexit &#123;</span><br><span class="line">			runtime.Goexit()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> c.val, c.err, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	c := <span class="built_in">new</span>(call)</span><br><span class="line">	c.wg.Add(<span class="number">1</span>)</span><br><span class="line">	g.m[key] = c</span><br><span class="line">	g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	g.doCall(c, key, fn)</span><br><span class="line">	<span class="keyword">return</span> c.val, c.err, c.dups &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个逻辑大致如下：</p>
<ul>
<li>任务已经在运行（即<code>c, ok := g.m[key]; ok</code>分支）：增加并发计数，等待wg，直接返回结果</li>
<li>任务没有运行：初始化call实例，注册到Group中，增加wg计数，doCall运行任务</li>
</ul>
<p>在doCall中的逻辑如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">doCall</span><span class="params">(c *call, key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>)</span> &#123;</span><br><span class="line">	normalReturn := <span class="literal">false</span></span><br><span class="line">	recovered := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !normalReturn &amp;&amp; !recovered &#123;</span><br><span class="line">			c.err = errGoexit</span><br><span class="line">		&#125;</span><br><span class="line">		g.mu.Lock()</span><br><span class="line">		<span class="keyword">defer</span> g.mu.Unlock()</span><br><span class="line">		c.wg.Done()</span><br><span class="line">		<span class="keyword">if</span> g.m[key] == c &#123;</span><br><span class="line">			<span class="built_in">delete</span>(g.m, key)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> e, ok := c.err.(*panicError); ok &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(c.chans) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">go</span> <span class="built_in">panic</span>(e)</span><br><span class="line">				<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(e)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> c.err == errGoexit &#123;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> _, ch := <span class="keyword">range</span> c.chans &#123;</span><br><span class="line">				ch &lt;- Result&#123;c.val, c.err, c.dups &gt; <span class="number">0</span>&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> !normalReturn &#123;</span><br><span class="line">				<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">					c.err = newPanicError(r)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		c.val, c.err = fn()</span><br><span class="line">		normalReturn = <span class="literal">true</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">if</span> !normalReturn &#123;</span><br><span class="line">		recovered = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过滤掉一些处理runtime异常的逻辑，实际只有这么些关键内容：</p>
<ul>
<li><code>c.val, c.err = fn()</code>：执行任务，返回结果</li>
<li>转到最外部的defer逻辑 -&gt; <code>c.wg.Done()</code>：其它触发的<code>wg.Wait()</code>通过了，直接拿到结果返回</li>
<li><code>delete(g.m, key)</code>，从Group中清除掉自己这个任务实例</li>
</ul>
<p>这样，整个singleflight的call就完成一组任务处理了。</p>
]]></content>
      <categories>
        <category>从零单排Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>后端开发</tag>
        <tag>源码分析</tag>
        <tag>并发</tag>
        <tag>singleflight</tag>
      </tags>
  </entry>
  <entry>
    <title>【DIY小记】工作中失误了，应该如何对待？</title>
    <url>/2023/06/11/diymemo/handle_mistakes/</url>
    <content><![CDATA[<p>今天整理博客时，恰好瞄到CSDN创作活动里，最近在搞这个主题：<span class="exturl" data-url="aHR0cHM6Ly9hY3Rpdml0eS5jc2RuLm5ldC9jcmVhdEFjdGl2aXR5P2lkPTEwNDY3" title="https://activity.csdn.net/creatActivity?id=10467">如何对待工作中的失误<i class="fa fa-external-link"></i></span>？笔者个人觉得，这个话题是非常有意义的，尤其是在现在经济形势不好，人人都担忧失业的情况下，怎么样对待工作的失误，甚至是工作本身，不论是从心态上，还是从策略（抓手）上，都是值得去深入讨论的。因此，笔者决定为【DIY小记】系列特别撰写一篇文章，来谈一下工作中失误了之后，到底需要如何对待。</p>
<p>那么接下来，就以CSDN创作模板里的几个问题入手，来讨论这个话题吧！</p>
<a id="more"></a>
<h2 id="一、在面对失误而带来的指责和沮丧时，你是如何做的？"><a href="#一、在面对失误而带来的指责和沮丧时，你是如何做的？" class="headerlink" title="一、在面对失误而带来的指责和沮丧时，你是如何做的？"></a>一、在面对失误而带来的指责和沮丧时，你是如何做的？</h2><p>首先我们要厘清一点，尤其假设你是在打工，而不是作为一个老板。打工人聚在一起，是因为利益聚在一起的，业务好了大家一起吃大锅饭，业务不好那就得吃散伙饭。你的一个失误，实际牵动着的，就是整个业务的利益。被人指责，可能也在所难免；自己沮丧，本质也是因为自己的心力无法满足自己的责任感，也是情有可原。工作失误带来指责和沮丧，客观上都是合理的表现。</p>
<p>但是，不论是指责别人，还是自己沮丧，这两种行为对于避免失误这件事情，实际都是无用功。工作的内容本身，就是一件件问题的解决。而弥补工作失误，也是工作中需要解决的问题之一。</p>
<p>要解决这个问题，业务里相关联的同学都需要担起责任来，通力合作，建立防范机制，去让类似的失误不再发生。从自己的角度出发，就是得做几个事情：</p>
<ul>
<li>止损，修复缺陷，解决面前的问题</li>
<li>事后集中复盘，看哪些环节出现了问题，优化大家后续的工作和配合方式</li>
</ul>
<h2 id="二、发生了失误之后，你是如何找到问题的？如何避免只看到表面现象而忽略了根本问题？"><a href="#二、发生了失误之后，你是如何找到问题的？如何避免只看到表面现象而忽略了根本问题？" class="headerlink" title="二、发生了失误之后，你是如何找到问题的？如何避免只看到表面现象而忽略了根本问题？"></a>二、发生了失误之后，你是如何找到问题的？如何避免只看到表面现象而忽略了根本问题？</h2><p>如何找到问题，第一块是需要反推什么时间点做了些什么，不只是你自己，也需要参考关联同学以及线上运作的时间线。把这些信息因素拼凑起来，就可能得到几种可能场景：</p>
<ul>
<li>技术失误：我的代码本身就有bug，有些业务场景/技术细节没有考虑，导致有线上问题</li>
<li>业务失误：我做的事情，如果什么时候给A同学评估下，给B同学测试下，可能不会发生失误</li>
<li>无感知失误：X同学如果在什么时候早一点告诉我什么信息，我可能就不会做出这种行为，导致”失误”产生</li>
</ul>
<p>这些就是所谓问题的”表面现象”了。其中的根本原因可能会是：</p>
<ul>
<li>技术失误：技术设计/交接文档不规范，部分场景没有清晰说明</li>
<li>业务失误：缺乏标准上线流程，上线内容没有方案review机制</li>
<li>无感知失误：业务上下游缺乏信息互通渠道，上游变更影响下游感知不到</li>
</ul>
<p>那么解决这些根本原因，就得：</p>
<ul>
<li>技术失误：针对失误内容，重新review并彻底梳理清楚实现细节。并且，修复逻辑一步到位，防止实际只弥补了冰山一角。</li>
<li>业务失误：建立起文字版的上线流程和标准持续集成（DevOps）工作流，上线内容的需求背景、技术设计、Review审批记录、发布过程记录全部留痕。一来通过能让更多人感知，避免失误在线上呈现的可能性；二来如果真的有发生问题，通过操作留痕也能够方便回溯排查。</li>
<li>无感知失误：上下游建立联防联控机制，联合梳理上游变更影响下游的场景。上游建立变更周知机制，必要时增加演练环节，使得下游业务第一时间能感知变更风险，确立对策。</li>
</ul>
<p>但不管怎么说，从合作的角度来讲，很多工作失误背后，可能是业务运作机制的问题，仅靠自己一个人，还是很难彻底解决问题的。说句实在话，要解决根本问题，还得靠所谓的拉通对齐，做好复盘，大家通力协作，打好组合拳。</p>
<h2 id="三、在工作中我们应该怎么做才能降低失误率，分享一下你的工作技巧和方法吧！"><a href="#三、在工作中我们应该怎么做才能降低失误率，分享一下你的工作技巧和方法吧！" class="headerlink" title="三、在工作中我们应该怎么做才能降低失误率，分享一下你的工作技巧和方法吧！"></a>三、在工作中我们应该怎么做才能降低失误率，分享一下你的工作技巧和方法吧！</h2><p>笔者自己是程序员，针对这个问题，就从程序员角度来回答一下。</p>
<p>首先是程序设计/实现的方面。虽然面试里头经常会有八股文的出现，但在实际写业务代码当中，八股文代码的成分其实不会太多，更多的是我们需要通过代码，去模拟某一领域业务的运作过程。因此，我们需要了解业务本身的需求，最终呈现的效果，以及在实现过程中，需要定义哪些概念，每个概念之间联系是什么。把你要代码实现的东西，先在大脑上或者在草稿纸上过一遍，然后再填上代码，这样就能有效避免代码写到一半，发现实现有问题，再弥补也为时已晚的窘境。</p>
<p>这里还需要注意的是，我们在做架构设计的时候，可能是自顶向下的，也就是有一个目标，通过层层分解，来确定技术呈现的方案。但是我们在编码的时候，是自底向上的，首先要把每个细分模块实现了，然后层层堆积，从而达到最终的效果。因此，概念的定义，概念间的联系，一定要想好，才可以下笔。</p>
<p>然后是沟通交流的层面。业务里不同线的同学，掌握的信息是不一样的。如果你在编码时候有实现效果上的疑问，不妨和产品同学对一对，效果能不能满足需求；如果你对觉得代码里很多badcase很难一时梳理到，不妨问问测试同学，对一下用例，或者测一轮，看有什么具体的问题呈现；如果你不确定操作某个接口会不会有危险，不妨问问接口的开发人，或者接口下游的负责人，一起拉来看一下会不会有什么case没有考虑到，或许就能规避某一次危险的操作。</p>
<p>工作中很多令人纠结的问题，其实可能找对个人，聊一两句话就可以解决。有同学可能觉得，当社牛找人聊天，是一件困难麻烦的事情。但如果你是抱有”规避失误”的工作态度的话，当社牛找人聊天，才是工作中必须要做的事情。</p>
<h2 id="四、怎样才能在错误中不断吸取教训，让自己得到更多成长呢？"><a href="#四、怎样才能在错误中不断吸取教训，让自己得到更多成长呢？" class="headerlink" title="四、怎样才能在错误中不断吸取教训，让自己得到更多成长呢？"></a>四、怎样才能在错误中不断吸取教训，让自己得到更多成长呢？</h2><p>如果可以的话，笔者希望大家的心态是，减少犯错，减少通过这种方式”成长”的机会。就算犯错本身真的不能避免，也得求一个工作态度，尽量不让自己的错误放大，影响到整个业务的运作。</p>
<p>比起从错误中吸取教训，工作更应该关注的，是拿到更多的工作结果。拿到更多结果的过程里，自然会有更多的成长。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>工作失误无法彻底避免。如果你对你的工作内容很有责任感，那么如果真的失误了，就不要沉浸在失误的沮丧里，得去解决工作失误，才是真正对的起你的责任感。所以，坦然面对吧！</p>
]]></content>
      <categories>
        <category>DIY小记</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>DevOps</tag>
        <tag>持续集成</tag>
        <tag>八股文</tag>
        <tag>研发效能</tag>
      </tags>
  </entry>
  <entry>
    <title>【GitHub探索】用python写web前端之reactpy探索</title>
    <url>/2023/06/10/githubdiscovery/reactpy/</url>
    <content><![CDATA[<p>你有想象过用python来写web前端这种操作么？近期在github-trending上就有这样的一个项目<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JlYWN0aXZlLXB5dGhvbi9yZWFjdHB5" title="https://github.com/reactive-python/reactpy">reactpy<i class="fa fa-external-link"></i></span>，可以满足你在python上写web前端的欲望。为此，笔者也决定踩踩坑，看看这个项目的形式到底如何，能不能很方便地实际投产。</p>
<p>要用到这个项目，除了reactpy库本身外，还需要一个backend-implementation来部署前端开发环境到本地端口。这里我们采取的操作是<code>pip install reactpy[fastapi]</code>，这样就能直接安装上以fastapi为后端实现的前端开发环境部署。</p>
<p>要开始写一个简单的网页，可以参考reactpy的<span class="exturl" data-url="aHR0cHM6Ly9yZWFjdHB5LmRldi9kb2NzL2d1aWRlcy9nZXR0aW5nLXN0YXJ0ZWQvaW5kZXguaHRtbA==" title="https://reactpy.dev/docs/guides/getting-started/index.html">官方网站<i class="fa fa-external-link"></i></span>。基本代码如下：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> reactpy</span><br><span class="line"><span class="keyword">from</span> reactpy <span class="keyword">import</span> component, html, run</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@component</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reactpy_content</span><span class="params">(count)</span>:</span></span><br><span class="line">    add_count, set_add_count = reactpy.use_state(<span class="number">1</span>)</span><br><span class="line">    multi_count = reactpy.use_memo(<span class="keyword">lambda</span>: count * <span class="number">3</span>, [count])</span><br><span class="line">    reactpy.use_effect(<span class="keyword">lambda</span>: set_add_count(add_count + multi_count), [multi_count])</span><br><span class="line">    <span class="keyword">return</span> html.div(</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">'style'</span>: &#123;<span class="string">'color'</span>: <span class="string">'#ff0000'</span>&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        html.ol(</span><br><span class="line">            html.li(<span class="string">f'count: <span class="subst">&#123;count&#125;</span>'</span>),</span><br><span class="line">            html.li(<span class="string">f'multi_count: <span class="subst">&#123;multi_count&#125;</span>'</span>),</span><br><span class="line">            html.li(<span class="string">f'add_count: <span class="subst">&#123;add_count&#125;</span>'</span>)</span><br><span class="line">        ),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@component</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reactpy_app</span><span class="params">()</span>:</span></span><br><span class="line">    count, set_count = reactpy.use_state(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> html.div(</span><br><span class="line">        html.h1(<span class="string">'Debug Site'</span>),</span><br><span class="line">        html.button(&#123;</span><br><span class="line">            <span class="string">'on_click'</span>: <span class="keyword">lambda</span> e: set_count(count + <span class="number">1</span>)</span><br><span class="line">        &#125;, <span class="string">"Increment Count"</span>),</span><br><span class="line">        reactpy_content(count)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    run(</span><br><span class="line">        reactpy_app,</span><br><span class="line">        host=<span class="string">'127.0.0.1'</span>,</span><br><span class="line">        port=<span class="number">7654</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>展现出来的效果是：</p>
<p><img src="/uploads/githubdiscovery/reactpy/debug_site.png" alt="测试页面"></p>
<p>可以看到这个案例里面，我们能够模拟到react的一些基本特性，包括：</p>
<ul>
<li>基础的html标签</li>
<li>组件嵌套</li>
<li>useState/useEffect/useMemo</li>
</ul>
<p>可以说如果想只用python写前端，做前后端不分离的页面app，而且是一些极其简单的前端，用reactpy，其实也可以满足你的需求。甚至如果需要调用到原生js模块，也可以考虑参考<span class="exturl" data-url="aHR0cHM6Ly9yZWFjdHB5LmRldi9kb2NzL2d1aWRlcy9lc2NhcGUtaGF0Y2hlcy9qYXZhc2NyaXB0LWNvbXBvbmVudHMuaHRtbA==" title="https://reactpy.dev/docs/guides/escape-hatches/javascript-components.html">这个文档<i class="fa fa-external-link"></i></span>去进行。</p>
<p>如果从工业化的角度来说，reactpy距离大规模的前端app还有一定的距离。不仅是因为以nodejs为基础的前端生态非常成熟，而且从开发部署角度来说，reactpy一是开发时期还没有办法做到响应文件变化随时重编译，二是部署前端的方式也不能用纯python，必须要<span class="exturl" data-url="aHR0cHM6Ly9yZWFjdHB5LmRldi9kb2NzL2d1aWRlcy9lc2NhcGUtaGF0Y2hlcy9kaXN0cmlidXRpbmctamF2YXNjcmlwdC5odG1s" title="https://reactpy.dev/docs/guides/escape-hatches/distributing-javascript.html">结合nodejs的方式<i class="fa fa-external-link"></i></span>进行。所以如果考虑做复杂的，需要与后端分离的前端应用，reactpy并不是一个选择，现在还只能够作为玩具来玩。</p>
]]></content>
      <categories>
        <category>GitHub探索</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>fastapi</tag>
        <tag>web开发</tag>
        <tag>react</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】管控数据类变更的重要性</title>
    <url>/2023/06/03/testlife/data_change_background/</url>
    <content><![CDATA[<p>大多数的事故来源于变更，这句话并不是妄言，而且确实是具有统计学意义的。在持续集成的过程中，一次发布对应的是一系列的变更，而变更意味着从一个已经稳定的状态切换到一个仅预期稳定的状态，这就导致了线上风险实际是在降低的。为了防止最终的发布的效果与预期不符，造成事故产生，除了对变更内容做业务功能上的测试之外，还需要考虑很多事情，比如分析变更影响到了哪些上下游业务跟服务性能，变更的时间是不是业务的高峰期，变更的行为是不是有更多的相关人员感知。充分考虑了这些因素，每一次变更发布才可以尽可能不产生事故或者事故的影响面被控制住。</p>
<p>对于一个业务而言，发布变更的方式有多种。占大部分的是代码变更，一个新业务的开发，老缺陷的bugfix，或是底层的技术优化，都需要代码变更来直接体现；其次是服务配置的变更，比如遇到特定feature关停或开放的场景，或是调整缓存/DB的容量，抑或是满足业务代码变更的需要，都需要通过配置变更的方式来体现。除这两个大头之外，数据变更也同样是占据一定比例的变更方式。数据变更主要场景有如下几块：</p>
<a id="more"></a>
<ul>
<li>SQL发布：对DB既有数据做SQL变更</li>
<li>批量刷数：因新增/修复业务需要，对已有缓存/持久化数据直接做批量新增/修改/删除</li>
<li>数据同步：DB同步、异构数据迁移等行为</li>
<li>离线数据处理：以数仓存储数据为基础，运行数据同步/分析/生成任务，新增/修改/删除原有的持久化数据</li>
</ul>
<p>相对于代码变更以及配置变更而言，数据变更的频率是相对较低，缺陷和事故的数量也不算挺多。但从缺陷/事故影响面的角度来看，数据类变更事故的影响是非常高的。数据类变更产生事故的形式是非常多样的，最典型的几种情况比如：</p>
<ul>
<li>SQL发布：DDL类语句造成主从同步延时影响DB可用性；UPDATE语句错误圈选数据导致出现预料之外的更新</li>
<li>批量刷数：刷数逻辑错误导致大面积脏数据；业务高峰期批量刷数导致DB负载过大；慢查询导致DB负载过大</li>
<li>数据同步：同步速率设置不合理导致写入侧DB压力或消息积压</li>
<li>离线数据处理：误操作数据处理任务导致数据重置</li>
</ul>
<p>这些情况，除去SQL发布场景，其它场景变更的时间实际是非常长的。时间漫长，就意味着不仅变更量大，变更期间风险难以控制，且如果出了问题也难以回滚。再考虑变更行为，假设这类变更没有沉淀为需求的话，那么就很有可能出现在缺乏审核、周知跟测试/监控方案的情况下，做出量级较大的变更。也就是说一个产品可能不知不觉地，就出线上问题了，一回溯起来，才发现是私底下做了动作。</p>
<p>因此，管控数据类变更，也是做持续集成当中非常重要的一环，是必要的一个动作。除去开发者在风险意识层面做到谨慎发布外，如果一个业务体量够大，并且本身对线上稳定性有很高的要求，那么这类变更的流程规范是需要做起来的。而不是等到事故发生了，才去考虑这些东西。</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>变更风险</tag>
        <tag>DevOps</tag>
        <tag>持续集成</tag>
        <tag>SQL</tag>
        <tag>数据变更</tag>
      </tags>
  </entry>
  <entry>
    <title>【从零单排Golang】第十一话：make和new的区别和用法</title>
    <url>/2023/05/10/gofromzero/11_make_new/</url>
    <content><![CDATA[<p>在Golang当中，对于常用数据结构的初始化方式，通常有2种：make跟new。这两种初始化方法用途不同，效果不同。本篇文章就来详细讲一下make和new具体都怎么用，在什么场景下会用上。</p>
<p>首先来看make。比起new，make所用到的场景非常特定，一般没法直接避开。我们看下面的代码例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMake</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">    t.Logf(<span class="string">"[Make] m is %v, len: %v, cap: %v"</span>, m, <span class="built_in">len</span>(m), <span class="built_in">cap</span>(m))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNoMake</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">    t.Logf(<span class="string">"[NoMake] m is %v, len: %v, cap: %v"</span>, m, <span class="built_in">len</span>(m), <span class="built_in">cap</span>(m))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个代码似乎都会初始化长度为5的“列表”m，但其实两个m的内在构造并不相同。实际上会出现如下的效果：</p>
<a id="more"></a>
<ul>
<li>TestMake构造出来长度为5，容量为10，可变长度的slice</li>
<li>TestNoMake构造出来长度为5，容量为5，不可变长度的array</li>
</ul>
<p>这就是其中的不同了，通过两种方式，实际会构造出来两种数据结构。我们常用的<code>var m []int</code>方法构造出来的，其实是可变长度的slice，可以通过append添加元素。通过make，针对slice、map、channel这三个数据结构，我们可以通过make给这些数据结构实例预设大小或容量，从而能够快速容纳一部分数据。对于需要利用这些容器类数据结构，预加载数据的场景，就可以用make来操作。</p>
<p>而new和make则完全不同，new的作用，主要是返回某个类型的“零值”的指针。我们来看下面的两个testcase：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNew</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">    t.Logf(<span class="string">"[New] value of i is %v"</span>, *i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNoNew</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i *<span class="keyword">int</span></span><br><span class="line">    t.Logf(<span class="string">"[NoNew] value of i is %v"</span>, *i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上出来的是如下的效果：</p>
<ul>
<li>TestNew构造出来指向0（int的零值）的指针，正常打印</li>
<li>TestNoNew构造出来nil指针，panic掉</li>
</ul>
<p>可以看到，如果我们希望在某些初始化函数里，返回某些基础数据类型，或者是struct的零值的指针，用new都可以做到，无需nil检查。尤其针对struct的零值的指针，在很多场景都能够用上。随便举一个测试协议序列化的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bytes.Buffer</span></span><br><span class="line"><span class="keyword">type</span> Buffer <span class="keyword">struct</span> &#123;</span><br><span class="line">    buf      []<span class="keyword">byte</span> <span class="comment">// contents are the bytes buf[off : len(buf)]</span></span><br><span class="line">    off      <span class="keyword">int</span>    <span class="comment">// read at &amp;buf[off], write at &amp;buf[len(buf)]</span></span><br><span class="line">    lastRead readOp <span class="comment">// last read operation, so that Unread* can work correctly.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMarshalText</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    buf := <span class="built_in">new</span>(bytes.Buffer)  <span class="comment">// 非nil零值指针</span></span><br><span class="line">    <span class="keyword">if</span> err := proto.MarshalText(buf, newTestMessage()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        t.Fatalf(<span class="string">"proto.MarshalText: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    s := buf.String()</span><br><span class="line">    <span class="keyword">if</span> s != text &#123;</span><br><span class="line">        t.Errorf(<span class="string">"Got:\n===\n%v===\nExpected:\n===\n%v===\n"</span>, s, text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>从零单排Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>make</tag>
        <tag>new</tag>
        <tag>初始化</tag>
        <tag>零值</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】初体验rust语言</title>
    <url>/2023/05/01/geekdaily/rust_examples/</url>
    <content><![CDATA[<p>作为一门“网红”语言，rust，已经在区块链、Web前端、游戏开发等领域凸显了作用。相对于golang、python、java、js跟cpp等其余主流语言，rust语言的编写和呈现方面都算是一个更为独立的体系。因此，本着对技术的好奇心，笔者也决定学习下rust语言，一是体验一下新一门编程语言的逻辑艺术，二来也是为未来可能的变化做一做准备。</p>
<p>由于还没有明确要写什么小demo的想法，笔者决定先参照官网<span class="exturl" data-url="aHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9zdGFibGUvcnVzdC1ieS1leGFtcGxlL2luZGV4Lmh0bWw=" title="https://doc.rust-lang.org/stable/rust-by-example/index.html">rust-by-example<i class="fa fa-external-link"></i></span>给到的代码案例，体验一下rust这门语言是如何做到实现各种基础场景的，心里有个底。官网所有的rust代码案例，笔者一一临摹，记录在了<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9ydXN0LXBsYXlncm91bmQ=" title="https://github.com/utmhikari/rust-playground">这个repo<i class="fa fa-external-link"></i></span>当中。</p>
<a id="more"></a>
<p>体验上初步来看，rust相当于一个加强版的cpp，编写层面不仅是能够继承很多c-style，而且在更加注重声明式的呈现，比如match、生命周期符号等等，语言最终的编译也更大成分依赖于开发者的标注，而非自动推断。虽然不像golang对高并发场景支持的那么深入，但以rust的编程模式会更易避免指针相关的问题，对于内存数据的每种呈现或者归属，都会有不同的标识去定义（比如Ok/Some/Err的声明），从而能够保证业务逻辑运行会更加稳定。对于继承或者多态的场景，通过traits的约定就可以组合实现，也是非常方便的。即便traits跟interface实际会有一些差别，但普遍作用上也相差无几，应该理解到是仅属于rust语言的一种特性就可以。此外，相对于cpp，rust在呈现上也会显示出函数式编程的一些特性，使得声明的信息会更加简明。</p>
<p>后续计划用rust写什么东西，现在还没有计划，就让时间来说吧。至少觉得，如果像游戏引擎、桌面GUI这种，以前需要复杂C++实现的东西，后面能用rust来写是最方便的了。作为开发者，还是希望一旦把代码写出来，一是能保证运行性能，二是能保证稳定，不至于除了问题也难以推断根因。至少从rust的编程模式看来，虽然学习成本比较大，但写出来的东西运行起来，可靠性很高。</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>教程</tag>
        <tag>面试</tag>
        <tag>函数式编程</tag>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】聊聊ChatGPT对于八股文程序员的冲击</title>
    <url>/2023/05/01/geekdaily/chatgpt_baguwen_shock/</url>
    <content><![CDATA[<p>2023年ChatGPT系列的问世，可谓是对整个世界的人类造成了冲击。在此之前，人们最多以为AI能够做的事情，主要是下棋玩游戏，但是对话模型AI的到来，造成的效果，是AI具备了和人交流的能力，能够理解人类语言，通过其它AI工作流，自动整合资料，生成人类想要的内容。也就是说，AI可以从事人类的工作了。</p>
<p>很多程序员同行开始恐慌，自己的工作是否会被这类AI所替代，笔者的答案是——不应该会。对于AI，拥抱它的能力，把关它的成果，才是人类程序员需要做的事情，而不是说强行去杠AI的长处。脑细胞再怎么多，大脑也就这么大，而且人类还要生活，管理情绪，大脑不可能100%专注到一个工作。在工作执行方面，AI必然超越人类，但在工作内容把控方面，一切应该由人类定义。如果说你作为一个程序员，过分沉浸在一些八股文知识里，不去构建自己的思维体系，那么从编程工作本身的角度考虑，可怕的不仅是你很难做出更有质量的程序，更甚的是这些工作都正好能被ChatGPT代替掉。这类八股文程序员，才是ChatGPT真正会给到冲击的对象。</p>
<a id="more"></a>
<p>说这些并不代表八股文本身不重要，因为对于编程来讲，八股文是基础中的基础。对于各领域的研发知识，笔者的博客、网上的资料，或多或少都会演化成为所谓的八股文；对于编程算法知识，像是leetcode、codeforces之类，其中的解法、思考，也是真实存在的八股文。但不论八股文的形式是怎么样，它的最重要的目的，就是它的本意——面试套路。八股文不是程序员的专利，各行各业肯定都存在八股文，但不一定叫这个名字。当面试官需要试探面试者的技术背景的时候，八股文就可以成为交流桥梁，把整个面试交流的过程带起来。这里也善意提醒，如果你是一个面试者，请记住人的脑容量是有限的，比起背八股文本身，更加需要重视交流。面试本身，是在寻找一个可靠的合作对象，而不是一个八股文背书机器，或者是八股文都一窍不通的人。后者是不够专业，前者的话，如果笔者是面试官，会更倾向于用ChatGPT，而不是用人。</p>
<p>因为找工作的需要，笔者曾经也沉浸于八股文，比如leetcode，笔者也曾经拿3门语言连轴刷几百道。这份大型代码笔记，作为纪念，笔者放到了<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9iYWd1d2VuX2xlZXRjb2Rl" title="https://github.com/utmhikari/baguwen_leetcode">这个repo<i class="fa fa-external-link"></i></span>中。对于笔者本人而言，这份笔记以后用的用不上还不清楚，但至少现在工作里大概率是用不上了。不仅是leetcode的记录，google、wiki、stackoverflow这类搜索/百科/咨询类的网站，在笔者实际工作中，优先级都已经被ChatGPT超越了，有ChatGPT能解决的问题，就不需要其它的平台工具。现实看起来很残酷，但笔者并不后悔沉浸于八股文的经历，不仅仅是因为这些内容能够帮助自己找工作，而更是因为作为程序员，在通读八股文的同时，可以强化自身的概念网络，比如将不同技术领域的共性概念串联起来，或是将不同业务场景跟不同的解决方案串联起来，从而进一步把技术经验丰富起来。有了这些经验，才能够知道问ChatGPT什么问题，才能够理解ChatGPT给到的答案。</p>
<p>说到底，如果有造物主这个概念的话，那么我们每一个自己，是不是都算造物主的AI呢？比起恐慌AI的冲击，把自己当成一个AI，100%专注于自己的持续成长，这样做不是更好吗？</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>八股文</tag>
        <tag>AI</tag>
        <tag>ChatGPT</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】《阿里测试之道》笔记之大促全链路压测</title>
    <url>/2023/04/08/testlife/alibaba_stress_test/</url>
    <content><![CDATA[<p>在2022年，阿里出品了一本《阿里测试之道》，讲述在阿里电商、物流、金融、大数据等业务场景下，测试活动业务层面是如何开展，以及技术层面是如何实现的。笔者有幸拜读此书，从其中也有所收获。本次以其中涉及电商的测试场景为例，记录一下“大促质量保障”一章的读书笔记。这一章主要讲述了在大促场景下，全链路压测是如何实施的，以及通过什么方式保证最终大促时的生产环境稳定性。</p>
<h2 id="风险与挑战"><a href="#风险与挑战" class="headerlink" title="风险与挑战"></a>风险与挑战</h2><p>全链路压测目标：尽可能真实模拟流量洪峰，进行高可用验证<br>用例场景需要考虑两个方面：</p>
<a id="more"></a>
<ul>
<li>横向多样膨胀：域内行业通用、特殊玩法叠加<ul>
<li>交易红包玩法，不同玩法红包叠加，核销打款失败</li>
<li>汽车行业轮胎+服务进到购物车，同店非轮胎商品进入后，购物车无法撤单</li>
</ul>
</li>
<li>纵向长链路顺畅：完整旅程顺畅<ul>
<li>一种表达货品重要销售类型的核心数据，由库存中心的系统打在交易订单信息上，通过履约系统传递，在分销系统、物流订单系统层层传递。在预售/相对时间销售情况下有问题，这个场景下数据需要变更，但库存是不管预售尾款的，不会更新这个数据，导致数据传递错误。<ul>
<li>后果是消费者预约到了早于货品到仓的时间，商家无法履约</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="全链路压测"><a href="#全链路压测" class="headerlink" title="全链路压测"></a>全链路压测</h2><h3 id="影子体系"><a href="#影子体系" class="headerlink" title="影子体系"></a>影子体系</h3><ul>
<li>流量隔离：压测流量有特殊标识，打在流量入口url上</li>
<li>全链路贯通：压测标识在Web服务器的LogFilter映射到中间件的context，从而透传到整条链路</li>
<li>资源共用：影子体系资源共用线上资源，影子表、正式表在一套数据库中，缓存中通过不同key区分压测和现上数据</li>
</ul>
<h3 id="压测模型"><a href="#压测模型" class="headerlink" title="压测模型"></a>压测模型</h3><ul>
<li>入口集合：覆盖商品详情、购物车浏览、确认订单、提交订单、订单列表、订单详情、二次付款、付款成功等入口</li>
<li>包含各个后端模型（不是前端流量入口的模型）</li>
<li>预测出各个场景QPS和各个后端元素比例</li>
<li>和大促玩法深度结合，用大促玩法对压测模型修正</li>
<li>构造压测模型<ul>
<li>在生产环境产出和双11同等量级数据：包含买家、卖家、商品</li>
<li>根据模型各个元素，完成构造优惠、领取红包、添加购物车操作</li>
<li>根据各流量入口请求规则，构造可行的压测流量</li>
</ul>
</li>
</ul>
<h3 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h3><ul>
<li>千万级施压能力<ul>
<li>一个流量平台，包含一个控制节点和上千个worker节点，每个worker节点部署压测引擎</li>
<li>压测引擎部署在cdn上，从外网向内网施压，模拟真实用户行为</li>
</ul>
</li>
<li>执行方法<ul>
<li>脉冲压测：按照设定模型脉冲，模拟0点流量</li>
<li>摸高：关闭限流，直接加压，直到扛不住</li>
<li>限流验证：摸高稳定情况下，开限流，看能否生效</li>
<li>破坏性测试：保持系统大促态，压力保持在峰值，执行各个紧急预案，看效果是否满足预期</li>
</ul>
</li>
</ul>
<p>常态化智能压测：非大促态下，通过智能压测机器人，对系统进行固定频率压测，及时发现系统瓶颈，定位原因</p>
<h2 id="全链路功能"><a href="#全链路功能" class="headerlink" title="全链路功能"></a>全链路功能</h2><p>功能测试方法：提前将线上业务数据同步至影子表中，将机器时间修改到大促时间点，模拟真实行为，然后执行业务链路，验证数据可用性准确性</p>
<h3 id="统一环境隔离"><a href="#统一环境隔离" class="headerlink" title="统一环境隔离"></a>统一环境隔离</h3><ul>
<li>流量隔离：http前端入口、rpc调用、消息入口、定时任务</li>
<li>时间控制<ul>
<li>修改JVM参数，只影响当前Java应用，阿里JVM有控制时间偏移参数</li>
<li>直接用date命令改虚拟机时间会影响机器上的其他应用</li>
<li>预案开关只在隔离环境生效，测试时不影响线上发布环境情况</li>
</ul>
</li>
</ul>
<h3 id="全链路影子数据"><a href="#全链路影子数据" class="headerlink" title="全链路影子数据"></a>全链路影子数据</h3><ul>
<li>数据生成：线上数据脱敏转换+数据区间映射，生成数据并写入影子表</li>
<li>特点：真实、海量、准备成本低</li>
</ul>
<h3 id="用例精简"><a href="#用例精简" class="headerlink" title="用例精简"></a>用例精简</h3><p>步骤如下：</p>
<ul>
<li>用一个RBC agent部署在交易链路核心应用上，用RBC服务端收集agent的数据</li>
<li>将每个应用中用例请求经过的代码信息采集下来</li>
<li>服务端接受代码覆盖信息后，将用例请求转化为链路级代码覆盖路径</li>
<li>将覆盖代码路径转换为唯一的内容签名，进行聚合</li>
<li>聚合后，进行数据固化</li>
</ul>
<p>注：相当于通过调用链路来确定用例类型，由线上数据产生用例</p>
<h3 id="RBC服务"><a href="#RBC服务" class="headerlink" title="RBC服务"></a>RBC服务</h3><ul>
<li>代码覆盖计算任务全部都在RBC服务完成，进行离线计算，不在agent计算</li>
<li>用metaq代替tlog进行数据通信，metaq只上传存储地址，存储探针数据在服务端，压缩存储，减少metaq和OSS开销</li>
<li>服务器从metaq接到消息，从OSS拉取原始数据，计算链路覆盖信息，并改造jacoco行覆盖率算法提升效率</li>
<li>通过阿里鹰眼监控将用例在交易链接各个应用串联起来，提升覆盖率工具到链路级</li>
<li>用hbase替代mysql存储覆盖率信息</li>
</ul>
<p>注：笔者以前做过skynet服务lua覆盖率测试，有些措施类似（比如代码覆盖在中心服计算），引入消息队列、OSS等，可以做更灵活的扩展（覆盖数据收集分析不需要即时性），中心服弄成集群也可以，覆盖数据分析计算可以再用非RBC中心服的其他节点来做（优化点）</p>
<h2 id="全民预演"><a href="#全民预演" class="headerlink" title="全民预演"></a>全民预演</h2><p>风险：</p>
<ul>
<li>测试链路协同成本高：交易链路上下游关联紧密复杂，优惠应用调整可能涉及上游导购、投放，下游交易、支付，也包括售后的服务、履约、供应链等方面</li>
<li>迭代量大：设计几十个事业部，万级发布，单链路无法满足全局质量保障需求</li>
<li>提前保障：大促核心业务玩法来之前，不会在线上生效</li>
</ul>
<p>目标：</p>
<ul>
<li>提前全链路验证业务购物功能正确性和完整性：重点关注用户在购物链路上遇到的营销、资金、物流、服务、氛围心智、价格表达等交易/导购链路上功能</li>
<li>大促产品验收：产品设计&amp;实现的匹配度、视觉交互</li>
<li>探索测试</li>
</ul>
<p>预演实施：</p>
<ul>
<li>人员构成：测试+研发所有人员</li>
<li>业务范围：交易+导购链路<ul>
<li>交易：商品详情到逆向交易的链路上，价格、库存、用户限购、资金、资产、物流、服务等核心交易信息的披露和计算</li>
<li>导购：基础导购、导购产品、推荐链路上的营销表达和价格透出</li>
</ul>
</li>
<li>用例：核心业务场景、用户行为路径</li>
<li>环境：网络上区分内网环境、外网隔离环境、wifi、4G；部署区分多地多单元、云与非云环境</li>
</ul>
<p>执行策略：1轮专项+2轮全面+2轮验收<br>问题跟进：链路上核心测试/研发支持bug筛选归并，每轮预演发现问题通晒<br>CI：全民预演中的用例沉淀成接口，UI层面用例高频执行<br>平台化：提升全民预演效率</p>
<h2 id="预案开关"><a href="#预案开关" class="headerlink" title="预案开关"></a>预案开关</h2><p>分为两种：</p>
<ul>
<li>提前预案：也是定时预案，提前预估大促期间系统业务状况，避免大促的业务峰值影响进行的缓存预热、机器重启、有限降级、磁盘清理或者业务下线，对业务没有明显影响</li>
<li>应急预案：针对可能存在的异常（流量超标、服务不可用），对业务有损，需要技术层面兜底</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>大促预案<ul>
<li>事前：提前预案，设置固定执行恢复时间（热点商品预热；提前对外公告/定时上线等业务操作；降级日志等非核心功能；降级无法承受大流量的下游服务调用）</li>
<li>事中：应急预案，根据系统业务指标决策（功能、服务降级/下线）</li>
<li>事后：回补，或者将功能大促态切换为日常态（数据追回）</li>
</ul>
</li>
<li>日常预案：线上故障快速回复，建立风险关联提前预案的关系</li>
</ul>
<h3 id="评估方式"><a href="#评估方式" class="headerlink" title="评估方式"></a>评估方式</h3><ul>
<li>应用强弱依赖关系明确，强依赖的外部服务都可以纳为预案对象</li>
<li>预估流量、压测验证，确定外部服务是否要提前降级</li>
<li>预案开启大概率有损，需要做好用户引导</li>
</ul>
<h3 id="预案流程"><a href="#预案流程" class="headerlink" title="预案流程"></a>预案流程</h3><ul>
<li>活动前：预案梳理、录入、正确性检查、演练、时间检查、通知配置</li>
<li>活动中：执行检查/结果验证、紧急预案执行与补偿</li>
<li>活动后：恢复检查/结果验证、紧急预案恢复检查</li>
</ul>
<h3 id="平台化"><a href="#平台化" class="headerlink" title="平台化"></a>平台化</h3><p>秩序化进行所有预案操作，降低多平台、多角色操作带来的风险，提升预案链路沟通效率</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>高可靠、高安全、低成本</p>
<h2 id="全链路预热"><a href="#全链路预热" class="headerlink" title="全链路预热"></a>全链路预热</h2><p>混部技术（类似潮汐车道，同一个节点的资源在多个集群内用到）降低机器成本，但是快上的应用导致混部机房没有足够时间通过线上用户访问充分预热，导致在峰值时刻比非混部机房更容易产生瞬间流量支持不足问题</p>
<ul>
<li>系统预热：用较小的压测流量对新发布系统运行20min左右</li>
<li>数据预热：将核心系统热点数据提前放入缓存中，防止系统发生缓存穿透、缓存击穿问题，主动防御</li>
<li>场景编排调度：先预热底层热点数据，再预热上层数据；考虑一些特定时间后才能执行预热的应用</li>
</ul>
<p>适用的业务场景：</p>
<ul>
<li>tair预热</li>
<li>本地缓存预热</li>
<li>db的buffer pool预热</li>
<li>缓存文件分发预热（本地加载）</li>
<li>缓存失效</li>
</ul>
<h2 id="快速扩-缩容"><a href="#快速扩-缩容" class="headerlink" title="快速扩/缩容"></a>快速扩/缩容</h2><p>分为水平伸缩（增加、减少实例数，时间长）、垂直伸缩（改变硬件规格，秒级，限于宿主机资源）<br>优化方法：</p>
<ul>
<li>水平伸缩<ul>
<li>扩容步骤精简<ul>
<li>紧急扩容不需要审批</li>
<li>扩容锁可以不用，因为不需要考虑应用发布版本不一致问题</li>
<li>账号、通道，可以异步添加</li>
<li>主机用途不需要修改，不需要加主机白名单等业务</li>
<li>agent不需要检查，成功率可以保证</li>
<li>vip操作可精简，比较麻烦</li>
</ul>
</li>
<li>新技术架构：DADI<ul>
<li>时间瓶颈：普通docker容器启动慢，需要在启动之前把每层镜像都下到本地，再解压到docker指定目录中</li>
<li>优化：zroot预热docker-registry数据，下发到节点的zagent<ul>
<li>只需要下载容器启动必要数据，来加速docker启动过程</li>
<li>启动容器只下载layer_meta元数据，容器启动需要什么数据，就从zroot读取</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>垂直伸缩<ul>
<li>用cgroup实现资源分配</li>
<li>需要有资源预留</li>
</ul>
</li>
</ul>
<h2 id="风控识别引擎压测"><a href="#风控识别引擎压测" class="headerlink" title="风控识别引擎压测"></a>风控识别引擎压测</h2><p>包括黑产、直播文本、商品都有风控需求<br>需要解决的问题：</p>
<ul>
<li>风控压测模型和交易压测模型有冲突，数据构造不兼容</li>
<li>风控对数据强依赖，交易压测模型和防控数据不同意，两份数据存储成本大，不能实现隔离</li>
<li>风控防控规则变化多，影响性能</li>
</ul>
<p>风控规则是由表达式+逻辑运算组成，分层，有短路执行特性，规则之间无关联，可以配置流转策略（命中继续/任何情况继续），因此影响性能的因素包括：</p>
<ul>
<li>单个表达式性能消耗：基本是定值</li>
<li>表达式的执行结果：影响规则执行表达式条数，影响流入下一条规则请求数</li>
</ul>
<p>如何通过控制表达式结果，让流量规则符合预期，可以：</p>
<ul>
<li>将表达式结果true/false比例作为预期结果</li>
<li>执行过程中改写表达式执行结果或者通过数据构造，将表达式结果符合预期</li>
</ul>
<p>第一点可以保存回流的风控数据，对表达式执行结果的比例进行特征挖掘提取<br>第二点数据构造，需要改写表达式，满足条件如下：</p>
<ul>
<li>只对压测流量干预，真实流量不处理</li>
<li>干预生效不发布，对应用无感</li>
</ul>
<p>只干预压测流量的实现，只要在runtime对压测标准进行识别，因为实现应用无感干预比较麻烦，最终采用javaagent挂载，对接口方法以字节码增强的方式干预（jvm-sandbox也可）</p>
<p>注：干预，实际上就是热更逻辑实现，参考文章：<span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTkvMDkvMDUvamF2YS1ieXRlY29kZS1lbmhhbmNlbWVudC5odG1s" title="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html<i class="fa fa-external-link"></i></span></p>
<p>最终，可以基于历史数据学习大促期间表达式执行特征，抽象成tuple：（规则ID，表达式ID，结果为true比例），使用jvm-sandbox编写module可以实现表达式改写，从而影响流入每条规则的请求，实现压力模型和大促期间保持一致。方案上，基于表达式特征（三元组）和规则特征（二元组）根据不同场景写入配置中间件，压测人员在控制台操作Agent挂载，在压测流量流入时，可以根据配置的特征对表达式、执行结果进行干预。</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>质量保障</tag>
        <tag>测试</tag>
        <tag>压测</tag>
        <tag>全链路压测</tag>
        <tag>电商</tag>
      </tags>
  </entry>
  <entry>
    <title>【从零单排Golang】第十话：快速理解并上手context的基础用法</title>
    <url>/2023/04/01/gofromzero/10_context/</url>
    <content><![CDATA[<p>在<code>Golang</code>的各种用法当中，<code>context</code>可谓是最能够体现<code>Golang</code>语言特性的模块之一。<code>context</code>的本意为<code>情境、上下文</code>，而在<code>Golang</code>程序当中，则可以被用于描述一次<code>调用</code>、<code>会话</code>或者<code>任务</code>的状态信息。关于<code>context</code>网上有很多语法以及源码分析的文档，但是里面很多却不能从实战场景体现<code>context</code>的作用，导致这个概念难以理解。因此这一回，经由踩坑<code>context</code>后，笔者将结合自己的理解，给大家讲述<code>context</code>在<code>Golang</code>怎么用来最为方便，怎么理解最为实用。</p>
<p>首先来了解一下什么是<code>context</code>。我们先走源码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() error</span><br><span class="line">    Value(key any) any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在源码定义中可以看到，<code>context</code>模块给开发者定义了一个接口约定<code>Context</code>。在先前<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjMvMDIvMTgvZ29mcm9temVyby8wOF9jYWNoZV9pbnRlcmZhY2Uv" title="https://utmhikari.top/2023/02/18/gofromzero/08_cache_interface/">关于接口的文章<i class="fa fa-external-link"></i></span>中有提到，接口本身定义的是一个实体可以做的行为，那么我们初步理解<code>context</code>的时候，就可以通过<code>Context</code>的定义，知道一个<code>Context</code>可以干什么。</p>
<p>假设一个<code>Context</code>实例<code>ctx</code>，关联到了一次<code>会话</code>，作为当次<code>会话</code>的<code>情境</code>。根据代码定义，<code>Context</code>可以做以下几种行为：</p>
<a id="more"></a>
<ul>
<li><code>Deadline</code> -&gt; 透出两个信息：本次<code>会话</code>的DDL是否有设置（<code>ok</code>），设置到了什么时候（<code>deadline</code>）</li>
<li><code>Done</code> -&gt; 通过调用<code>&lt;- ctx.Done()</code>，可以阻塞等待本次<code>会话</code>的<code>情境</code>结束</li>
<li><code>Err</code> -&gt; 当<code>情境</code>结束时，可以知道本次<code>会话</code>结束掉<code>情境</code>的原因<ul>
<li>这个原因是程序性质的，比如<code>超时</code>或者<code>程序主动调用cancel</code>，不具备业务性质</li>
<li>要给到具备业务性质的<code>情境</code>结束原因，需要用到<code>context.Cause</code>，具体用法见下文</li>
</ul>
</li>
<li><code>Value</code> -&gt; 透出当前<code>情境</code>设定的某一个<code>字段</code>的值</li>
</ul>
<p>可以看到，<code>Context</code>实例具备共享值信息（<code>Value</code>、<code>Deadline</code>）以及共享状态信息（<code>Done</code>、<code>Err</code>）的作用，定义上非常轻量实用。在实战场景里，<code>context</code>也有两个最为典型的应用场景，分别是：</p>
<ul>
<li>单次会话里，在相互配合的<code>goroutine</code>之间，共享当次会话的值、状态等情境信息</li>
<li>长链路调用里，透传调用信息，覆盖到整个调用链路，使得每单个调用链路信息都可回溯</li>
</ul>
<p>这两种应用场景，通过<code>context</code>模块的预置功能，加以组合，就可以充分实现。</p>
<p>在<code>Golang</code>的设计里，每一个<code>context.Context</code>实例生成，都必须关联到一个父级的<code>Context</code>实例，这样的设计下，比如父级的情境结束了，那么子级的情境也会递归结束，从而能够满足情境之间的关联关系。<code>Golang</code>为开发者提供了两个最根部的<code>Context</code>实例：<code>context.Background()</code>和<code>context.TODO()</code>，均是单纯实现了<code>Context</code>接口定义，返回零值。在状态层面，这两个<code>Context</code>不可结束，因为没有等待结束的<code>chan</code>在<code>Done</code>接口里实现。</p>
<p>业务如果要自己定义<code>Context</code>实例，就必须继承这两个<code>Context</code>实例，或者他们的子<code>Context</code>实例。这两个根部<code>Context</code>的业务含义是：</p>
<ul>
<li><code>context.Background()</code>：业务层面需要起一个最根部的<code>Context</code>实例，继承这个</li>
<li><code>context.TODO()</code>：业务还不清楚继承什么<code>Context</code>时，继承这个</li>
</ul>
<p>上一段代码案例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCtxBase</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ctxBg := context.Background()</span><br><span class="line">    ctxTodo := context.TODO()</span><br><span class="line">    t.Logf(<span class="string">"context.Background: %s, %d"</span>, ctxBg, ctxBg)</span><br><span class="line">    t.Logf(<span class="string">"context.TODO: %s, %d"</span>, ctxBg, ctxTodo)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctxTodo.Done():</span><br><span class="line">        t.Logf(<span class="string">"context.TODO is done"</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">        t.Logf(<span class="string">"timeout"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>context.Background()</code>和<code>context.TODO()</code>不可取消，显然地，这段代码会1秒之后打印<code>timeout</code>。</p>
<p>接下来就来看一下，<code>context</code>怎么在不同<code>goroutine</code>之间共享会话情境信息。<code>Golang</code>默认定义了<code>context.WithCancel</code>、<code>context.WithCancelCause</code>、<code>context.WithDeadline</code>以及<code>context.WithValue</code>等几个<code>Context</code>实例构造器，构造出来的内容里，除了新创建的<code>Context</code>实例之外，也会给一些回调函数，用来修改新<code>Context</code>实例的状态信息。</p>
<p>首先来看<code>context.WithCancel</code>和<code>context.WithCancelCause</code>，两者作用相似：</p>
<ul>
<li><code>context.WithCancel(parent Context) (ctx Context, cancel CancelFunc)</code><ul>
<li>输入：父<code>Context</code></li>
<li>输出：新<code>Context</code>、用于结束掉新<code>Context</code>的回调，签名为<code>func()</code></li>
</ul>
</li>
<li><code>context.WithCancelCause(parent Context) (ctx Context, cancel CancelFunc)</code><ul>
<li>输入：父<code>Context</code></li>
<li>输出：新<code>Context</code>、用于结束掉新<code>Context</code>的回调，签名为<code>func(cause error)</code></li>
</ul>
</li>
</ul>
<p><code>context.WithCancelCause</code>相对于<code>context.WithCancel</code>，唯一的不同点是可以输入一个<code>cause</code>信息，来声明是因为什么业务性质的原因从而取消整个<code>Context</code>，而程序写法上大致相似。</p>
<p>假设我们针对一次会话，建立起这样的<code>goroutine</code>协作模式：</p>
<ul>
<li>主<code>goroutine</code>决定某个会话要不要继续做下去</li>
<li>子<code>goroutine</code>处理业务逻辑，但期间还要关注主<code>goroutine</code>的决策，来决定继不继续做</li>
</ul>
<p>那么从程序角度，就可以写这么一个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCtxWithCancel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    cancelCause := errors.New(<span class="string">"debug"</span>)</span><br><span class="line">    ctxCancel, cancel := context.WithCancelCause(context.Background())</span><br><span class="line">    t.Logf(<span class="string">"context.WithCancel: %v, %p -&gt; cause: %v"</span>, ctxCancel, cancel, cancelCause)</span><br><span class="line"></span><br><span class="line">    sleepTimeout := <span class="number">1</span> * time.Second  <span class="comment">// 主goroutine觉得这个工作该完成的用时</span></span><br><span class="line">    waiterTimeout := <span class="number">2</span> * time.Second  <span class="comment">// 子goroutine觉得这个工作该完成的用时</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子goroutine</span></span><br><span class="line">    join := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, timeout time.Duration, retChan <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> ret <span class="keyword">string</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():  <span class="comment">// 主goroutine都不干了，那就摆烂吧，返回done</span></span><br><span class="line">            t.Logf(<span class="string">"ctx done! -&gt; err: %v, cause: %v"</span>, ctx.Err(), context.Cause(ctx))</span><br><span class="line">            ret = <span class="string">"done"</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(waiterTimeout):  <span class="comment">// 返回timeout</span></span><br><span class="line">            t.Logf(<span class="string">"waiter timeout"</span>)</span><br><span class="line">            ret = <span class="string">"timeout"</span></span><br><span class="line">        &#125;</span><br><span class="line">        retChan &lt;- ret</span><br><span class="line">    &#125;(ctxCancel, waiterTimeout, join)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主goroutine再等待sleepTimeout就不干了</span></span><br><span class="line">    time.Sleep(sleepTimeout)</span><br><span class="line">    cancel(cancelCause)</span><br><span class="line">    t.Logf(<span class="string">"cancel done!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// join waiter</span></span><br><span class="line">    ret := &lt;-join</span><br><span class="line">    t.Logf(<span class="string">"waiter ret: %s"</span>, ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种场景下，如果<code>sleepTimeout</code>小于<code>waiterTimeout</code>，由于主<code>goroutine</code>先调用<code>cancel</code>，那么子<code>goroutine</code>的<code>select</code>里就会先监听到<code>ctx.Done</code>，从而直接返回一个<code>done</code>字符串结束掉。反之如果<code>sleepTimeout</code>大于<code>waiterTimeout</code>，子<code>goroutine</code>会等到<code>waiterTimeout</code>之后，再返回一个<code>timeout</code>字符串。但不管怎么说，<code>ctxCancel</code>实例在主<code>goroutine</code>和子<code>goroutine</code>之间是有效共享的，主<code>goroutine</code>通过<code>cancel</code>方法操作<code>ctxCancel</code>实例的结果，子<code>goroutine</code>是可以感知到的。</p>
<p>接下来看一下<code>context.WithDeadline</code>，和<code>context.WithCancel</code>一样，也是返回新的<code>Context</code>实例和主动结束情境的<code>cancel</code>函数。但有所不同的是，业务需要输入一个自动结束掉情境的<code>deadline</code>时刻，这样到了<code>deadline</code>的时候，新的<code>Context</code>实例会自动地<code>cancel</code>掉整个情境。有兴趣的同学，可以看下<code>context.WithDeadline</code>怎么通过源码实现的，本文不做源码解析，只看用法。</p>
<p>假设和刚才一样，对于一次业务会话的协作关系，主<code>goroutine</code>决定做不做，子<code>goroutine</code>做牛马，那么如果用到<code>context.WithDeadline</code>的话，可以这样描述：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCtxWithDeadline</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    timeout := <span class="number">3</span> * time.Second</span><br><span class="line"></span><br><span class="line">    deadline := time.Now().Add(timeout)</span><br><span class="line">    ctxDeadline, cancel := context.WithDeadline(context.Background(), deadline)</span><br><span class="line">    t.Logf(<span class="string">"context.WithDeadline: %v, %p"</span>, ctxDeadline, cancel)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deadline/cancel detector</span></span><br><span class="line">    join := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, retChan <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> ret <span class="keyword">string</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            ddl, ok := ctx.Deadline()</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                t.Logf(<span class="string">"ctx deadline not set"</span>)</span><br><span class="line">                ret = <span class="string">"nothing"</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> time.Now().After(ddl) &#123;</span><br><span class="line">                t.Logf(<span class="string">"ctx reached deadline: %v -&gt; err: %v"</span>, ddl, ctx.Err())</span><br><span class="line">                ret = <span class="string">"deadline"</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t.Logf(<span class="string">"ctx early canceled! -&gt; err: %v"</span>, ctx.Err())</span><br><span class="line">                ret = <span class="string">"cancel"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        retChan &lt;- ret</span><br><span class="line">    &#125;(ctxDeadline, join)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// manually cancel after cancelTimeout</span></span><br><span class="line">    cancelTimeout := <span class="number">1</span> * time.Second</span><br><span class="line">    time.Sleep(cancelTimeout)</span><br><span class="line">    cancel()</span><br><span class="line">    t.Logf(<span class="string">"cancel done!"</span>)</span><br><span class="line"></span><br><span class="line">    ret := &lt;-join</span><br><span class="line">    t.Logf(<span class="string">"ret: %s"</span>, ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当子<code>goroutine</code>有监听到整个情境结束时，就有几种可能性：</p>
<ul>
<li>情境没有设置<code>deadline</code>，因为其它原因被结束掉</li>
<li>情境设置了<code>deadline</code>，并且到了<code>deadline</code>时间</li>
<li>情境设置了<code>deadline</code>，但还没到<code>deadline</code>时间就被其它原因取消掉了</li>
</ul>
<p>那么业务层面，就可以根据这几种可能性，来分配不同的业务逻辑了。</p>
<p>最后，我们来看<code>context.WithValue</code>的作用。<code>context.WithValue</code>，本质是为继承的<code>Context</code>实例，新增一对<code>key</code>和<code>value</code>的映射。用法非常简单：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCtxWithValue</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    key1, value1 := <span class="string">"hello"</span>, <span class="string">"world"</span></span><br><span class="line">    ctxValue1 := context.WithValue(context.Background(), key1, value1)</span><br><span class="line">    key2, value2 := <span class="string">"foo"</span>, <span class="string">"bar"</span></span><br><span class="line">    ctxValue2 := context.WithValue(ctxValue1, key2, value2)</span><br><span class="line"></span><br><span class="line">    t.Logf(<span class="string">"ctxValue1: %s"</span>, ctxValue1)</span><br><span class="line">    t.Logf(<span class="string">"ctxValue1.%s = %v"</span>, key1, ctxValue1.Value(key1))  <span class="comment">// world</span></span><br><span class="line">    t.Logf(<span class="string">"ctxValue1.%s = %v"</span>, key2, ctxValue1.Value(key2))  <span class="comment">// nil</span></span><br><span class="line">    t.Logf(<span class="string">"ctxValue2: %s"</span>, ctxValue2)</span><br><span class="line">    t.Logf(<span class="string">"ctxValue2.%s = %v"</span>, key1, ctxValue2.Value(key1))  <span class="comment">// world</span></span><br><span class="line">    t.Logf(<span class="string">"ctxValue2.%s = %v"</span>, key2, ctxValue2.Value(key2))  <span class="comment">// bar</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在长链路调用的场景下，RPC/日志框架层面，可以约定一组携带调用信息的<code>keys</code>。以此为基准，RPC框架在收到请求时，可以创建一次调用的<code>Context</code>，通过<code>context.WithValue</code>为这些<code>keys</code>赋值，然后再把包含调用信息的<code>Context</code>实例给到业务<code>handler</code>。业务<code>handler</code>需要利用到这个<code>Context</code>实例，不仅调用下游的时候需要带上，而且在日志打印逻辑中，也需要输入<code>Context</code>实例，从而使得调用信息可以在日志中被打印出。这样一来，调用信息就可以覆盖到整条链路。当我们需要排查调用逻辑问题的时候，就可以把调用信息里某个<code>key</code>的值作为日志关键字，从而查到整条链路的日志了。</p>
]]></content>
      <categories>
        <category>从零单排Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>context</tag>
        <tag>WithCancel</tag>
        <tag>WithDeadline</tag>
        <tag>WithValue</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python随笔】一天搞定，爬虫爬取w3schools的sql语句案例集</title>
    <url>/2023/03/11/pythonnotes/w3schools_sqls_crawler/</url>
    <content><![CDATA[<p>在很久以前的<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wL2NhdGVnb3JpZXMvRWFzeS1QeXRob24v" title="https://utmhikari.top/categories/Easy-Python/">Easy Python<i class="fa fa-external-link"></i></span>系列中，介绍了通过爬虫手段<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMTkvMDMvMzEvZWFzeXB5dGhvbi9paWkv" title="https://utmhikari.top/2019/03/31/easypython/iii/">爬取豆瓣电影信息<i class="fa fa-external-link"></i></span>的一种技术套路。今天故技重施，为了迎合先前做<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjMvMDMvMDQvZ29mcm9temVyby8wOV9zcWxfcGFyc2VyLw==" title="https://utmhikari.top/2023/03/04/gofromzero/09_sql_parser/">SQL语句分析<i class="fa fa-external-link"></i></span>的需要，决定爬取<span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2xzLmNvbS9zcWwv" title="https://www.w3schools.com/sql/">w3schools网站<i class="fa fa-external-link"></i></span>上面所有SQL案例，用作测试用例。</p>
<p>本文就来详细讲述，爬取w3schools网站的实现方式，以及里面需要注意的一些点。代码统一放在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS93M3NjaG9vbHNfc3Fsc19jcmF3bGVy" title="https://github.com/utmhikari/w3schools_sqls_crawler">这里<i class="fa fa-external-link"></i></span>。</p>
<a id="more"></a>
<p>首先需要定位包含SQL语句的页面和元素。在w3schools网站当中，侧边栏部分（<code>id=&#39;leftmenuinnerinner&#39;</code>）列举了所有页面的链接，通过网页的<code>&lt;a target=&#39;_top&gt;</code>标签就能筛选到，通过<code>href</code>属性的指向就能够知道对应网页的URL。之后，对于每个网页里的SQL语句，所有语句都封装在<code>class=w3-code notranslate sqlHigh</code>样式的标签当中。因此，我们只需要拿到所有网页，遍历打开所有页面，再把所有SQL标签里的语句文本抽出来，处理一下就可以了。</p>
<p>通过request的GET方式，能够直接获取到URL对应的网页内容，再用BeautifulSoup解析，就能够拿到HTML树，然后就可以按照这些条件来寻找对应元素以及里面的内容了。</p>
<p>比如，获取所有网页的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_all_pages</span><span class="params">()</span> -&gt; List[Tuple[str, str]]:</span></span><br><span class="line">    <span class="comment"># get root page</span></span><br><span class="line">    page_url = ROOT_URL</span><br><span class="line">    print(<span class="string">'get all pages from %s'</span> % page_url)</span><br><span class="line">    resp = requests.get(page_url, headers=_headers())</span><br><span class="line">    soup = BeautifulSoup(resp.text, <span class="string">'html.parser'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># find leftmenuinnerinner</span></span><br><span class="line">    left_menu = soup.find(id=<span class="string">'leftmenuinnerinner'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># find all pages at &lt;a target="_top"&gt;</span></span><br><span class="line">    links = left_menu.find_all(name=<span class="string">'a'</span>, target=<span class="string">'_top'</span>)</span><br><span class="line">    pages = []</span><br><span class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> links:</span><br><span class="line">        pages.append((link.text, link[<span class="string">'href'</span>]))</span><br><span class="line">    print(<span class="string">'all pages are: %s'</span> % json.dumps(pages, indent=<span class="number">2</span>, ensure_ascii=<span class="literal">False</span>))</span><br><span class="line">    print(<span class="string">'overall %d pages!'</span> % len(pages))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pages</span><br></pre></td></tr></table></figure>
<p>爬取一个网页的SQL案例集的逻辑如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_crawl_sqls</span><span class="params">(name, page, referer_page=<span class="string">''</span>)</span>:</span></span><br><span class="line">    sql_set = set()</span><br><span class="line">    url = _page_url(page)</span><br><span class="line">    print(<span class="string">'[%s] crawling page url %s...'</span> % (name, url))</span><br><span class="line">    resp = requests.get(url, headers=_headers(referer_page=referer_page))</span><br><span class="line">    soup = BeautifulSoup(resp.text, <span class="string">'html.parser'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># get all examples in class="w3-code notranslate sqlHigh"</span></span><br><span class="line">    sql_blocks = soup.find_all(class_=<span class="string">'w3-code notranslate sqlHigh'</span>)</span><br><span class="line">    print(<span class="string">'[%s] overall %d sql blocks'</span> % (name, len(sql_blocks)))</span><br><span class="line">    <span class="keyword">for</span> sql_block <span class="keyword">in</span> sql_blocks:</span><br><span class="line">        <span class="comment"># some children blocks may not contain space, which leads to</span></span><br><span class="line">        <span class="comment"># extracting non-separated SQLs like -&gt; SELECT * FROM CustomersLIMIT 3;</span></span><br><span class="line">        <span class="comment"># so we should use get_text API</span></span><br><span class="line">        <span class="comment"># instead of using sql_block.text straightly</span></span><br><span class="line">        sql_text_no_endl = sql_block.get_text(<span class="string">' '</span>, strip=<span class="literal">True</span>).replace(<span class="string">'\n'</span>, <span class="string">' '</span>).strip()</span><br><span class="line">        sql_text = re.sub(<span class="string">r'\s+'</span>, <span class="string">' '</span>, sql_text_no_endl)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sql_text.endswith(<span class="string">';'</span>):  <span class="comment"># add semicolon</span></span><br><span class="line">            sql_text = sql_text + <span class="string">';'</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sql_text <span class="keyword">not</span> <span class="keyword">in</span> sql_set:</span><br><span class="line">            print(<span class="string">'[%s] crawled new sql -&gt; %s'</span> % (name, sql_text))</span><br><span class="line">            sql_set.add(sql_text)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'[%s] detected duplicated sql -&gt; %s'</span> % (name, sql_text))</span><br><span class="line"></span><br><span class="line">    sqls = list(sql_set)</span><br><span class="line">    print(<span class="string">'[%s] crawl finished! added %d sqls!'</span> % (name, len(sqls)))</span><br><span class="line">    <span class="keyword">return</span> sqls</span><br></pre></td></tr></table></figure>
<p>这两块代码就基本上形成了爬虫的主逻辑，但是仅有这些还是远远不够的。很多网站为了反爬虫，会有一些限流操作，比如在w3schools每秒爬一个网页的话，爬到中间会request不到网页的内容，这就有可能触发限流机制了。面对这种场景，有几个方法可以规避：</p>
<ul>
<li>时间间隔：调整长一点，比如10s一次</li>
<li>User-Agent：随机设置为不同浏览器的UA，使得限流认为是不同的访问</li>
<li>Referer：设置为网站主站，表示是从主站访问过来当前网页的</li>
<li>自动存储进度：每爬一个网站就把当前进度存下来，这样失败了下一次爬，就可以不需要从一开始爬起</li>
</ul>
<p>如果还有更高级点，可以用代理服务器来爬，这样也能规避限流机制。通过以上的方式，就能把w3schools上面几百条SQL都给爬取到了。一天搞定，EZPZ！</p>
]]></content>
      <categories>
        <category>Python随笔</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>BeautifulSoup</tag>
        <tag>HTML</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>【从零单排Golang】第九话：用go语言解析并分析sql语句的方法</title>
    <url>/2023/03/04/gofromzero/09_sql_parser/</url>
    <content><![CDATA[<p>在<code>Golang</code>的实战中，总会遇到一些场景，比如抓包分析<code>sql</code>指纹，或者是输入<code>sql</code>时检查<code>sql</code>的风险，这类操作都需要解析<code>sql</code>的工具才能够生效。今天，就来介绍一些<code>Golang</code>当中解析<code>sql</code>的工具包和使用方法。</p>
<p>本文介绍的工具是<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JsYXN0cmFpbi92aXRlc3Mtc3FscGFyc2Vy" title="https://github.com/blastrain/vitess-sqlparser">vitess-sqlparser<i class="fa fa-external-link"></i></span>，主要结合了两个<code>sql</code>解析工具：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3h3YjE5ODkvc3FscGFyc2Vy" title="https://github.com/xwb1989/sqlparser">xwb1989/sqlparser<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BpbmdjYXAvdGlkYi90cmVlL21hc3Rlci9wYXJzZXI=" title="https://github.com/pingcap/tidb/tree/master/parser">tidbparser<i class="fa fa-external-link"></i></span></li>
</ul>
<p>其中，<code>xwb1989/sqlparser</code>项目支持的功能有限，尤其对于<code>DDL</code>没有很好的支持，而<code>tidbparser</code>则功能比较全面。下面以<code>tidbparser</code>为例，讲述一下解析以及分析<code>sql</code>里<code>DDL</code>语句的一种方式。</p>
<p>代码相关写法可以查看<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDc3MDc2NQ==" title="https://zhuanlan.zhihu.com/p/34770765">这篇文章<i class="fa fa-external-link"></i></span>。首先，我们先自定义一个要验证的<code>DDL</code>语句：</p>
<a id="more"></a>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Persons <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> DateOfBirth, <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> <span class="keyword">ID</span>;</span><br></pre></td></tr></table></figure>
<p>很明显是一个删除列的语句，这类语句在线上执行也是会有风险的。如果用<code>xwb1989/sqlparser</code>工具，是无法解析识别的，而用<code>tidbparser</code>，可以这样写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sqlcheck</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/blastrain/vitess-sqlparser/tidbparser/ast"</span></span><br><span class="line">    <span class="string">"github.com/blastrain/vitess-sqlparser/tidbparser/parser"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个可以访问SQL解析树节点的Visitor</span></span><br><span class="line"><span class="keyword">type</span> DropColumnVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">    TableName <span class="keyword">string</span></span><br><span class="line">    Columns   []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *DropColumnVisitor)</span> <span class="title">IsValid</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v.TableName != <span class="string">""</span> &amp;&amp; <span class="built_in">len</span>(v.Columns) &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *DropColumnVisitor)</span> <span class="title">Enter</span><span class="params">(in ast.Node)</span> <span class="params">(out ast.Node, skipChildren <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, in)</span><br><span class="line">    <span class="comment">// 识别了ALTER就直接访问子节点，看是不是DropColumn</span></span><br><span class="line">    <span class="keyword">switch</span> in.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> *ast.AlterTableStmt:</span><br><span class="line">        <span class="keyword">if</span> v.TableName != <span class="string">""</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        node := in.(*ast.AlterTableStmt)</span><br><span class="line">        v.TableName = node.Table.Name.String()</span><br><span class="line">        <span class="keyword">for</span> _, spec := <span class="keyword">range</span> node.Specs &#123;</span><br><span class="line">            <span class="comment">// 看解析的Tp枚举是不是ast.AlterTableDropColumn对应的枚举</span></span><br><span class="line">            <span class="keyword">if</span> spec.Tp == ast.AlterTableDropColumn &#123;</span><br><span class="line">                v.Columns = <span class="built_in">append</span>(v.Columns, spec.OldColumnName.OrigColName())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不需要访问子节点</span></span><br><span class="line">    <span class="keyword">return</span> in, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *DropColumnVisitor)</span> <span class="title">Leave</span><span class="params">(in ast.Node)</span> <span class="params">(out ast.Node, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> in, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestParseDropColumn</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    sql := <span class="string">"ALTER TABLE Persons DROP COLUMN DateOfBirth, DROP COLUMN ID;"</span></span><br><span class="line">    sqlParser := parser.New()</span><br><span class="line">    stmtNodes, err := sqlParser.Parse(sql, <span class="string">""</span>, <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        t.Fatalf(<span class="string">"Parse error: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    t.Logf(<span class="string">"stmt: %s"</span>, JsonDump(stmtNodes))</span><br><span class="line"></span><br><span class="line">    v := &amp;DropColumnVisitor&#123;</span><br><span class="line">        TableName: <span class="string">""</span>,</span><br><span class="line">        Columns:   []<span class="keyword">string</span>&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每个根节点开始起访问</span></span><br><span class="line">    <span class="keyword">for</span> _, stmtNode := <span class="keyword">range</span> stmtNodes &#123;</span><br><span class="line">        stmtNode.Accept(v)</span><br><span class="line">    &#125;</span><br><span class="line">    t.Logf(<span class="string">"visitor: %s"</span>, JsonDump(v))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !v.IsValid() &#123;</span><br><span class="line">        t.Fatalf(<span class="string">"invalid drop column ddl"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    t.Logf(<span class="string">"drop columns %v at table %s"</span>, v.Columns, v.TableName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当解析了<code>sql</code>之后，我们需要定义一个实现了<code>Enter</code>和<code>Leave</code>方法的<code>Visitor</code>接口<code>interface</code>，才能够开始识别<code>sql</code>解析树具体的内容。这里灵活用到了接口<code>interface</code>的设计方式，在<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjMvMDIvMTgvZ29mcm9temVyby8wOF9jYWNoZV9pbnRlcmZhY2Uv" title="https://utmhikari.top/2023/02/18/gofromzero/08_cache_interface/">cache-interface<i class="fa fa-external-link"></i></span>一篇文章中也有介绍到。如果解析的节点是<code>*ast.AlterTableStmt</code>类型，那么首先它就是个<code>ALTER</code>语句，再往下需要查<code>Specs</code>属性里是不是有<code>DROP COLUMN</code>对应的类型枚举，如果有的话，那就是一个删除列的语句了。</p>
<p>我们打印整个解析树，就能够清晰的看到结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">=== RUN   TestParseDropColumn</span><br><span class="line">    vitess_sqlparser_test.go:50: stmt: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;Table&quot;: &#123;</span><br><span class="line">              &quot;Schema&quot;: &#123;</span><br><span class="line">                &quot;O&quot;: &quot;&quot;,</span><br><span class="line">                &quot;L&quot;: &quot;&quot;</span><br><span class="line">              &#125;,</span><br><span class="line">              &quot;Name&quot;: &#123;</span><br><span class="line">                &quot;O&quot;: &quot;Persons&quot;,</span><br><span class="line">                &quot;L&quot;: &quot;persons&quot;</span><br><span class="line">              &#125;,</span><br><span class="line">              &quot;DBInfo&quot;: null,</span><br><span class="line">              &quot;TableInfo&quot;: null,</span><br><span class="line">              &quot;IndexHints&quot;: null</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Specs&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;Tp&quot;: 4,</span><br><span class="line">                &quot;Name&quot;: &quot;&quot;,</span><br><span class="line">                &quot;Constraint&quot;: null,</span><br><span class="line">                &quot;Options&quot;: null,</span><br><span class="line">                &quot;NewTable&quot;: null,</span><br><span class="line">                &quot;NewColumns&quot;: null,</span><br><span class="line">                &quot;OldColumnName&quot;: &#123;</span><br><span class="line">                  &quot;Schema&quot;: &#123;</span><br><span class="line">                    &quot;O&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;L&quot;: &quot;&quot;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &quot;Table&quot;: &#123;</span><br><span class="line">                    &quot;O&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;L&quot;: &quot;&quot;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &quot;Name&quot;: &#123;</span><br><span class="line">                    &quot;O&quot;: &quot;DateOfBirth&quot;,</span><br><span class="line">                    &quot;L&quot;: &quot;dateofbirth&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;Position&quot;: null,</span><br><span class="line">                &quot;LockType&quot;: 0</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;Tp&quot;: 4,</span><br><span class="line">                &quot;Name&quot;: &quot;&quot;,</span><br><span class="line">                &quot;Constraint&quot;: null,</span><br><span class="line">                &quot;Options&quot;: null,</span><br><span class="line">                &quot;NewTable&quot;: null,</span><br><span class="line">                &quot;NewColumns&quot;: null,</span><br><span class="line">                &quot;OldColumnName&quot;: &#123;</span><br><span class="line">                  &quot;Schema&quot;: &#123;</span><br><span class="line">                    &quot;O&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;L&quot;: &quot;&quot;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &quot;Table&quot;: &#123;</span><br><span class="line">                    &quot;O&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;L&quot;: &quot;&quot;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &quot;Name&quot;: &#123;</span><br><span class="line">                    &quot;O&quot;: &quot;ID&quot;,</span><br><span class="line">                    &quot;L&quot;: &quot;id&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;Position&quot;: null,</span><br><span class="line">                &quot;LockType&quot;: 0</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    vitess_sqlparser_test.go:59: visitor: &#123;</span><br><span class="line">          &quot;TableName&quot;: &quot;Persons&quot;,</span><br><span class="line">          &quot;Columns&quot;: [</span><br><span class="line">            &quot;DateOfBirth&quot;,</span><br><span class="line">            &quot;ID&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">    vitess_sqlparser_test.go:64: drop columns [DateOfBirth ID] at table Persons</span><br><span class="line">--- PASS: TestParseDropColumn (0.00s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure>
<p>通过解析之后，就能够提取出来<code>ALTER</code>的表<code>Persons</code>以及<code>DROP</code>的列<code>DateOfBirth</code>跟<code>ID</code>，也就确定了这是一个删除列的操作。</p>
<p>可以看到，<code>sql</code>解析器本身是非常强大灵活的。通过我们自定义一些逻辑规则，能很方便的检查<code>sql</code>的合法性跟风险性。</p>
]]></content>
      <categories>
        <category>从零单排Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>SQL</tag>
        <tag>vitess-sqlparser</tag>
        <tag>tidbparser</tag>
        <tag>DDL</tag>
      </tags>
  </entry>
  <entry>
    <title>【从零单排Golang】第八话：通过cache缓存模块示范interface该怎么用</title>
    <url>/2023/02/18/gofromzero/08_cache_interface/</url>
    <content><![CDATA[<p>和许多面向对象的编程语言一样，<code>Golang</code>也存在<code>interface</code>接口这样的概念。<code>interface</code>相当于是一个中间层，下游只需要关心<code>interface</code>实现了什么行为，利用这些行为做些业务级别事情，而上游则负责实现<code>interface</code>，把这些行为具象化。本文就来通过一个简单的缓存<code>cache</code>模块的实现，来示范一下<code>Golang</code>的<code>interface</code>该怎么用。</p>
<p>首先，从业务<code>service</code>角度而言，一个cache模块可能需要以下几种方法：</p>
<ul>
<li>获取缓存中的某个值</li>
<li>缓存数据，加缓存时效</li>
<li>删除缓存内容</li>
</ul>
<p>那么这些个方法，就可以用一类叫<code>Cache</code>的<code>interface</code>来表示：</p>
<a id="more"></a>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cache <span class="keyword">interface</span> &#123;</span><br><span class="line">    Get(key <span class="keyword">string</span>) (<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span><br><span class="line">    Set(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    SetExpire(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;, expire time.Duration)</span><br><span class="line">    Delete(key <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>Get</code>方法返回一个<code>interface{}</code>的<code>value</code>，以及是否存在的<code>bool</code>标识；<code>Set</code>跟<code>SetExpire</code>表示无时限跟有时限的缓存行为；<code>Delete</code>表示删除缓存内容。整块<code>Cache</code>的接口定义也非常明显。</p>
<p>这样写有什么好处？如果你是下游业务服务的话，你只需要这样写就可以了。这里给一个同<code>package</code>下的测试用例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCache</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    k, v := <span class="string">"hello"</span>, <span class="string">"world"</span></span><br><span class="line">    <span class="comment">// Current()的实现，在下文慢慢解释</span></span><br><span class="line">    <span class="keyword">var</span> curCache Cache = Current()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set &amp; get &amp; delete</span></span><br><span class="line">    curCache.Set(k, v)</span><br><span class="line">    cached, ok := curCache.Get(k)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        t.Fatalf(<span class="string">"cannot cache %s:%s"</span>, k, v)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t.Logf(<span class="string">"got cached %s:%v (type: %s)"</span>, k, cached, reflect.TypeOf(cached).Name())</span><br><span class="line">    &#125;</span><br><span class="line">    curCache.Delete(k)</span><br><span class="line">    _, ok = curCache.Get(k)</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        t.Fatalf(<span class="string">"cannot delete %s:%s"</span>, k, v)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t.Logf(<span class="string">"delete cached %s:%s"</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set expire</span></span><br><span class="line">    curCache.SetExpire(k, v, <span class="number">1</span>*time.Second)</span><br><span class="line">    cached, ok = curCache.Get(k)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        t.Fatalf(<span class="string">"cannot cache %s:%s"</span>, k, v)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t.Logf(<span class="string">"got cached %s:%v (type: %s)"</span>, k, cached, reflect.TypeOf(cached).Name())</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    _, ok = curCache.Get(k)</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        t.Fatalf(<span class="string">"cannot expire %s:%s"</span>, k, v)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t.Logf(<span class="string">"expired %s:%s"</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们指定的缓存对象<code>curCache</code>标识为一个<code>Cache</code>，是个接口定义，这样标识起来的话，下面的代码就可以正常使用<code>Get</code>、<code>Set</code>之类的方法了。而更重要的是，下面的代码，不会因为<code>Cache</code>的具体实现变化而有所变化。举个例子，你有10个开源的缓存库，想定时切换<code>Current() Cache</code>背后的缓存对象实现，就算你再怎么换，只要用到缓存的代码标注缓存对象为<code>Cache</code>这个<code>interface</code>，并且<code>interface</code>的定义没有变化，那么使用缓存的代码就不需要动。这样，就彻底实现了缓存提供方和使用方的解耦，开发效率也会噌噌噌的上去。</p>
<p>既然提到了提供方<code>Provider</code>的概念，那在缓存的实现上，就可以走依赖注入控制反转的模式。假设某个Web服务有个本地缓存模块，在实现上，就可以考虑提供多个<code>Cache</code>接口的实现，同时在配置里指定默认的一种。这里，就以<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BhdHJpY2ttbi9nby1jYWNoZQ==" title="https://github.com/patrickmn/go-cache">go-cache<i class="fa fa-external-link"></i></span>为例，做一个实现案例。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/patrickmn/go-cache"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    GoCacheDefaultExpiration = <span class="number">10</span> * time.Minute</span><br><span class="line">    GoCacheCleanupInterval   = <span class="number">15</span> * time.Minute</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GoCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    c *cache.Cache</span><br><span class="line"></span><br><span class="line">    defaultExpiration time.Duration</span><br><span class="line">    cleanupInterval   time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GoCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> g.c.Get(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GoCache)</span> <span class="title">Set</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    g.c.Set(key, value, GoCacheDefaultExpiration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GoCache)</span> <span class="title">SetExpire</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;, expire time.Duration)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> expire &lt; <span class="number">0</span> &#123;</span><br><span class="line">        expire = g.defaultExpiration</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> expire &gt; g.cleanupInterval &#123;</span><br><span class="line">        expire = g.cleanupInterval</span><br><span class="line">    &#125;</span><br><span class="line">    g.c.Set(key, value, expire)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GoCache)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    g.c.Delete(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGoCache</span><span class="params">()</span> *<span class="title">GoCache</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;GoCache&#123;</span><br><span class="line">        c: cache.New(GoCacheDefaultExpiration, GoCacheCleanupInterval),</span><br><span class="line"></span><br><span class="line">        defaultExpiration: GoCacheDefaultExpiration,</span><br><span class="line">        cleanupInterval:   GoCacheCleanupInterval,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们定义一个<code>GoCache</code>的<code>struct</code>，实现了<code>Cache</code>接口定义的所有行为，那么<code>GoCache</code>的实例，在<code>Golang</code>里，就能够被标识为一个<code>Cache</code>接口实例。<code>NewGoCache</code>方法，不仅是提供了一个<code>GoCache</code>的实例，而在业务层面，更是提供了一个<code>Cache</code>实例。因此，我们可以简单用一个<code>map</code>来管理所有的<code>Cache</code>的构造器，从而标识不同的缓存实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">provideGoCache</span><span class="params">()</span> <span class="title">Cache</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> NewGoCache()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cacheProviders = <span class="keyword">map</span>[<span class="keyword">string</span>]Cache&#123;</span><br><span class="line">    <span class="string">"go-cache"</span>: provideGoCache(),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    DefaultCacheProvider = <span class="string">"go-cache"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(provider <span class="keyword">string</span>)</span> <span class="title">Cache</span></span> &#123;</span><br><span class="line">    c, ok := cacheProviders[provider]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Default</span><span class="params">()</span> <span class="title">Cache</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Get(DefaultCacheProvider)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上文提到的样例代码，就用了这个方法拿到go-cache实现的Cache接口实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Current</span><span class="params">()</span> <span class="title">Cache</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Default()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显而易见，通过这样的一个代码组织，不论是<code>go-cache</code>，抑或是其它的<code>Cache</code>实现，都可以集中管理并灵活取用。这，便是<code>interface</code>在<code>Golang</code>编程中给我们带来的便利了。</p>
]]></content>
      <categories>
        <category>从零单排Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>依赖注入</tag>
        <tag>interface</tag>
        <tag>cache</tag>
        <tag>go-cache</tag>
      </tags>
  </entry>
  <entry>
    <title>【DIY小记】VMWare设置主机连接到的Ubuntu虚拟机的网络端口</title>
    <url>/2023/02/05/diymemo/vmware_ubuntu_network/</url>
    <content><![CDATA[<p>很多同学在自己机器上玩开发的时候，都会用到<code>VMWare</code>、<code>VirtualBox</code>之类的虚拟OS容器装一个带<code>GUI</code>的<code>Linux OS</code>，然后在里面另外安装开发工具做开发。这里面遇到的最经典问题，就是比如我在虚拟机里面起了个<code>MySQL</code>、<code>Redis</code>之类的服务，如果DB的客户端/GUI工具是放在主机里面，不在虚拟机里，那怎么连进去？这个问题，本文提供一种解决方案。</p>
<p>本文采取的虚拟机环境如下：</p>
<ul>
<li>主机：Win11</li>
<li>虚拟机容器：VMWare Workstation 16</li>
<li>虚拟机：Ubuntu 22.04</li>
</ul>
<p>首先需要了解到，<code>VMWare</code>场景下，我们通常用<code>NAT</code>模式新开一个网段来管理虚拟机的网络配置，而虚拟机内部，假设使用<code>IPV4</code>，会默认采取<code>DHCP</code>机制，自动设置一个<code>IP</code>跟相应的网络配置。相关资料可以看这几篇文档：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NzcxNDc4MDE=" title="https://zhuanlan.zhihu.com/p/477147801">网络中的NAT模式<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOEElQTglRTYlODAlODElRTQlQjglQkIlRTYlOUMlQkElRTklODUlOEQlRTclQkQlQUUlRTUlOEQlOEYlRTglQUUlQUUvMTA3Nzg2NjM=" title="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE/10778663">DHCP百度百科<i class="fa fa-external-link"></i></span></li>
</ul>
<p>而为了让我们主机能连到虚拟机内部，实际上是满足下面两个条件之一即可：</p>
<a id="more"></a>
<ul>
<li>主机知道虚拟机的IP，能够直连虚拟机IP</li>
<li>主机端口和某个IP的虚拟机端口存在转发映射关系</li>
</ul>
<p>在本文的场景下，解决方案是第二种。具体配置如下：</p>
<p>首先，在<code>VMWare</code>的<code>编辑</code>菜单打开<code>虚拟网络编辑器</code>，选中用于管理你虚拟机网络的一组虚拟网络（比如是<code>NAT模式</code>，名字是<code>VMnet8</code>这种）。如果你不确定你的虚拟机是不是<code>NAT模式</code>，可以在虚拟机自己的设置里查看<code>硬件 -&gt; 网络适配器</code>项目，看是不是<code>NAT模式</code>。</p>
<p>选中<code>NAT模式</code>虚拟网络配置之后，点击<code>NAT设置</code>按钮，即可进入到端口转发映射设置。</p>
<p><img src="/uploads/diymemo/vmware_ubuntu_network/vmnet_nat_config.png" alt="NAT端口设置"></p>
<p>在其中，我们可以看到<code>NAT</code>网络的<code>子网IP</code>、<code>子网掩码</code>跟<code>网关IP</code>，这些信息都会在后续的虚拟机内部设置里用上，而再下面的<code>端口转发</code>部分，就是需要我们手动配置的内容。其中包括几项：</p>
<ul>
<li>虚拟机IP地址：虚拟机的IP+端口</li>
<li>类型：TCP/UDP，标识什么类型的数据包会被转发</li>
<li>主机端口：选定一个主机端口，这样发到主机端口的指定<code>类型</code>的数据包会被转发到对应<code>虚拟机IP地址</code></li>
</ul>
<p>比如虚拟机里面<code>MySQL</code>开在<code>3306</code>端口，那么<code>虚拟机IP地址</code>一项就填<code>虚拟机IP:3306</code>，类型填<code>TCP</code>，主机端口填一个自己喜欢的即可。</p>
<p>那么这里就遗留另外一个问题：虚拟机IP怎么填？这里的话，以<code>Ubuntu</code>为例，由于默认是用<code>DHCP</code>机制分配IP，因此IP可能不是固定的。所以我们要做的是，在虚拟机中去设置固定一个IP，然后把这个IP回填到<code>虚拟机IP地址</code>一项当中。</p>
<p>在此之前，首先回到<code>VMWare</code>的<code>虚拟网络编辑器</code>当中，选中刚才<code>NAT</code>的一组虚拟网络，点击<code>DHCP</code>设置按钮，我们可以看到网络的配置跟<code>DHCP</code>的分配地址：</p>
<p><img src="/uploads/diymemo/vmware_ubuntu_network/vmnet_dhcp_config.png" alt="DHCP设置"></p>
<p>这里我们只需要记住的信息是<code>起始IP地址</code>跟<code>结束IP地址</code>。我们后面设置虚拟机固定的IP地址时，需要在这个范围之内。</p>
<p>然后进入虚拟机，以笔者用的<code>Ubuntu 22.04</code>为例，右上角<code>开关按钮</code>点击下拉<code>Settings</code>一栏，选择<code>Network</code>页签，然后选中当前连接到的网络点<code>设置图标</code>进入设置界面。</p>
<p><img src="/uploads/diymemo/vmware_ubuntu_network/ubuntu_network_panel.png" alt="Ubuntu网络设置面板"></p>
<p>由于先前设置的网络IP都是<code>IPV4</code>的，因此在网络选项当中，选中<code>IPV4</code>页签，即可开始编辑。编辑的内容如下所示：</p>
<p><img src="/uploads/diymemo/vmware_ubuntu_network/ubuntu_ipv4_config.png" alt="Ubuntu的IPV4设置"></p>
<p>这里需要编辑几个点：</p>
<ul>
<li><code>IPV4 Method</code>：选择<code>Manual</code>，表示手动配置</li>
<li><code>Addresses</code>：地址，这里新建一行<ul>
<li><code>Address</code>：网段分配的IP地址，也就是我们所要设置的<code>虚拟机固定IP</code>，参考上面<code>DHCP设置</code>里的网段范围自选一个</li>
<li><code>Netmask</code>：子网掩码，在上面<code>NAT设置</code>当中有相关信息</li>
<li><code>Gateway</code>：网关IP，在上面<code>NAT设置</code>当中有相关信息</li>
</ul>
</li>
<li><code>DNS</code>：DNS的IP，这个场景填写跟<code>Gateway</code>一样的即可</li>
</ul>
<p>弄好之后<code>Apply</code>，然后重启虚拟机，就可以试试看行不行了。注意，主机一边，需要发请求到先前<code>端口转发</code>设置里的<code>主机端口</code>，才能够生效！</p>
]]></content>
      <categories>
        <category>DIY小记</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>虚拟机</tag>
        <tag>VMWare</tag>
        <tag>NAT</tag>
        <tag>DHCP</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】准入准出质量红线的技术设计</title>
    <url>/2023/01/26/testlife/quality_redline_design/</url>
    <content><![CDATA[<p>在应用日常开发的过程中，不论是在测试、开发联调，还是实际构建发布的时候，我们都需要一定的指标去衡量技术产物的质量，从而判断技术产物是否符合质量标准，是否能够继续发布投产，如果不符合投产标准则拦截发布。从发布过程的角度，由于一般发布过程会收口到特定的CI流水线上，因此在做这类能力的时候，通常是采用开发一个特殊的质量红线原子的方案，集成到CI流水线当中，实现发布准入准出的原子能力。</p>
<p>准入准出质量红线能力的开发者，通常是DevOps中台，中台提供原子能力以及配置化的能力，用户可以根据自己的业务去配置相应的指标产出与拦截规则，也可以直接套用特定的模板来快速实现准入准出的效果。本文就来讨论，这类能力要开发出来，在技术实现上，需要做怎样的考虑跟设计。</p>
<p>首先，针对真实业务，要用到准入准出质量红线的话，可能会考虑以下场景：</p>
<ul>
<li>日常开发提测，在代码提交MR时，通过MR的hook触发对最新代码的规范检查<ul>
<li>代码检查需要关心一系列指标，包括：代码缺陷、代码安全、编码规范、重复代码、复杂度</li>
<li>不符合指标的情况下，显示被质量红线拦截，MR被阻止</li>
</ul>
</li>
<li>版本转测时，保证代码质量与单元测试代码覆盖率符合要求<ul>
<li>不符合指标的情况下，终止归档构件</li>
</ul>
</li>
<li>用户采用脚本等方式，自定义发布红线指标与生成过程，不符合指标的，阻止发布流程</li>
</ul>
<p>因此，从技术实现角度上，这里可以拆解成几个维度：</p>
<a id="more"></a>
<ul>
<li>红线指标<ul>
<li>指标设置：数值类型、比较符号以及阈值</li>
<li>适用节点：如bash脚本任务原子节点</li>
<li>指标大类：内置指标、自定义指标</li>
<li>指标业务类型：代码检查、测试、安全等</li>
<li>开放范围：项目内适用还是全局适用</li>
<li>指标生成方式约定</li>
</ul>
</li>
<li>红线规则<ul>
<li>引用了什么红线指标</li>
<li>包含哪些准入准出规则</li>
<li>拦截审批机制<ul>
<li>自动/人工审批，超时处理</li>
<li>触发拦截后，终止CI流水线，周知相关人员</li>
</ul>
</li>
</ul>
</li>
<li>执行记录<ul>
<li>拦截报告：业务、结果明细、处理人、处理结果、处理原因</li>
<li>数据分析：各业务的拦截/逃逸率以及原因分析</li>
</ul>
</li>
</ul>
<p>从业务侧的角度，最关心的内容是【拦截报告】。作为最终输出产物，拦截报告需要有详尽的信息帮助业务决定发布内容是否符合预期。在拦截报告的实现当中，有几点细节需要体现：</p>
<ul>
<li>即时通知：拦截的通知，可以是邮件或者IM群，但一定要周知到对应的人<ul>
<li>如果存在告警，需要有不同级别的告警机制</li>
</ul>
</li>
<li>拦截原因：在哪个步骤拦截，因为什么被拦截</li>
<li>拦截明细：拦截的指标中，具体有哪些地方报错，相关的内容跟数值指标是什么</li>
<li>问题分析：不论指标是否通过，对于全部扫出来的问题，按照优先级划分<ul>
<li>让开发者知道哪些问题需要优先修复，防止部分指标通过但其中仍遗留严重问题的情况</li>
</ul>
</li>
<li>修复指引：需要通过什么方式，才能修复拦截的问题<ul>
<li>这一点比较重要，能够直接强化拦截指标的效力</li>
</ul>
</li>
</ul>
<p>好比说，针对代码检查场景，不同的编程语言，可能对应不同的代码检查工具，比如Clang、Coverity、ESLint这些，但即便如此，代码检查的结果都是统一的。作为开发者，需要了解到，哪里的代码出了问题，这些问题如何修复排查，以及相对于以前的报告，减少或者新增了什么问题。大多数线上问题都由变更产生，因此详细了解检查问题信息，包括与历史问题的对比，都是在拦截报告中，很需要突出的内容。</p>
<p>最后，准入准出质量红线的原子能力，针对红线指标、红线规则、拦截告警方面，都可以抽象固化出通用的样板间，让业务得以快速接入跟配置。这样能够显著减少落地成本，提升落地效率。</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>准入准出</tag>
        <tag>质量红线</tag>
        <tag>CI</tag>
        <tag>原子能力</tag>
      </tags>
  </entry>
  <entry>
    <title>【从零单排Golang】第七话：反射模块reflect使用方式探索</title>
    <url>/2023/01/01/gofromzero/07_reflect_module/</url>
    <content><![CDATA[<p><code>Golang</code>的反射功能，在很多场景都会用到，最基础的莫过于<code>rpc</code>、<code>orm</code>跟<code>json</code>的编解码，更复杂的可能会到做另外一门语言的虚拟机。通过反射模块，我们可以在编程语言的<code>runtime</code>运行时期间去访问内部产生对象的信息。了解反射模块的实现，对我们了解<code>Golang</code>对象机制本身，也是莫大的帮助。</p>
<p>今天，恰逢阳康+新年，就决定来探究一下<code>Golang</code>的反射模块——<code>reflect</code>。</p>
<p>从最基础的开始，<code>reflect</code>模块，以获取整数对象的类型信息为例，我们可以这么用：</p>
<a id="more"></a>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflect_Integer</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    v := reflect.ValueOf(i)</span><br><span class="line">    vKind := v.Kind()</span><br><span class="line">    vType := v.Type()</span><br><span class="line">    t.Logf(<span class="string">"i kind: %+v\n"</span>, vKind)</span><br><span class="line">    t.Logf(<span class="string">"i type: %+v\n"</span>, vType)</span><br><span class="line"></span><br><span class="line">    itf := v.Interface()</span><br><span class="line">    j, ok := itf.(<span class="keyword">int</span>)</span><br><span class="line">    t.Logf(<span class="string">"j val: %+v\n"</span>, j)</span><br><span class="line">    <span class="keyword">if</span> !ok || j != i &#123;</span><br><span class="line">        t.Fatalf(<span class="string">"i != j"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>reflect.ValueOf</code>的入参是<code>interface{}</code>类型，新版本也叫做<code>any</code>，得到的返回值是<code>reflect.Value</code>类型的对象，可以认为是对原对象的一个描述性质的对象（元对象，233）。<code>reflect.Value</code>包含几个成员：</p>
<ul>
<li><code>typ</code>：原对象类型的元信息</li>
<li><code>ptr</code>：指向原对象值的原生指针</li>
<li><code>flag</code>：原对象类型的正整数标识</li>
</ul>
<p>当调用<code>Kind</code>跟<code>Type</code>接口，四舍五入就是获取了<code>reflect.Value</code>对象的<code>flag</code>跟<code>typ</code>成员实例了。</p>
<p>要把<code>reflect.Value</code>转换回原对象，首先需要通过<code>Interface</code>方法转化成<code>interface{}</code>类型的对象，再通过<code>.(int)</code>强转逻辑去转化成原对象。但这里需要注意下，如果真需要用到<code>reflect</code>反射功能且涉及到一些看似要“强转”的场景，可能是没有必要真的在代码中强转回特定类型对象的。好比<code>rpc</code>的调用，实质是在声明接口方法的基础上，把接口方法变成<code>reflect.Value</code>对象，再用<code>Func.Call</code>方法做函数调用。这里，也给个<code>example</code>：</p>
<p>假设我们定义<code>User</code>结构体，内部嵌套<code>UserInfo</code>结构体，均有<code>json</code>标注，然后定义了<code>ToString</code>跟<code>Response</code>两个方法，大概长这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    Desc <span class="keyword">string</span> <span class="string">`json:"desc"`</span></span><br><span class="line">    City <span class="keyword">string</span> <span class="string">`json:"city" desc:"the city of user"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID   <span class="keyword">int</span>       <span class="string">`json:"id"`</span></span><br><span class="line">    Name <span class="keyword">string</span>    <span class="string">`json:"name"`</span></span><br><span class="line">    Info *UserInfo <span class="string">`json:"info"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">ToString</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"[%d]%s"</span>, u.ID, u.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">Response</span><span class="params">(from <span class="keyword">string</span>, msg <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"User %s received msg %s from &lt;%s&gt;"</span>, u.ToString(), msg, from)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么比如<code>Response</code>方法，实际上也能够这样调用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflect_Method</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    u := &amp;User&#123;<span class="number">1</span>, <span class="string">"jack"</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    uPtr := reflect.ValueOf(u)</span><br><span class="line">    <span class="comment">// MethodByName：获取特定名字的Method</span></span><br><span class="line">    meth, ok := uPtr.Type().MethodByName(<span class="string">"Response"</span>)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        t.Fatalf(<span class="string">"no method named Response"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    t.Logf(<span class="string">"meth Response: %+v\n"</span>, meth)</span><br><span class="line"></span><br><span class="line">    methType := meth.Type</span><br><span class="line">    <span class="comment">// 入参3个：User实例、from、msg</span></span><br><span class="line">    <span class="keyword">if</span> methType.NumIn() != <span class="number">3</span> &#123;</span><br><span class="line">        t.Fatalf(<span class="string">"invalid NumIn %d, expected %d"</span>, methType.NumIn(), <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回值1个：response string</span></span><br><span class="line">    <span class="keyword">if</span> methType.NumOut() != <span class="number">1</span> &#123;</span><br><span class="line">        t.Fatalf(<span class="string">"invalid NumOut %d, expected %d"</span>, methType.NumOut(), <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过Func.Call得到返回值list</span></span><br><span class="line">    from, msg := reflect.ValueOf(<span class="string">"client"</span>), reflect.ValueOf(<span class="string">"ping"</span>)</span><br><span class="line">    rets := meth.Func.Call([]reflect.Value&#123;uPtr, from, msg&#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(rets) != <span class="number">1</span> &#123;</span><br><span class="line">        t.Fatalf(<span class="string">"invalid num rets %d, expected %d"</span>, <span class="built_in">len</span>(rets), <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回1个string对象</span></span><br><span class="line">    respVal := rets[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> respVal.Type() != reflect.TypeOf(<span class="string">""</span>) &#123;</span><br><span class="line">        t.Fatalf(<span class="string">"invalid ret type %v, expected %s"</span>, respVal.Type(), <span class="string">"STRING"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    resp, ok := respVal.Interface().(<span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        t.Fatalf(<span class="string">"ret value cannot be converted to string"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    t.Logf(<span class="string">"resp: %s\n"</span>, resp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>MethodByName</code>方法，可以定位到一个对象下的某个名字的方法实例，通过对方法实例调用<code>Func.Call</code>，就能实际实现对方法的调用，得到返回值列表。</p>
<p>涉及到指针对象的反射值，可以通过<code>reflect.Indirect(反射值)</code>或者<code>反射值.Elem()</code>的方式，获取到指针指向实例的反射值。<code>example</code>代码如下，因为上面我们定义<code>ToString</code>和<code>Response</code>方法绑定的是指针对象，在这样的条件下，指针指向实例的反射值就拿不到<code>ToString</code>方法了，打印便知：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflect_Pointer</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    u := &amp;User&#123;<span class="number">1</span>, <span class="string">"jack"</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    vPtr := reflect.ValueOf(u)</span><br><span class="line">    vPtrKind := vPtr.Kind()</span><br><span class="line">    vPtrType := vPtr.Type()</span><br><span class="line">    t.Logf(<span class="string">"ptr kind: %+v\n"</span>, vPtrKind)</span><br><span class="line">    t.Logf(<span class="string">"ptr type: %+v\n"</span>, vPtrType)</span><br><span class="line">    meth, ok := vPtrType.MethodByName(<span class="string">"ToString"</span>)</span><br><span class="line">    t.Logf(<span class="string">"ptr meth ToString: %+v (%+v)\n"</span>, meth, ok)</span><br><span class="line"></span><br><span class="line">    vVal := reflect.Indirect(vPtr)</span><br><span class="line">    <span class="comment">// vVal := vPtr.Elem()</span></span><br><span class="line">    vValKind := vVal.Kind()</span><br><span class="line">    vValType := vVal.Type()</span><br><span class="line">    t.Logf(<span class="string">"val kind: %+v\n"</span>, vValKind)</span><br><span class="line">    t.Logf(<span class="string">"val type: %+v\n"</span>, vValType)</span><br><span class="line">    meth, ok = vValType.MethodByName(<span class="string">"ToString"</span>)</span><br><span class="line">    t.Logf(<span class="string">"val meth ToString: %+v (%+v)\n"</span>, meth, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再进一步来看，对于<code>slice</code>、<code>map</code>这类对象，也可以通过<code>reflect.Value</code>内置的一些方法，访问到内部的对象。假设我们要实现<code>slice</code>跟<code>map</code>的复制操作，用纯反射的方式也可以实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflect_CopySliceAndMap</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    mp := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">        <span class="string">"jack"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"tom"</span>:  <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    sl := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>&#125;</span><br><span class="line">    vals := []reflect.Value&#123;reflect.ValueOf(mp), reflect.ValueOf(sl)&#125;</span><br><span class="line">    <span class="keyword">var</span> copyVals []reflect.Value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> vals &#123;</span><br><span class="line">        <span class="keyword">var</span> copyVal reflect.Value</span><br><span class="line">        <span class="keyword">switch</span> val.Kind() &#123;</span><br><span class="line">        <span class="keyword">case</span> reflect.Map:</span><br><span class="line">            <span class="comment">// MakeMap：创建map实例</span></span><br><span class="line">            copyVal = reflect.MakeMap(val.Type())</span><br><span class="line">            <span class="comment">// MapRange：获取map对象的Iterator</span></span><br><span class="line">            iter := val.MapRange()</span><br><span class="line">            <span class="keyword">for</span> iter.Next() &#123;</span><br><span class="line">                copyVal.SetMapIndex(iter.Key(), iter.Value())</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> reflect.Slice:</span><br><span class="line">            <span class="comment">// AppendSlice：在一个slice的基础上extend另一个slice</span></span><br><span class="line">            copyVal = reflect.AppendSlice(</span><br><span class="line">                reflect.MakeSlice(val.Type(), <span class="number">0</span>, val.Len()),</span><br><span class="line">                val)</span><br><span class="line">        &#125;</span><br><span class="line">        copyVals = <span class="built_in">append</span>(copyVals, copyVal)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过DeepEqual方法，可以做值的相等性比较</span></span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> copyVals &#123;</span><br><span class="line">        <span class="keyword">switch</span> val.Kind() &#123;</span><br><span class="line">        <span class="keyword">case</span> reflect.Map:</span><br><span class="line">            <span class="keyword">if</span> val.Len() != <span class="built_in">len</span>(mp) &#123;</span><br><span class="line">                t.Fatalf(<span class="string">"invalid map length %d, expected %d"</span>, val.Len(), <span class="built_in">len</span>(mp))</span><br><span class="line">            &#125;</span><br><span class="line">            copyVal, ok := val.Interface().(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                t.Fatalf(<span class="string">"map convert failed"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            t.Logf(<span class="string">"copied map: %+v"</span>, copyVal)</span><br><span class="line">            <span class="keyword">for</span> k, v := <span class="keyword">range</span> mp &#123;</span><br><span class="line">                copyV, ok := copyVal[k]</span><br><span class="line">                <span class="keyword">if</span> !ok || !reflect.DeepEqual(v, copyV) &#123;</span><br><span class="line">                    t.Fatalf(<span class="string">"copy value of key %s failed, expected %d, actual %d"</span>, k, v, copyV)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> reflect.Slice:</span><br><span class="line">            <span class="keyword">if</span> val.Len() != <span class="built_in">len</span>(sl) &#123;</span><br><span class="line">                t.Fatalf(<span class="string">"invalid slice length %d, expected %d"</span>, val.Len(), <span class="built_in">len</span>(sl))</span><br><span class="line">            &#125;</span><br><span class="line">            copyVal, ok := val.Interface().([]<span class="keyword">int</span>)</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                t.Fatalf(<span class="string">"slice convert failed"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            t.Logf(<span class="string">"copied slice: %+v"</span>, copyVal)</span><br><span class="line">            <span class="keyword">if</span> !reflect.DeepEqual(copyVal, sl) &#123;</span><br><span class="line">                t.Fatalf(<span class="string">"slice not equal"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，也看一下<code>reflect</code>作用到<code>struct</code>定义的一些使用方法，这里就需要看<code>reflect.Value.Type()</code>返回的<code>Type</code>实例有什么功能了。对于<code>Type</code>实例来讲，我们可以遍历所有结构体字段定义，甚至是访问标注信息，比如<code>json</code>、<code>orm</code>的编解码，就极度依赖这些字段的标注信息。这里的实现，也给个<code>example</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflect_Struct</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    st := reflect.ValueOf(&amp;User&#123;</span><br><span class="line">        ID:   <span class="number">9</span>,</span><br><span class="line">        Name: <span class="string">"Ronaldo"</span>,</span><br><span class="line">        Info: &amp;UserInfo&#123;</span><br><span class="line">            Desc: <span class="string">"SC"</span>,</span><br><span class="line">            City: <span class="string">"Madrid"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;).Elem().Type()</span><br><span class="line">    <span class="comment">// 多少个字段</span></span><br><span class="line">    numField := st.NumField()</span><br><span class="line">    t.Logf(<span class="string">"num fields: %d"</span>, numField)</span><br><span class="line">    <span class="comment">// 一个个字段遍历，输出字段名字、数据类型、json标注</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numField; i++ &#123;</span><br><span class="line">        field := st.Field(i)</span><br><span class="line">        t.Logf(<span class="string">"field %d -&gt; name: %s, type: %v, json: %s"</span>,</span><br><span class="line">            i+<span class="number">1</span>,</span><br><span class="line">            field.Name,</span><br><span class="line">            field.Type,</span><br><span class="line">            field.Tag.Get(<span class="string">"json"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 嵌套的字段，用FieldByIndex可以定位到</span></span><br><span class="line">    cityField := st.FieldByIndex([]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="comment">// 按照上面UserInfo.City的定义，拿取desc标注信息</span></span><br><span class="line">    cityFieldDesc, ok := cityField.Tag.Lookup(<span class="string">"desc"</span>)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        t.Fatalf(<span class="string">"cannot find city field desc"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    t.Logf(<span class="string">"CityField -&gt; name: %s, type: %v, desc: %s"</span>,</span><br><span class="line">        cityField.Name,</span><br><span class="line">        cityField.Type,</span><br><span class="line">        cityFieldDesc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们可以很方便拿到结构体的定义信息，更加深层嵌套的定义信息也都能拿到。可以说，太灵活了！</p>
]]></content>
      <categories>
        <category>从零单排Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>反射</tag>
        <tag>reflect</tag>
        <tag>interface</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>【代码艺廊】daggre：数据聚合与联表检查工具</title>
    <url>/2022/12/10/codegallery/daggre/</url>
    <content><![CDATA[<p>在以前写过的一篇关于游戏策划配置检查工具设计的<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjEvMDMvMDYvdGVzdGxpZmUvdGFibGVfY2hlY2sv" title="https://utmhikari.top/2021/03/06/testlife/table_check/">文章<i class="fa fa-external-link"></i></span>里，笔者讲述了一种表格检查工具的分层设计方法，简而言之也就是两部分：</p>
<ul>
<li>配置数据源服务：管理本地策划配置<code>repo</code>，通过自定义脚本解析<code>repo</code>中文件，提供实际的配置数据</li>
<li>配置数据处理服务：处理实际的配置测试业务，比如表格检查、<code>excel-diff</code>等等</li>
</ul>
<p>其中，配置数据源服务，在许久以前写过一个样例的版本<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9yZXBvbWFzdGVy" title="https://github.com/utmhikari/repomaster">repomaster<i class="fa fa-external-link"></i></span>，<br>实际也就是一个管理<code>git-repo</code>的小服务，在<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjEvMDEvMDEvY29kZWdhbGxlcnkvcmVwb21hc3Rlci8=" title="https://utmhikari.top/2021/01/01/codegallery/repomaster/">这篇博客<i class="fa fa-external-link"></i></span>里有详细阐述实现内容。</p>
<p>而今天的主题则是配置数据处理服务方面的内容，笔者采纳通过配置化方式声明数据处理过程的设计，编写了一个数据聚合工具：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9kYWdncmU=" title="https://github.com/utmhikari/daggre">daggre<i class="fa fa-external-link"></i></span>，全称为<code>DAta-AGGREgator</code>，专门用于处理数据的联表视图、过滤检查相关的需求。</p>
<p>以游戏业务测试为例，<code>daggre</code>的使用场景，我们可以看两个例子：</p>
<a id="more"></a>
<p>第一个例子，是针对一些游戏内置的商店配置，在功能提测的过程中，游戏测试同学需要验证商店实际的配置和策划的运营配置方案是否相符。对于商店的配置，可能会涉及到很多表格的连接，包括：</p>
<ul>
<li>集市配置：所有类型的集市，以及关联的商店列表</li>
<li>商店配置：所有类型的商店，以及关联的商品列表</li>
<li>商品配置：所有商品的配置，包括关联的物品、上架时间、折扣、一捆的数量、是否绑定等配置</li>
<li>物品配置：所有物品的列表</li>
</ul>
<p>如果没有一个完整的视图去把这些配置联接在一起，仅仅是一个个表格切换着来检查的话，是非常麻烦的。通过<code>lookup</code>步骤，可以将两个表格的数据通过一个特定的字段映射进行联接，从而使得不同表格的数据记录可以串联在一起，这样就能够形成一个集市-&gt;商店-&gt;商品-&gt;物品的完整视图，从而测试人员能够更加清晰看到每一个商品具体配置的细节。</p>
<p>第二个例子，是配置规则的检查，针对不同的游戏业务模块，需要制定特定的检查规则，来验证或是监控策划配置内容是否不够合理，好比说针对带敏感词文案，或者是物品弹出按钮跳转UI的关联配置等等。通过<code>filter</code>步骤，可以实现字段值的筛选逻辑，从而能够满足这类需求。在<code>daggre</code>中，不论是<code>lookup</code>还是<code>filter</code>之类的步骤，都已经做了简单的实现，基本上是呈现了<code>mongodb</code>聚合里面的效果。</p>
<p>在数据处理的实际设计上，<code>daggre</code>定义了几个概念：</p>
<ul>
<li>数据集<code>data</code>：相当于一系列<code>table/collection</code>的集合，每个表格有独立的名字</li>
<li>聚合规则<code>aggregation</code>：声明整个数据处理的规则，包括所有数据处理流水线，以及唯一的一个主流水线</li>
<li>流水线<code>pipeline</code>：声明初始数据由哪些表格合并而来，以及具体经过哪些处理步骤</li>
</ul>
<p>聚合规则最终输出的是主流水线的数据，而支流水线可以通过<code>lookup</code>步骤合并到主流水线的表格数据当中。通过声明<code>data</code>和<code>aggregation</code>，经过一系列流水线步骤，就能生成所有流水线的执行统计<code>stats</code>，以及最终处理后的<code>output</code>表格数据。</p>
<p>流水线步骤，除了默认的<code>filter</code>、<code>lookup</code>、<code>unwind</code>等常用的这些，开发者也可以按照流水线步骤的接口实现约定，自定义自己需要的流水线步骤实现。具体详情，可以参考<code>daggre</code>的<code>README</code>以及源代码。</p>
]]></content>
      <categories>
        <category>代码艺廊</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>工具开发</tag>
        <tag>表格检查</tag>
        <tag>数据聚合</tag>
        <tag>daggre</tag>
      </tags>
  </entry>
  <entry>
    <title>【从零单排Golang】第六话：基于wire的kratos微服务框架示例项目</title>
    <url>/2022/12/03/gofromzero/06_wire_kratos/</url>
    <content><![CDATA[<p>《从零单排Golang》系列，又重新开张了。后续会不定期更新自己学习<code>Golang</code>的笔记跟心得。</p>
<p>这次的话，就介绍一款名为奎爷<code>kratos</code>的微服务框架，以及讲述一下基础的使用机理。</p>
<p><code>kratos</code>是B站开源的微服务框架，不仅提供了<code>grpc</code>、<code>http</code>协议支持，而且有较为完善的层级架构、微服务中间件以及第三方组件的编写约定，可以说是非常方便上手跟扩展。</p>
<p>要上手<code>kratos</code>，我们可以从两个地方入手：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvLWtyYXRvcy9rcmF0b3M=" title="https://github.com/go-kratos/kratos">kratos-github<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9nby1rcmF0b3MuZGV2Lw==" title="https://go-kratos.dev/">kratos官方文档<i class="fa fa-external-link"></i></span></li>
</ul>
<p>通过<code>kratos</code>的<span class="exturl" data-url="aHR0cHM6Ly9nby1rcmF0b3MuZGV2L2VuL2RvY3MvZ2V0dGluZy1zdGFydGVkL3N0YXJ0" title="https://go-kratos.dev/en/docs/getting-started/start">quickstart文档<i class="fa fa-external-link"></i></span>，我们可以创建一个名为<code>kratostest</code>的项目。项目的目录结构遵循<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvLWtyYXRvcy9rcmF0b3MtbGF5b3V0" title="https://github.com/go-kratos/kratos-layout">kratos-layout<i class="fa fa-external-link"></i></span>，具体如下：</p>
<a id="more"></a>
<ul>
<li><code>api</code>：接口定义，主要是proto文件<ul>
<li>需要生成<code>go</code>文件给到<code>internal</code>或者<code>service</code>模块做请求处理实现的编写</li>
</ul>
</li>
<li><code>cmd</code>：<code>main.go</code>与<code>wire.go</code></li>
<li><code>configs</code>：配置<code>yaml</code></li>
<li><code>internal</code>：<ul>
<li><code>biz</code>：业务逻辑<ul>
<li>若相较于<code>controller</code>或<code>handler</code>，则类似于<code>service</code>的概念</li>
<li>此<code>service</code>不是指<code>kratos</code>的<code>service</code></li>
</ul>
</li>
<li><code>conf</code>：配置</li>
<li><code>data</code>：数据访问</li>
<li><code>server</code>：对外服务</li>
<li><code>service</code>：类似于<code>controller</code>、<code>handler</code></li>
</ul>
</li>
<li><code>third_party</code>：第三方内容</li>
</ul>
<p><code>kratostest</code>项目在启动之前，除了需要<code>go-protobuf</code>环境把<code>proto</code>文件编译成<code>go</code>文件之外，默认还需要通过<code>wire</code>模块自动初始化对象实例。<code>wire</code>是一种在<code>golang</code>里实现依赖注入的解决方案，可以参考以下文档，了解<code>wire</code>的作用：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS93aXJl" title="https://github.com/google/wire">wire-github<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYvYmxvZy93aXJl" title="https://go.dev/blog/wire"><code>wire</code>介绍博客<i class="fa fa-external-link"></i></span></li>
</ul>
<p>从使用角度上来说，实际上经过了如下的步骤：</p>
<ul>
<li>解析各个Provider接口出入参的实现</li>
<li>根据不同Provider出入参的依赖关系，生成实际的初始化代码，填充入参，实现注入的效果</li>
</ul>
<p>以<code>http-server</code>的基础<code>greeter</code>接口为例，存在着这样的调用层次：</p>
<ul>
<li><code>NewHTTPServer</code>：在<code>internal/server/http.go</code>，生成<code>HTTPServer</code>实例<ul>
<li>入参有<code>conf.Server</code>实例，是服务器启动的配置，可以通过<code>internal/conf/conf.proto</code>生成<ul>
<li><code>configs/config.yaml</code>实际配置这些内容</li>
</ul>
</li>
<li>入参<code>*service.GreeterService</code>，该实例需要实现<code>GreeterHTTPServer</code>的接口定义</li>
<li><code>GreeterHTTPServer</code>的接口定义实际是由<code>greeter.proto</code>定义之后自动生成的</li>
</ul>
</li>
<li><code>NewGreeterService</code>：在<code>internal/service/greeter.go</code>，生成<code>GreeterService</code>实例<ul>
<li>在这里需要实现<code>GreeterHTTPServer</code>的接口定义</li>
<li>需要定义<code>biz</code>层成员<code>*biz.GreeterUsecase</code>，在接口实现会调用这个成员方法执行实际业务</li>
</ul>
</li>
<li><code>NewGreeterUsecase</code>：在<code>internal/biz/greeter.go</code>，生成<code>GreeterUsecase</code>实例<ul>
<li>需要定义<code>GreeterRepo</code>类型成员，用来做数据的CRUD</li>
</ul>
</li>
<li><code>NewGreeterRepo</code>：在<code>internal/data/greeter.go</code>，生成<code>GreeterRepo</code>实例<ul>
<li>需要定义<code>*Data</code>类型成员，用来做实际对接数据库的访问操作</li>
</ul>
</li>
<li><code>NewData</code>：在<code>internal/data/data.go</code>，生成<code>*Data</code>实例<ul>
<li>入参有<code>conf.Data</code>实例，是数据库的配置，可以通过<code>internal/conf/conf.proto</code>生成</li>
<li>这些方法可以打包成<code>wire</code>的<code>ProviderSet</code>，然后一并<code>Build</code>起来</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cmd/kratostest/main.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newApp</span><span class="params">(logger log.Logger, gs *grpc.Server, hs *http.Server)</span> *<span class="title">kratos</span>.<span class="title">App</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> kratos.New(</span><br><span class="line">        kratos.ID(id),</span><br><span class="line">        kratos.Name(Name),</span><br><span class="line">        kratos.Version(Version),</span><br><span class="line">        kratos.Metadata(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;),</span><br><span class="line">        kratos.Logger(logger),</span><br><span class="line">        kratos.Server(</span><br><span class="line">            gs,</span><br><span class="line">            hs,</span><br><span class="line">        ),</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cmd/kratostest/wire.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wireApp</span><span class="params">(*conf.Server, *conf.Data, log.Logger)</span> <span class="params">(*kratos.App, <span class="keyword">func</span>()</span>, <span class="title">error</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(wire.Build(server.ProviderSet, data.ProviderSet, biz.ProviderSet, service.ProviderSet, newApp))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>cmd/kratostest</code>执行了<code>wire</code>之后，就会把这些依赖注入，代码重新组装起来，最后生成<code>wire_gen.go</code>文件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wireApp</span><span class="params">(confServer *conf.Server, confData *conf.Data, logger log.Logger)</span> <span class="params">(*kratos.App, <span class="keyword">func</span>()</span>, <span class="title">error</span>)</span> &#123;</span><br><span class="line">    dataData, cleanup, err := data.NewData(confData, logger)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    greeterRepo := data.NewGreeterRepo(dataData, logger)</span><br><span class="line">    greeterUsecase := biz.NewGreeterUsecase(greeterRepo, logger)</span><br><span class="line">    greeterService := service.NewGreeterService(greeterUsecase)</span><br><span class="line">    grpcServer := server.NewGRPCServer(confServer, greeterService, logger)</span><br><span class="line">    httpServer := server.NewHTTPServer(confServer, greeterService, logger)</span><br><span class="line">    app := newApp(logger, grpcServer, httpServer)</span><br><span class="line">    <span class="keyword">return</span> app, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        cleanup()</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>wire_gen.go</code>的<code>wireApp</code>，最终会在<code>main.go</code>里实际执行，从而真正启动整个<code>kratostest</code>服务和各层的对象实例。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 忽略上面</span></span><br><span class="line">    app, cleanup, err := wireApp(bc.Server, bc.Data, logger)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> cleanup()</span><br><span class="line">    <span class="comment">// start and wait for stop signal</span></span><br><span class="line">    <span class="keyword">if</span> err := app.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，整个<code>kratos</code>服务的基础逻辑结构就顺起来了。</p>
]]></content>
      <categories>
        <category>从零单排Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>后端开发</tag>
        <tag>微服务</tag>
        <tag>wire</tag>
        <tag>kratos</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】游戏测试开发干货——Python进阶与游戏自动化测试攻略</title>
    <url>/2022/11/24/geekdaily/python_and_game_autotest_notes/</url>
    <content><![CDATA[<p>在互联网上，关于游戏测试（开发）领域的技术分享，实际是非常稀少。尤其针对游戏功能测试领域，很多文章的思想维度仍然停留在很久以前，关注的更多是测试用例设计以及质量管理这些更加偏向业务方面的内容。很多同学认为游戏业务测试缺乏技术含量，其实本质上是因为，很少同学愿意投入精力去研究这个领域的技术，以及研究这些技术如何更好地契合到实际的业务当中。</p>
<p>为此，针对游戏测试（开发）的工作特性，笔者根据自己以前的博客整合了两个文集，分别是：</p>
<a id="more"></a>
<ul>
<li>Python进阶：<span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC91MDEzODQyNTAxLzg2NzM1Nzk0" title="https://download.csdn.net/download/u013842501/86735794">《HiKari为了拿捏Python整理的技术笔记》<i class="fa fa-external-link"></i></span></li>
<li>游戏自动化测试攻略：<span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC91MDEzODQyNTAxLzg3MTQ5NzI5" title="https://download.csdn.net/download/u013842501/87149729">《HiKari的游戏自动化测试笔记》<i class="fa fa-external-link"></i></span></li>
</ul>
<p>《HiKari为了拿捏Python整理的技术笔记》系列，旨在通过源码分析的方式，让大家能够对Python语言有更加深入透彻的理解，从而更加掌控这门语言。Python可以说是游戏测试领域最常用的编程语言了，不论你是游戏测试（开发）人员，还是正统的Python开发者，如果想要进阶你的Python水平的话，这个系列你值得拥有。</p>
<p>《HiKari的游戏自动化测试笔记》系列，旨在从技术设计、业务价值以及实战经验等多种角度，讲述笔者对于游戏自动化测试这个概念的理解和思考。如果你恰好是游戏测试领域的工作者，尤其是正好在做游戏自动化测试，那么这个系列你一定不能错过。</p>
<p>如果说人生如游戏，那么这两个文集就是针对游戏测试（开发）工作者的职业攻略。ENJOY！</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化测试</tag>
        <tag>游戏测试</tag>
        <tag>测试开发</tag>
        <tag>功能测试</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】UE4大世界游戏寻路效果自动化测试</title>
    <url>/2022/11/20/testlife/navi_autotest/</url>
    <content><![CDATA[<p>在一些无缝大世界的游戏当中，我们通常能够体验到游戏的自动寻路功能，通过自动寻路，玩家可以不用任何操作就到达任务或者玩法的目的地，从而让游戏过程更加轻松。在测试寻路功能时，不仅需要检查寻路是否成功到达，而且也需要关注寻路路径呈现的效果，从而确定玩家是否走在策划预想的路径上。</p>
<p>由于寻路起点、终点选择的随机性，人工执行寻路测试时，往往需要根据自定义的规则遍历多个特定的起点终点，这样操作起来不仅非常耗费人力，而且针对再后台存储<code>navmesh</code>数据、做动态烘焙以及计算寻路路径的场景，在验收寻路效果时，测试人员还需要多次手动从后台拉取一定范围的<code>navmesh</code>数据并绘制在客户端的路面上，才能知道玩家是走在什么样的路面。为了解决寻路效果测试的效率问题，引入自动化技术显得非常有必要。</p>
<p>因此，笔者将结合自己实际的工作经验，分享一种在<code>UE4</code>大世界游戏中，寻路效果自动化测试的方案。</p>
<a id="more"></a>
<p><code>UE4</code>默认采用<code>Recast&amp;Detour</code>的方式实现寻路。通俗来讲，<code>Recast</code>是一种在3D世界生成2D寻路网格面<code>navmesh</code>的方案，使得寻路的问题转化为在一个网格面上的一个格子到另一个格子的路径计算问题，而<code>Detour</code>则是根据寻路网格计算寻路路径的方法。</p>
<p>有兴趣的读者，可以查阅相关资料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JlY2FzdG5hdmlnYXRpb24vcmVjYXN0bmF2aWdhdGlvbg==" title="https://github.com/recastnavigation/recastnavigation">recastnavigation-github<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjEvMDgvMDcvZ2FtZWRldi9yZWNhc3RkZW1vLw==" title="https://utmhikari.top/2021/08/07/gamedev/recastdemo/">初识RecastDemo<i class="fa fa-external-link"></i></span></li>
</ul>
<p>3D世界中包含不同的地形，比如山地、水体、公路等，如果忽略这些地形信息，那么计算出来的寻路路径，效果就可能趋于一条直线。如果玩家真按照这样的路径行走的话，很可能会出现走到水里或者障碍物的情况，导致实际会没有走到一个最符合现实的路径方案。</p>
<p>为了解决这个问题，在<code>UE4</code>编辑器中，也支持通过不同类型的<code>NavModifierVolume</code>标记网格路面，从而使得每个路面在实际寻路计算中，具备不同的经过成本<code>cost</code>。</p>
<p>有兴趣的读者，可以查看官方文档的资料，详细了解：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vNS4xL2VuLVVTL25hdmlnYXRpb24tc3lzdGVtLWluLXVucmVhbC1lbmdpbmUv" title="https://docs.unrealengine.com/5.1/en-US/navigation-system-in-unreal-engine/">Navigation System<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vNS4xL2VuLVVTL25hdmlnYXRpb24tY29tcG9uZW50cy1pbi11bnJlYWwtZW5naW5lLw==" title="https://docs.unrealengine.com/5.1/en-US/navigation-components-in-unreal-engine/">Navigation Components<i class="fa fa-external-link"></i></span></li>
</ul>
<p>充分了解了这些内容，再结合下自己项目实际的情况，就能着手实现寻路效果自动化测试了。假设游戏是采用后台寻路的方案，整个自动化测试的流程可以这样做：</p>
<p>首先，我们需要预先准备<code>NavModifierVolume</code>配置数据，通过这些数据，才能判断玩家行走在怎样的路面上。同时，也要准备一系列测试用例，包含寻路的起点终点、期望时间和路面占比等等，整个自动化的流程需要遍历这些内容。</p>
<p>然后，需要一套自动化驱动寻路的流程，并且需要在寻路过程中，以特定的频率收集玩家所经过的路径点。这样，每一次寻路我们都能够得到玩家的路径点集，从而能够反映玩家的寻路效果。</p>
<p>对于每个路径点，需要求得这些点对应的是怎样的路面，这时候就需要用到预先准备的<code>NavModifierVolume</code>配置数据了。这个计算过程实质上是求在3D空间内，一个点是否在一个长方体内。由于每个<code>NavModifierVolume</code>导出的<code>transform</code>数据中，包含位置、旋转以及长宽高数据，因此可以参考<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjEvMDkvMDEvZ2FtZWRldi91ZTRfcG9pbnRfaW5fY3Vib2lkLw==" title="https://utmhikari.top/2021/09/01/gamedev/ue4_point_in_cuboid/">这篇文章<i class="fa fa-external-link"></i></span>，进行计算判断。</p>
<p>最终，整个自动化测试过程完成后，我们就可以得到这样一些数据：</p>
<ul>
<li>结果汇总：每个起点终点的寻路测试结果以及所有路径点跟路径点所对应的路面</li>
<li>是否通过指标：寻路是否成功、寻路时长是否符合预期、寻路路径占比是否符合预期</li>
</ul>
<p>通过表格或者3D散点图对结果进行可视化处理，就可以得到一份更加清晰的寻路测试报告。通过报告，我们可能可以排查出这样的问题：</p>
<ul>
<li>寻路路面配置缺失或不对，或因为寻路路面配置变化导致寻路效果相较以前有较大差别</li>
<li>因副本切换等原因重新生成阻挡物件，或者<code>navmesh</code>生成效果与实际物件摆放有出入，导致寻路实际阻塞</li>
</ul>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>寻路</tag>
        <tag>recast</tag>
        <tag>UE4</tag>
        <tag>自动化测试</tag>
        <tag>游戏测试</tag>
      </tags>
  </entry>
  <entry>
    <title>【Game Of AutoTest】5、游戏自动化测试的价值</title>
    <url>/2022/11/02/gameofautotest/v/</url>
    <content><![CDATA[<p>《Game Of AutoTest》的最后一篇文章，聊一下游戏自动化测试的价值。</p>
<p>一千个人心中有一千个哈姆雷特。仅以笔者的角度，游戏自动化测试的价值，可以体现在这几个方面：</p>
<ul>
<li>效率提升</li>
<li>缺陷发现</li>
<li>质量监控</li>
<li>技术支持</li>
</ul>
<p>做好自动化测试的价值分析，不仅能够自动化测试技术落地做足理论基础，而且也能在任意时候指引自动化技术落地者做好当下的决策，从而逐渐把自动化测试做出更大的规模跟成果。</p>
<a id="more"></a>
<h2 id="效率提升"><a href="#效率提升" class="headerlink" title="效率提升"></a>效率提升</h2><p>自动化测试作为代替人力的一种测试手段，最为基础核心的价值就是减少人力劳动，实现测试效能的提升。在自动化技术基础稳定性恒定的前提下，自动化用例产出的越多，运行/节省的时间越多，那么带来的测试效率提升也会越多。</p>
<p>考虑到游戏项目较短的生命周期，要成功落地自动化测试并做成成熟的日常业务，并不是一件容易的事情，尤其是当没有技术基建的支持下，从零到一去做自动化技术，会很容易陷入唯技术的误区。这种情况下，首先要考虑的就是一些操作复杂度并不高，但测试内容多的测试场景，这类测试场景就比较适合作为自动化初期落地的切入点。好比说一款大世界的游戏，对于大世界布怪相关的遍历测试，就是一种适合自动化的场景。不仅可以显著减少人力成本，而且其中的测试数据生成、玩家操作实现相关的内容，也有复用到其他测试场景的潜力。</p>
<p>当更多操作简单而测试量大的场景被自动化后，得到的初步成果就是，整体人力成本有显著的降低幅度。这样，测试人员也更愿意相信跟接纳自动化测试技术，会认为自动化测试技术能切实地解决日常工作中的效率难点。以这种信任为基础，作为自动化技术的落地者，后续也能够腾出更多思考空间，去探索自动化测试在实际业务中更多的可能性。</p>
<h2 id="缺陷发现"><a href="#缺陷发现" class="headerlink" title="缺陷发现"></a>缺陷发现</h2><p>很多测试同行在接触游戏自动化测试的时候，都会提出一个问题：自动化测试能发现什么游戏缺陷？这个问题其实本身就不够严谨。当我们谈游戏性能测试、压力测试的时候，我们实际是需要测试出一些反映产品质量的指标；而当我们谈自动化测试的时候，实际是在讨论一种测试的方式。所以说，自动化测试能发现什么缺陷，这个问题，提问的方式不对。对于测试工作而言，自动化是一种手段；而对于质量保障而言，测试本身就是一种手段。当讨论到质量保障的问题，如何设计测试策略才是关键，而不是实现测试的方式。因此，缺陷发现，其核心还是测试策略决定的，而不是自动化本身。</p>
<p>当然，这并不代表自动化测试不能决定缺陷发现，这是因为，自动化测试应用到的场景也是有限度的，因此这种手段也只能发现适用于自动化测试的业务场景中生成的缺陷。</p>
<p>对于一般的业务系统，自动化适合做业务基础功能的冒烟测试，因此其发现的缺陷，也将局限在冒烟测试所覆盖的范围内。这种情况下，即便发现的缺陷数量不会很多，但发现的缺陷严重程度一般都比较重，甚至阻塞整个功能。在笔者做自动冒烟测试的经验中，发现的缺陷里面，大约三分之二是显著影响玩家体验的。这种场景下，自动化测试就适合做成日常质量监控的形式，详细会在质量监控部分阐述。</p>
<p>对于复杂度较高，无法充分遍历所有情况的系统，自动化适合做随机的探索测试。比如针对各种UI场景的<code>MonkeyTest</code>，或者是针对某些游戏机制排列组合的随机检查/全量遍历，都是自动化测试可以发挥的地方。这种场景下，自动化测试既可以发现人工难以探索到的功能缺陷，也可以发现许多偶现甚至必现的崩溃操作。</p>
<p>如果应用自动化测试过程中，比较注重缺陷发现的话，建议在测试场景选型上，就有限选择缺陷量较大、疑难杂症较多的游戏系统尝试应用自动化测试，这样才能使得缺陷发现方面可以达到更大的效果。自动化测试，更多的是工具性作用，而非业务性作用。</p>
<h2 id="质量监控"><a href="#质量监控" class="headerlink" title="质量监控"></a>质量监控</h2><p>自动化测试作为一种代替人力实现缺陷发现的方案，本身就有做成日常质量监控的能力。测试人员可以不受工时限制，随时随地发起自动化测试，并即时产出游戏报告，做到实时的测试闭环。因此可以说，不仅是对测试工作本身，对于质量保障而言，自动化测试也可以发挥作用。</p>
<p>针对不同的场景，质量监控的时机和周期也是不一样的。好比说，针对每日主干版本的服务器、客户端发布，需要有实时的自动化测试用以验证服务器和客户端基本功能可用；针对重点但质量问题较多的玩法，需要有周级甚至日级的冒烟测试以保证基本功能可用。此外，针对一些探索性的测试内容，也可以放到日常的质量监控环节，可以和人工测试形成优势互补。</p>
<p>这里需要注意的是，过量的质量监控并不一定能够对业务本身带来更多的正向效益。质量监控是倡导实时反馈的，但是尤其在游戏里，针对较长链路的业务功能自动化测试，如果有测试失败的情况，报错结果并不一定能够直接反映问题的根因，甚至还可能存在因自动化稳定性不足导致用例执行无效。因此，许多自动化测试过程需要人工介入排查问题根因和复现手法，才能完成缺陷反馈的闭环。人工排查本身就会带来工作成本，如果质量监控的覆盖面非常大，但人力无法支持问题排查工作的话，就会造成很多自动化测试内容是冗余的，没有形成最终的业务闭环。因此，在自动化落地到日常质量监控时，需要时刻把握自动化的量以及人工整合工作的平衡，首先保证自动化测试在整个业务闭环的的有效性，在此基础上才再逐步提升监控的量。</p>
<p>如果监控的内容是针对游戏配置、资产检查之类的内容的话，那么由于这些测试的链路较短，测试结果能够直接反映质量情况，整个流程能直接闭环，因此是多多益善的。</p>
<h2 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h2><p>除了业务落地性质的内容之外，自动化测试本身作为一种测试技术，本身就具有技术价值。这部分尤其体现在，游戏自动化技术可以直接和游戏客户端/服务器等程序运行时交互，从而能够很方便地通过程序手段访问游戏运行的数据。好比说，压测场景构造、特定玩法测试账号构造、游戏日志解析、游戏数据收集以及玩家操作录制回放，这些人工难以操作的内容，通过自动化技术都可以迅速解决。</p>
<p>自动化技术不能代替人去判断某些事物的合理性，但可以简化并代替人的操作，在更加细致的粒度上去控制整个游戏程序。充分利用这一点，可以让自动化技术在更多的玩法测试上发挥可能性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>游戏自动化技术，无论是对测试技术的丰富，还是对于测试效能的提升，或者是对整个质量保障业务的巩固方面，都有充分的发挥余地。游戏自动化测试能够产生业务价值，坚持这样的信念，是成功落地自动化技术的第一步；从技术选型，到框架设计，再到稳定性保障，做好技术方面的基建，是落地自动化技术的第二步；整个测试团队通力协作，充分发挥自动化技术的优势，由点到面丰富自动化玩法测试策略，固化日常质量监控和测试执行业务，这是落地自动化技术的最后一步。如果你是一个负责游戏自动化专项测试的同学，请坚信游戏自动化技术带来的价值。无论遇到什么困难，做好技术基建，做好业务沟通，就算有再复杂的问题，最终都可以迎刃而解。</p>
]]></content>
      <categories>
        <category>Game Of AutoTest</category>
      </categories>
      <tags>
        <tag>游戏自动化</tag>
        <tag>自动化测试</tag>
        <tag>游戏测试</tag>
        <tag>质量保障</tag>
        <tag>质量管理</tag>
      </tags>
  </entry>
  <entry>
    <title>【DIY小记】Ubuntu22.04去掉侧边菜单栏Floppy Disk图标的方法</title>
    <url>/2022/10/15/diymemo/ubuntu22_floppy_disk/</url>
    <content><![CDATA[<p>近期装<code>Ubuntu22.04</code>虚拟机，发现侧边菜单栏多了个<code>Floppy Disk</code>图标。软驱这东西毕竟是上世纪的了，2022年也没什么用，但就是找不到入口去掉这个冗余的图标。</p>
<p>今天偶然之间发现去掉图标的方式，供大家参考：</p>
<ul>
<li>右上角点<code>电源/声音/网络按钮</code>，选择<code>Settings设置</code></li>
<li>选择<code>Appearance</code>，就是能调<code>Light/Dark</code>风格的页签</li>
<li>下拉，在<code>Dock</code>栏目下，点击<code>Configure dock behavior</code></li>
<li>里面的<code>Show Volumes and Devices</code>下，有一个<code>Include Unmounted Volumes</code>项。反正软驱一般也不会挂载，所以取消点选这个项，<code>Floppy Disk</code>图标就没了。</li>
</ul>
]]></content>
      <categories>
        <category>DIY小记</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Floppy Disk</tag>
        <tag>linux</tag>
        <tag>操作系统</tag>
        <tag>系统设置</tag>
      </tags>
  </entry>
  <entry>
    <title>【GitHub探索】ebook-boilerplate——批量转markdown为PDF和电子书</title>
    <url>/2022/10/05/githubdiscovery/ebook_boilerplate/</url>
    <content><![CDATA[<p>正值十一假期，近期准备把自己的<code>python</code>笔记精编整理，做一个<code>pdf</code>电子书。在调研如何把多个<code>markdown</code>文档转化为单个<code>pdf</code>的时候，试了很多种方法。最后找到了最佳方案，也就是本文的主角，由<code>phodal</code>前辈整理的电子书生成项目<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Bob2RhbC9lYm9vay1ib2lsZXJwbGF0ZQ==" title="https://github.com/phodal/ebook-boilerplate">ebook-boilerplate<i class="fa fa-external-link"></i></span>。这个项目不仅支持批量转<code>markdown</code>为<code>pdf</code>，而且还支持转成<code>ebook</code>等多种格式。</p>
<p>使用这个项目的时候，也踩了一些坑，需要做一些额外的配置。以笔者的场景为例，电子书生成环境是<code>Ubuntu22</code>，需要转化一堆中文的<code>markdown</code>。<code>clone</code>了这个项目之后，除了<code>ebook-boilerplate</code>本身<code>README.md</code>里描述的内容之外，实际还需要留意以下环节：</p>
<a id="more"></a>
<p>第一块是<code>pandoc</code>跟<code>texlive</code>的环境，最好是官网下载最新的版本，<code>apt</code>里面的版本已经过时了。尤其是<code>texlive</code>，<code>apt</code>拿到的版本很多宏库都没有，得要用官网最新的<code>install</code>脚本才会自动把各种<code>package</code>都装上。</p>
<p>然后是生成<code>pdf</code>的操作里，需要指定一种支持中文的<code>tex-engine</code>，笔者是选择了<code>xelatex</code>。需要在<code>makefile</code>的<code>pandoc</code>生成<code>pdf</code>那块做修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pdf: markdown</span><br><span class="line">	pandoc -s $(filename).md -o $(filename).pdf \</span><br><span class="line">		--title-prefix $(title) \</span><br><span class="line">		--listings -H listings-setup.tex \</span><br><span class="line">		--template=template/template.tex \</span><br><span class="line">		--pdf-engine=xelatex \  # 加这一行，声明pdf-engine</span><br><span class="line">		--toc</span><br></pre></td></tr></table></figure>
<p>之后，<code>markdown</code>生成<code>pdf</code>的步骤，实际是把所有<code>markdown</code>内容按文件名顺序（可以用数字标识组织一下）拼接在一起，然后用<code>toc</code>按照<code>markdown</code>的标题文本（<code>h1</code>、<code>h2</code>之类）生成目录，最后再生成<code>pdf</code>。这里有一个问题，就是我们每一章都要分页，而在<code>markdown</code>里标识分页的<code>html</code>标签<code>&lt;div STYLE=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;</code>在<code>tex-engine</code>下面，是没法出分页的效果的。这种情况下的解决方案是：把这个标签换成<code>\newpage</code>，这样<code>tex-engine</code>就能识别了。也就是说，你的<code>md</code>文件的内容应该是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1.1 xxx.md</span><br><span class="line"></span><br><span class="line"># 上面忽略你的markdown正文</span><br><span class="line"></span><br><span class="line">\newpage</span><br></pre></td></tr></table></figure>
<p>再之后，我们可以修改<code>listings-setup.tex</code>以及<code>template/template.tex</code>里的内容，去修改代码高亮跟正文的排版参数。以笔者的观感为例，这里面的内容编辑了以下几个部分：</p>
<ul>
<li>代码高亮，即<code>listings-setup</code>，<code>basicstyle</code>设置字号为<code>\small</code></li>
<li><code>template.tex</code>里，取消对于中文刊物习惯的设置，正文字号为<code>9pt</code>，行距调整为<code>1.1</code>。</li>
<li><code>xelatex</code>下，中文字体为<code>Noto Sans CJK SC</code>，默认字体为<code>Helvetica</code>。当然，如果你喜欢衬线<code>Serif</code>字体，也都得调整成衬线的形式。</li>
</ul>
<p>最后就是各种调试勘误，生成最后的文档了。</p>
<p>当然，一开始所说的，笔者精心整理的<code>python</code>笔记，现在也已出炉。各位读者可以阅读<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3JlYWQvY3YxODkzMzg2Mg==" title="https://www.bilibili.com/read/cv18933862">这篇文章<i class="fa fa-external-link"></i></span>以获取资源。</p>
]]></content>
      <categories>
        <category>GitHub探索</category>
      </categories>
      <tags>
        <tag>pdf</tag>
        <tag>ebook-boilerplate</tag>
        <tag>tex</tag>
        <tag>pandoc</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>【Game Of AutoTest】4、游戏自动化测试的稳定性保障</title>
    <url>/2022/10/03/gameofautotest/iv/</url>
    <content><![CDATA[<p>在游戏自动化测试技术落地过程当中，如何保证自动化测试的稳定性，是一个需要重点优先解决的困难问题。</p>
<p>以手机游戏客户端自动化测试为例，和一般服务架构的自动化单元测试或集成测试不同，自动化驱动的过程，其本质更加类似于网络爬虫，每次测试执行都是一个时间较长的过程，而流程一长，不稳定因素则随之而来。游戏自动化的整个过程，大致是这样的：</p>
<ul>
<li>前置环境准备（setup）：设置用例运行环境、设备状态与玩家状态，保证用例运行的条件</li>
<li>用例脚本执行（run）：执行自动化用例脚本</li>
<li>后置恢复操作（teardown）：恢复测试环境、设备状态与玩家状态</li>
<li>测试报告输出（report）：整合跑测期间游戏的运行数据与用例脚本收集/导出的数据，生成测试报告</li>
</ul>
<p>要分析如何保障整个自动化过程的稳定性，我们可以根据这几个步骤进行细节切分，对每一个环节影响稳定性的因素逐个理顺，从而最终，我们就可以得到一整套自动化稳定性保障的解决方案。在这四个步骤当中，前置环境准备和用例脚本执行这两步，对自动化流程稳定性的影响面最大，而最后面两步的影响程度，则相对较低。</p>
<a id="more"></a>
<h2 id="前置环境准备"><a href="#前置环境准备" class="headerlink" title="前置环境准备"></a>前置环境准备</h2><p>前置环境准备步骤，在本地环境执行较为方便，人工手动去设置设备环境跟玩家状态就可以。但是在平台化运行场景下，需要考虑全自动的任务调度、自动装包、账号环境准备等流程。其中每一个因素，都会影响整个自动化流程的稳定性。</p>
<p>从手机自动化测试平台的设计来看，除了一个云真机平台所必需的设备管理、项目管理、用例管理等必须的功能之外，最需要推敲的还是任务调度这一部分。任务调度模块需要管理并实时监控所有运行中的自动化任务，单个自动化任务的运行以及对应的系统设计，大概是这样：</p>
<ul>
<li>任务创建：指定自动化用例集、测试设备，创建一个自动化任务<ul>
<li>任务管理模块存储自动化任务定义到数据库</li>
</ul>
</li>
<li>运行任务实例：用户为任务指定选择客户端版本，触发单个任务实例的执行<ul>
<li>任务调度模块根据任务里测试设备的声明，确定合适的测试设备执行自动化任务</li>
<li>任务调度模块创建一个任务实例记录以及多个关联的用例执行实例记录，存储到数据库</li>
<li>任务调度模块将任务下发给测试设备对应的<code>PC-Agent</code></li>
<li>在缓存中备份一份任务和用例运行的状态信息，用于在新的状态上报时，快速获取并对比状态信息，确认任务和用例执行记录是否更新</li>
</ul>
</li>
<li>用例执行：<code>Agent</code>接收任务后，创建自动化测试用例所必需的运行环境，并按照用例集定义执行用例<ul>
<li>指定的设备执行用例有排队机制，只有前面的用例执行完，才能执行新的用例</li>
<li>执行用例前，<code>Agent</code>需要和<code>CI</code>平台打通，实现自动下包、装包的流程</li>
<li>实际测试用例执行前，需要实现游戏的账号登录和进游过程，这一过程也需要抽象成一个前置用例</li>
<li>准备好一切后，才执行实际的测试用例</li>
</ul>
</li>
<li>设备执行状态更新<ul>
<li><code>PC-Agent</code>在下包装包、前置用例、实际测试用例执行期间，以固定频率上报当前用例（包含对应任务实例ID）的执行状态。任务调度模块在用例/任务状态变化情况下，更新数据库信息</li>
<li>当一个用例执行完毕，任务调度模块标记该用例执行实例已完成，并更新对应任务实例的统计信息</li>
<li>当所有机器所有用例执行完毕（或者异常中断），整个自动化任务实例结束，任务管理模块标记对应任务实例已完成</li>
</ul>
</li>
</ul>
<p>因此，我们需要从自动化平台<code>infra</code>方以及自动化用例开发方两个角度，去分析保障自动化稳定性需要考量的一些点。<br>从平台<code>infra</code>方的角度考虑，要维持自动化流程的稳定性，除去技术设施本身程序稳定性外，在系统设计上，需要重点关注：</p>
<ul>
<li>任务调度模块对于任一用例的所有执行步骤，需要建立超时失败机制，防止状态阻塞<ul>
<li><code>CI</code>下包接口失效、用例执行时间过长、<code>Agent</code>宕机、执行机器无故迁移，都会引起用例卡状态</li>
<li>任务调度模块需要在特定状态持续时间过长，或是与<code>Agent</code>断连的情况下，主动标识用例运行异常</li>
</ul>
</li>
<li>对于长时间排队无法执行的用例，任务调度模块可考虑增加重调度机制，把用例重新安排到其他空闲的机器运行<ul>
<li>从业务角度来讲，长时间排队也是自动化不稳定的一种情况，因为会导致用例无法在期望的时间期限中完成执行，从而达不到自动化测试的效果</li>
</ul>
</li>
</ul>
<p>从业务自动化开发的角度考虑，在用例执行环境构造方面，需要重点关注：</p>
<ul>
<li>单独维护一个游戏的更新、登录用例，保证这个用例的稳定性<ul>
<li>登录进游用例是实际测试用例的基础，如果登陆进游失败会直接导致测试用例无法执行</li>
<li>用尽可能保守的逻辑触达每个分支，比如对于拉起第三方<code>app</code>登录的过程，每一步都考虑建立多次重试的机制。时间不是问题，成功率才是问题。</li>
</ul>
</li>
<li>测试账号需要实时维护，同时也需要考量维护的成本<ul>
<li>如果测试账号量大，但因为游戏新特性发布导致各种弹窗的出现，可以统一在测试用例的<code>setup</code>步骤中抽象出来，从而解决同类问题</li>
<li>如果游戏有账号数据复制这一机制的支持，可以优先用来保证玩家能够快速达到用例执行的前置状态</li>
</ul>
</li>
</ul>
<h2 id="用例脚本执行"><a href="#用例脚本执行" class="headerlink" title="用例脚本执行"></a>用例脚本执行</h2><p>用例脚本执行期间的稳定性，是自动化业务逻辑保证的。除去代码质量外，合适的自动化流程和代码设计，是保证自动化稳定性的根本。<br>在<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjIvMDkvMDQvZ2FtZW9mYXV0b3Rlc3QvaWlpLw==" title="https://utmhikari.top/2022/09/04/gameofautotest/iii/">框架设计<i class="fa fa-external-link"></i></span>一文当中，笔者强调了行为驱动对于自动化开发的重要性，通过对行为层面的抽象，用例开发者不必关心行为的具体实现，只需组装玩家行为，即可实现自动化流程。因此，行为库，作为自动化逻辑的基础，是影响自动化稳定性的关键。</p>
<p>自动化行为可以通过脚本驱动和UI驱动实现。至于如何提升行为实现的稳定性，这里就给出几个tips可以参考：</p>
<ul>
<li>脚本自动化<ul>
<li>在客户端游戏代码中抽象一层自动化专属模块，用于整合基础常用的游戏接口<ul>
<li>客户端开发的目标是仿真，而非原子串行地执行玩家行为，因此客户端许多原生接口的实现是被动响应式的，不一定直接满足自动化主动执行的需求</li>
<li>游戏接口调用尽量挑业务底层模块的，一般接口名不会有太多变化，减少自动化专属模块的维护量</li>
<li>抽象自动化专属模块，同时可以让自动化逻辑更加可控，防止开发频繁修改游戏接口实现导致的不稳定性</li>
</ul>
</li>
<li>在框架代码中，基于游戏自动化模块再抽象一个接口层，在接口实现里组装代码和参数<ul>
<li>需要实现一个通用方法，将框架运行时的数据对象转化成游戏脚本代码的表达形式</li>
<li>效果上，用例开发者无需关心代码组装逻辑，进一步减少脚本驱动逻辑开发难度，提升代码易读性</li>
</ul>
</li>
</ul>
</li>
<li>UI自动化<ul>
<li>如果控件名称或者控件文本较为独特唯一，优先用控件名称或文本作为UI的筛选条件<ul>
<li>如果是动态生成的控件，以<code>UE4</code>为例，控件名会有ID后缀，因此不能采取全文匹配，可以用关键字匹配</li>
</ul>
</li>
<li>如果是容器内（如列表）的一批控件，控件名/文本都相同，需要筛选其中一个的话，可以通过子控件的独特性来筛选<ul>
<li>游戏迭代过程中，控件之间的层级关系一般不会有太大的变化，因此可以通过子控件筛选来反推父控件，并且这种逻辑维护起来也比较方便</li>
</ul>
</li>
<li>对于包含图像的控件，优先用图像资源路径的关键字进行匹配，再次之用图像识别<ul>
<li>资源路径的关键字特征通常较明显，实际使用时也通常能筛选出屏幕中唯一的那一个</li>
<li>图像识别方案，一来会被图像识别技术本身的不稳定性影响；二来游戏迭代过程中，相对于控件/资源名的关键字变化，UI样式变化会来的多，但图像识别方案是不能接受UI样式变化的。因此，如果需要大规模使用UI自动化情况下，图像识别方案需要谨慎选择。</li>
</ul>
</li>
<li>通过控件树前后是否变化，判断UI操作是否生效，并抽象重试机制，提升UI自动化的容错性</li>
<li>不直接用控件ID、控件坐标筛选控件，因为无法直接兼容到其他机器</li>
</ul>
</li>
</ul>
<p>这些tips，即便是在自动化业务逻辑里，需要实现一些游戏行为的场景下，也都是通用的。</p>
<p>在行为库一层之上，自动化业务逻辑的稳定性，其实多取决于测试业务本身的复杂度，以及用例开发者的业务理解跟编码水平。在这里，就需要考虑自动化业务选型和流程设计了。为了规避可能的不稳定性，发挥自动化技术的价值，这里也有几个tips可以参考：</p>
<ul>
<li>选择操作不复杂，但遍历量大的场景，实现自动化遍历</li>
<li>选择人工测试操作复杂，但可以通过直接和游戏程序运行时交互去收集数据/执行测试的场景，实现自动化遍历</li>
<li>在同时有多个测试点的情况下，每个测试点执行过后，需要有执行失败的兜底逻辑，恢复玩家状态，从而能继续测试<ul>
<li>如果兜底方式不明确，可考虑设计成能够串行执行+<code>fast-fail</code>立即终止的形式</li>
<li>通过配置驱动来动态决定哪些测试点需要执行</li>
</ul>
</li>
<li>业务功能自动化测试场景下，一个用例尽量只专注于一类测试点，不要在自动化流程期间验证很多分支测试点<ul>
<li>会引起用例代码量过大，逻辑复杂，难以维护</li>
<li>自动化测试无法代替功能测试全部内容，真正代替的是测试人力，需要强调下这个思路</li>
</ul>
</li>
</ul>
<h2 id="后置恢复操作"><a href="#后置恢复操作" class="headerlink" title="后置恢复操作"></a>后置恢复操作</h2><p>自动化用例的后置恢复操作，对自动化整个流程的稳定性影响不是特别大。这部分，只有几点需要注意：</p>
<ul>
<li>对于有前后继关系的测试用例，每个用例的后置恢复操作，需要和先前所述一样，实质是一个失败兜底逻辑，保证玩家状态恢复正常，或者达到能直接检测到<code>fast-fail</code>的形式</li>
<li>对于单个机器运行多个用例的情况，保证机器能够稳定恢复到未装游戏之前的状态即可</li>
</ul>
<h2 id="测试报告输出"><a href="#测试报告输出" class="headerlink" title="测试报告输出"></a>测试报告输出</h2><p>测试报告是自动化测试的重要部分，只有测试报告才能够证明自动化测试是有效的。因此，能保障测试报告的有效性，也就可以保障自动化测试报告环节的执行稳定性。</p>
<p>对于测试报告的整合输出过程，有几点需要注意：</p>
<ul>
<li>一份有效的自动化报告，应当聚焦于自动化的测试目标，最优先是用程序分析的方式直接给出结论，再次则给出一系列有用的数据/截图/录屏到人工二次排查<ul>
<li>针对业务功能的自动化测试，测试的对象不是程序本身，而是基于人类的业务设计和测试经验。这种情况下强求用程序分析错误根因不现实，从实用角度来讲，应该要统一做成数据呈现+人工排查的<code>半自动化</code>形式。</li>
<li>需要做到的效果是，如果自动化报告会被标注为成功，那么整个过程是一定被信任的，默认是没有发现问题。只有标注失败的用例，才需要做人工介入。</li>
</ul>
</li>
<li>自动化过程耗时较长，不可避免会因为崩溃、设备断线等原因，出现用例执行中途断掉的情况。因此自动化业务逻辑需要有根据已有报告存档，在测试过程中忽略已测试内容的机制，从而避免冗余测试的情况。<ul>
<li>这种机制下，可以满足测试用例随时停止重启的需求，不同测试用例的报告可以随时合并，成为汇总的报告内容。</li>
</ul>
</li>
</ul>
<p>自动化测试报告一般需要持久化保存，对于一些耗时较长、输出截图/录屏量较大的用例，用<strong>对象存储</strong>是最适合做报告持久化的。</p>
<p>在业务功能自动化测试领域，对于大规模冒烟监控的场景，需要考虑到测试报告分析的人力成本。这种情况下，报告分析成本和自动化执行的时间是成正比的，因此，如果自动化测试通入的人力不多，需要酌情控制自动化测试的规模，防止无意义的人力成本消耗，导致没有更多的时间去维护已有用例的稳定性，或者开发新场景的用例。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自动化测试的稳定性，作为一个重点问题，其解决方案，并非一言以蔽之的固定套路，而更多是技术细节的累积，以及测试工作者实事求是的分析。本文主要从笔者工作经验出发，讲述一种保障游戏自动化测试稳定性的方法，希望各位读者/同行能够通过这篇文章，对于<code>自动化测试稳定性</code>这一命题，拥有更新的理解。</p>
]]></content>
      <categories>
        <category>Game Of AutoTest</category>
      </categories>
      <tags>
        <tag>系统设计</tag>
        <tag>游戏自动化</tag>
        <tag>自动化测试</tag>
        <tag>自动化稳定性</tag>
        <tag>自动化测试平台</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python随笔】PyQt5的QListView兼容左键双击事件和右键上下文菜单的方法</title>
    <url>/2022/10/02/pythonnotes/pyqt_listview_fileviewer/</url>
    <content><![CDATA[<p>近期笔者因工作原因，需要做一个安卓手机的文件浏览功能，集成在笔者以前用<code>PyQt5</code>做的一个的工具当中。文件浏览功能大概做成这样：</p>
<ul>
<li>一个列表界面，列出某个目录下的所有文件名（不区分文件和文件夹）</li>
<li>双击某个文件名，尝试进入这个文件名代表的文件夹（文件的情况会失败）</li>
<li>右键某个文件名，弹出上下文菜单，可以进入这个文件名对应的文件夹，也可以复制路径到其他的输入框</li>
</ul>
<p>其中，文件列表选型用了<code>QListView</code>组件，但在实现兼容双击进入文件夹+右键菜单功能时，稍微踩了下坑。为了解决这个问题，笔者在网上查阅了许多资料，最后找到一种解决方法，决定记录于本文当中。</p>
<p>首先需要了解，<code>Qt</code>对于<code>QListView</code>这类数据容器组件，是遵循<code>MVC</code>的设计模式的。<code>QListView</code>数据的初始化，方法是这样的：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br><span class="line">model = QStringListModel()</span><br><span class="line">model.setStringList(data)</span><br><span class="line">listview = QListView()</span><br><span class="line">listview.setModel(model)</span><br></pre></td></tr></table></figure>
<p>可以看到，是<code>data -&gt; model -&gt; view</code>这样的关系呈现。</p>
<p>要让<code>listview</code>同时支持双击和右键事件，常见的想法是用<code>doubleClicked</code>、<code>clicked</code>之类的<code>signal</code>去<code>connect</code>对应的事件委托。但这里有一个误区：<code>clicked</code>有<code>connect</code>事件委托这种情况下，不论在<code>listview</code>里单击鼠标左键或者单击右键，都能触发鼠标单击事件，而如果同时<code>connect</code>了<code>doubleClicked</code>的委托，<code>doubleClicked</code>的委托会无法执行。这样的话，就无法同时满足左键双击和右键上下文菜单功能。</p>
<p>看似这个问题无法解决，实际上<code>Qt</code>还是给开发者留下了一个后门——<code>QWidget</code>本身有一个<code>setContextMenuPolicy</code>接口去设置上下文菜单策略，而这个上下文菜单就是右键触发的。因此，我们可以通过绑定<code>doubleClicked</code>事件委托，同时<code>setContextMenuPolicy</code>为自定义菜单模式<code>CustomContextMenu</code>，并绑定<code>customContextMenuRequested</code>这个<code>signal</code>到一个自动弹出上下文菜单的方法，就可以事件左键双击事件和右键上下文菜单的兼容了。</p>
<p>代码样例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_double_clicked</span><span class="params">(idx)</span>:</span></span><br><span class="line">    <span class="comment"># idx为QModelIndex类型，通过row方法获取数据索引值</span></span><br><span class="line">    print(<span class="string">f'triggered double-click -&gt; <span class="subst">&#123;data[idx.row()]&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_trigger_menu_action</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 通过selectedIndexes方法可以获得点中的所有项</span></span><br><span class="line">    selected_indexes = listview.selectedIndexes()</span><br><span class="line">    <span class="keyword">if</span> len(selected_indexes) &gt; <span class="number">0</span>:</span><br><span class="line">        data_idx = selected_indexes[<span class="number">0</span>].row()</span><br><span class="line">        print(<span class="string">f'triggered context menu -&gt; <span class="subst">&#123;data[data_idx]&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_custom_context_menu_requested</span><span class="params">(pos)</span>:</span></span><br><span class="line">    ctx_menu = QtGui.QMenu()</span><br><span class="line">    menu_action = popMenu.addAction(<span class="string">'打印信息'</span>)</span><br><span class="line">    menu_action.triggered.connect(on_trigger_menu_action)</span><br><span class="line">    ctx_menu.exec_(QtGui.QCursor.pos())  <span class="comment"># 由当前鼠标位置弹出菜单</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">listview.doubleClicked.connect(on_double_clicked)</span><br><span class="line">listview.setContextMenuPolicy(Qt.CustomContextMenu)</span><br><span class="line">listview.customContextMenuRequested.connect(on_custom_context_menu_requested)</span><br></pre></td></tr></table></figure>
<p>在<code>doubleClicked</code>的场景下，可以通过传参的<code>QModelIndex</code>实例直接获取数据的索引值，从而拿到数据；在<code>customContextMenuRequested</code>的场景下，可以通过<code>listview</code>的<code>selectedIndexes</code>获取所有选中项的<code>QModelIndex</code>，进而也是通过<code>row</code>接口，就可以知道哪个下标的数据被选中了。</p>
]]></content>
      <categories>
        <category>Python随笔</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>QListView</tag>
        <tag>Qt</tag>
        <tag>上下文菜单</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】GAutomator安卓UE4版本的实现机理与优化实战</title>
    <url>/2022/09/12/testlife/gautomator_ue4_android/</url>
    <content><![CDATA[<p>在<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjAvMDUvMDUvdGVzdGxpZmUvdHJ5X2dhdXRvbWF0b3Iv" title="https://utmhikari.top/2020/05/05/testlife/try_gautomator/">2年以前的一篇文章<i class="fa fa-external-link"></i></span>中，讲述了游戏UI自动化方案<code>GAutomator</code>的基础机理、使用方式和一些工具扩展的想法。今天，趁着<code>Game Of AutoTest</code>系列的连载，结合<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjIvMDgvMTMvZ2FtZW9mYXV0b3Rlc3QvaWkv" title="https://utmhikari.top/2022/08/13/gameofautotest/ii/">游戏自动化技术选型<i class="fa fa-external-link"></i></span>一文，笔者将深入剖析<code>GAutomator</code>作为<code>UE4</code>安卓游戏UI自动化方案的实现机理，以及自己在实际工作中对<code>GAutomator</code>的优化实践。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><code>GAutomator</code>是这样的调用链路：</p>
<a id="more"></a>
<ul>
<li>PC和手机的连通 <ul>
<li><code>GAutomator</code>插件被启用编译，启动时在手机内启动一个<code>tcp-server</code></li>
<li>PC端<code>GAClient</code>通过<code>adb forward</code>转发端口，然后连到手机内的<code>tcp-server</code></li>
</ul>
</li>
<li>获取控件 <ul>
<li>通过给<code>GAutomator-Server</code>发送<code>DUMP_TREE</code>命令，获取控件树的<code>XML</code>字符串</li>
<li>PC端<code>GAClient</code>接收到的控件树数据，可以被我们自己的业务逻辑取到，因此我们可以通过自定义的筛选条件找到对应控件的<code>Element</code></li>
</ul>
</li>
<li>点击控件 <ul>
<li>PC端<code>GAClient</code>通过筛选控件得到的，或是自定义的<code>Element</code>，给到<code>click</code>接口</li>
<li><code>click</code>接口发送<code>GET_ELEMENTS_BOUND</code>命令，根据<code>Element</code>信息，查询到对应控件在视口中的坐标</li>
<li>获取坐标后，用<code>adb input tap</code>点击屏幕</li>
</ul>
</li>
</ul>
<h2 id="UE-SDK"><a href="#UE-SDK" class="headerlink" title="UE-SDK"></a>UE-SDK</h2><p><code>GAutomator</code>的<code>UE-SDK</code>实质是一个<code>UE4</code>插件，按需启用。</p>
<h3 id="插件启动"><a href="#插件启动" class="headerlink" title="插件启动"></a>插件启动</h3><p>插件启动时，会启动一个<code>TCP-Server</code>监听设备的某个端口，接取命令请求。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插件启动</span></span><br><span class="line"><span class="keyword">void</span> FGAutomatorModule::StartupModule()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined PLATFORM_IOS || defined __ANDROID__</span></span><br><span class="line">	CommandDispatcherPtr = <span class="keyword">new</span> WeTestU3DAutomation::FCommandDispatcher();</span><br><span class="line">	CommandDispatcherPtr-&gt;Initialize();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CommandDispatcher初始化</span></span><br><span class="line"><span class="keyword">bool</span> FCommandDispatcher::Initialize()</span><br><span class="line">&#123;</span><br><span class="line">    SocketListenerThreadInstance = FRunnableThread::Create(<span class="keyword">this</span>, TEXT(<span class="string">"GAutomatorListenerThread"</span>));</span><br><span class="line">    <span class="keyword">return</span> SocketListenerThreadInstance != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务主循环</span></span><br><span class="line">uint32 FConnectionHandler::Run()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = HandleOneCommand();</span><br><span class="line">    &#125; <span class="keyword">while</span> (result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle命令</span></span><br><span class="line"><span class="keyword">bool</span> FConnectionHandler::HandleOneCommand() </span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 获取头部长度信息</span></span><br><span class="line">    int32 length = RecvIntLength(); </span><br><span class="line">    <span class="keyword">if</span> (length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取命令请求body</span></span><br><span class="line">    TArray&lt;uint8&gt; BodyBinrary;</span><br><span class="line">    <span class="keyword">bool</span> RecvContentResult = RecvContent(length, BodyBinrary);</span><br><span class="line">    <span class="keyword">if</span> (!RecvContentResult) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FString ContentStr = StringFromBinaryArray(BodyBinrary);</span><br><span class="line">    UE_LOG(GALog, Log, TEXT(<span class="string">"Recv command:%s"</span>), *ContentStr);</span><br><span class="line">    TSharedPtr&lt;FJsonValue&gt; JsonParsed;</span><br><span class="line">    TSharedRef&lt; TJsonReader&lt;TCHAR&gt; &gt; JsonReader = TJsonReaderFactory&lt;TCHAR&gt;::Create(ContentStr);</span><br><span class="line">    <span class="keyword">bool</span> BFlag = FJsonSerializer::Deserialize(JsonReader, JsonParsed);</span><br><span class="line">    <span class="keyword">if</span> (!BFlag) &#123;</span><br><span class="line">        UE_LOG(GALog, Error, TEXT(<span class="string">"Deserialize request to json failed.\n %s"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handle-command并返回</span></span><br><span class="line">    FString Response;</span><br><span class="line">    <span class="keyword">bool</span> res= HandleCommandInGameThread(JsonParsed, Response);</span><br><span class="line">    length= <span class="keyword">this</span>-&gt;SendData(Response);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据不同的命令码，内部会<code>dispatch</code>到不同<code>handler</code>去运行得到对应命令的结果。</p>
<h3 id="控件信息获取"><a href="#控件信息获取" class="headerlink" title="控件信息获取"></a>控件信息获取</h3><p><code>GAutomator</code>最重要的一个功能是控件树导出，其实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取控件树xml字符串</span></span><br><span class="line"><span class="function">FString <span class="title">GetCurrentWidgetTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TSharedPtr&lt;FXmlFile&gt; xml = CreateFXmlFile();</span><br><span class="line">    FString XmlStr;</span><br><span class="line">    FXmlNode* RootNode = xml-&gt;GetRootNode();</span><br><span class="line">    <span class="comment">// 遍历每层可见的根UUserWidget实例</span></span><br><span class="line">    <span class="keyword">for</span> (TObjectIterator&lt;UUserWidget&gt; Itr; Itr; ++Itr)</span><br><span class="line">    &#123;</span><br><span class="line">        UUserWidget* UserWidget = *Itr;</span><br><span class="line">        <span class="keyword">if</span> (UserWidget == <span class="literal">nullptr</span> || !UserWidget-&gt;GetIsVisible() || UserWidget-&gt;WidgetTree == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            UE_LOG(GALog, Log, TEXT(<span class="string">"UUserWidget Iterator get a null(unvisible) UUserWidget"</span>));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代向下遍历</span></span><br><span class="line">        ForWidgetAndChildren(UserWidget-&gt;WidgetTree-&gt;RootWidget, RootNode);</span><br><span class="line">    &#125;</span><br><span class="line">    WriteNodeHierarchy(*RootNode, FString(), XmlStr);</span><br><span class="line">    <span class="keyword">return</span> MoveTemp(XmlStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ForWidgetAndChildren</span><span class="params">(UWidget* Widget, FXmlNode* Parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 过滤无效widget</span></span><br><span class="line">    <span class="keyword">if</span> (Widget == <span class="literal">nullptr</span> || Parent == <span class="literal">nullptr</span> || !Widget-&gt;IsVisible()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 提取UWidget实例信息</span></span><br><span class="line">    FXmlNode* WidgetXmlNode = TransformUmg2XmlElement(Widget, Parent);</span><br><span class="line">    <span class="comment">// 遍历Named-Slot，参考：https://docs.unrealengine.com/5.0/en-US/using-named-slots-in-umg-for-unreal-engine/</span></span><br><span class="line">    <span class="keyword">if</span> (INamedSlotInterface* NamedSlotHost = Cast&lt;INamedSlotInterface&gt;(Widget))</span><br><span class="line">    &#123;</span><br><span class="line">        TArray&lt;FName&gt; SlotNames;</span><br><span class="line">        NamedSlotHost-&gt;GetSlotNames(SlotNames);</span><br><span class="line">        <span class="keyword">for</span> (FName SlotName : SlotNames)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (UWidget* SlotContent = NamedSlotHost-&gt;GetContentForSlot(SlotName))</span><br><span class="line">            &#123;</span><br><span class="line">                ForWidgetAndChildren(SlotContent, WidgetXmlNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历Panel-Widget</span></span><br><span class="line">    <span class="keyword">if</span> (UPanelWidget* PanelParent = Cast&lt;UPanelWidget&gt;(Widget))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (int32 ChildIndex = <span class="number">0</span>; ChildIndex &lt; PanelParent-&gt;GetChildrenCount(); ChildIndex++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (UWidget* ChildWidget = PanelParent-&gt;GetChildAt(ChildIndex))</span><br><span class="line">            &#123;</span><br><span class="line">                ForWidgetAndChildren(ChildWidget, WidgetXmlNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>机理上，会从所有的<code>Root Widget</code>开始向下遍历，拿到每个<code>Widget</code>的数据<br>而获取控件坐标方面，会涉及寻找控件的逻辑。在<code>UE4</code>插件内部，<code>GAutomator</code>默认支持通过控件名的方式查找：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> UWidget* <span class="title">FindUWidgetObject</span><span class="params">(<span class="keyword">const</span> FString&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TObjectIterator&lt;UUserWidget&gt; Itr; Itr; ++Itr)</span><br><span class="line">    &#123;</span><br><span class="line">        UUserWidget* UserWidget = *Itr;</span><br><span class="line">        <span class="keyword">if</span> (UserWidget == <span class="literal">nullptr</span> || !UserWidget-&gt;GetIsVisible() || UserWidget-&gt;WidgetTree == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            UE_LOG(GALog, Log, TEXT(<span class="string">"UUserWidget Iterator get a null(unvisible) UUserWidget"</span>));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过控件名寻找控件</span></span><br><span class="line">        UWidget* Widget = UserWidget-&gt;GetWidgetFromName(FName(*name));</span><br><span class="line">        <span class="keyword">if</span> (Widget != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Widget;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>机理上，会遍历所有根控件，调用<code>GetWidgetFromName</code>方法，找到的第一个<code>Widget</code>即返回。而之后获取屏幕视口坐标，则会从<code>CachedGeometry</code>获取到：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> FUWidgetHelper::GetElementBound(<span class="keyword">const</span> FString&amp; name, FBoundInfo&amp; BoundInfo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> UWidget* WidgetPtr = FindUWidgetObject(name);</span><br><span class="line">    <span class="comment">// 由GetCachedGeometry获取渲染几何信息</span></span><br><span class="line">    <span class="keyword">const</span> FGeometry geometry = WidgetPtr-&gt;GetCachedGeometry();</span><br><span class="line">    FVector2D Position = geometry.GetAbsolutePosition();</span><br><span class="line">    FVector2D Size = geometry.GetAbsoluteSize();</span><br><span class="line">    BoundInfo.x = Position.X / WidthScale;</span><br><span class="line">    BoundInfo.y = Position.Y / HeightScale;</span><br><span class="line">    BoundInfo.width = Size.X / WidthScale;</span><br><span class="line">    BoundInfo.height = Size.Y / HeightScale;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a>优化手段</h3><p><code>GAutomator</code>的<code>UE-SDK</code>在实现上，现在还存在许多不足，在笔者的实际应用中发现，很多地方没有考虑到。比如：</p>
<ul>
<li>不支持<code>ListView</code>子空间的信息拉取</li>
<li>不支持富文本控件</li>
<li>不支持图片控件</li>
<li>不支持输入控件输入内容</li>
<li>不能通过<code>UniqueID</code>查询控件<ul>
<li>如果出现控件名重复，或者动态生成控件的情况，会难以定位到，甚至每次都只能查到第一个</li>
</ul>
</li>
<li>不能一次性返回控件基础+坐标信息<ul>
<li>若业务侧一开始查询控件树，不会一次性返回控件坐标，执行控件操作还需要额外再查询一次</li>
</ul>
</li>
<li>PC游戏无法实现点击按下等操作</li>
</ul>
<p>因此在实际业务中，笔者做了如下的优化，可供参考：</p>
<ul>
<li>支持<code>ListView</code>子控件的信息提取逻辑</li>
<li>支持富文本控件信息提取（这个看具体项目富文本控件实现而定）</li>
<li>支持以资源路径为图片控件的文本信息，利于筛选特定图片</li>
<li>支持对<code>EditableText</code>等控件输入内容</li>
<li>支持通过<code>UniqueID</code>查询控件</li>
<li>支持拉取控件树时，一次性返回控件基础信息+视口坐标信息</li>
<li>支持<code>Broadcast</code>控件委托来实现点击按下等操作，从而支持PC端游戏的控件操作</li>
</ul>
<h2 id="GA-Client"><a href="#GA-Client" class="headerlink" title="GA-Client"></a>GA-Client</h2><p><code>GAutomator</code>的PC端<code>Client</code>主要的内容集中在<code>GAutomatorAndroid</code>以及<code>GAutomatorIos</code>下，本文以<code>GAutomatorAndroid</code>的部分为例，讲述<code>GA-Client</code>的核心实现。</p>
<p><code>GAutomatorAndroid</code>项目本身杂糅了很多<code>wetest</code>相关的内容，以及很多无比粗糙的代码，这部分内容其实和<code>GA-Client</code>核心逻辑没有太大的联系。如果自己写一个<code>GA-Client</code>的话，可能只需要五分之一的代码量就可以了。</p>
<h3 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a>核心逻辑</h3><p><code>GA-Client</code>的核心部分在于<code>GameEngine</code>，所有与游戏内<code>SDK</code>交互的逻辑，都集中在这里：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># engine.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameEngine</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, address, port,uiauto_interface)</span>:</span></span><br><span class="line">        self.address = address</span><br><span class="line">        self.port = port</span><br><span class="line">        self.sdk_version = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 初始化SocketClient实例，用以和游戏SDK通信</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">try</span> :</span><br><span class="line">                self.socket = SocketClient(self.address, self.port)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                logger.error(e)</span><br><span class="line">                time.sleep(<span class="number">20</span>)</span><br><span class="line">                ret = forward(self.port, unity_sdk_port)  <span class="comment"># with retry...</span></span><br><span class="line">        <span class="comment"># 初始化UIAutomator实例</span></span><br><span class="line">        self.ui_device = uiauto_interface</span><br></pre></td></tr></table></figure>
<p>在<code>GameEngine</code>实例初始化的时候，会生成一个连接游戏内<code>SDK</code>的<code>socket</code>实例，以及一个<code>uiautomator</code>实例<code>ui_device</code>。当游戏需要和<code>native-ui</code>交互的时候（比如QQ登录），就需要<code>uiautomator</code>的支持（然而在<code>GameEngine</code>的基础方法里，<code>ui_device</code>实例没有发挥作用）。</p>
<p>当我们向游戏SDK发送命令的时候，会调用到<code>socket</code>的<code>send_command</code>方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># engine.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameEngine</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_dump_tree</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""获取控件树"""</span></span><br><span class="line">        ret = self.socket.send_command(Commands.DUMP_TREE)</span><br><span class="line">    	<span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment"># socket_client.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_command</span><span class="params">(self, cmd, params=None, timeout=<span class="number">20</span>)</span>:</span></span><br><span class="line">        <span class="string">"""发送命令，带重试机制"""</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> params:</span><br><span class="line">            params = <span class="string">""</span></span><br><span class="line">        command = &#123;&#125;</span><br><span class="line">        command[<span class="string">"cmd"</span>] = cmd</span><br><span class="line">        command[<span class="string">"value"</span>] = params</span><br><span class="line">        <span class="keyword">for</span> retry <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.socket.settimeout(timeout)</span><br><span class="line">                self._send_data(command)</span><br><span class="line">                ret = self._recv_data()</span><br><span class="line">                <span class="keyword">return</span> ret</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="comment"># 这里忽略异常处理/重连逻辑</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Socket Error'</span>)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">_send_data</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""发送数据"""</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            serialized = json.dumps(data)</span><br><span class="line">        <span class="keyword">except</span> (TypeError, ValueError) <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> WeTestInvaildArg(<span class="string">'You can only send JSON-serializable data'</span>)</span><br><span class="line">        length = len(serialized)</span><br><span class="line">        buff = struct.pack(<span class="string">"i"</span>, length)</span><br><span class="line">        self.socket.send(buff)</span><br><span class="line">        <span class="keyword">if</span> six.PY3:</span><br><span class="line">            self.socket.sendall(bytes(serialized, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.socket.sendall(serialized)</span><br></pre></td></tr></table></figure>
<p>从代码内容易知，发送命令的方式是：</p>
<ul>
<li>用<code>json.dumps</code>序列化命令<code>cmd</code>和参数<code>params</code></li>
<li>在序列化数据前<code>pack</code>一个<code>int</code>长度信息，把它和数据连起来发送给游戏内<code>SDK</code></li>
<li>游戏内<code>SDK</code>先<code>recv</code>长度信息，再根据长度信息<code>recv</code>对应长度的数据，用<code>json.loads</code>反序列化，就得到原始命令和参数</li>
</ul>
<p>当接收到数据时，也是跟游戏内<code>SDK</code>接收数据相同的方式。具体的实现在<code>recv_package</code>里：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># socket_client.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recv_package</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 拉取长度信息</span></span><br><span class="line">        length_buffer = self.socket.recv(<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">if</span> length_buffer:</span><br><span class="line">            total = struct.unpack_from(<span class="string">"i"</span>, length_buffer)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> WeTestSDKError(<span class="string">'recv length is None?'</span>)</span><br><span class="line">        <span class="comment"># 拉取数据，开total长度的memoryview作为buffer</span></span><br><span class="line">        view = memoryview(bytearray(total))</span><br><span class="line">        next_offset = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> total - next_offset &gt; <span class="number">0</span>:</span><br><span class="line">            recv_size = self.socket.recv_into(view[next_offset:], total - next_offset)</span><br><span class="line">            next_offset += recv_size</span><br><span class="line">        <span class="comment"># 反序列化数据</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> six.PY3:</span><br><span class="line">                deserialized = json.loads(str(view.tobytes(), encoding=<span class="string">'utf-8'</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                deserialized = json.loads(view.tobytes())</span><br><span class="line">            <span class="keyword">return</span> deserialized</span><br><span class="line">        <span class="keyword">except</span> (TypeError, ValueError) <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> WeTestInvaildArg(<span class="string">'Data received was not in JSON format'</span>)</span><br></pre></td></tr></table></figure>
<p>类似<code>dump_tree</code>这种命令，返回的是<code>xml-string</code>，相当于是没有二次封装过的控件树。而类似<code>click</code>这种操作命令，实际用到的就是<code>adb shell input</code>这一系列的命令了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># engine.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameEngine</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click</span><span class="params">(self, locator)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> locator <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(locator, Element):  <span class="comment"># 考虑入参Element的情况</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                bound = self.get_element_bound(locator)</span><br><span class="line">                <span class="keyword">if</span> bound:</span><br><span class="line">                    <span class="keyword">return</span> self.click_position(bound.x + bound.width / <span class="number">2</span>, bound.y + bound.height / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">except</span> WeTestRuntimeError <span class="keyword">as</span> e:</span><br><span class="line">                logger.error(<span class="string">"Get element(&#123;0&#125;) bound faild &#123;1&#125;"</span>.format(locator, e.message))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 忽略只给ElementBound以及其他情况</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">click_position</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        x = int(x)</span><br><span class="line">        y = int(y)</span><br><span class="line">        cmd = <span class="string">"shell input tap "</span> + str(x) + <span class="string">" "</span> + str(y)</span><br><span class="line">        excute_adb_process(cmd)  <span class="comment"># adb shell input tap</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># adb_process.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">excute_adb_process</span><span class="params">(cmd, serial=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> serial:</span><br><span class="line">        command = <span class="string">"adb -s &#123;0&#125; &#123;1&#125;"</span>.format(serial, cmd)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        command = <span class="string">"adb &#123;0&#125;"</span>.format(cmd)</span><br><span class="line">	<span class="comment"># popen一个adb命令进程，执行命令</span></span><br><span class="line">    ret = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">3</span>):</span><br><span class="line">        p = subprocess.Popen(command, shell=<span class="literal">True</span>, stderr=subprocess.STDOUT, stdout=subprocess.PIPE)</span><br><span class="line">        lines = p.stdout.readlines()</span><br><span class="line">        ret = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            ret += str(line) + <span class="string">"\n"</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">"no devices/emulators found"</span> <span class="keyword">in</span> ret <span class="keyword">or</span> <span class="string">"device offline"</span> <span class="keyword">in</span> ret:</span><br><span class="line">            logger.error(<span class="string">"rety in excute_adb_process"</span>)</span><br><span class="line">            time.sleep(<span class="number">20</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h3 id="优化手段-1"><a href="#优化手段-1" class="headerlink" title="优化手段"></a>优化手段</h3><p>从<code>GA-Client</code>核心逻辑的实现可以看到，有很多地方是值得精简的。以笔者的经验为例，是按照自己自动化框架约定，重写了一版<code>GA-Client</code>。具体是做了以下优化：</p>
<ul>
<li>单独分离出设备接口模块，用以统一管理设备信息和操作<ul>
<li>设备序列号、<code>adb</code>命令、<code>shell</code>命令，都在这个模块执行</li>
</ul>
</li>
<li><code>GA-Client</code>和<code>uiautomator</code>分离，做成插件的形式<ul>
<li><code>GAutomator</code>和<code>uiautomator</code>的操作，比如点击按下这些，就可以由设备接口模块执行</li>
</ul>
</li>
<li>控件树的<code>XML</code>字符串做二次封装，对每个控件抽象成<code>Widget</code>类<ul>
<li>单独做一个<code>GA</code>操作接口模块，传入<code>Widget</code>类实例就可以对控件做操作</li>
<li><code>Widget</code>类做一些更复杂的控件筛选功能，这块就不需要游戏内<code>SDK</code>来深入做了</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>游戏自动化</tag>
        <tag>UE4</tag>
        <tag>自动化测试</tag>
        <tag>UI自动化</tag>
        <tag>GAutomator</tag>
      </tags>
  </entry>
  <entry>
    <title>【Game Of AutoTest】3、游戏自动化测试的框架设计</title>
    <url>/2022/09/04/gameofautotest/iii/</url>
    <content><![CDATA[<p>自动化在技术层面上，除了基础的技术选型之外，最终还是需要落实到具体的工具框架，才能够助力我们自动化脚本开发的过程。因此，本文将讲述一下如何对游戏自动化测试框架进行设计。</p>
<p>在<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjIvMDgvMTMvZ2FtZW9mYXV0b3Rlc3QvaWkv" title="https://utmhikari.top/2022/08/13/gameofautotest/ii/">上一篇文章<i class="fa fa-external-link"></i></span>讲到，自动化测试的方式可以有客户端、服务器、编辑器三种方式，除了编辑器需要强依赖引擎层面的特性之外，其他两种自动化方式在工具或者框架的技术实现上有这么几个特点：</p>
<ul>
<li>框架模块设计具有共通性，只是最终执行自动化用例/脚本的方式不同</li>
<li>许多框架模块可以不依赖游戏本身的特性去实现，可以实现很多企业业务功能的集成</li>
<li>由于和产品没有太多的耦合，可以做成易于在不同项目测试之间迁移通用的形式</li>
</ul>
<p>考虑到当前我国有许多游戏企业的工作习惯是，测试由中台dispatch到各个项目，不直接参与研发过程（Code Review？不存在的），项目产品以提测的方式交付测试，测试侧可以运用自己的测试手法和工具去完成任务。从这样的角度看，拥有一个功能性强且通用的自动化测试工具，不仅是对于项目所需要自动化测试的场景，更是对于测试组整体的技术基建提升而言，都显得非常重要。</p>
<p>以笔者工作经验为参考，要做到游戏自动化框架得以通用，设计上需要遵循如下准则：</p>
<a id="more"></a>
<ul>
<li>技术集成<ul>
<li>在自动化逻辑实现方面，尽可能集成更多的自动化底层技术方案</li>
<li>在自动化业务落地方面，尽可能集成更多报告工具以及通用业务SDK<ul>
<li>报告工具包括：录屏、截图、日志分析、通用报告输出、IM/邮件推送等</li>
<li>通用业务SDK：这个比较灵活，根据各个企业内具体业务而定</li>
</ul>
</li>
</ul>
</li>
<li>用例隔离<ul>
<li>业务用例和框架底层相互隔离，通过接口约定或是依赖注入的方式衔接起来</li>
<li>不同用例之间，在逻辑意义上，不应出现相互的模块引用，有共性的需求需要抽象到框架当中</li>
<li>不同用例之间，在物理意义上，由框架统一管理各个用例的内容（脚本、配置）和运行时状态，测试人员通过启动框架去间接驱动用例的运行</li>
</ul>
</li>
<li>行为驱动<ul>
<li>在玩家行为层面上，对于每类玩法以及系统功能，抽象出基础接口集</li>
<li>在自动化测试层面上，对于每类固化的自动测试流程，抽象出固化的行为策略</li>
</ul>
</li>
</ul>
<h2 id="技术集成"><a href="#技术集成" class="headerlink" title="技术集成"></a>技术集成</h2><p>技术集成，从一个框架的角度而言，能集成更多的功能肯定是更好的。在技术集成方面需要分成两块考虑，一块是自动化的实现，我们需要把先前提到的各种自动化技术方案都整合进来，大多数业界开源的框架也都是这样做的。</p>
<p>另一块是具体到业务方面，就是在技术实现的基础上，怎样提升自动化的开发效率，怎样让自动化跟实际测试业务衔接的更好。这一part相比于自动化底层技术实现是更加重要的，因为会影响到自动化框架落地到业务的效果。</p>
<p>针对后者，开源框架和工具很难你这些，而就算企业内部做的许多技术方案，以笔者的经历来看，基本都缺乏这方面的思考沉淀。因此，如果是从0到1实现自动化测试的情况，建议是从具体业务出发，找一个适用于应用自动化技术的玩法测试场景，实事求是去琢磨一下。</p>
<h2 id="用例隔离"><a href="#用例隔离" class="headerlink" title="用例隔离"></a>用例隔离</h2><p>用例隔离，包含两个方面，一块是用例逻辑和框架逻辑的隔离，一块是不同用例之间的隔离。</p>
<p>针对前者，用例和框架的隔离，需要强调框架本身存在的意义是为用例提供运行环境还有便捷的功能接口，不应当依赖于用例本身，或者说，就算是非游戏领域的自动化测试甚至其他需求，用这个框架稍微改装一下就可以完成，这是框架作为底层基础需要达到的效果。</p>
<p>针对不同用例之间的隔离，严格意义上需要达到的效果是，用例本身的版本迭代是独立的，不同的用例开发者可以在相同版本框架的基础上开发不同的内容，最终这些内容都无冲突地合入到同一个开发分支。如果有可以抽象出来的内容，可以由框架开发者统一整理并入，也可以由用例开发者请求合入（这种情况有冲突的可能性），总之都是为了让框架集成的功能更加丰富。</p>
<p>在这样的设计基础上，用例的执行是需要框架机制驱动的，以笔者的经验为例，在<code>python</code>框架的场景下，可以参考下述方式实现。首先，框架可以呈现这样的目录结构：</p>
<ul>
<li><code>cfg</code>：框架配置</li>
<li><code>engine</code>：框架核心逻辑</li>
<li><code>testcases</code>：用例集根目录<ul>
<li><code>testcase_1</code>：用例1的工作目录<ul>
<li><code>main.py</code>：用例1的入口</li>
</ul>
</li>
</ul>
</li>
<li><code>main.py</code>：框架入口</li>
</ul>
<p>之后，在<code>main.py</code>中，用例开发者需要实现一个<code>run</code>函数，作为真实的用例跑测逻辑。<code>run</code>函数的入参可以是框架的一些特性实例，比如脚本/UI自动化的<code>Handle</code>。从用例开发者角度而言，不需要关心这些<code>Handle</code>的来源，可以直接拿来用；从框架开发者角度而言，框架需要根据用例的运行配置创建这些特性实例，然后<code>inject</code>给用例的<code>run</code>接口。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># testcases/testcase_1/main.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(r: RunnerHandle, d: DeviceHandle, s: ScriptHandle, u: UIHandle)</span> -&gt; Result:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    main entry of testcase logic</span></span><br><span class="line"><span class="string">    handles will be automatically injected by the autotest framework</span></span><br><span class="line"><span class="string">    :param r: handle of current runner, use this instance to log or get env-vars of testcase runtime</span></span><br><span class="line"><span class="string">     :param d: handle of device</span></span><br><span class="line"><span class="string">    :param s: handle of script-based autotest</span></span><br><span class="line"><span class="string">    :param u: handle of ui-based autotest</span></span><br><span class="line"><span class="string">    :return: testcase result</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 用例：关闭商城界面</span></span><br><span class="line">    r.logger.info(<span class="string">'start testcase_1!'</span>)</span><br><span class="line">    s.send(<span class="string">'print("helloworld")'</span>)</span><br><span class="line">    d.screenshot(<span class="string">'before_close'</span>)</span><br><span class="line">    <span class="keyword">if</span> u.find_and_click(name=<span class="string">'BtnClose_Mall'</span>):</span><br><span class="line">        r.logger.info(<span class="string">'found and clicked close-btn of mall panel'</span>)</span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line">        d.screenshot(<span class="string">'after_close'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r.logger.error(<span class="string">'failed to find close-btn of mall panel'</span>)</span><br><span class="line">    <span class="keyword">if</span> s.call(<span class="string">'UIModule.IsInMainPanel()'</span>).boolval():</span><br><span class="line">        <span class="keyword">return</span> Result.ok(message=<span class="string">'successfully closed mall panel'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> Result.err(message=<span class="string">'failed to close mall panel'</span>)</span><br></pre></td></tr></table></figure>
<p>最后，框架内部需要有一个通过<code>用例名</code>配置，从而动态<code>import</code>到<code>testcases/用例名</code>下的<code>main</code>模块，并调用<code>run</code>接口的运行机制。从用例开发者的角度，框架配置在<code>cfg</code>目录下指定（命令行也可以），之后运行框架入口脚本<code>main.py</code>，达到运行用例逻辑的效果。</p>
<h2 id="行为驱动"><a href="#行为驱动" class="headerlink" title="行为驱动"></a>行为驱动</h2><p>（游戏）自动化用例本质是一系列用户（玩家）行为的组装，因此在面向游戏自动化测试的框架设计上，需要充分对游戏行为进行抽象，使得不同的游戏行为能够复用到各个用例当中，减少用例代码量以及编写难度。</p>
<p>自动化的行为分为两种粒度，一种是测试玩家单个操作的粒度，好比说，打开某个玩法的界面、进入某玩法位面、设置某种画质，甚至是说查询任务进度数据、执行恢复状态GM命令这种，都属于测试玩家的单个操作。这些行为可以随时随地被不同的用例复用，拼装成整个自动化流程</p>
<p>举个例子，我们有<code>登录游戏</code>以及<code>玩PVP</code>的测试场景，这两个场景会遇到<code>等待加载</code>的过程，因此在自动化逻辑实现上，就可以抽象出<code>等待加载</code>的操作，放到单独的地方。代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># scene.py，场景模块（公共）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_loading</span><span class="params">()</span> -&gt; bool:</span></span><br><span class="line">    script_handle = ScriptHandle.current()</span><br><span class="line">    resp = script_handle.call(<span class="string">'SceneModule.IsLoading()'</span>)</span><br><span class="line">    <span class="keyword">return</span> resp.boolval()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait_for_loading</span><span class="params">(timeout=<span class="number">20</span>, interval=<span class="number">3</span>)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> is_loading():</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(timeout):</span><br><span class="line">        time.sleep(interval)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_loading():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录游戏</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_game</span><span class="params">()</span> -&gt; bool:</span></span><br><span class="line">    login_server(player_id=<span class="number">123</span>, server_id=<span class="number">456</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> scene.wait_for_loading():</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> is_in_game():</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 玩PVP</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_pvp</span><span class="params">()</span> -&gt; bool:</span></span><br><span class="line">    start_pvp_match(scene_id=<span class="number">999</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> scene.wait_for_loading():</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> is_in_pvp():</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>第二种粒度的行为是固化的自动化流程，这个流程可以指玩法流程，比如某个副本的行为树逻辑，也可以指测试流程，比如<code>buff</code>效果测试，只要给这个流程指定一些<code>buffID</code>，就可以自动执行<code>addBuff</code>、<code>checkPlayerState</code>之类的测试逻辑。这一类的行为是以第一类的行为为基础搭建而成的，从用例开发者角度来看，只需要自定义流程属性（类似行为树的黑板）以及重载一些流程中钩子函数的实现，就可以把自己需要的自动化逻辑搭建起来。</p>
<p>比如我们需要实现<code>跑副本</code>的操作，那么我们就可以抽象单独的副本流程出来，尽可能复用到游戏里所有独立的副本当中。我们可以根据<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjEvMDUvMjAvdGVzdGxpZmUvZHVuZ2Vvbl9hdXRvdGVzdC8=" title="https://utmhikari.top/2021/05/20/testlife/dungeon_autotest/">副本自动化测试<i class="fa fa-external-link"></i></span>一文所示的方式去构建一个基础的副本流程类，然后再根据我们游戏的具体情况去实现一版副本跑测类，最后就可以通过这个跑测类来适配所有独立的副本。代码示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DungeonBehavior</span>:</span></span><br><span class="line">    <span class="string">"""基础副本流程，参考【副本自动化测试】文章的实现"""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGameDungeonBehavior</span><span class="params">(DungeonBehavior)</span>:</span></span><br><span class="line">    <span class="string">"""当前游戏的副本流程实现"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, dungeon_id: int, **kwargs)</span>:</span></span><br><span class="line">        DungeonBehavior.__init__(self, **kwargs)</span><br><span class="line">        self._dungeon_id = dungeon_id</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_state</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""implement update_state step upon MyGame here"""</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_state_changed</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""implement on_state_changed step upon here"""</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChaosSanctuaryDungeonBehavior</span><span class="params">(MyGameDungeonBehavior)</span>:</span></span><br><span class="line">    <span class="string">"""假设有个叫做【混沌避难所】的副本"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        MyGameDungeonBehavior.__init__(self, <span class="number">123</span>, **kwargs)</span><br><span class="line">        self.does_diablo_exist = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_state</span><span class="params">(self)</span>:</span></span><br><span class="line">        MyGameDungeonBehavior.update_state(self)</span><br><span class="line">        self.does_diablo_exist = entity.has_entity(entity_id=<span class="number">99999</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_state</span><span class="params">(self)</span>:</span></span><br><span class="line">        default_state = MyGameDungeonBehavior.get_state(self)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'<span class="subst">&#123;default_state&#125;</span>_<span class="subst">&#123;self.does_diablo_exist&#125;</span>'</span></span><br></pre></td></tr></table></figure>
<p>如果有条件的话，可以编写行为树框架+可视化工具，甚至是能够实现BDD的原语支持，这样都能进一步提效自动化的开发。</p>
<p>通过对不同粒度的游戏行为进行抽象，不论是用例编写还是逻辑维护上，容易层度都可以上一个台阶。<strong>这一part的组织，是自动化框架设计当中最为重要的一环。</strong></p>
<h2 id="模块分层"><a href="#模块分层" class="headerlink" title="模块分层"></a>模块分层</h2><p>基于上述的设计思路，自动化框架可以依据这样的模块分层进行设计：</p>
<ul>
<li>框架底层<ul>
<li>基础逻辑：包括运行时配置管理、环境管理、依赖注入等机制</li>
<li>技术方案组件/插件化：包括设备操作模块、自动化底层技术、报告工具以及业务SDK等内容</li>
<li>用例运行：包括配置与脚本加载、用例运行监控、测试结果输出等内容</li>
</ul>
</li>
<li>游戏业务层<ul>
<li>玩家行为、自动化测试行为的封装</li>
<li>脚本/UI等自动化底层实现的封装<ul>
<li>根据每个游戏具体情况开发相关内容</li>
<li>脚本自动化，建议在游戏代码基础上，编写一层单独的自动化模块，使得拼装游戏脚本代码更加方便</li>
</ul>
</li>
<li>仅适用于本游戏的工具/业务SDK内容</li>
</ul>
</li>
<li>用例层<ul>
<li>用例运行配置</li>
<li>准备数据：主要是游戏的配置数据，也可以考虑在脚本代码中动态获取的方式</li>
<li>用例脚本代码</li>
</ul>
</li>
</ul>
<h2 id="工具扩展"><a href="#工具扩展" class="headerlink" title="工具扩展"></a>工具扩展</h2><p>如果把自动化框架这个概念向外延伸的话，那么除了基础框架本身之外，还需要周边工具的支持，才能最大化提升自动化测试的体验。<br>这些工具不一定需要集成到框架里，可以包括：</p>
<ul>
<li>调试工具：能够实现针对单个脚本/UI自动化逻辑给予即时结果反馈，用于日常开发调试用</li>
<li>代码生成工具：如行为树/脚本可视化编程、UI录制回放等，用于快速生成模板代码或是自动化逻辑</li>
<li>准备数据生成工具：用于快速生成某种玩法自动化测试所需的配置/用例数据</li>
<li>结果可视化工具：用于可视化展现自动化测试的结果</li>
<li>IDE：IDE可以显著简化研发过程，但IDE研发工作量大，需要考虑投入产出比</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作为游戏自动化测试框架来讲，既然是底层框架，那么打铁还需自身硬。除了上面说的一些设计理念跟工具选型，一些基础的方面，工程化、产品化的技术原则，比如保证稳定性、易扩展性、易上手性，高内聚低耦合，丰富的文档包装，SLA意识，这些都是通用框架设计落地必须具备的东西。自动化框架之于自动化用例，犹如游戏引擎之于游戏业务逻辑。如果框架开发者不去深入调研业务过程，而是纯粹堆砌自动化底层技术，那这类框架的结果，只能是炒作到大规模<strong>试用</strong>，而永远不可能在单个游戏项目内实现大规模<strong>应用</strong>。遗憾的是，在业界这种半成品依然大行其道。</p>
<p>最后还是得讲点东西。从游戏测试行业的角度来看，国内许多企业都执行中台测开+项目业务测试+中台/项目专项测试的模式，但由于项目测试通常有较高tick的工作模式，中台的工作模式通常又是同时服务多个项目组，就会造成对于许多专项测试需求，中台的支持效率显得很低，同时各项目测试因为不能及时得到支持，工作产出效能也会有所下降。以研发通用的自动化测试框架为例，建议采取的模式是，中台测试主控基础模块开发与业务特性合入，项目测试直接参与业务特性研发，并能随时申请合入一些自己项目遇到且可以通用给其他项目的内容。这样的开发模式下，不仅可以解决中台测试服务效率的问题，也能充分发挥项目测试的业务理解力和技术生产力，同时也能在不涉及保密问题的条件下最大限度集成各类技术模块。而更重要的，是可以加强不同测试团队之间的交流，减少信息的不对称性，这点从部门战斗力建设角度来讲，着实大有裨益。</p>
]]></content>
      <categories>
        <category>Game Of AutoTest</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化测试</tag>
        <tag>自动化框架</tag>
        <tag>BDD</tag>
        <tag>依赖注入</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python随笔】python的web开发——WSGI、ASGI、uvicorn与FastAPI</title>
    <url>/2022/08/14/pythonnotes/asgi_uvicorn_fastapi/</url>
    <content><![CDATA[<p>今天这篇文章，聊一下<code>python</code>在<code>web</code>开发上的一些基础实现，阐述下自己理解中的<code>WSGI</code>、<code>ASGI</code>，以及拿<code>uvicorn</code>+<code>FastAPI</code>的组合举个<code>ASGI</code>应用的例子。</p>
<h2 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h2><p><code>python</code>的<code>web</code>服务的诞生，其实追溯到一种机制，叫做<code>WSGI</code>，全称<code>Web Server Gateway Interface</code>。<code>WSGI</code>的提案来源于<span class="exturl" data-url="aHR0cHM6Ly9wZXBzLnB5dGhvbi5vcmcvcGVwLTAzMzMv" title="https://peps.python.org/pep-0333/">PEP-333<i class="fa fa-external-link"></i></span>，可以理解为一种<code>python-web-server</code>和<code>python-web-app</code>的接口通信标准。在这种场景下，<code>python</code>的<code>web</code>服务呈现以下的工作模式：</p>
<ul>
<li><code>python-web-app</code>，也就是<code>web</code>应用层，实现<code>WSGI</code>接口，用作<code>web</code>请求的<code>handler</code></li>
<li>用户向<code>python-web-server</code>发送<code>web</code>请求</li>
<li><code>python-web-server</code>，又称作<code>WSGI Server</code>，解析请求数据，整理当前<code>session</code>的环境信息</li>
<li><code>python-web-server</code>加载<code>python-web-app</code>，调用<code>python-web-app</code>实例的<code>WSGI</code>接口，处理请求</li>
<li><code>python-web-app</code>处理完请求，返回结果给到<code>python-web-server</code></li>
<li><code>python-web-server</code>写回返回结果，给回用户</li>
</ul>
<p>代码上是这样的表现，以官方提案的例子为例：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># python-web-app</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_app</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    python-web-app implementation</span></span><br><span class="line"><span class="string">    :param environ: 由python-web-server提供，表示当前请求的环境信息</span></span><br><span class="line"><span class="string">    :param start_response: 由python-web-server提供的回调，用以初始化返回结果的状态</span></span><br><span class="line"><span class="string">    :return: 返回结果的数据内容</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    status = <span class="string">'200 OK'</span></span><br><span class="line">    response_headers = [(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>)]</span><br><span class="line">    start_response(status, response_headers)</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'Hello world!\n'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># python-web-server</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_with_cgi</span><span class="params">(application)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    WSGI layer implementation</span></span><br><span class="line"><span class="string">    :param application: 实现WSGI的app</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    environ = dict(os.environ.items())</span><br><span class="line">    headers_set = []</span><br><span class="line">    headers_sent = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(data)</span>:</span></span><br><span class="line">        <span class="string">"""写回数据的逻辑"""</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headers_set:</span><br><span class="line">             <span class="keyword">raise</span> AssertionError(<span class="string">"write() before start_response()"</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> headers_sent:</span><br><span class="line">             <span class="comment"># Before the first output, send the stored headers</span></span><br><span class="line">             status, response_headers = headers_sent[:] = headers_set</span><br><span class="line">             sys.stdout.write(<span class="string">'Status: %s\r\n'</span> % status)</span><br><span class="line">             <span class="keyword">for</span> header <span class="keyword">in</span> response_headers:</span><br><span class="line">                 sys.stdout.write(<span class="string">'%s: %s\r\n'</span> % header)</span><br><span class="line">             sys.stdout.write(<span class="string">'\r\n'</span>)</span><br><span class="line">        sys.stdout.write(data)</span><br><span class="line">        sys.stdout.flush()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_response</span><span class="params">(status, response_headers, exc_info=None)</span>:</span></span><br><span class="line">        <span class="string">"""初始化response的逻辑"""</span></span><br><span class="line">        <span class="keyword">if</span> exc_info:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> headers_sent:</span><br><span class="line">                    <span class="keyword">raise</span> exc_info[<span class="number">0</span>], exc_info[<span class="number">1</span>], exc_info[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                exc_info = <span class="literal">None</span>     <span class="comment"># avoid dangling circular ref</span></span><br><span class="line">        <span class="keyword">elif</span> headers_set:</span><br><span class="line">            <span class="keyword">raise</span> AssertionError(<span class="string">"Headers already set!"</span>)</span><br><span class="line">        headers_set[:] = [status, response_headers]</span><br><span class="line">        <span class="keyword">return</span> write</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用应用层的WSGI接口，获取返回数据</span></span><br><span class="line">    result = application(environ, start_response)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> result:  <span class="comment"># 写回返回数据</span></span><br><span class="line">            <span class="keyword">if</span> data:    <span class="comment"># don't send headers until body appears</span></span><br><span class="line">                write(data)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headers_sent:</span><br><span class="line">            write(<span class="string">''</span>)   <span class="comment"># send headers now if body was empty</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> hasattr(result, <span class="string">'close'</span>):</span><br><span class="line">            result.close()</span><br></pre></td></tr></table></figure>
<p>通过<code>WSGI</code>，就可以实现<code>python-web-app</code>和<code>python-web-server</code>的分离，这样无论什么<code>python-web-app</code>，只要实现了<code>WSGI</code>接口标准，就能够无缝移植到其它支持<code>WSGI</code>的<code>python-web-server</code>上。</p>
<h2 id="ASGI"><a href="#ASGI" class="headerlink" title="ASGI"></a>ASGI</h2><p>自<code>python3</code>推出异步IO实现<code>asyncio</code>之后，<code>ASGI</code>也应运而生。<code>ASGI</code>的目标和<code>WSGI</code>相同，但也有一些改进点，一方面是支持<code>asyncio</code>的机制，另一方面也能够解决<code>WSGI</code>难以支持<code>WebSocket</code>之类长连接模式的问题。要深入了解<code>ASGI</code>，可以参考<span class="exturl" data-url="aHR0cHM6Ly9hc2dpLnJlYWR0aGVkb2NzLmlvL2VuL2xhdGVzdC9pbmRleC5odG1s" title="https://asgi.readthedocs.io/en/latest/index.html">这篇文档<i class="fa fa-external-link"></i></span>。</p>
<p>在<code>ASGI</code>标准下，<code>python-web-app</code>需要这样的接口实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(scope, receive, send)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    python-web-app应用层实现</span></span><br><span class="line"><span class="string">    :param scope: 由python-web-server提供，表示当前连接的环境信息</span></span><br><span class="line"><span class="string">    :param receive: 通过这个协程，可以收到由python-web-server发来的事件</span></span><br><span class="line"><span class="string">    :param send: 通过这个协程，可以写回事件给python-web-server，比如让python-web-server处理response</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    event = <span class="keyword">await</span> receive()</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">await</span> send(&#123;<span class="string">"type"</span>: <span class="string">"websocket.send"</span>, <span class="string">"text"</span>: <span class="string">"Hello world!"</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>不论是<code>receive</code>到的还是<code>send</code>出去的<code>event</code>，都会包含一个<code>type</code>字段表示这个<code>event</code>的类型，一般<code>type</code>会有：</p>
<ul>
<li><code>http.xxx</code>：<code>http</code>连接、请求、返回相关</li>
<li><code>websocket.xxx</code>：<code>websocket</code>连接、请求、返回相关</li>
<li><code>xxx.send/receive</code>：收发消息相关</li>
<li><code>lifespan.xxx</code>：<code>web</code>服务生命周期相关</li>
</ul>
<h2 id="ASGI案例之uvicorn-FastAPI"><a href="#ASGI案例之uvicorn-FastAPI" class="headerlink" title="ASGI案例之uvicorn+FastAPI"></a>ASGI案例之uvicorn+FastAPI</h2><p>为了更加直观感受<code>ASGI</code>的应用，本文也顺带以<code>uvicorn</code>加<code>FastAPI</code>的组合，通过源码实现来看<code>ASGI</code>是如何串联起<code>python-web-server</code>和<code>python-web-app</code>的。</p>
<p>在笔者封装的简易<code>http-web-app</code>框架<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9zdGFydC1mYXN0YXBp" title="https://github.com/utmhikari/start-fastapi">start-fastapi<i class="fa fa-external-link"></i></span>中，就支持了通过<code>uvicorn</code>启动<code>FastAPI</code>应用。其中，<code>main.py</code>的<code>uvicorn</code>实例会加载<code>app</code>模块下的<code>APP</code>这一<code>FastAPI</code>实例，启动<code>web-app</code>应用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ============ start-fastapi project ============</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    uvicorn.run(<span class="string">'app:APP'</span>, **cfg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># app/__init__.py</span></span><br><span class="line">APP = FastAPI(**FASTAPI_CFG)</span><br></pre></td></tr></table></figure>
<p>首先从<code>uvicorn.run</code>开始看起，其代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># uvicorn/main.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(app: typing.Union[ASGIApplication, str], **kwargs: typing.Any)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    config = Config(app, **kwargs)  <span class="comment"># uvicorn Config实例</span></span><br><span class="line">    server = Server(config=config)  <span class="comment"># uvicorn Server实例，包装Config实例</span></span><br><span class="line">    <span class="keyword">if</span> (config.reload <span class="keyword">or</span> config.workers &gt; <span class="number">1</span>) <span class="keyword">and</span> <span class="keyword">not</span> isinstance(app, str):</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> config.should_reload:  <span class="comment"># 用watchdog监测文件改动，实时重启，开发环境用</span></span><br><span class="line">        sock = config.bind_socket()</span><br><span class="line">        ChangeReload(config, target=server.run, sockets=[sock]).run()</span><br><span class="line">    <span class="keyword">elif</span> config.workers &gt; <span class="number">1</span>:  <span class="comment"># spawn多个worker，实现多进程的web服务</span></span><br><span class="line">        sock = config.bind_socket()</span><br><span class="line">        Multiprocess(config, target=server.run, sockets=[sock]).run()</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 默认standalone的web服务</span></span><br><span class="line">        server.run()</span><br></pre></td></tr></table></figure>
<p>默认会走<code>Server</code>实例的<code>run</code>方法，我们来看其中的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># uvicorn/server.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, sockets=None)</span>:</span></span><br><span class="line">        self.config.setup_event_loop()  <span class="comment"># 根据uvicorn配置，动态加载EventLoop的环境</span></span><br><span class="line">        loop = asyncio.get_event_loop()  <span class="comment"># EventLoop走asyncio的机制</span></span><br><span class="line">        loop.run_until_complete(self.serve(sockets=sockets))  <span class="comment"># 启动web服务</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">serve</span><span class="params">(self, sockets=None)</span>:</span></span><br><span class="line">        config = self.config</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> config.loaded:  <span class="comment"># 加载一次配置，即Config实例</span></span><br><span class="line">            config.load()</span><br><span class="line">        self.lifespan = config.lifespan_class(config)</span><br><span class="line">        self.install_signal_handlers()  <span class="comment"># 初始化os-signal处理逻辑</span></span><br><span class="line">        <span class="keyword">await</span> self.startup(sockets=sockets)  <span class="comment"># 初始化服务</span></span><br><span class="line">        <span class="keyword">if</span> self.should_exit:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">await</span> self.main_loop()  <span class="comment"># 开始主循环</span></span><br><span class="line">        <span class="keyword">await</span> self.shutdown(sockets=sockets)  <span class="comment"># 终止服务</span></span><br></pre></td></tr></table></figure>
<p>这里有两个重要步骤：</p>
<ul>
<li><code>config.load</code>：加载配置</li>
<li><code>startup</code>：启动服务器</li>
</ul>
<p>首先看配置加载，里面会将<code>app</code>实例进行初始化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># uvicorn/config.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">not</span> self.loaded</span><br><span class="line">        <span class="comment"># 上面略，会加载http_protocol_class/ws_protocol_class/lifespan_class</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># FastAPI走这个链路，加载到先前说的app.APP实例</span></span><br><span class="line">            self.loaded_app = import_from_string(self.app)  </span><br><span class="line">        <span class="keyword">except</span> ImportFromStringError <span class="keyword">as</span> exc:</span><br><span class="line">            logger.error(<span class="string">"Error loading ASGI app. %s"</span> % exc)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.interface == <span class="string">"auto"</span>:  <span class="comment"># FastAPI走的是asgi3</span></span><br><span class="line">            <span class="keyword">if</span> inspect.isclass(self.loaded_app):</span><br><span class="line">                use_asgi_3 = hasattr(self.loaded_app, <span class="string">"__await__"</span>)</span><br><span class="line">            <span class="keyword">elif</span> inspect.isfunction(self.loaded_app):</span><br><span class="line">                use_asgi_3 = asyncio.iscoroutinefunction(self.loaded_app)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                call = getattr(self.loaded_app, <span class="string">"__call__"</span>, <span class="literal">None</span>)</span><br><span class="line">                use_asgi_3 = asyncio.iscoroutinefunction(call)</span><br><span class="line">            self.interface = <span class="string">"asgi3"</span> <span class="keyword">if</span> use_asgi_3 <span class="keyword">else</span> <span class="string">"asgi2"</span></span><br><span class="line"></span><br><span class="line">        self.loaded = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fastapi/applications.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FastAPI</span><span class="params">(Starlette)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, scope: Scope, receive: Receive, send: Send)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.root_path:</span><br><span class="line">            scope[<span class="string">"root_path"</span>] = self.root_path</span><br><span class="line">        <span class="keyword">if</span> AsyncExitStack:</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> AsyncExitStack() <span class="keyword">as</span> stack:</span><br><span class="line">                scope[<span class="string">"fastapi_astack"</span>] = stack</span><br><span class="line">                <span class="keyword">await</span> super().__call__(scope, receive, send)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">await</span> super().__call__(scope, receive, send)  <span class="comment"># pragma: no cover</span></span><br></pre></td></tr></table></figure>
<p>可以看到<code>FastAPI</code>的<code>app</code>实现里，定义了<code>ASGI</code>，并且也在<code>uvicorn</code>的<code>config.load</code>里被识别到了。<code>FastAPI</code>继承了<code>Starlette</code>，而<code>Starlette</code>本身即是支持<code>ASGI</code>的<code>web</code>框架，为<code>python-web-app</code>提供了路由、中间件相关的应用级底层支持。<code>FastAPI</code>实际是对<code>Starlette</code>的包装，相关<code>handler</code>、<code>middleware</code>的注册也是给到<code>Starlette</code>框架里面的。针对<code>web-server</code>发来的请求，<code>FastAPI</code>在设置一些环境信息后，最终也是交由<code>Starlette</code>底层处理。</p>
<p>之后回到<code>uvicorn</code>，看一下<code>startup</code>的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># uvicorn/server.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">startup</span><span class="params">(self, sockets: list = None)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">await</span> self.lifespan.startup()</span><br><span class="line">        <span class="keyword">if</span> self.lifespan.should_exit:</span><br><span class="line">            self.should_exit = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        config = self.config</span><br><span class="line"></span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            reader: asyncio.StreamReader, writer: asyncio.StreamWriter</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span> -&gt; <span class="keyword">None</span>:</span>  <span class="comment"># http-handler</span></span><br><span class="line">            <span class="keyword">await</span> handle_http(</span><br><span class="line">                reader, writer, server_state=self.server_state, config=config</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里省略其他分支</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            server = <span class="keyword">await</span> asyncio.start_server(</span><br><span class="line">                handler,</span><br><span class="line">                host=config.host,</span><br><span class="line">                port=config.port,</span><br><span class="line">                ssl=config.ssl,</span><br><span class="line">                backlog=config.backlog,</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">except</span> OSError <span class="keyword">as</span> exc:</span><br><span class="line">            logger.error(exc)</span><br><span class="line">            <span class="keyword">await</span> self.lifespan.shutdown()</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 下略</span></span><br></pre></td></tr></table></figure>
<p><code>startup</code>分两步：</p>
<ul>
<li>初始化<code>lifespan</code></li>
<li>定义<code>http-handler</code>，通过<code>asyncio.start_server</code>启动<code>http-server</code></li>
</ul>
<p>在初始化<code>lifespan</code>过程中，<code>uvicorn</code>会发送<code>lifespan.startup</code>事件，这个事件就会被<code>FastAPI-app</code>的<code>ASGI</code>捕获到，最终层层往下，会走到<code>Starlette</code>的<code>Router</code>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># starlette/routing.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, scope: Scope, receive: Receive, send: Send)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> scope[<span class="string">"type"</span>] <span class="keyword">in</span> (<span class="string">"http"</span>, <span class="string">"websocket"</span>, <span class="string">"lifespan"</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"router"</span> <span class="keyword">not</span> <span class="keyword">in</span> scope:</span><br><span class="line">            scope[<span class="string">"router"</span>] = self</span><br><span class="line">        <span class="keyword">if</span> scope[<span class="string">"type"</span>] == <span class="string">"lifespan"</span>:</span><br><span class="line">            <span class="keyword">await</span> self.lifespan(scope, receive, send)  <span class="comment"># 走到这里</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 下略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">lifespan</span><span class="params">(self, scope: Scope, receive: Receive, send: Send)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        first = <span class="literal">True</span></span><br><span class="line">        app = scope.get(<span class="string">"app"</span>)</span><br><span class="line">        <span class="keyword">await</span> receive()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> inspect.isasyncgenfunction(self.lifespan_context):</span><br><span class="line">                <span class="keyword">async</span> <span class="keyword">for</span> item <span class="keyword">in</span> self.lifespan_context(app):  <span class="comment"># 调用lifespan-event</span></span><br><span class="line">                    first = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">await</span> send(&#123;<span class="string">"type"</span>: <span class="string">"lifespan.startup.complete"</span>&#125;)</span><br><span class="line">                    <span class="keyword">await</span> receive()</span><br><span class="line">            <span class="comment"># 下略</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>当<code>Startlette</code>的<code>Router</code>检测到<code>lifespan</code>事件时，就会走到<code>lifespan</code>逻辑，其中会看<code>lifespan</code>的当前阶段是否有对应的<code>hook</code>函数，有的话就执行。当前阶段是<code>lifespan.startup</code>，因此如果我们在<code>FastAPI</code>中定义了这个协程，就可以在<code>startup</code>阶段执行到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># register startup event</span></span><br><span class="line"><span class="meta">@APP.on_event('startup')</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">start_app</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><code>lifespan.startup</code>之后，就定义<code>http-handler</code>并绑到<code>listen-server</code>上。<code>http-handler</code>会解析请求数据，然后调用<code>app</code>的<code>ASGI</code>接口处理请求，大致是这样的链路：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H11Protocol</span><span class="params">(asyncio.Protocol)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_events</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> event_type <span class="keyword">is</span> h11.Request:</span><br><span class="line">                task = self.loop.create_task(self.cycle.run_asgi(app))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestResponseCycle</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run_asgi</span><span class="params">(self, app)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = <span class="keyword">await</span> app(self.scope, self.receive, self.send)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>好比我们<code>GET</code>健康检查接口<code>/api/v1/core/health</code>，那么最终被<code>FastAPI-app</code>捕获到的请求数据里，<code>scope</code>长这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scope = &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"http"</span>,</span><br><span class="line">    <span class="string">"method"</span>: <span class="string">"GET"</span>,</span><br><span class="line">    <span class="string">"root_path"</span>: <span class="string">""</span></span><br><span class="line">    <span class="string">"path"</span>: <span class="string">"/api/v1/core/health"</span>,</span><br><span class="line">    <span class="string">"query_string"</span>: <span class="string">b""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据这些信息，层层往下，就会又走到<code>Starlette</code>的路由逻辑：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># starlette/routing.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, scope: Scope, receive: Receive, send: Send)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># 上略</span></span><br><span class="line">        <span class="comment"># 有全部匹配的路由就直接处理</span></span><br><span class="line">        <span class="keyword">for</span> route <span class="keyword">in</span> self.routes:</span><br><span class="line">            match, child_scope = route.matches(scope)</span><br><span class="line">            <span class="keyword">if</span> match == Match.FULL:</span><br><span class="line">                scope.update(child_scope)</span><br><span class="line">                <span class="keyword">await</span> route.handle(scope, receive, send)  <span class="comment"># 路由实例来handle</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">elif</span> match == Match.PARTIAL <span class="keyword">and</span> partial <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                partial = route</span><br><span class="line">                partial_scope = child_scope</span><br><span class="line">        <span class="comment"># 匹配部分匹配的路由</span></span><br><span class="line">        <span class="keyword">if</span> partial <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            scope.update(partial_scope)</span><br><span class="line">            <span class="keyword">await</span> partial.handle(scope, receive, send)  </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 重定向</span></span><br><span class="line">        <span class="keyword">if</span> scope[<span class="string">"type"</span>] == <span class="string">"http"</span> <span class="keyword">and</span> self.redirect_slashes <span class="keyword">and</span> scope[<span class="string">"path"</span>] != <span class="string">"/"</span>:</span><br><span class="line">            redirect_scope = dict(scope)</span><br><span class="line">            <span class="keyword">if</span> scope[<span class="string">"path"</span>].endswith(<span class="string">"/"</span>):</span><br><span class="line">                redirect_scope[<span class="string">"path"</span>] = redirect_scope[<span class="string">"path"</span>].rstrip(<span class="string">"/"</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                redirect_scope[<span class="string">"path"</span>] = redirect_scope[<span class="string">"path"</span>] + <span class="string">"/"</span></span><br><span class="line">            <span class="keyword">for</span> route <span class="keyword">in</span> self.routes:</span><br><span class="line">                match, child_scope = route.matches(redirect_scope)</span><br><span class="line">                <span class="keyword">if</span> match != Match.NONE:</span><br><span class="line">                    redirect_url = URL(scope=redirect_scope)</span><br><span class="line">                    response = RedirectResponse(url=str(redirect_url))</span><br><span class="line">                    <span class="keyword">await</span> response(scope, receive, send)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 默认逻辑</span></span><br><span class="line">        <span class="keyword">await</span> self.default(scope, receive, send)</span><br></pre></td></tr></table></figure>
<p>由于我们在<code>start-fastapi</code>项目中，通过<code>APIRouter</code>定义了这个路由的<code>handler</code>，注册到了<code>Starlette</code>中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ============ start-fastapi ============</span></span><br><span class="line"><span class="comment"># core/handler/base.py</span></span><br><span class="line">ROUTER = APIRouter()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ROUTER.get('/api/v1/core/health')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">health_check</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Resp.ok(message=<span class="string">'ok'</span>)</span><br></pre></td></tr></table></figure>
<p>那么<code>/api/v1/core/health</code>就会被完整匹配，走到对应路由实例的<code>handle</code>步骤：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># starlette/routing.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route</span><span class="params">(BaseRoute)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self, scope: Scope, receive: Receive, send: Send)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.methods <span class="keyword">and</span> scope[<span class="string">"method"</span>] <span class="keyword">not</span> <span class="keyword">in</span> self.methods:  <span class="comment"># 没有对应的method</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">"app"</span> <span class="keyword">in</span> scope:</span><br><span class="line">                <span class="keyword">raise</span> HTTPException(status_code=<span class="number">405</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                response = PlainTextResponse(<span class="string">"Method Not Allowed"</span>, status_code=<span class="number">405</span>)</span><br><span class="line">            <span class="keyword">await</span> response(scope, receive, send)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 有method，直接处理</span></span><br><span class="line">            <span class="keyword">await</span> self.app(scope, receive, send)</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_response</span><span class="params">(func: typing.Callable)</span> -&gt; ASGIApp:</span></span><br><span class="line">    is_coroutine = iscoroutinefunction_or_partial(func)</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">app</span><span class="params">(scope: Scope, receive: Receive, send: Send)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        request = Request(scope, receive=receive, send=send)</span><br><span class="line">        <span class="keyword">if</span> is_coroutine:</span><br><span class="line">            response = <span class="keyword">await</span> func(request)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            response = <span class="keyword">await</span> run_in_threadpool(func, request)</span><br><span class="line">        <span class="keyword">await</span> response(scope, receive, send)</span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># fastapi/routing.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_request_handler</span><span class="params">()</span> -&gt; Callable[[Request], Coroutine[Any, Any, Response]]:</span></span><br><span class="line">    raw_response = <span class="keyword">await</span> run_endpoint_function(</span><br><span class="line">        dependant=dependant, values=values, is_coroutine=is_coroutine</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run_endpoint_function</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    *, dependant: Dependant, values: Dict[str, Any], is_coroutine: bool</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> -&gt; Any:</span></span><br><span class="line">    <span class="keyword">assert</span> dependant.call <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">"dependant.call must be a function"</span></span><br><span class="line">    <span class="keyword">if</span> is_coroutine:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> dependant.call(**values)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> run_in_threadpool(dependant.call, **values)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run_in_threadpool</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    func: typing.Callable[..., T], *args: typing.Any, **kwargs: typing.Any</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> -&gt; T:</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="keyword">if</span> contextvars <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># pragma: no cover</span></span><br><span class="line">        <span class="comment"># Ensure we run in the same context</span></span><br><span class="line">        child = functools.partial(func, *args, **kwargs)</span><br><span class="line">        context = contextvars.copy_context()</span><br><span class="line">        func = context.run</span><br><span class="line">        args = (child,)</span><br><span class="line">    <span class="keyword">elif</span> kwargs:  <span class="comment"># pragma: no cover</span></span><br><span class="line">        func = functools.partial(func, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> loop.run_in_executor(<span class="literal">None</span>, func, *args)</span><br></pre></td></tr></table></figure>
<p>由于我们对健康检查路由定义了<code>GET</code>方法，那么这个路由就支持处理。最终来到了<code>FastAPI</code>的<code>run_endpoint_function</code>方法，调用我们定义的<code>Controller</code>。由于我们是直接<code>def health_check()</code>，因此会走到<code>loop.run_in_executor</code>线程池方法，去执行<code>Controller</code>，然后返回结果。否则如果是<code>async def</code>定义的<code>Controller</code>的话，就直接<code>await</code>。</p>
<p>所以整个请求返回的链路就完成了，而且我们也会看到，针对需要耗时耗<code>CPU</code>的请求，尽量不要用<code>async def</code>定义<code>FastAPI</code>的<code>Controller</code>，否则会有阻塞整个<code>asyncio</code>事件循环的风险，而用线程池处理就可以规避这种情况。</p>
]]></content>
      <categories>
        <category>Python随笔</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>fastapi</tag>
        <tag>WSGI</tag>
        <tag>ASGI</tag>
        <tag>uvicorn</tag>
      </tags>
  </entry>
  <entry>
    <title>【Game Of AutoTest】2、游戏自动化测试的技术选型</title>
    <url>/2022/08/13/gameofautotest/ii/</url>
    <content><![CDATA[<p>要做游戏自动化测试，首先需要了解游戏自动化技术。因此，本文详细讲解下游戏自动化测试领域可能用到的一些技术以及对应的场景，为自动化测试落地的技术选型提供参考。</p>
<p>游戏自动化测试的测试对象是游戏本身。对于游戏这个概念，可以有以下几种：</p>
<ul>
<li>客户端：我们实际玩到的游戏本体，比如说PC程序，手机App，Web-App。</li>
<li>服务器：在多人网络游戏中，用以模拟游戏世界的本体。</li>
<li>编辑器：包含未烘焙到OS平台的游戏程序以及资源。</li>
</ul>
<p>我们在技术层面上所要做到的，就是通过某些方式访问这些程序运行环境产生的内容，改变游戏呈现以及玩家行为，操作玩家或游戏程序本身，达到我们的测试目的。在笔者的工作经验当中，主要做的是<code>UE</code>安卓客户端的自动化，应用场景主要在业务功能测试方面，因此本文会对客户端自动化做稍微详尽的解析。其他自动化的方案和叙述，如果其中描述有所纰漏，恳请指正。</p>
<h2 id="客户端自动化"><a href="#客户端自动化" class="headerlink" title="客户端自动化"></a>客户端自动化</h2><p>针对游戏客户端的自动化，在游戏测试里是最为广泛应用的，不仅是因为客户端是一个游戏必须有的成分，而更加因为我们在手工测试游戏的时候，实际是拿着客户端来测的。因此，客户端自动化会最贴合游戏功能测试的需求。</p>
<p>要实现客户端自动化，有以下的方法：</p>
<a id="more"></a>
<ul>
<li>脚本自动化：通过游戏脚本代码驱动游戏运行。<ul>
<li>适用于业务逻辑主要采用可热更的脚本语言（如<code>lua</code>、<code>js</code>）编写的游戏。</li>
<li>游戏对外暴露一个接口，对这个接口发送脚本代码，游戏内部即可自动执行这段脚本代码。</li>
</ul>
</li>
<li>UI自动化：通过UI操作驱动游戏运行，分为UI查询、UI操作两部分。<ul>
<li>UI查询可以通过图像识别/OCR识别推断控件所在坐标，也可以通过从游戏运行环境中导出UI控件树，获取每个控件的属性和在视口里的坐标数据。<ul>
<li>由控件树定位控件的方案，相较于图像识别的方案，稳定性会更高，但也需要一定的定位策略。通常来讲，控件之间的层级关系不会有太多的变化，而控件的名称会微调，因此可以通过关键字+层级关系的条件去精准筛选控件。</li>
<li>图像识别方案不稳定在于几点：图像识别技术本身的不确定性，以及UI风格迭代导致图像识别的基线数据失效。</li>
</ul>
</li>
<li>UI操作可以通过<code>adb</code>之类的方式直接模拟屏幕操作；也可以在游戏中运行一个UI自动化模块，测试人员可以向这个模块请求对某个UI发起点击/按下/释放的操作，而后这个模块内部执行UI实例<code>OnClick/OnPress/OnRelease</code>的委托。</li>
</ul>
</li>
<li>指令自动化：在游戏逻辑中预置一些玩家操作接口以及参数，通过调用指令实现玩家操控。<ul>
<li>游戏内部暴露给外部指令调用接口，外部发送指令和参数，然后游戏内部做<code>dispatch</code>，去执行对应封装好的指令。</li>
<li>对于手工测试需求而言是标配，对于自动化测试需求而言，只需要额外支持外部程序调用这些内容。</li>
</ul>
</li>
</ul>
<p>客户端自动化的开源实现也有不少，其中有两个比较广泛应用：<code>Airtest</code>和<code>GAutomator</code>。</p>
<ul>
<li><code>Airtest</code>：一个完整的游戏自动化测试方案，参考<span class="exturl" data-url="aHR0cHM6Ly9haXJ0ZXN0LmRvYy5pby5uZXRlYXNlLmNvbS8=" title="https://airtest.doc.io.netease.com/">这个文档<i class="fa fa-external-link"></i></span><ul>
<li>主要实现的是面向不同平台应用的UI自动化，并且自带IDE。</li>
<li>底层是<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FpcnRlc3RQcm9qZWN0L1BvY28tU0RL" title="https://github.com/AirtestProject/Poco-SDK">PocoSDK<i class="fa fa-external-link"></i></span>，支持<code>Android/iOS</code>的<code>Native</code>控件，也支持<code>Unity/UE/Cocos</code>应用。</li>
</ul>
</li>
<li><code>GAutomator</code>：针对<code>Unity</code>、<code>UE</code>的UI自动化测试框架，源码在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RlbmNlbnQvR0F1dG9tYXRvcg==" title="https://github.com/Tencent/GAutomator">这里<i class="fa fa-external-link"></i></span><ul>
<li>相对<code>Airtest</code>比较轻量级，适合集成+二次开发</li>
</ul>
</li>
</ul>
<p>一般来讲，开源的自动化方案基本上是UI自动化相关，而脚本自动化和指令自动化，则需要依据不同游戏项目的实现去自定义相关逻辑。</p>
<p>客户端自动化适用于以下的场景：</p>
<ul>
<li>功能测试：代替人工测试工作。<ul>
<li>玩法冒烟测试：适用于各个玩法的基础功能冒烟。<ul>
<li>可以应用于强UI的玩法，比如商业化、活动、社交、装备一类。</li>
<li>可以应用于流程类的玩法，比如副本、任务一类。</li>
</ul>
</li>
<li>功能遍历测试：适用于操作不复杂但重复量较大，繁琐耗时的功能测试任务。<ul>
<li>依据不同玩法的测试点特性而定，每个玩法可能都有测试点是遍历性质的。</li>
<li>可以应用于地图/大世界相关的跑测，比如对场景物件、寻路、空气墙、切线的效果检查。</li>
<li>可以应用于玩家状态机、<code>Buff</code>或是技能效果的遍历测试。</li>
</ul>
</li>
</ul>
</li>
<li>专项测试：自动执行整个专项测试流程，或是作为流程的一部分，提供对测试有用的信息。<ul>
<li>客户端性能测试：跑测游戏客户端，并在其中收集游戏以及设备的性能数据，用于做性能分析。</li>
<li>客户端适配测试：跑测不同机型的客户端，覆盖一些简单的场景跟操作，看性能或者表现上是否一致。</li>
<li>UI专项测试：这里指UI状态互斥、UI层级关系这一类非强业务相关的专项测试点。</li>
<li>玩法业务专项：跑测游戏客户端，收集特定游戏玩法数据，用于玩家状态检查、玩法效果评估、数据一致性检查等测试点。需要按各个玩法的特性去自定义自动跑测逻辑。</li>
<li>玩法环境构造：调用多台客户端机器，自动游玩一个玩法，模拟多人场景。<ul>
<li>用真实客户端构造场景，通常会消耗许多线上机器资源。因此在资源紧缺或是线上运行环境不稳定的情况下，不建议采取此方案。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>不论是功能还是专项测试场景，在自动化行为的实现上，脚本、UI、指令三种自动化方式都可以相互结合。这是因为，从游戏测试用例过程的角度来看，每一个步骤其实都是一个玩家操作，而玩家操作的实现，可以是发一段脚本，也可以是点某个UI，更可以是执行一个指令。</p>
<p>相对于其它自动化方式，脚本自动化的实现方案是最优先的，这是因为能够支持热执行客户端脚本的话，理论上可以操纵整个客户端的运行，从而能够满足更多自动化行为的需求。因此如果有条件，比如说测试侧有项目的源代码权限，那么自动化行为的实现，就优先采用脚本编写的方案，而对于一些需要复杂脚本实现的行为，才用UI操作代替。如果没有源码条件，也可以考虑在客户端源码里抽出一个单独的<code>project</code>，包装项目代码<code>API</code>类型信息以及一系列自动化指令，做成一个测试侧也可以单独维护的自动化底层模块。</p>
<h2 id="服务器自动化"><a href="#服务器自动化" class="headerlink" title="服务器自动化"></a>服务器自动化</h2><p>针对服务器的自动化测试是非常关键的一部分。比如我们经常提到的服务器压测，其实本质上是一种自动化驱动的逻辑。从整个游戏产品的质量保证而言，服务器自动化同样是不可或缺的。</p>
<p>要实现服务器自动化，一般是两种方法：</p>
<ul>
<li>协议交互：通过<code>C/S</code>协议交互的方式驱动游戏逻辑进行<ul>
<li>一般是通过一个机器人客户端连到服务器，作为一个玩家的身份发送登录协议登入游戏，然后再发送其他<code>C/S</code>协议，从而驱动玩家做某些行为，或者是达到某些状态。</li>
</ul>
</li>
<li>内部指令调用：服务器预编写一些测试接口，通过调用这些接口驱动服务器逻辑。<ul>
<li>可以是通过机器人客户端连到服务器，发送登录协议登入游戏，但之后不直接通过<code>C/S</code>协议，而是通过某些外部调用，或者是这个机器人发送某个特定的指令，驱动服务器逻辑，从而让机器人参与到某些测试活动当中。</li>
</ul>
</li>
</ul>
<p>具体的技术实现，实际得依据服务器本身的技术栈以及协议交互的技术栈而定，并没有一套确定的方案。</p>
<p>服务器自动化适用于以下场景：</p>
<ul>
<li>服务器代码单元测试<ul>
<li>用以在程序层面测试服务器的基础代码逻辑，通常会配合<code>CI</code>流水线使用。</li>
<li>也可以配合代码覆盖率测试工具一起使用，用以观测测试用例/代码实现的完整性。</li>
<li>实现上，可以调用某个接口指令，一次性批量或有序地执行服务器业务模块的单元测试代码。</li>
</ul>
</li>
<li>压力测试<ul>
<li>驱动多个机器人登录服务器，模拟玩家操作。</li>
<li>需配合服务器性能监控工具，观测服务链路性能表征，分析性能瓶颈。</li>
</ul>
</li>
<li>功能测试环境构造<ul>
<li>实现原理和压力测试类似，通常会涉及多个机器人玩家在游戏中漫游。</li>
<li>相比于用多个真实客户端设备构造多人玩法环境的方法，通过机器人构造更加方便，不浪费设备资源。</li>
<li>可以应用于匹配、登录、世界<code>Boss</code>等涉及海量玩家参与的玩法模块。</li>
</ul>
</li>
<li>服务器协议安全测试<ul>
<li>同样可以通过机器人的方式驱动，但测试策略需参考协议测试需求。</li>
<li>通常的测试目标是，绕过客户端做游戏机制限定之外的请求，预期无法通过服务器业务逻辑的校验。</li>
</ul>
</li>
</ul>
<h2 id="编辑器自动化"><a href="#编辑器自动化" class="headerlink" title="编辑器自动化"></a>编辑器自动化</h2><p>编辑器代表着游戏的开发环境，其中的资源会直接影响到游戏的构建结果，因此针对编辑器及资产的自动化测试也是重要的一部分。以<code>UE</code>为例，其中内置了许多自动化测试的机制：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vNS4wL3poLUNOL3NjcmlwdGluZy10aGUtdW5yZWFsLWVkaXRvci11c2luZy1weXRob24v" title="https://docs.unrealengine.com/5.0/zh-CN/scripting-the-unreal-editor-using-python/">Python Scriping<i class="fa fa-external-link"></i></span><ul>
<li>通过<code>python</code>脚本驱动编辑器和运行的手段，可以作为编辑器开发环境的提效工具，也可以对编辑器资产做测试检查</li>
</ul>
</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vNC4yNy96aC1DTi9UZXN0aW5nQW5kT3B0aW1pemF0aW9uL0F1dG9tYXRpb24v" title="https://docs.unrealengine.com/4.27/zh-CN/TestingAndOptimization/Automation/">Automation System<i class="fa fa-external-link"></i></span><ul>
<li>支持对编辑器资产/引擎功能的测试，或是在关卡里运行游戏功能测试用例</li>
<li>也可以支持在多个平台同时运行<code>UE</code>游戏会话，执行简单的测试内容，是用<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vNC4yNy96aC1DTi9UZXN0aW5nQW5kT3B0aW1pemF0aW9uL0F1dG9tYXRpb24vR2F1bnRsZXQv" title="https://docs.unrealengine.com/4.27/zh-CN/TestingAndOptimization/Automation/Gauntlet/">Gauntlet<i class="fa fa-external-link"></i></span>框架实现的。</li>
</ul>
</li>
</ul>
<p>编辑器自动化适用于以下的场景：</p>
<ul>
<li>编辑器与开发者工具的功能测试</li>
<li>引擎核心功能测试</li>
<li>游戏资产静态测试<ul>
<li>测试对象可以是美术、UI甚至是特定玩法的资产，主要测试的场景是对资产配置的合规性和可用性检查。</li>
<li>许多游戏客户端本体和策划<code>excel</code>配置可能是分离的，由于在本文范畴中，<code>excel</code>配置不直接影响游戏构建结果，因此关于<code>excel</code>配置的合规性检查暂不纳入本文叙述范围。</li>
</ul>
</li>
<li>关卡配置检查<ul>
<li>打开特定关卡/子关卡，静态检查关卡内场景物件配置的合规性。</li>
<li>启动<code>PIE</code>，在游玩期间进行功能测试。<ul>
<li>如果偏重于系统玩法级的功能测试，并且客户端构建频繁交付，实际用客户端自动化方案会更贴合产品测试的需求。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="自动化周边技术"><a href="#自动化周边技术" class="headerlink" title="自动化周边技术"></a>自动化周边技术</h2><p>客户端/服务器/编辑器自动化技术，是游戏自动化实现的最底层逻辑。在此基础上，还可以加码一些周边技术包装，从而优化自动化测试的效果。</p>
<h3 id="录制回放"><a href="#录制回放" class="headerlink" title="录制回放"></a>录制回放</h3><p>通常在微服务测试中，会通过录制的方式记录真实访问的流量，作为测试用例，然后在测试环境随时回放，从而起到观测真实流量反映的作用。</p>
<p>在游戏自动化中，也存在录制回放的操作，服务器跟客户端都能做。以客户端为例，录制回放主要是在UI测试中应用，技术实现上大致有两种方法：</p>
<ul>
<li>图像识别<ul>
<li>录制：根据屏幕操作坐标，记录操作时间，以及坐标附近的特征图。</li>
<li>回放：根据特征图，识别特征图在屏幕中的位置，再根据操作时间，有序地模拟屏幕操作。</li>
</ul>
</li>
<li>输入事件<ul>
<li>录制：引擎底层记录玩家操作的输入事件，以及操作时间。</li>
<li>回放：根据输入事件，推断操作控件与操作方式，再根据操作时间，有序地调用控件对应的操作。</li>
</ul>
</li>
</ul>
<p>客户端UI测试的录制回放技术，可以用到的场景有：</p>
<ul>
<li>UI功能测试：测试游戏UI的可用性，监控不同版本UI呈现的变化。</li>
<li>UI耗时测试：测试特定玩家UI操作下，界面加载的性能损耗。</li>
<li>录制的产物，可用于快速生成UI自动化测试用例代码。</li>
</ul>
<h3 id="行为树"><a href="#行为树" class="headerlink" title="行为树"></a>行为树</h3><p>行为树是AI的一种实现，主要通过行为抽象+流程控制的方式，实现AI机器人的自动决策。</p>
<p>在自动化测试领域，通常会提到AI自动化，而行为树就是AI自动化的一种典型案例。但这里需要强调的是，AI驱动并不是最底层的自动化技术，以运行在游戏客户端的行为树为例，每个行为本身的实现，还是得走UI自动化、脚本自动化的套路。AI驱动的，只是业务逻辑，不是游戏本身。</p>
<p>行为树决策的逻辑是人为制定的，因此引入行为树，会很适合一些操作复杂，耗时长，但比较有规律的测试场景，让这些场景实现自动化的成本大大降低。比如说：</p>
<ul>
<li>PVE副本、任务：这类型的玩法通常分为很多环，每一环需要根据副本阶段指引信息、任务类型信息等采取行为决策，因此比较适合用行为树表征。</li>
<li>PVP、竞技玩法：这类型的玩法通常有特定的游玩规则/目标，因此也适合行为树去做决策。</li>
</ul>
<p>针对自动化测试本身而言，行为树也可以帮助我们快速确定基础的自动化逻辑结构，生成基础代码，提高自动化研发效率。但也需要注意，行为树不能作为代码编程的完整代替方案，否则一旦行为复杂度较高，行为树本身就难以维护，详情可以参考<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjIvMDQvMDMvdGVzdGxpZmUvYnRyZWVfYXV0b3Rlc3RfdGFsay8=" title="https://utmhikari.top/2022/04/03/testlife/btree_autotest_talk/">这篇文章<i class="fa fa-external-link"></i></span>。</p>
<p>行为树方案，建议是配套可视化编程工具提效开发和调试工作，否则研发效率并不一定优于纯粹的代码编写。</p>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>机器学习是一种更为复杂的AI实现案例，有几个特点：</p>
<ul>
<li>有一定的目标，实质是通过不断的运算，来达到特定的目标，通过自学习的方式形成更多的经验。</li>
<li>决策的过程是黑盒的，经验论，无法追溯其中的思维链路。</li>
<li>学习方式上有监督（人工数据介入）或是无监督均可，但无论如何都需要处理大量的数据作为决策依据。</li>
</ul>
<p>因此机器学习的方案，可以考虑在几个自动化测试的场景应用：</p>
<ul>
<li>行为复杂度较高，不容易被行为树表征的的PVP、竞技玩法。<ul>
<li>训练竞技AI，收集数据，用以评价玩法数值配置的合理性，或是做漫游探索测试，尝试发现问题。</li>
</ul>
</li>
<li>需要识别客户端显现异常图像的场景。<ul>
<li>结合客户端自动化方案执行，可用于监测捏脸/时装等丰富美术场景的显示异常，也可以用于场景穿模、适配闪屏等场景的监控。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Game Of AutoTest</category>
      </categories>
      <tags>
        <tag>客户端自动化</tag>
        <tag>服务器自动化</tag>
        <tag>编辑器自动化</tag>
        <tag>录制回放</tag>
        <tag>AI自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>【Game Of AutoTest】1、再度启程，重识游戏自动化测试</title>
    <url>/2022/08/02/gameofautotest/i/</url>
    <content><![CDATA[<p>2022年的8月，结束了很长一段时间的犹豫，笔者决定开启新的文章系列：《Game Of AutoTest》，向外界公开自己近两年来在游戏自动化测试方面所沉淀的工作经验，以及许多关于自动化测试本身的思考跟想法。在先前的<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wL2NhdGVnb3JpZXMvJUU2JUI1JThCJUU4JUFGJTk1JUU0JUJBJUJBJUU3JTk0JTlGLw==" title="https://utmhikari.top/categories/%E6%B5%8B%E8%AF%95%E4%BA%BA%E7%94%9F/">测试人生<i class="fa fa-external-link"></i></span>栏目中，曾经分享过许多关于游戏自动化测试的技术，但并没有一个比较系统化的输出。因此借这个机会，笔者也决定好好分享一下，从一个更加纯粹的技术人的角度，对于游戏自动化测试这一细分领域的理解。</p>
<p>自动化测试本身已经不是一个新鲜的名词，不论是游戏还是传统互联网行业，我们都能够见到自动化测试落地的身影。但是，自动化测试基础技术到底需要往怎样的方向搭建，业务应用需要覆盖哪些场景，这些话题其实很少被讨论，并且实际沉淀下来的知识分享和业务产出，也不尽然特别引人注目。尤其在游戏测试领域，自动化测试如何被应用到实际测试工作当中，相关的沉淀是少之又少，可以算是一片待开垦的荒地。</p>
<p>游戏自动化测试——这个名词本身都没有一个确切的定义。有些人认为，只有像自动驱动客户端玩游戏，测试场景物件是否正常交互，这种能够实际测到和测试用例相关的内容，才算是自动化测试；也有些人认为，像一些纯粹收集性能数据的场景，比如驱动玩家在地图里跑图，收集前后台数据，也算是自动化测试。这说明了，只要是用了程序化的手段，去完成游戏测试的整个或一部分的流程，那么就有可能被定义为一种游戏自动化测试的方案。但遗憾的是，正因为如此，很多测试工作者为了让自己的工作有技术含量，都会尝试沾自动化测试技术的光，为了技术而技术，用一些现成的自动化工具去做了个demo规模的东西，然后很阿里味地包装成富有技术含量的测试工作，但实际上相对于原来反倒增加了学习、维护、执行成本，是毫无价值的负优化。其中原因，归根到底，还是自动化测试这个工作被很多人小看了。如果你是个测试工作者，但业务经验、技术能力以及良师指导三者都很缺乏，并且业务环境上没啥落地场景，组织氛围也没啥支持的话，要做好自动化测试，那是非常困难的。</p>
<p>因此，我们有必要去重新认识游戏自动化测试这个概念。有几个准则：</p>
<a id="more"></a>
<ul>
<li>自动化——是技术层面不可或缺的关键点，且相对于人工能显著提升工作效率。</li>
<li>测试——是最终的目标，整个测试流程里自动化过程可能只是其中的一部分，但这个流程不论如何最终都需要闭环，输出测试结论。</li>
<li>游戏——是我们做自动化测试的对象。在这一范畴上，我们可以将游戏测试的自动化和日常工作提效的自动化区分开。</li>
</ul>
<p>所以，要做到游戏自动化测试，落到实处，你需要：</p>
<ul>
<li>熟悉游戏自动化的各种技术方案。</li>
<li>熟悉你的测试内容，并且从整个测试过程的角度挖掘可以通过自动化技术提升效率的优化点。</li>
<li>评估你在技术实现上的工作成本，结合先前挖掘出来优化点实际的优化程度，来决定是否真正有必要去做自动化技术开发。技术实现的成本，可以参考几个维度：自动化技术的学习、自动化研发环境/基础框架的搭建、自动化用例的开发/发布、自动化用例的维护/迭代。</li>
<li>做好问题分析与反馈机制。比如，你的自动化用例报错了，首先要界定是自动化用例的问题，还是游戏本身的bug；以及，发现了bug之后，应该怎样做反馈，怎样和已有的业务联系起来，实现流程闭环。这样让自动化技术的价值得到体现。</li>
<li>时刻总结，不断迭代、优化你的自动化方案。不论是从时间效率提升角度，还是测试覆盖面/问题发现角度，都可以尝试扩充你的自动化覆盖场景。这样，才能够把自动化测试做深做大。</li>
</ul>
<p>接下来，开始启程……</p>
]]></content>
      <categories>
        <category>Game Of AutoTest</category>
      </categories>
      <tags>
        <tag>游戏自动化</tag>
        <tag>自动化测试</tag>
        <tag>游戏测试</tag>
        <tag>测试开发</tag>
        <tag>专项测试</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python随笔】python多线程什么情况下可以并行？什么情况下不能？</title>
    <url>/2022/07/03/pythonnotes/multithread_parallel/</url>
    <content><![CDATA[<p>在<code>python</code>面试里，多线程是避不开的话题，其中一个经典问题就是，多线程<code>threading.Thread</code>是不是并行运行。这个问题的答案，说是也不对，说不是也不对，得分情况讨论。本文就带领大家，分析并回答这个问题。</p>
<p>我们用一段代码来做实验：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_lock = Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> _lock:</span><br><span class="line">        print(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_io_task</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 单个task执行约3s</span></span><br><span class="line">    subprocess.run([<span class="string">'ping'</span>, <span class="string">'127.0.0.1'</span>], capture_output=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_code_task</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 单个task执行约0.8s</span></span><br><span class="line">    tms = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> tms &lt; <span class="number">50000000</span>:</span><br><span class="line">        tms += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testfunc</span><span class="params">(num)</span>:</span></span><br><span class="line">    st = datetime.datetime.now()</span><br><span class="line">    <span class="comment"># _io_task()</span></span><br><span class="line">    _code_task()</span><br><span class="line">    et = datetime.datetime.now()</span><br><span class="line">    dt = et - st</span><br><span class="line">    log(<span class="string">f'<span class="subst">&#123;num&#125;</span> -&gt; <span class="subst">&#123;dt.total_seconds() * <span class="number">1000</span>&#125;</span>ms'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    num_threads = <span class="number">5</span></span><br><span class="line">    threads = []</span><br><span class="line">    st = datetime.datetime.now()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_threads):</span><br><span class="line">        t = Thread(target=testfunc, args=(i,))</span><br><span class="line">        threads.append(t)</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.start()</span><br><span class="line">    time.sleep(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    et = datetime.datetime.now()</span><br><span class="line">    dt = et - st</span><br><span class="line">    log(<span class="string">f'overall <span class="subst">&#123;dt.total_seconds() * <span class="number">1000</span>&#125;</span>ms'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>这段代码意思很容易懂，起了5个<code>testfunc</code>为<code>target</code>的线程，然后主线程等待这些线程全部执行结束<code>join</code>，最后统计每个线程的开始结束时间间隔和开始结束时间间隔。</p>
<p>执行了之后我们会发现如果<code>test_func</code>里设置的是<code>code_task</code>的话，那么总时间相当于一个线程执行时间的<code>num_threads</code>倍，这个可以通过设置<code>num_threads</code>为1以及更高的数字来实验到，而更为蹊跷的是，每个线程执行的时间间隔和总的执行时间间隔几乎相差无几。可以看下面的输出例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># num_threads = 1</span><br><span class="line">0 -&gt; 873.087ms</span><br><span class="line">overall 874.0830000000001ms</span><br><span class="line"></span><br><span class="line"># num_threads = 5</span><br><span class="line">0 -&gt; 4278.944ms</span><br><span class="line">1 -&gt; 4412.494ms</span><br><span class="line">2 -&gt; 4488.241ms</span><br><span class="line">4 -&gt; 4243.062ms</span><br><span class="line">3 -&gt; 4882.43ms</span><br><span class="line">overall 5156.513ms</span><br></pre></td></tr></table></figure>
<p>然后，如果<code>test_func</code>里设置的是<code>io_task</code>的话，<code>num_threads</code>就算设置三五个，用的时间基本都一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># num_threads = 3</span><br><span class="line">0 -&gt; 3061.7909999999997ms</span><br><span class="line">2 -&gt; 3061.7909999999997ms</span><br><span class="line">1 -&gt; 3061.7909999999997ms</span><br><span class="line">overall 3062.788ms</span><br><span class="line"></span><br><span class="line"># num_threads = 5</span><br><span class="line">2 -&gt; 3036.288ms</span><br><span class="line">4 -&gt; 3035.291ms</span><br><span class="line">1 -&gt; 3036.288ms</span><br><span class="line">0 -&gt; 3549.756ms</span><br><span class="line">3 -&gt; 3549.756ms</span><br><span class="line">overall 3549.756ms</span><br></pre></td></tr></table></figure>
<p>所以两种情况下，一个是节省时间并行的，一个是没节省时间不并行的。这是为什么呢？</p>
<p>很多同学会提到<code>GIL</code>这个概念，没错，<code>GIL</code>就是关键。<code>GIL</code>是全局解释器锁，它的意义就在于，单个<code>python</code>运行时环境里，同一时刻，保证只有一个操作系统线程能够解释执行<code>python</code>代码。<code>python</code>多线程，实质是起了多个操作系统线程，竞争<code>GIL</code>锁解释执行<code>python</code>代码，在多线程执行<code>code_task</code>的情况下，不同线程需要获取<code>GIL</code>，才能执行<code>while</code>、<code>+=</code>之类的语句，所以这些线程全部执行完的话，总的时间是累加的。而在<code>io_task</code>的情况下，等待<code>ping</code>命令返回的期间是阻塞在操作系统的<code>io</code>接口，并不需要解释执行<code>python</code>代码，因此单个任务线程不需要每时每刻都拥有<code>GIL</code>，各个线程间也没有什么竞争关系了，所以最后呈现了并行的状态。这就是上述问题的答案了。</p>
<p>当然，这个问题还有引申的空间——为什么<code>code_task</code>的场景下，每个线程执行的时间间隔和总的执行时间间隔几乎相差无几，而不是线程一个接一个串行执行完毕呢？这是因为在<code>python</code>运行时环境里<code>GIL</code>的竞争是时分复用的，每个时间间隔<code>sys.getswitchinterval()</code>都会触发一次<code>GIL</code>的释放和竞争，这样呈现的结果就是一个线程执行一点字节码，之后另一个线程抢到机会也执行一点字节码，循环往复，直到所有线程执行结束。所以这种机制下，多线程之间是并发的，最终结束的时刻，不会相差太多时间。</p>
<p><code>python</code>多线程的机制，如果要深入了解，可以参考笔者以前在<code>Medium Python</code>系列写的<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjEvMTAvMzAvbWVkaXVtcHl0aG9uL2lpaS8=" title="https://utmhikari.top/2021/10/30/mediumpython/iii/">这篇文章<i class="fa fa-external-link"></i></span>，里面已经清楚讲述了<code>python</code>线程启动的逻辑以及<code>GIL</code>竞争的逻辑。</p>
]]></content>
      <categories>
        <category>Python随笔</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>GIL</tag>
        <tag>并行</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python随笔】掌握子进程subprocess模块的使用方法</title>
    <url>/2022/07/02/pythonnotes/subprocess_popen/</url>
    <content><![CDATA[<p>在<code>python</code>开发期间，很多时候我们会需要执行一段<code>cmd</code>终端命令，或者是执行其他程序返回<code>stdout</code>或者文件输出结果。这种时候，我们就需要用到<code>subprocess</code>模块。虽然我们用<code>os.system</code>也可以达到执行命令的需求，但用<code>os.system</code>只是干发一段命令，对于执行命令的程序，我们没有办法跟踪它的内部状态以及执行结果，因此从稳定性的角度来讲不是一个好的选择。因此，本篇文章讲解下<code>subprocess</code>子进程模块的的基础应用，让没用过这个模块或是经常踩坑的同学都避避坑。</p>
<p><code>subprocess</code>模块的官方文档在<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9saWJyYXJ5L3N1YnByb2Nlc3MuaHRtbA==" title="https://docs.python.org/3/library/subprocess.html">这里<i class="fa fa-external-link"></i></span>，最核心的单位是<code>subprocess.Popen</code>类，它描述了一个正在运行中的进程。<code>subprocess</code>最基础的用法是<code>subprocess.run</code>，我们入参一段<code>cmd</code>终端命令，<code>run</code>方法内部就会启动一个<code>Popen</code>对象执行这个命令，等待命令执行结束后，返回这个命令执行的退出码<code>retcode</code>，标准输出流内容<code>stdout</code>以及标准错误流内容<code>stderr</code>。我们可以从源码中详细捋一下<code>subprocess.run</code>的流程：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(*popenargs,</span></span></span><br><span class="line"><span class="function"><span class="params">        input=None, capture_output=False, timeout=None, check=False, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># 忽略上面参数处理部分</span></span><br><span class="line">    <span class="keyword">with</span> Popen(*popenargs, **kwargs) <span class="keyword">as</span> process:  <span class="comment"># 新起一个Popen的context</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 通过communicate方法拉取最终stdout、stderr的所有数据</span></span><br><span class="line">            stdout, stderr = process.communicate(input, timeout=timeout)  </span><br><span class="line">        <span class="keyword">except</span> TimeoutExpired <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="comment"># 超时处理，向os申请杀进程，等待进程结束</span></span><br><span class="line">            process.kill()</span><br><span class="line">            <span class="keyword">if</span> _mswindows:</span><br><span class="line">                exc.stdout, exc.stderr = process.communicate()  <span class="comment"># communicate也可用来模拟键盘输入</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                process.wait()</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">except</span>:  <span class="comment"># Including KeyboardInterrupt, communicate handled that.</span></span><br><span class="line">            <span class="comment"># 向os申请杀进程</span></span><br><span class="line">            process.kill()</span><br><span class="line">            <span class="comment"># We don't call process.wait() as .__exit__ does that for us.</span></span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        retcode = process.poll()  <span class="comment"># 获取exitcode</span></span><br><span class="line">        <span class="keyword">if</span> check <span class="keyword">and</span> retcode:</span><br><span class="line">            <span class="keyword">raise</span> CalledProcessError(retcode, process.args,</span><br><span class="line">                                     output=stdout, stderr=stderr)</span><br><span class="line">    <span class="keyword">return</span> CompletedProcess(process.args, retcode, stdout, stderr)</span><br></pre></td></tr></table></figure>
<p><code>subprocess.run</code>是一个阻塞方法，执行了这个接口后，需要等待<code>run</code>入参的命令执行完才能返回。而有些时候，我们需要单独起一个（进程执行）<code>cmd</code>命令，然后周期性每几秒钟去检查命令执行的状态，检查完之后我们还可以在主进程干别的事情，也就是搞一个独立出来的进程。这种情况下，<code>subprocess.run</code>就无法满足，必须直接开<code>subprocess.Popen</code>。</p>
<p>一个基本的示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_decode_bytes</span><span class="params">(_bytes)</span>:</span></span><br><span class="line">    encoding = <span class="string">'gbk'</span></span><br><span class="line">    <span class="keyword">return</span> _bytes.decode(encoding)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_decode_stream</span><span class="params">(stream)</span>:</span></span><br><span class="line">    <span class="string">"""windows下解码stdout/stderr的数据"""</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> stream:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    <span class="keyword">return</span> _decode_bytes(stream.read())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># set params</span></span><br><span class="line">args = [<span class="string">'ping'</span>, <span class="string">'127.0.0.1'</span>]  <span class="comment"># windows这里不用timeout，因为不支持stdin的重定向，用ping大概3~4s的时间总共</span></span><br><span class="line">working_directory = <span class="string">'.'</span>  <span class="comment"># 支持设置命令的工作目录</span></span><br><span class="line">wait_timeout = <span class="number">1</span>  <span class="comment"># 命令每周期等待时间</span></span><br><span class="line">cnt, maxcnt = <span class="number">0</span>, <span class="number">4</span>  <span class="comment"># 等待次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># run process</span></span><br><span class="line">print(<span class="string">f'platform system: <span class="subst">&#123;platform.system()&#125;</span>'</span>)</span><br><span class="line">p = subprocess.Popen(args,</span><br><span class="line">                     cwd=working_directory,</span><br><span class="line">                     <span class="comment"># 设置subprocess.PIPE，这样执行完后可以从p.stdout/p.stderr获取输出数据</span></span><br><span class="line">                     stdout=subprocess.PIPE,</span><br><span class="line">                     stderr=subprocess.PIPE)</span><br><span class="line">print(<span class="string">f'process args: <span class="subst">&#123;args&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'process pid: <span class="subst">&#123;p.pid&#125;</span>'</span>)</span><br><span class="line"><span class="keyword">while</span> cnt &lt; maxcnt:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p.wait(timeout=wait_timeout)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">f'attempt <span class="subst">&#123;cnt&#125;</span> -&gt; wait err: <span class="subst">&#123;e&#125;</span>'</span>)</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> p.returncode <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 看是否有退出码，来判断进程是否执行结束</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># check retcode</span></span><br><span class="line"><span class="keyword">if</span> p.returncode <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    print(<span class="string">'[ERROR] retcode is None, maybe timeout, try kill process...'</span>)</span><br><span class="line">    <span class="keyword">if</span> platform.system() == <span class="string">'Windows'</span>:  <span class="comment"># windows下，强杀进程用taskkill，因为没有SIGKILL</span></span><br><span class="line">        kill_proc_ret = subprocess.run([<span class="string">'taskkill'</span>, <span class="string">'/f'</span>, <span class="string">'/pid'</span>, str(p.pid)], capture_output=<span class="literal">True</span>)</span><br><span class="line">        print(<span class="string">f'[KILLPROC] <span class="subst">&#123;_decode_bytes(kill_proc_ret.stdout)&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 其他情况下可以发送SIGKILL</span></span><br><span class="line">        os.kill(p.pid, signal.SIGKILL)</span><br><span class="line"><span class="keyword">else</span>:  <span class="comment"># 打印返回数据</span></span><br><span class="line">    retcode, stdout, stderr = p.returncode, _decode_stream(p.stdout), _decode_stream(p.stderr)</span><br><span class="line">    print(<span class="string">f'[OK] retcode: <span class="subst">&#123;retcode&#125;</span>\n\tstdout: <span class="subst">&#123;stdout&#125;</span>\n\tstderr: <span class="subst">&#123;stderr&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>
<p>这段程序模拟了周期性等待子进程执行完成的场景，执行完成后拉取<code>stdout</code>和<code>stderr</code>打印，执行超时就强杀进程。基本上关键的地方都有注释，如果有其他类似的场景，可以直接照搬代码。</p>
<p>最后我们也能看到，<code>subprocess</code>本质也是多进程，但和<code>multiprocessing</code>有所不同，<code>multiprocessing</code>是多个<code>python</code>进程，着重于管理多个<code>python</code>进程的运行时环境以及之间的通信；而<code>subprocess</code>则是侧重于去跟踪<code>python</code>程序启动的任意类型进程的状态。两者也有共同点，就是主进程都会持有子进程的<code>handle</code>，只要没调用类似<code>subprocess.run</code>这种阻塞获取子进程状态/结果的接口，在起了新进程后，主进程内都能够随时随地去获取子进程的状态信息。</p>
]]></content>
      <categories>
        <category>Python随笔</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>多进程</tag>
        <tag>subprocess</tag>
        <tag>Popen</tag>
        <tag>子进程</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】vue3中实现Array数组更新的方法</title>
    <url>/2022/06/17/geekdaily/vue3_array_update/</url>
    <content><![CDATA[<p>近期由于工作原因，开始了解<code>vue3</code>的内容。<code>vue3</code>相对于<code>vue2</code>采用了组合式的描述，原来的写法是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'HelloWorld'</span>,</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            a: <span class="number">1</span>,</span><br><span class="line">            b: <span class="number">2</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        <span class="keyword">this</span>.a = <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        onConfirm() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而到了<code>vue3</code>，提倡的写法变成了：</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, reactive, toRefs &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'HelloWorld'</span>,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        <span class="keyword">const</span> a = ref(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">            b: <span class="number">2</span></span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            a.value = <span class="number">3</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">const</span> onConfirm = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            a,</span><br><span class="line">            onConfirm,</span><br><span class="line">            ...toRefs(state)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说不需要把<code>methods</code>、<code>data</code>、<code>computed</code>还有各类钩子区分开，<code>script</code>的内容都能通过一个<code>setup</code>函数来组织，这样代码会有更强的可读性，实际开发时候也不会上下来回切。</p>
<p>初次接触这种写法的时候就遇到了一个问题，好比说有个<code>table</code>绑定了属性<code>dataList</code>，是个<code>Array</code>，那么<code>dataList</code>在<code>setup</code>里处理逻辑应该是怎样的呢？</p>
<p>这里有两种方法，一种方法是用<code>ref</code>修饰，这样这个<code>dataList</code>实例如果调用<code>push</code>之类的方法，其变化不会被侦测到，但可以用新的一个数组全量替换原来的<code>dataList</code>；另一种方法是用<code>reactive</code>修饰，这样一些类方法调用时候能<code>hook</code>到，使得对应的页面内容产生变化，但如果全量替换，是没法感知到的。</p>
<p>综合以上两点，实际场景下，还是推荐第三种方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'HelloWorld'</span>,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        <span class="keyword">const</span> abcState = reactive(&#123;</span><br><span class="line">            abcDataList: []</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">const</span> defState = reactive(&#123;</span><br><span class="line">            defDataList: []</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            abcState,</span><br><span class="line">            defState</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先定义各类<code>state</code>，可以认为是划分功能模块所<code>model</code>的数据，再把实际的数据属性放到<code>state</code>里，最后组合在一起。这样列表类型的数据只能全量替换，但有一个好处，就是通过不同<code>state</code>的组合，代码逻辑更加清晰了，有点像以前<code>store</code>的设计，同时也能规避列表类型数据更新后同步渲染到页面的问题。</p>
<p>以上就是<code>vue3</code>中实现<code>Array</code>数组更新的解决方式。</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>vue3</tag>
        <tag>array</tag>
        <tag>state</tag>
        <tag>reactive</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】通过motrix启动逻辑初探electron的项目结构</title>
    <url>/2022/06/05/geekdaily/electron_motrix_launcher/</url>
    <content><![CDATA[<p>近期准备开始做<code>electron</code>相关的开发工作，因此借着这个机会就再去了解下<code>electron</code>。在<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMTkvMTAvMjAvZ2Vla2RhaWx5L2VsZWN0cm9uX3JlYWN0Lw==" title="https://utmhikari.top/2019/10/20/geekdaily/electron_react/">很久以前的文章<i class="fa fa-external-link"></i></span>中有稍微玩过<code>electron+react+antd</code>的脚手架，但也只限于快速开发<code>electron</code>应用，并没有去剖析整个项目结构。因此这次，还是得深入一下。</p>
<p>先前一段时间特别喜欢用开源的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FnYWx3b29kL01vdHJpeA==" title="https://github.com/agalwood/Motrix">Motrix<i class="fa fa-external-link"></i></span>下载器，就是基于<code>electron+vue+aria2</code>去实现的，所以索性就把源码给<code>clone</code>了下来。本文就从最基础的开始，以<code>Motrix</code>的启动逻辑为入口，来研究下一个<code>electron</code>应用是如何打开的。</p>
<p>首先看一下<code>Motrix</code>的目录结构，源码基本在<code>src</code>下，呈现这样的层级关系：</p>
<a id="more"></a>
<ul>
<li><code>main</code>：主进程，应用内部逻辑<ul>
<li><code>configs</code>：内部环境配置</li>
<li><code>core</code>：软件核心管理逻辑</li>
<li><code>menus</code>：不同<code>os</code>下的菜单配置</li>
<li><code>pages</code>：基础页面</li>
<li><code>ui</code>：各<code>ui</code>相关的<code>Manager</code>逻辑</li>
<li><code>utils</code>：工具方法库</li>
<li><code>Application.js</code>：应用入口</li>
<li><code>Launcher.js</code>：启动器入口</li>
<li><code>index.js/index.dev.js</code>：程序入口<ul>
<li><code>index.dev.js</code>相对于<code>index.js</code>只是另外安装了<code>devtools</code></li>
</ul>
</li>
</ul>
</li>
<li><code>renderer</code>：渲染进程，<code>vue</code>页面逻辑，目录结构也是<code>vue</code>默认的，可以参考<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZHJhZ29uaXIvcC84NzExNzYxLmh0bWw=" title="https://www.cnblogs.com/dragonir/p/8711761.html">这篇文章<i class="fa fa-external-link"></i></span><ul>
<li><code>api</code>：外部接口</li>
<li><code>assets</code>：资源文件</li>
<li><code>components</code>：组件页面</li>
<li><code>pages</code>：应用页面入口，<code>App.vue+main.js</code></li>
<li><code>router</code>：路由</li>
<li><code>store</code>：应用内部数据</li>
<li><code>utils</code>：工具方法库</li>
<li><code>workers</code>：只有一个<code>tray.worker.js</code>用来绘制托盘<code>icon</code></li>
</ul>
</li>
<li><code>shared</code>：公用逻辑/工具<ul>
<li><code>aria2</code>：下载工具<code>jslib</code></li>
<li><code>locales</code>：本地化</li>
<li><code>utils</code>：公用<code>js</code>工具方法库</li>
</ul>
</li>
</ul>
<p>从<code>MVC</code>的角度，<code>main</code>主进程的逻辑相当于是<code>model</code>，<code>renderer</code>渲染进程的逻辑相当于是<code>view</code>，而至于<code>controller</code>，可以通过<code>electron</code>支持下的两个进程的<code>ipc</code>事件处理机制来呈现。这一点，我们直接看启动逻辑就能明白。</p>
<p>运行<code>yarn run dev</code>，会启动<code>.election-vue/dev-runner.js</code>，其中会先初始化<code>renderer</code>和<code>main</code>，然后再启动<code>electron</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .election-vue/dev-runner.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  greeting()</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.all([startRenderer(), startMain()])</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      startElectron()</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>startRenderer</code>和<code>startMain</code>中会读取<code>js</code>配置的程序入口，编译后运行。两个进程的入口<code>entry</code>分别是：</p>
<ul>
<li>渲染进程：<code>src/pages/index/main.js</code></li>
<li>主进程：<code>src/main/index.dev.js</code></li>
</ul>
<p>首先看渲染进程，运行的入口在这里：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.dispatch(<span class="string">'preference/fetchPreference'</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">'[Motrix] load preference:'</span>, config)</span><br><span class="line">    init(config)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    alert(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>首先会通过<code>preference/fetchPreference</code>这个<code>action</code>来获得应用配置，然后调用<code>init</code>函数启动界面。先看获取配置的逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/renderer/store/modules/preferences.js</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  fetchPreference (&#123; dispatch &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      api.fetchPreference()</span><br><span class="line">        .then(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">          dispatch(<span class="string">'updatePreference'</span>, config)</span><br><span class="line">          resolve(config)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/renderer/api/Api.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line">  fetchPreference () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.config = <span class="keyword">this</span>.loadConfig()</span><br><span class="line">      resolve(<span class="keyword">this</span>.config)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">async</span> loadConfig () &#123;</span><br><span class="line">    <span class="keyword">let</span> result = is.renderer()  <span class="comment">// electron-is，包含electron相关的IsXXX工具函数</span></span><br><span class="line">      ? <span class="keyword">await</span> <span class="keyword">this</span>.loadConfigFromNativeStore()</span><br><span class="line">      : <span class="keyword">this</span>.loadConfigFromLocalStorage()</span><br><span class="line"></span><br><span class="line">    result = changeKeysToCamelCase(result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  loadConfigFromLocalStorage () &#123;</span><br><span class="line">    <span class="keyword">const</span> result = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> loadConfigFromNativeStore () &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> ipcRenderer.invoke(<span class="string">'get-app-config'</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到最终获取配置的逻辑落到<code>ipcRenderer.invoke(&#39;get-app-config&#39;)</code>。<code>ipcRenderer</code>相当于是渲染进程里进程间（与<code>Main</code>主进程）通信的<code>handle</code>，这里相当于是向主进程<code>invoke</code>了一个<code>get-app-config</code>事件。在主进程端的<code>ipcMain</code>可以注册这个事件的监听，然后返回对应的数据。<br><code>ipcRenderer</code>和<code>ipcMain</code>的通信，可以查看这两个文档：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudzNjc2Nob29sLmNuL2VsZWN0cm9ubWFudWFsL2VsZWN0cm9ubWFudWFsLWlwYy1yZW5kZXJlci5odG1s" title="https://www.w3cschool.cn/electronmanual/electronmanual-ipc-renderer.html">ipcRenderer模块<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudzNjc2Nob29sLmNuL2VsZWN0cm9ubWFudWFsL2VsZWN0cm9ubWFudWFsLWlwYy1tYWluLmh0bWw=" title="https://www.w3cschool.cn/electronmanual/electronmanual-ipc-main.html">ipcMain模块<i class="fa fa-external-link"></i></span></li>
</ul>
<p>到这里就暂停，看下主进程的启动，主进程<code>index.js</code>会启用一个<code>Launcher</code>来开始主进程逻辑</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/main/index.js</span></span><br><span class="line">global.launcher = <span class="keyword">new</span> Launcher()</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/main/Launcher.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.url = EMPTY_STRING</span><br><span class="line">    <span class="keyword">this</span>.file = EMPTY_STRING</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有一个实例可以运行，通过app.requestSingleInstanceLock()获取</span></span><br><span class="line">    <span class="keyword">this</span>.makeSingleInstance(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.init()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  init () &#123;</span><br><span class="line">    <span class="keyword">this</span>.exceptionHandler = <span class="keyword">new</span> ExceptionHandler()</span><br><span class="line">    <span class="keyword">this</span>.openedAtLogin = is.macOS()</span><br><span class="line">      ? app.getLoginItemSettings().wasOpenedAtLogin</span><br><span class="line">      : <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (process.argv.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 场景：网页直接下载文件或者url</span></span><br><span class="line">      <span class="keyword">this</span>.handleAppLaunchArgv(process.argv)</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(<span class="string">'[Motrix] openedAtLogin:'</span>, <span class="keyword">this</span>.openedAtLogin)</span><br><span class="line">    <span class="keyword">this</span>.handleAppEvents()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  handleAppEvents () &#123;</span><br><span class="line">    <span class="keyword">this</span>.handleOpenUrl()</span><br><span class="line">    <span class="keyword">this</span>.handleOpenFile()</span><br><span class="line">    <span class="keyword">this</span>.handelAppReady()</span><br><span class="line">    <span class="keyword">this</span>.handleAppWillQuit()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主进程启动逻辑最终落到这<code>handleAppEvents</code>里面四个<code>handler</code>，分别是如下作用：</p>
<ul>
<li><code>handleAppReady</code>：监听<code>ready</code>事件，初始化<code>Application</code>实例（<code>global.application</code>）并为其注册监听事件；监听<code>activate</code>事件，打开<code>index</code>页面</li>
<li><code>handleOpenUrl</code>：监听<code>open-url</code>事件，发送<code>url</code>给<code>Application</code></li>
<li><code>handleOpenFile</code>：监听<code>open-file</code>事件，发送<code>file</code>给<code>Application</code></li>
<li><code>handleAppWillQuit</code>：监听<code>will-quit</code>事件，停止<code>Application</code></li>
</ul>
<p><code>election-app</code>的一系列事件，可以在<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxlY3Ryb25qcy5vcmcvemgvZG9jcy9sYXRlc3QvYXBpL2FwcA==" title="https://www.electronjs.org/zh/docs/latest/api/app">这个网站<i class="fa fa-external-link"></i></span>查阅具体作用<br>接下来看下<code>Application</code>实例的初始化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/main/Application.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.isReady = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.init()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init () &#123;</span><br><span class="line">    <span class="comment">// 配置管理</span></span><br><span class="line">    <span class="keyword">this</span>.configManager = <span class="keyword">this</span>.initConfigManager()</span><br><span class="line">    <span class="comment">// 本地化</span></span><br><span class="line">    <span class="keyword">this</span>.locale = <span class="keyword">this</span>.configManager.getLocale()</span><br><span class="line">    <span class="keyword">this</span>.localeManager = setupLocaleManager(<span class="keyword">this</span>.locale)</span><br><span class="line">    <span class="keyword">this</span>.i18n = <span class="keyword">this</span>.localeManager.getI18n()</span><br><span class="line">    <span class="comment">// 菜单</span></span><br><span class="line">    <span class="keyword">this</span>.setupApplicationMenu()</span><br><span class="line">    <span class="comment">// ? Window</span></span><br><span class="line">    <span class="keyword">this</span>.initWindowManager()</span><br><span class="line">    <span class="comment">// ? UPnP</span></span><br><span class="line">    <span class="keyword">this</span>.initUPnPManager()</span><br><span class="line">    <span class="comment">// 内部engine与client</span></span><br><span class="line">    <span class="keyword">this</span>.startEngine()</span><br><span class="line">    <span class="keyword">this</span>.initEngineClient()</span><br><span class="line">    <span class="comment">// 界面Managers</span></span><br><span class="line">    <span class="keyword">this</span>.initTouchBarManager()</span><br><span class="line">    <span class="keyword">this</span>.initThemeManager()</span><br><span class="line">    <span class="keyword">this</span>.initTrayManager()</span><br><span class="line">    <span class="keyword">this</span>.initDockManager()</span><br><span class="line">    <span class="keyword">this</span>.autoLaunchManager = <span class="keyword">new</span> AutoLaunchManager()</span><br><span class="line">    <span class="keyword">this</span>.energyManager = <span class="keyword">new</span> EnergyManager()</span><br><span class="line">    <span class="comment">// 更新Manager</span></span><br><span class="line">    <span class="keyword">this</span>.initUpdaterManager()</span><br><span class="line">    <span class="comment">// 内部协议Manager</span></span><br><span class="line">    <span class="keyword">this</span>.initProtocolManager()</span><br><span class="line">    <span class="comment">// 注册应用操作事件的handlers</span></span><br><span class="line">    <span class="keyword">this</span>.handleCommands()</span><br><span class="line">    <span class="comment">// 下载进度事件的event</span></span><br><span class="line">    <span class="keyword">this</span>.handleEvents()</span><br><span class="line">    <span class="comment">// on/handle event channels</span></span><br><span class="line">    <span class="keyword">this</span>.handleIpcMessages()</span><br><span class="line">    <span class="keyword">this</span>.handleIpcInvokes()</span><br><span class="line">    <span class="keyword">this</span>.emit(<span class="string">'application:initialized'</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其他的先不说，在<code>handleIpcInvokes</code>里面注册了<code>get-app-config</code>的<code>handler</code>，逻辑如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/main/Application.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;  </span><br><span class="line">  handleIpcInvokes () &#123;</span><br><span class="line">    ipcMain.handle(<span class="string">'get-app-config'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> systemConfig = <span class="keyword">this</span>.configManager.getSystemConfig()</span><br><span class="line">      <span class="keyword">const</span> userConfig = <span class="keyword">this</span>.configManager.getUserConfig()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> result = &#123;</span><br><span class="line">        ...systemConfig,</span><br><span class="line">        ...userConfig</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/main/core/ConfigManager.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigManager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.systemConfig = &#123;&#125;</span><br><span class="line">    <span class="keyword">this</span>.userConfig = &#123;&#125;</span><br><span class="line">    <span class="keyword">this</span>.init()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  init () &#123;</span><br><span class="line">    <span class="keyword">this</span>.initSystemConfig()</span><br><span class="line">    <span class="keyword">this</span>.initUserConfig()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  initSystemConfig () &#123;</span><br><span class="line">    <span class="keyword">this</span>.systemConfig = <span class="keyword">new</span> Store(&#123;</span><br><span class="line">      name: <span class="string">'system'</span>,</span><br><span class="line">      defaults: &#123;</span><br><span class="line">        <span class="string">'all-proxy'</span>: EMPTY_STRING</span><br><span class="line">        <span class="comment">// 这里省略其他的了</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.fixSystemConfig()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  initUserConfig () &#123;</span><br><span class="line">    <span class="keyword">this</span>.userConfig = <span class="keyword">new</span> Store(&#123;</span><br><span class="line">      name: <span class="string">'user'</span>,</span><br><span class="line">      defaults: &#123;</span><br><span class="line">        <span class="string">'all-proxy-backup'</span>: EMPTY_STRING,</span><br><span class="line">        <span class="comment">// 这里省略其他的了</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.fixUserConfig()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用了<code>electron-store</code>持久化用户配置，详情参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9lbGVjdHJvbi1zdG9yZQ==" title="https://github.com/sindresorhus/electron-store">这个链接<i class="fa fa-external-link"></i></span><br>最终给到渲染进程的<code>config</code>，就是<code>systemConfig</code>和<code>userConfig</code>合并的结果，因此可以再转到渲染进程查看<code>init(config)</code>的逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (is.renderer()) &#123;</span><br><span class="line">    Vue.use(<span class="built_in">require</span>(<span class="string">'vue-electron'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  Vue.http = Vue.prototype.$http = axios</span><br><span class="line">  Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> &#123; locale &#125; = config</span><br><span class="line">  <span class="keyword">const</span> localeManager = getLocaleManager()</span><br><span class="line">  localeManager.changeLanguageByLocale(locale)</span><br><span class="line">  Vue.use(VueI18Next)</span><br><span class="line">  <span class="keyword">const</span> i18n = <span class="keyword">new</span> VueI18Next(localeManager.getI18n())</span><br><span class="line">  Vue.use(Element, &#123;</span><br><span class="line">    size: <span class="string">'mini'</span>,</span><br><span class="line">    i18n: <span class="function">(<span class="params">key, value</span>) =&gt;</span> i18n.t(key, value)</span><br><span class="line">  &#125;)</span><br><span class="line">  Vue.use(Msg, Message, &#123;</span><br><span class="line">    showClose: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  Vue.component(<span class="string">'mo-icon'</span>, Icon)</span><br><span class="line">  <span class="keyword">const</span> loading = Loading.service(&#123;</span><br><span class="line">    fullscreen: <span class="literal">true</span>,</span><br><span class="line">    background: <span class="string">'rgba(0, 0, 0, 0.1)'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  sync(store, router)</span><br><span class="line">  <span class="comment">/* eslint-disable no-new */</span></span><br><span class="line">  global.app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    components: &#123; App &#125;,</span><br><span class="line">    router,</span><br><span class="line">    store,</span><br><span class="line">    i18n,</span><br><span class="line">    template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">  &#125;).$mount(<span class="string">'#app'</span>)</span><br><span class="line">  global.app.commands = commands</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./commands'</span>)</span><br><span class="line">  global.app.trayWorker = initTrayWorker()</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    loading.close()</span><br><span class="line">  &#125;, <span class="number">400</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一段代码主要设置<code>Vue</code>的内部属性并起了<code>Vue</code>实例赋予<code>global.app</code>。在其中，加载了<code>App.vue</code>中<code>id=app</code>的页面内容，包括这些：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mo-title-bar</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-if</span>=<span class="string">"isRenderer"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:showActions</span>=<span class="string">"showWindowActions"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mo-engine-client</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:secret</span>=<span class="string">"rpcSecret"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mo-ipc</span> <span class="attr">v-if</span>=<span class="string">"isRenderer"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mo-dynamic-tray</span> <span class="attr">v-if</span>=<span class="string">"enableTraySpeedometer"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>&lt;router-view /&gt;</code>是实质展示了路由为<code>/</code>的页面，对应到<code>routers</code>里面就是<code>@/components/Main</code>以及其下级的<code>task</code>的路由组件。其他几个分别是：</p>
<ul>
<li><code>mo-title-bar</code>：顶层的最小化、最大化、退出按钮</li>
<li><code>mo-engine-client</code>：不渲染界面的组件，实质只有<code>js</code>逻辑，用于管理下载进度</li>
<li><code>mo-ipc</code>：不渲染界面的组件，实质只有<code>js</code>逻辑，用于<code>ipc</code></li>
<li><code>mo-dynamic-tray</code>：下载速度显示组件</li>
</ul>
<p>到了这里，整个<code>app</code>就启动完成了。</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>工具开发</tag>
        <tag>electron</tag>
        <tag>vue</tag>
        <tag>nodejs</tag>
        <tag>ipc</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hard Python】【第五章-字符串】2、re，正则表达式源码详解</title>
    <url>/2022/05/14/hardpython/5_str_2/</url>
    <content><![CDATA[<p>正则表达式是文本处理中的重要部分，通过匹配特定的正则表达式，能够很方便地编写提取特定文本的代码。在<code>python</code>中，同样也已经拥有了正则表达式库<code>re</code>，为各位开发者提供了正则表达式的支持。</p>
<p>在<code>python</code>官方文档中，已经对正则表达式模块接口、词法和用法做了详细的介绍：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvemgtY24vMy9saWJyYXJ5L3JlLmh0bWw=" title="https://docs.python.org/zh-cn/3/library/re.html"><code>re</code>——正则表达式操作<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvemgtY24vMy9ob3d0by9yZWdleC5odG1sI3JlZ2V4LWhvd3Rv" title="https://docs.python.org/zh-cn/3/howto/regex.html#regex-howto">正则表达式HOWTO<i class="fa fa-external-link"></i></span></li>
</ul>
<p>正则表达式常见的用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_pattern</span><span class="params">()</span>:</span></span><br><span class="line">    pat = re.compile(<span class="string">'[0-9]&#123;2,3&#125;'</span>)</span><br><span class="line">    print(pat.match(<span class="string">'a'</span>))</span><br><span class="line">    print(pat.match(<span class="string">'1'</span>))</span><br><span class="line">    print(pat.match(<span class="string">'111'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_matches</span><span class="params">()</span>:</span></span><br><span class="line">    s = <span class="string">'123abc456def789xyz007ddc'</span></span><br><span class="line">    pat = re.compile(<span class="string">'([0-9]+)([a-z]+([0-9]+))'</span>)</span><br><span class="line">    <span class="keyword">for</span> match <span class="keyword">in</span> pat.finditer(s):</span><br><span class="line">        print(match.groups())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test_pattern()</span><br><span class="line">    test_matches()</span><br></pre></td></tr></table></figure>
<p><code>test_pattern</code>中，<code>compile</code>了一个只匹配2~3个数字字符的正则对象，<code>test_matches</code>中，则匹配了数字+小写字母+数字的正则对象，并且用括号分了三个组。两个函数打印出来的结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">None</span><br><span class="line">None</span><br><span class="line">&lt;re.Match object; span=(0, 3), match=&apos;111&apos;&gt;</span><br><span class="line">(&apos;123&apos;, &apos;abc456&apos;, &apos;456&apos;)</span><br><span class="line">(&apos;789&apos;, &apos;xyz007&apos;, &apos;007&apos;)</span><br></pre></td></tr></table></figure>
<p>接下来我们就深入其中，看下源码怎么实现的。</p>
<a id="more"></a>
<p>首先我们就这两个语句来看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pat = re.compile(<span class="string">'[0-9]&#123;2,3&#125;'</span>)</span><br><span class="line">pat.match(<span class="string">'111'</span>)</span><br></pre></td></tr></table></figure>
<p><code>re.compile</code>对一个正则表达式解析后，会生成正则模式<code>Pattern</code>对象，<code>Pattern</code>对象可以用于匹配一个特定的字符串。因此我们可以通过<code>re.compile</code>的逻辑切入，先探究<code>Pattern</code>对象的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># re.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compile</span><span class="params">(pattern, flags=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _compile(pattern, flags)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_compile</span><span class="params">(pattern, flags)</span>:</span></span><br><span class="line">    <span class="comment"># 尝试先从LRU获取</span></span><br><span class="line">    p = sre_compile.compile(pattern, flags)</span><br><span class="line">    <span class="comment"># 更新LRU</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># sre_compile.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compile</span><span class="params">(p, flags=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isstring(p):</span><br><span class="line">        pattern = p</span><br><span class="line">        p = sre_parse.parse(p, flags)  <span class="comment"># 解析字符串</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pattern = <span class="literal">None</span></span><br><span class="line">    code = _code(p, flags)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; SRE_FLAG_DEBUG:</span><br><span class="line">        print()</span><br><span class="line">        dis(code)</span><br><span class="line">    <span class="comment"># map in either direction</span></span><br><span class="line">    groupindex = p.state.groupdict</span><br><span class="line">    indexgroup = [<span class="literal">None</span>] * p.state.groups</span><br><span class="line">    <span class="keyword">for</span> k, i <span class="keyword">in</span> groupindex.items():</span><br><span class="line">        indexgroup[i] = k</span><br><span class="line">    <span class="keyword">return</span> _sre.compile(</span><br><span class="line">        pattern, flags | p.state.flags, code,</span><br><span class="line">        p.state.groups<span class="number">-1</span>,</span><br><span class="line">        groupindex, tuple(indexgroup)</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>正则<code>Pattern</code>的生成，最终走到了<code>sre_compile.py</code>中的<code>compile</code>函数，主要是两个步骤：</p>
<ul>
<li>通过<code>sre_parse.parse</code>解析正则表达式字符串</li>
<li>通过<code>_code</code>方法生成解析结果的字节码，然后通过<code>_sre.compile</code>生成最终的<code>Pattern</code>对象</li>
</ul>
<p>首先我们来看<code>parse</code>解析逻辑，其代码实现如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sre_parse.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(str, flags=<span class="number">0</span>, state=None)</span>:</span></span><br><span class="line">    source = Tokenizer(str)</span><br><span class="line">    <span class="keyword">if</span> state <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        state = State()</span><br><span class="line">    state.flags = flags</span><br><span class="line">    state.str = str</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = _parse_sub(source, state, flags &amp; SRE_FLAG_VERBOSE, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">except</span> Verbose:</span><br><span class="line">        state = State()</span><br><span class="line">        state.flags = flags | SRE_FLAG_VERBOSE</span><br><span class="line">        state.str = str</span><br><span class="line">        source.seek(<span class="number">0</span>)</span><br><span class="line">        p = _parse_sub(source, state, <span class="literal">True</span>, <span class="number">0</span>)</span><br><span class="line">    p.state.flags = fix_flags(str, p.state.flags)</span><br><span class="line">    <span class="keyword">if</span> source.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">assert</span> source.next == <span class="string">")"</span></span><br><span class="line">        <span class="keyword">raise</span> source.error(<span class="string">"unbalanced parenthesis"</span>)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; SRE_FLAG_DEBUG:</span><br><span class="line">        p.dump()</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_parse_sub</span><span class="params">(source, state, verbose, nested)</span>:</span></span><br><span class="line">    items = []</span><br><span class="line">    itemsappend = items.append</span><br><span class="line">    sourcematch = source.match</span><br><span class="line">    start = source.tell()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        itemsappend(_parse(source, state, verbose, nested + <span class="number">1</span>,</span><br><span class="line">                           <span class="keyword">not</span> nested <span class="keyword">and</span> <span class="keyword">not</span> items))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sourcematch(<span class="string">"|"</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> len(items) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> items[<span class="number">0</span>]</span><br><span class="line">    subpattern = SubPattern(state)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        prefix = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> item:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> prefix <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                prefix = item[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">elif</span> item[<span class="number">0</span>] != prefix:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">                <span class="keyword">del</span> item[<span class="number">0</span>]</span><br><span class="line">            subpattern.append(prefix)</span><br><span class="line">            <span class="keyword">continue</span> <span class="comment"># check next one</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    set = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> len(item) != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        op, av = item[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> op <span class="keyword">is</span> LITERAL:</span><br><span class="line">            set.append((op, av))</span><br><span class="line">        <span class="keyword">elif</span> op <span class="keyword">is</span> IN <span class="keyword">and</span> av[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">is</span> <span class="keyword">not</span> NEGATE:</span><br><span class="line">            set.extend(av)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        subpattern.append((IN, _uniq(set)))</span><br><span class="line">        <span class="keyword">return</span> subpattern</span><br><span class="line">    subpattern.append((BRANCH, (<span class="literal">None</span>, items)))</span><br><span class="line">    <span class="keyword">return</span> subpattern</span><br></pre></td></tr></table></figure>
<p>大致捋一下流程：</p>
<ul>
<li>初始化<code>Tokenizer</code>：提供了访问、检索字符串当前以及后续的词法单元<code>token</code>的一系列方法，供<code>parser</code>运行过程中调用</li>
<li>初始化<code>State</code>：用于记录解析过程中的状态，检测一些解析的异常情况，主要是记录跟组<code>group</code>有关的信息<ul>
<li><code>group</code>在正则表达式中，相当于小括号之间的内容</li>
</ul>
</li>
<li>调用<code>_parse_sub</code>，传入<code>Tokenizer</code>跟<code>State</code>实例，解析正则表达式</li>
</ul>
<p>在<code>_parse_sub</code>里，则是这样的流程：</p>
<ul>
<li>不断调用<code>_parse</code>解析出以<code>|</code>符号分隔的一个个<code>SubPattern</code>实例<ul>
<li><code>SubPattern</code>可以认为是一个单位<code>Pattern</code>，不同<code>SubPattern</code>之间相互嵌套，形成树的结构</li>
</ul>
</li>
<li>如果只出一个<code>SubPattern</code>实例，直接返回，否则进行后续逻辑</li>
<li>如果每个<code>SubPattern</code>实例都共享相同匹配前缀，就把相同前缀提取出来</li>
<li>如果每个<code>SubPattern</code>实例都能以字符集表示，就整合成一个字符集</li>
<li>将多个<code>SubPattern</code>实例组合为一个<code>BRANCH</code>分支匹配<code>SubPattern</code>，并返回</li>
</ul>
<p><code>_parse</code>函数是解析正则的主体逻辑，具体代码可以在<code>sre_parse.py</code>中查阅。以刚才给定的<code>&#39;[0-9]{2,3}&#39;</code>为例子，会进行如下的步骤：</p>
<ul>
<li>匹配到<code>[</code>符号，进入<code>[</code>的分支<ul>
<li>首先判断是否有<code>^</code>符号（<code>negate</code>），即表示<code>“非xxx字符”</code>的含义，实际是没有</li>
<li>进入字符集取值循环，首先取到字符<code>0</code></li>
<li>取完了之后判断是否有范围匹配模式<code>-</code>，发现有，进入<code>-</code>的分支</li>
<li>在<code>-</code>的分支里，取到字符<code>9</code></li>
<li>之后取到<code>]</code>，退出字符集取值循环</li>
<li>后处理：对字符集取值取交集，如果有<code>negate</code>就取非</li>
<li>退出<code>]</code>的分支，当前<code>SubPattern</code>实例包含了模式：<code>(IN, [(RANGE, (48, 57))])</code></li>
</ul>
</li>
<li>在<code>REPEAT_CHARS</code>匹配到<code>{</code>符号，进入<code>{</code>的分支<ul>
<li><code>REPEAT_CHARS</code>表示重复字符，即<code>*+?{</code></li>
<li>不断提取字符，解析<code>x,y</code>样式的字符串，确定重复次数范围</li>
<li>解析到<code>}</code>，退出 <code>{</code> 的分支</li>
<li><code>wrap</code>前面的<code>SubPattern</code>，得到新的<code>SubPattern</code>模式：<code>(MAX_REPEAT, (2, 3, [(IN, [(RANGE, (48, 57))])]))</code></li>
</ul>
</li>
<li>取不到下一个字符，退出循环</li>
</ul>
<p>可以看到整个<code>_parse</code>逻辑是一个状态机的形式，匹配到不同的词法单元<code>token</code>，在不同分支的词法分析状态下，相同的<code>token</code>会呈现不同的涵义。因此整块代码呈现起来，就成了<code>if-else</code>的大杂烩</p>
<p>如果是包含多个<code>group</code>的情况，就还要走更多的的分支逻辑。我们用一个例子来看：<code>&#39;(?&lt;=ab)([^\\si-w]+([125]+?))&#39;</code>，它的逻辑是这样走的：</p>
<ul>
<li>匹配到<code>(</code>符号，进入<code>(</code>的分支<ul>
<li>发现第一个符号是<code>?</code>，表明这一段是非获取匹配<ul>
<li>非获取匹配表示，整个模式最终能匹配到的各个字符串组里，不会包括非获取匹配的括号的部分</li>
<li>判断下一个符号是不是<code>&lt;</code>，如果是则为反向预查匹配</li>
<li>解析非获取匹配的<code>SubPattern</code>实例</li>
<li>判断对比符号是<code>=</code>还是 <code>!</code> ，决定这组<code>SubPattern</code>要么是<code>ASSERT</code>，要么是<code>ASSERT_NOT</code></li>
<li>得到<code>SubPattern</code>实例<code>(ASSERT, (-1, [(LITERAL, 97), (LITERAL, 98)]))</code>，继续下一轮循环</li>
</ul>
</li>
</ul>
</li>
<li>又匹配到<code>(</code>符号，再次进入<code>(</code>的分支<ul>
<li>第一个符号不是<code>?</code>，进入后续逻辑，调用<code>state.opengroup</code>，自增<code>groups</code>计数</li>
<li>解析后面的<code>pattern</code>，先得到<code>[^\\si-w]+</code>对应的一段：<code>(MAX_REPEAT, (1, MAXREPEAT, [(IN, [(NEGATE, None), (CATEGORY, CATEGORY_SPACE), (RANGE, (105, 119))])]))</code></li>
<li>再次匹配到<code>(</code>符号，又进入一次<code>(</code>的分支<ul>
<li>得到<code>[125]+?</code>对应的一段<code>SubPattern</code>：<code>(MIN_REPEAT, (1, MAXREPEAT, [(IN, [(LITERAL, 49), (LITERAL, 50), (LITERAL, 53)])]))</code><br>可以注意到非贪婪匹配实际用<code>MIN_REPEAT</code>语义表示</li>
<li>匹配到<code>)</code>符号，退出</li>
<li>调用<code>state.closegroup</code>，在<code>state</code>中记录<code>[125]+?</code>对应的匹配宽度到组<code>2：(1, 4294967295)</code></li>
<li>添加一个<code>SUBPATTERN</code>类型的<code>SubPattern</code>实例，里面封装<code>group</code>计数号、解析到的真实<code>SubPattern</code>实例以及其它信息</li>
<li>匹配 <code>)</code>，退出<code>(</code>的分支</li>
</ul>
</li>
<li>匹配到<code>)</code>，退出<code>(</code>的分支</li>
<li>调用<code>state.closegroup</code>，在<code>state</code>中记录<code>[^\\si-w]+([125]+?)</code>对应的匹配宽度到组<code>1：(2, MAXREPEAT)</code></li>
</ul>
</li>
<li>父<code>subpattern</code>遍历名下所有<code>SubPattern</code>实例，如果发现由<code>SUBPATTERN</code>类型且真实<code>SubPattern</code>实例为非捕获组（<code>non-capturing</code>，即形似<code>(?:)</code>的形式），就提取真实的<code>SubPattern</code>实例出来替换当前<code>SUBPATTERN</code>类型的实例</li>
</ul>
<p>这样整个<code>parse</code>的部分就结束了，最终我们获取到：</p>
<ul>
<li><code>subpattern</code><ul>
<li>根<code>subpattern</code>，也就是整个正则表达式</li>
<li><code>SUBPATTERN</code>实例1：<code>[^\\si-w]+([125]+?)</code></li>
<li><code>SUBPATTERN</code>实例2：<code>[125]+?</code></li>
</ul>
</li>
<li><code>state</code><ul>
<li><code>groups</code>计数为3（下一个<code>group</code>的<code>id</code>），需要再-1，即实际只有2个<code>group</code></li>
<li>1、2号下标宽度：<code>(2, MAXREPEAT)</code>、<code>(1, 4294967295)</code></li>
</ul>
</li>
<li><code>code</code>：<code>subpattern</code>被编译出来的字节码序列，用以进行实际的匹配操作</li>
</ul>
<p>接下来就是<code>_sre.compile</code>的逻辑了，这里先暂不列举了，有兴趣可以在<code>_sre.c</code>中看到，主要作用就是把所有信息集合在一起封装成为单独的一个<code>re.Pattern</code>实例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _sre.c</span></span><br><span class="line"><span class="keyword">static</span> PyType_Spec pattern_spec = &#123;</span><br><span class="line">    .name = <span class="string">"re.Pattern"</span>,</span><br><span class="line">    .basicsize = <span class="keyword">sizeof</span>(PatternObject),</span><br><span class="line">    .itemsize = <span class="keyword">sizeof</span>(SRE_CODE),</span><br><span class="line">    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_IMMUTABLETYPE |</span><br><span class="line">              Py_TPFLAGS_DISALLOW_INSTANTIATION | Py_TPFLAGS_HAVE_GC),</span><br><span class="line">    .slots = pattern_slots,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>封装完了之后的<code>Pattern</code>实例，就可以用来匹配字符串了。我们以<code>&#39;(?&lt;=ab)([^\\si-w]+([125]+?))&#39;</code>这个<code>Pattern</code>实例为例，来匹配字符串<code>&#39;  abcde1233  gabh5455&#39;</code>，找到所有匹配的组合</p>
<p>我们可以用<code>finditer</code>方法，寻找所有匹配的<code>Match</code>实例，<code>finditer</code>方法的实现在<code>_sre_SRE_Pattern_finditer_impl</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">_sre_SRE_Pattern_finditer_impl(PatternObject *self, PyTypeObject *cls,</span><br><span class="line">                               PyObject *<span class="built_in">string</span>, Py_ssize_t pos,</span><br><span class="line">                               Py_ssize_t endpos)</span><br><span class="line">&#123;</span><br><span class="line">    _sremodulestate *module_state = get_sre_module_state_by_class(cls);</span><br><span class="line">    PyObject* scanner;</span><br><span class="line">    PyObject* search;</span><br><span class="line">    PyObject* iterator;</span><br><span class="line">    scanner = pattern_scanner(module_state, self, <span class="built_in">string</span>, pos, endpos);</span><br><span class="line">    <span class="keyword">if</span> (!scanner)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    search = PyObject_GetAttrString(scanner, <span class="string">"search"</span>);</span><br><span class="line">    Py_DECREF(scanner);</span><br><span class="line">    <span class="keyword">if</span> (!search)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    iterator = PyCallIter_New(search, Py_None);</span><br><span class="line">    Py_DECREF(search);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iterator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>finditer</code>创建了一个<code>ScannerObject</code>用于对整个字符串的扫描，会不断调用<code>ScannerObject</code>的<code>search</code>方法取搜索匹配但不重叠的子串。<code>ScannerObject</code>和<code>Pattern</code>的<code>search</code>方法原理是一样的，只不过<code>Pattern.search</code>是一次性的，而<code>ScannerObject</code>的<code>search</code>在进行一轮之后会更新自身内部的状态，调整匹配起始位置，以方便下一轮匹配</p>
<p><code>ScannerObject</code>的<code>search</code>方法是如下的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">_sre_SRE_Scanner_search_impl(ScannerObject *self, PyTypeObject *cls)</span><br><span class="line">&#123;</span><br><span class="line">    _sremodulestate *module_state = get_sre_module_state_by_class(cls);</span><br><span class="line">    SRE_STATE* state = &amp;self-&gt;state;</span><br><span class="line">    PyObject* match;</span><br><span class="line">    Py_ssize_t status;</span><br><span class="line">    <span class="keyword">if</span> (state-&gt;start == <span class="literal">NULL</span>)</span><br><span class="line">        Py_RETURN_NONE;</span><br><span class="line">    state_reset(state);</span><br><span class="line">    state-&gt;ptr = state-&gt;start;</span><br><span class="line">    status = sre_search(state, PatternObject_GetCode(self-&gt;pattern));</span><br><span class="line">    <span class="keyword">if</span> (PyErr_Occurred())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    match = pattern_new_match(module_state, (PatternObject*) self-&gt;pattern,</span><br><span class="line">                              state, status);</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">0</span>)</span><br><span class="line">        state-&gt;start = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        state-&gt;must_advance = (state-&gt;ptr == state-&gt;start);</span><br><span class="line">        state-&gt;start = state-&gt;ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> match;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其步骤如下：</p>
<ul>
<li>重置内部维护的状态</li>
<li>调用<code>sre_search</code>，匹配一个符合正则的子串</li>
<li>调用<code>pattern_new_match</code>，生成一个<code>Match</code>实例</li>
</ul>
<p><code>sre_search</code>最终会调用<code>SRE(match)</code>进行匹配操作，如果第一个字符起头匹配失败的话，<code>sre_search</code>还会继续以后面的字符起头开始匹配，直到匹配到为止</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sre_lib.h</span></span><br><span class="line">LOCAL(Py_ssize_t)</span><br><span class="line">SRE(search)(SRE_STATE* state, SRE_CODE* pattern)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 省略上面</span></span><br><span class="line">		<span class="comment">/* general case */</span></span><br><span class="line">        assert(ptr &lt;= end);</span><br><span class="line">        TRACE((<span class="string">"|%p|%p|SEARCH\n"</span>, pattern, ptr));</span><br><span class="line">        state-&gt;start = state-&gt;ptr = ptr;</span><br><span class="line">        status = SRE(match)(state, pattern, <span class="number">1</span>);  <span class="comment">// status为0表示匹配失败，1表示成功</span></span><br><span class="line">        state-&gt;must_advance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (status == <span class="number">0</span> &amp;&amp; ptr &lt; end) &#123;</span><br><span class="line">            ptr++;</span><br><span class="line">            RESET_CAPTURE_GROUP();</span><br><span class="line">            TRACE((<span class="string">"|%p|%p|SEARCH\n"</span>, pattern, ptr));</span><br><span class="line">            state-&gt;start = state-&gt;ptr = ptr;</span><br><span class="line">            status = SRE(match)(state, pattern, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> status</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SRE(match)</code>会根据<code>pattern</code>编译出来的<code>code</code>字节码里面的内容，根据不同的字节码，走到对应的分支逻辑再逐字匹配，类似于<code>python</code>虚拟机解析<code>python</code>字节码的操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LOCAL(Py_ssize_t)</span><br><span class="line">SRE(match)(SRE_STATE* state, <span class="keyword">const</span> SRE_CODE* pattern, <span class="keyword">int</span> toplevel)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 大循环</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ++sigcount;</span><br><span class="line">        <span class="keyword">switch</span> (*ctx-&gt;pattern++) &#123;  <span class="comment">// 根据不同的操作符，执行不同的匹配判断</span></span><br><span class="line">        <span class="keyword">case</span> SRE_OP_MARK:</span><br><span class="line">            TRACE((<span class="string">"|%p|%p|MARK %d\n"</span>, ctx-&gt;pattern,</span><br><span class="line">                   ctx-&gt;ptr, ctx-&gt;pattern[<span class="number">0</span>]));</span><br><span class="line">            i = ctx-&gt;pattern[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">                state-&gt;lastindex = i/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; state-&gt;lastmark) &#123;</span><br><span class="line">                Py_ssize_t j = state-&gt;lastmark + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; i)</span><br><span class="line">                    state-&gt;mark[j++] = <span class="literal">NULL</span>;</span><br><span class="line">                state-&gt;lastmark = i;</span><br><span class="line">            &#125;</span><br><span class="line">            state-&gt;mark[i] = ctx-&gt;ptr;</span><br><span class="line">            ctx-&gt;pattern++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> SRE_OP_LITERAL:</span><br><span class="line">            TRACE((<span class="string">"|%p|%p|LITERAL %d\n"</span>, ctx-&gt;pattern,</span><br><span class="line">                   ctx-&gt;ptr, *ctx-&gt;pattern));</span><br><span class="line">            <span class="keyword">if</span> (ctx-&gt;ptr &gt;= end || (SRE_CODE) ctx-&gt;ptr[<span class="number">0</span>] != ctx-&gt;pattern[<span class="number">0</span>])</span><br><span class="line">                RETURN_FAILURE;</span><br><span class="line">            ctx-&gt;pattern++;</span><br><span class="line">            ctx-&gt;ptr++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在字符串<code>&#39;  abcde1233  gabh5455&#39;</code>中，当起始字符<code>ptr</code>指向第一个<code>c</code>的时候，将会有一次成功的匹配，其步骤如下：</p>
<ul>
<li>遇到<code>SRE_OP_ASSERT</code>以及<code>SRE_OP_LITERAL</code>字节码，反向匹配前面的<code>ab</code>子串</li>
<li>遇到<code>SRE_OP_MARK</code>字节码，记录第一个<code>group</code>的起始位置，<code>MARK</code>的参数为<code>0</code></li>
<li>遇到<code>SRE_OP_REPEAT_ONE</code>字节码，匹配<code>[^\\si-w]+</code>模式的最大子串，即为<code>cde1233</code><ul>
<li>尝试匹配后面的内容，在<code>SRE_OP_MARK</code>分支记录第二个<code>group</code>的起始位置，参数为<code>2</code></li>
<li>遇到<code>SRE_OP_MIN_REPEAT_ONE</code>，非贪婪匹配<code>[125]+?</code></li>
<li>因为<code>cde1233</code>后面的字符是空格，匹配失败，退出一轮匹配</li>
<li>先前匹配最大字串为<code>cde1233</code>，因后面模式匹配失败，尾部索引-1，继续匹配</li>
<li>直到子串为<code>cde1</code>，非贪婪匹配到<code>2</code>，匹配成功</li>
</ul>
</li>
<li>连续遇到<code>SRE_OP_MARK</code>字节码，记录两个<code>group</code>的最终位置，<code>MARK</code>的参数分别为<code>3</code>和<code>1</code><ul>
<li>这样<code>MARK</code>里面，<code>0、1</code>和<code>2、3</code>里面的指向内容，就分别对应了两个<code>group</code>的起止位置</li>
</ul>
</li>
<li>遇到<code>SRE_OP_SUCCESS</code>字节码，表示最终匹配成功</li>
</ul>
<p>接下来就是通过<code>pattern_new_match</code>生成<code>Match</code>实例，其实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject*</span><br><span class="line">pattern_new_match(_sremodulestate* module_state,</span><br><span class="line">                  PatternObject* pattern,</span><br><span class="line">                  SRE_STATE* state,</span><br><span class="line">                  Py_ssize_t status)</span><br><span class="line">&#123;</span><br><span class="line">    MatchObject* match;</span><br><span class="line">    Py_ssize_t i, j;</span><br><span class="line">    <span class="keyword">char</span>* base;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (status &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        match = PyObject_GC_NewVar(MatchObject,module_state-&gt;Match_Type,<span class="number">2</span>*(pattern-&gt;groups+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (!match)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        Py_INCREF(pattern);</span><br><span class="line">        match-&gt;pattern = pattern;</span><br><span class="line">        Py_INCREF(state-&gt;<span class="built_in">string</span>);</span><br><span class="line">        match-&gt;<span class="built_in">string</span> = state-&gt;<span class="built_in">string</span>;</span><br><span class="line">        match-&gt;regs = <span class="literal">NULL</span>;</span><br><span class="line">        match-&gt;groups = pattern-&gt;groups+<span class="number">1</span>;</span><br><span class="line">        base = (<span class="keyword">char</span>*) state-&gt;beginning;</span><br><span class="line">        n = state-&gt;charsize;</span><br><span class="line">        match-&gt;mark[<span class="number">0</span>] = ((<span class="keyword">char</span>*) state-&gt;start - base) / n;</span><br><span class="line">        match-&gt;mark[<span class="number">1</span>] = ((<span class="keyword">char</span>*) state-&gt;ptr - base) / n;</span><br><span class="line">        <span class="keyword">for</span> (i = j = <span class="number">0</span>; i &lt; pattern-&gt;groups; i++, j+=<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> (j+<span class="number">1</span> &lt;= state-&gt;lastmark &amp;&amp; state-&gt;mark[j] &amp;&amp; state-&gt;mark[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                match-&gt;mark[j+<span class="number">2</span>] = ((<span class="keyword">char</span>*) state-&gt;mark[j] - base) / n;</span><br><span class="line">                match-&gt;mark[j+<span class="number">3</span>] = ((<span class="keyword">char</span>*) state-&gt;mark[j+<span class="number">1</span>] - base) / n;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                match-&gt;mark[j+<span class="number">2</span>] = match-&gt;mark[j+<span class="number">3</span>] = <span class="number">-1</span>; <span class="comment">/* undefined */</span></span><br><span class="line">        match-&gt;pos = state-&gt;pos;</span><br><span class="line">        match-&gt;endpos = state-&gt;endpos;</span><br><span class="line">        match-&gt;lastindex = state-&gt;lastindex;</span><br><span class="line">        PyObject_GC_Track(match);</span><br><span class="line">        <span class="keyword">return</span> (PyObject*) match;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">        Py_RETURN_NONE;</span><br><span class="line">    &#125;</span><br><span class="line">    pattern_error(status);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中最关键的部分是<code>match-&gt;mark</code>的几段代码，会记录每一个<code>group</code>在字符串中的位置。<code>match-&gt;mark</code>的<code>0、1</code>对应的是整个匹配到的字串的起止位置，而后面的<code>2、3</code>跟<code>4、5</code>就匹配<code>state-&gt;mark</code>里面的<code>0、1</code>跟<code>2、3</code>两个<code>group</code>的起止位置。生成完<code>MatchObject</code>之后，<code>Scanner</code>会更新起始指针到匹配子串的末尾，以便进行下一轮的匹配。</p>
<p>当我们获取到一个<code>MatchObject</code>的时候，我们可以通过调用<code>group(i)</code>取获取每个匹配组匹配到的子串。<code>group(i)</code>最终会落到<code>match_getslice_by_index</code>方法，会根据传进去的<code>i</code>，匹配<code>match-&gt;mark[i]</code>到<code>match-&gt;mark[i + 1]</code>的字串。也就是说，<code>group(0)</code>就是整一个匹配的字符串<code>cde12</code>，而<code>group(1)</code>以及<code>group(2)</code>就对应着两个小括号的匹配组，分别是<code>cde12</code>跟<code>2</code>。这样，我们就完成了整一个匹配的过程。</p>
<p>正则表达式的源码就解析到这里。本文对<code>re</code>库的“正则字符串-&gt;匹配模式-&gt;字符串匹配”这一流程涉及的代码做了详细的讲解，希望各位读者通过阅读这篇文章，能够对正则表达式本身的概念以及python正则表达式的实现由更加深入的理解，也希望一些先前对正则表达式有所纠结的朋友，看完这篇文章之后，能够不再感到纠结，从而提升对正则表达式的掌控力！</p>
<p>最后说一句，笔者决定，Hard Python系列，到此画上句号。希望每一位喜欢<code>python</code>，并且阅读过这个系列的朋友，能够有所感悟，有所收获！技术永不死，望诸君共勉！</p>
]]></content>
      <categories>
        <category>Hard Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>re</tag>
        <tag>正则表达式</tag>
        <tag>pattern</tag>
        <tag>字符串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hard Python】【第五章-字符串】1、unicode，py3的字符串实现</title>
    <url>/2022/05/08/hardpython/5_str_1/</url>
    <content><![CDATA[<p><code>python</code>的字符串实质到底是什么类型的数据，这个可是困扰着很多编程者的话题。在<code>python2</code>我们已经被中文编码相关的问题折磨的不轻，那到了<code>python3</code>之后为什么又解决了这个问题呢？今天这篇文章就带大家详细剖析<code>python3</code>的字符串实现。</p>
<p>我们首先看一段代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_str_basic</span><span class="params">()</span>:</span></span><br><span class="line">    s = <span class="string">'123456789'</span></span><br><span class="line">    print(type(s))</span><br></pre></td></tr></table></figure>
<p>这段代码打印了一个字符串对象的类型，其结果为<code>&lt;class &#39;str&#39;&gt;</code>。<code>str</code>类型从哪里来？从C源码中我们可以搜索到，其来源于<code>unicodeobject.c</code>的<code>PyUnicode_Type</code></p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unicodeobject.c</span></span><br><span class="line">PyTypeObject PyUnicode_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">"str"</span>,                        <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyUnicodeObject),      <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="number">0</span>,                            <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    <span class="comment">/* Slots */</span></span><br><span class="line">    (destructor)unicode_dealloc,  <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                            <span class="comment">/* tp_vectorcall_offset */</span></span><br><span class="line">    <span class="number">0</span>,                            <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                            <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                            <span class="comment">/* tp_as_async */</span></span><br><span class="line">    unicode_repr,                 <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;unicode_as_number,           <span class="comment">/* tp_as_number */</span></span><br><span class="line">    &amp;unicode_as_sequence,         <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    &amp;unicode_as_mapping,          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc) unicode_hash,      <span class="comment">/* tp_hash*/</span></span><br><span class="line">    <span class="number">0</span>,                            <span class="comment">/* tp_call*/</span></span><br><span class="line">    (reprfunc) unicode_str,       <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,      <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                            <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                            <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |</span><br><span class="line">        Py_TPFLAGS_UNICODE_SUBCLASS |</span><br><span class="line">        _Py_TPFLAGS_MATCH_SELF, <span class="comment">/* tp_flags */</span></span><br><span class="line">    unicode_doc,                  <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                            <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                            <span class="comment">/* tp_clear */</span></span><br><span class="line">    PyUnicode_RichCompare,        <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                            <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    unicode_iter,                 <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                            <span class="comment">/* tp_iternext */</span></span><br><span class="line">    unicode_methods,              <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                            <span class="comment">/* tp_members */</span></span><br><span class="line">    <span class="number">0</span>,                            <span class="comment">/* tp_getset */</span></span><br><span class="line">    &amp;PyBaseObject_Type,           <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                            <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                            <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                            <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                            <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                            <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                            <span class="comment">/* tp_alloc */</span></span><br><span class="line">    unicode_new,                  <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_Del,                 <span class="comment">/* tp_free */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对应地，其大小为<code>PyUnicodeObject</code>所占的大小。<code>PyUnicodeObject</code>可表示的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unicodeobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyCompactUnicodeObject _base;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *any;</span><br><span class="line">        Py_UCS1 *latin1;</span><br><span class="line">        Py_UCS2 *ucs2;</span><br><span class="line">        Py_UCS4 *ucs4;</span><br><span class="line">    &#125; data;                     <span class="comment">/* Canonical, smallest-form Unicode buffer */</span></span><br><span class="line">&#125; PyUnicodeObject;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyASCIIObject _base;</span><br><span class="line">    Py_ssize_t utf8_length;     <span class="comment">/* Number of bytes in utf8, excluding the</span></span><br><span class="line"><span class="comment">                                 * terminating \0. */</span></span><br><span class="line">    <span class="keyword">char</span> *utf8;                 <span class="comment">/* UTF-8 representation (null-terminated) */</span></span><br><span class="line">    Py_ssize_t wstr_length;     <span class="comment">/* Number of code points in wstr, possible</span></span><br><span class="line"><span class="comment">                                 * surrogates count as two code points. */</span></span><br><span class="line">&#125; PyCompactUnicodeObject;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    Py_ssize_t length;          <span class="comment">/* Number of code points in the string */</span></span><br><span class="line">    Py_hash_t hash;             <span class="comment">/* Hash value; -1 if not set */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> interned:<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> kind:<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> compact:<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> ascii:<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> ready:<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> :<span class="number">24</span>;</span><br><span class="line">    &#125; state;</span><br><span class="line">    <span class="keyword">wchar_t</span> *wstr;              <span class="comment">/* wchar_t representation (null-terminated) */</span></span><br><span class="line">&#125; PyASCIIObject;</span><br></pre></td></tr></table></figure>
<p>其中，<code>PyUnicodeObject</code>、<code>PyCompactUnicodeObject</code>、<code>PyASCIIObject</code>分别对应三种不同的字符串类型，它们有以下区别：</p>
<ul>
<li><code>PyASCIIObject</code>：通过<code>PyUnicode_New</code>生成的只包含<code>ASCII</code>字符的字符串，字符数据会紧随结构体排列</li>
<li><code>PyCompactUnicodeObject</code>：通过<code>PyUnicode_New</code>生成的包含非<code>ASCII</code>字符的字符串，字符数据会紧随结构体排列</li>
<li><code>PyUnicodeObject</code>：通过<code>PyUnicode_FromUnicode</code>创建</li>
</ul>
<p>其中<code>PyUnicode_FromUnicode</code>是已经过时的方法，因此我们常见的<code>unicode</code>对象是以<code>PyASCIIObject</code>、<code>PyCompactUnicodeObject</code>的形式存在的，也就是说现在我们日常创建的字符串对象，其数据会紧随结构体排列。</p>
<p><code>python</code>的<code>unicode</code>实现是对标标准<code>unicode</code>规范的，因此要深入了解其中原理，我们需要预备一些关于<code>unicode</code>的知识，比如：</p>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy51bmlmb3VuZHJ5LmNvbS91bmljb2RlLXR1dG9yaWFsLmh0bWw=" title="http://www.unifoundry.com/unicode-tutorial.html">unicode tutorial<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWhhbnMvVW5pY29kZQ==" title="https://zh.wikipedia.org/zh-hans/Unicode">unicode wiki<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY3JhenlscXkvcC8xMDE4NDI5MS5odG1s" title="https://www.cnblogs.com/crazylqy/p/10184291.html">彻底弄懂unicode编码<i class="fa fa-external-link"></i></span></li>
</ul>
<p><code>unicode</code>本身存在的意义是将世界上任意一个字符（包括<code>emoji</code>）映射到一个特定的数字，这个数字被称为<code>code point</code>。<code>unicode</code>的<code>code point</code>是分组的，每组<code>65536</code>个，称作为一个个<code>plane</code>。每个<code>unicode</code>字符用4个字节表示，但如果需要进行二进制编码的话，比如存储文件或是网络传输，每个字符都使用4个字节往往会有冗余，因此需要一个比较效率的二进制编码方式，比如：<code>utf8</code>、<code>utf16</code>。</p>
<p><code>utf8</code>编码是最常见的编码之一，其长度可变，但针对不同<code>unicode</code>的<code>code point</code>值，会编码成不同长度的形式，比如<code>ASCII</code>支持的英文在<code>utf8</code>编码里只占1个字节，但汉字可能就是3个字节。在python中，当我们需要把字符串编码成<code>utf8</code>的二进制形式时，就需要<code>string.encode(&#39;utf-8&#39;)</code>的调用，反之假设我们从一个<code>socket</code>接收到<code>utf8</code>编码的数据，需要解码成字符串时，就需要<code>bytestring.decode(&#39;utf-8&#39;)</code>对字符串进行解码。</p>
<p>言归正传，现在我们回到对<code>PyASCIIObject</code>、<code>PyCompactUnicodeObject</code>数据结构的研究当中。首先我们看<code>PyASCIIObject</code>，它有以下几个部分：</p>
<ul>
<li><code>length</code>：字符串的长度，按<code>code point</code>个数计算</li>
<li><code>hash</code>：字符串的hash编码</li>
<li><code>state</code>：字符串状态，用一个完整4字节存储<ul>
<li><code>interned</code>（2）：是否被短字符串缓存，以及是否永久缓存</li>
<li><code>kind</code>（3）：字符串的类型<ul>
<li>0：<code>wide-char</code>宽字符类型</li>
<li>1：<code>1byte</code>，全部字符都可用<code>8bits</code>无符号表示</li>
<li>2：<code>2byte</code>，全部字符都可用<code>16bits</code>无符号表示</li>
<li>4：<code>4byte</code>，全部字符都可用<code>32bits</code>无符号表示</li>
</ul>
</li>
<li><code>compact</code>（1）：字符串数据是否紧凑于结构体排列<ul>
<li>先前提到<code>PyASCIIObject</code>、<code>PyCompactUnicodeObject</code>都是紧凑排列</li>
</ul>
</li>
<li><code>ascii</code>（1）：是否只有<code>ascii</code>字符<ul>
<li>先前<code>kind=1</code>的时候由于是<code>unsigned</code>，因此可以表示除<code>ascii</code>外到200多的字符</li>
</ul>
</li>
<li><code>ready</code>（1）：是否数据已准备完成<ul>
<li>紧凑排列数据，或者非紧凑排列但数据指针已经填好字符串数据，都算<code>read</code>y</li>
</ul>
</li>
<li>24位<code>padding</code></li>
</ul>
</li>
<li><code>wstr</code>：<code>wide-char</code>的字符串表示</li>
</ul>
<p><code>PyASCIIObject</code>用来表示<code>ASCII</code>字符，而含有非<code>ASCII</code>字符的字符串则用<code>PyCompactUnicodeObject</code>表示，其包含以下内容：</p>
<ul>
<li><code>_base</code>：<code>PyASCIIObject</code>的实例</li>
<li><code>utf8_length</code>：除了<code>\0</code>之外，<code>utf8</code>的字符串表示的比特数</li>
<li><code>utf8</code>：<code>utf8</code>的字符串表示</li>
<li><code>wstr_length</code>：wide-char字符串表示里<code>code point</code>的个数</li>
</ul>
<p>而字符串的真实数据则放到了<code>PyUnicodeObject</code>的<code>data</code>当中，以一个<code>union</code>的形式表示不同长度表示的字符串</p>
<p>接下来我们通过一个例子来展示<code>unicode</code>字符串是如何被创建的。我们的代码是字母+汉字+数字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">"abc哈咯123"</span></span><br></pre></td></tr></table></figure>
<p>当这段代码被打入到解释器中，被词法分析器分析时，就会调用字符串创建的逻辑<code>unicode_decode_utf8</code>，将<code>const char</code>类型的原生字符转化为<code>PyUnicodeObject</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unicodeobject.c</span></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">unicode_decode_utf8(<span class="keyword">const</span> <span class="keyword">char</span> *s, Py_ssize_t size,</span><br><span class="line">                    _Py_error_handler error_handler, <span class="keyword">const</span> <span class="keyword">char</span> *errors,</span><br><span class="line">                    Py_ssize_t *consumed)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (consumed)</span><br><span class="line">            *consumed = <span class="number">0</span>;</span><br><span class="line">        _Py_RETURN_UNICODE_EMPTY();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ASCII is equivalent to the first 128 ordinals in Unicode. */</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span> &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">char</span>)s[<span class="number">0</span>] &lt; <span class="number">128</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (consumed) &#123;</span><br><span class="line">            *consumed = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> get_latin1_char((<span class="keyword">unsigned</span> <span class="keyword">char</span>)s[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *starts = s;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *end = s + size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fast path: try ASCII string.</span></span><br><span class="line">    PyObject *u = PyUnicode_New(size, <span class="number">127</span>);</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s += ascii_decode(s, end, PyUnicode_1BYTE_DATA(u));</span><br><span class="line">    <span class="keyword">if</span> (s == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use _PyUnicodeWriter after fast path is failed.</span></span><br><span class="line">    _PyUnicodeWriter writer;</span><br><span class="line">    _PyUnicodeWriter_InitWithBuffer(&amp;writer, u);</span><br><span class="line">    writer.pos = s - starts;</span><br><span class="line"></span><br><span class="line">    Py_ssize_t startinpos, endinpos;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *errmsg = <span class="string">""</span>;</span><br><span class="line">    PyObject *error_handler_obj = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *exc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (s &lt; end) &#123;</span><br><span class="line">        Py_UCS4 ch;</span><br><span class="line">        <span class="keyword">int</span> kind = writer.kind;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kind == PyUnicode_1BYTE_KIND) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PyUnicode_IS_ASCII(writer.buffer))</span><br><span class="line">                ch = asciilib_utf8_decode(&amp;s, end, writer.data, &amp;writer.pos);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ch = ucs1lib_utf8_decode(&amp;s, end, writer.data, &amp;writer.pos);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (kind == PyUnicode_2BYTE_KIND) &#123;</span><br><span class="line">            ch = ucs2lib_utf8_decode(&amp;s, end, writer.data, &amp;writer.pos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(kind == PyUnicode_4BYTE_KIND);</span><br><span class="line">            ch = ucs4lib_utf8_decode(&amp;s, end, writer.data, &amp;writer.pos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> (s == end || consumed)</span><br><span class="line">                <span class="keyword">goto</span> End;</span><br><span class="line">            errmsg = <span class="string">"unexpected end of data"</span>;</span><br><span class="line">            startinpos = s - starts;</span><br><span class="line">            endinpos = end - starts;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            errmsg = <span class="string">"invalid start byte"</span>;</span><br><span class="line">            startinpos = s - starts;</span><br><span class="line">            endinpos = startinpos + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> (consumed &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">char</span>)s[<span class="number">0</span>] == <span class="number">0xED</span> &amp;&amp; end - s == <span class="number">2</span></span><br><span class="line">                &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">char</span>)s[<span class="number">1</span>] &gt;= <span class="number">0xA0</span> &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">char</span>)s[<span class="number">1</span>] &lt;= <span class="number">0xBF</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* Truncated surrogate code in range D800-DFFF */</span></span><br><span class="line">                <span class="keyword">goto</span> End;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* fall through */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            errmsg = <span class="string">"invalid continuation byte"</span>;</span><br><span class="line">            startinpos = s - starts;</span><br><span class="line">            endinpos = startinpos + ch - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span> (_PyUnicodeWriter_WriteCharInline(&amp;writer, ch) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> onError;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// case 1、3、4的逻辑，会获取不同类型的error_handler，这里先忽略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">End:</span><br><span class="line">    <span class="keyword">if</span> (consumed)</span><br><span class="line">        *consumed = s - starts;</span><br><span class="line"></span><br><span class="line">    Py_XDECREF(error_handler_obj);</span><br><span class="line">    Py_XDECREF(exc);</span><br><span class="line">    <span class="keyword">return</span> _PyUnicodeWriter_Finish(&amp;writer);</span><br><span class="line"></span><br><span class="line">onError:</span><br><span class="line">    Py_XDECREF(error_handler_obj);</span><br><span class="line">    Py_XDECREF(exc);</span><br><span class="line">    _PyUnicodeWriter_Dealloc(&amp;writer);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>unicode_decode_utf8</code>做了以下几件事情：</p>
<ul>
<li>当<code>size</code>为1并且第一个字符值小于128时，通过<code>get_latin1_char</code>方法获取<code>unicode</code>实例</li>
<li>采用<code>PyUnicode_New</code>初始化<code>unicode</code>实例并预设最大字符值为127，然后先尝试用<code>ascii_decode</code>将原生字符串转换为一个<code>ascii</code>的<code>unicode</code>实例<ul>
<li>如果成功就<code>return</code>了</li>
<li>如果没成功，<code>s</code>会停在第一个非<code>ascii</code>字符的前面<ul>
<li>在上面的例子里，<code>s</code>也就表示<code>&quot;哈咯123&quot;</code></li>
</ul>
</li>
</ul>
</li>
<li>以先前的<code>unicode</code>实例为<code>buffer</code>，初始化<code>PyUnicodeWriter</code>实例处理非<code>ASCII</code>字符串，循环处理剩余的字符，写入到<code>buffer</code><ul>
<li><code>PyUnicodeWriter</code>实例默认的<code>kind</code>为<code>PyUnicode_1BYTE_KIND</code>。一般第一个字符会走到<code>asciilib_utf8_decode</code>逻辑，这个逻辑如果发现字符越界，会返回字符实际的<code>code point</code>值</li>
</ul>
</li>
<li>发现第一个字符越界不能用<code>ASCII</code>表示，调用<code>_PyUnicodeWriter_WriteCharInline</code>逻辑写入字符<ul>
<li>调用<code>_PyUnicodeWriter_Prepare</code>逻辑，其中会根据第一个字符的值大小决定<code>writer</code>写入的字符类型<code>kind</code><ul>
<li>汉字<code>&quot;哈&quot;</code>对应<code>code point</code>值为<code>27014</code>，即<code>\u54c8</code>。因此<code>writer</code>将<code>kind</code>调整到<code>PyUnicode_2BYTE_KIND</code>，以适配汉字<code>&quot;哈&quot;</code>的写入</li>
</ul>
</li>
<li>调用<code>PyUnicode_WRITE</code>，写入字符<code>&quot;哈&quot;</code>到<code>buffer</code></li>
</ul>
</li>
<li><code>writer.kind</code>为<code>PyUnicode_2BYTE_KIND</code>，下一个循环之后，调用<code>ucs2lib_utf8_decode</code>方法<ul>
<li>由于汉字基本是<code>PyUnicode_2BYTE_KIND</code>，通过<code>ucs2lib_utf8_decode</code>方法，就能把后面所有的字符都进行处理</li>
</ul>
</li>
<li>调用<code>_PyUnicodeWriter_Finish</code>，生成最终的<code>unicode</code>实例<ul>
<li>调用<code>resize_compact</code>，重新调整<code>unicode</code>实例数据</li>
</ul>
</li>
</ul>
<p>通过以上的操作，一个<code>unicode</code>字符串实例就生成了。</p>
]]></content>
      <categories>
        <category>Hard Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>字符串</tag>
        <tag>str</tag>
        <tag>unicode</tag>
        <tag>utf8</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hard Python】【第四章-日志】2、日志消费者Handler的实现</title>
    <url>/2022/04/16/hardpython/4_log_2/</url>
    <content><![CDATA[<p>在<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjIvMDQvMDkvaGFyZHB5dGhvbi80X2xvZ18xLw==" title="https://utmhikari.top/2022/04/09/hardpython/4_log_1/">上篇文章<i class="fa fa-external-link"></i></span>里说完了日志实例<code>Logger</code>和日志管理<code>Manager</code>，现在该提到<code>Handler</code>了。<code>Handler</code>是日志信息的消费者，单个<code>Logger</code>实例注册多个<code>Handler</code>，每生成一个<code>LogRecord</code>，就会被合法的<code>Handler</code>消费，在不同地方打印出日志信息。</p>
<p>要研究<code>Handler</code>，首先需要看下基类的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span><span class="params">(Filterer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self, record)</span>:</span></span><br><span class="line">        rv = self.filter(record)</span><br><span class="line">        <span class="keyword">if</span> rv:</span><br><span class="line">            self.acquire()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.emit(record)</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self.release()</span><br><span class="line">        <span class="keyword">return</span> rv</span><br></pre></td></tr></table></figure>
<p><code>Handler</code>会通过自带的重入锁限制日志记录被串行处理。<code>Handler</code>也是继承<code>Filterer</code>，首先会通过<code>filter</code>过滤日志是否满足<code>Handler</code>的要求，如果合法，然后调用<code>emit</code>方法处理日志。</p>
<p><code>emit</code>方法在基类是<code>NotImplemented</code>，需要子类加以实现。因此接下来我们具体抽几个例子来看。</p>
<a id="more"></a>
<h2 id="StreamHandler"><a href="#StreamHandler" class="headerlink" title="StreamHandler"></a>StreamHandler</h2><p><code>StreamHandler</code>打印日志的实现比较简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamHandler</span><span class="params">(Handler)</span>:</span></span><br><span class="line">    terminator = <span class="string">'\n'</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">emit</span><span class="params">(self, record)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            msg = self.format(record)</span><br><span class="line">            stream = self.stream</span><br><span class="line">            <span class="comment"># issue 35046: merged two stream.writes into one.</span></span><br><span class="line">            stream.write(msg + self.terminator)</span><br><span class="line">            self.flush()</span><br><span class="line">        <span class="keyword">except</span> RecursionError:  <span class="comment"># See issue 36272</span></span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            self.handleError(record)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flush</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> self.stream <span class="keyword">and</span> hasattr(self.stream, <span class="string">"flush"</span>):</span><br><span class="line">                self.stream.flush()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self.release()</span><br></pre></td></tr></table></figure>
<p><code>StreamHandler</code>默认的<code>stream</code>是<code>sys.stderr</code>。只要我们在<code>basicConfig</code>中给到的<code>stream</code>实例实现了<code>write</code>跟<code>flush</code>方法，就可以被放到<code>StreamHandler</code>里头处理日志。日志首先通过<code>format</code>方法被<code>Handler</code>实例的<code>formatter</code>格式化，然后再被输出。</p>
<p>以<code>sys.stderr</code>为例，我们来看标准错误流在<code>python</code>中的源码实现。首先需要追溯<code>sys.stderr</code>的来源，我们节选一部分代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pylifecycle.c</span></span><br><span class="line"><span class="keyword">static</span> PyStatus</span><br><span class="line">init_sys_streams(PyThreadState *tstate)</span><br><span class="line">&#123;</span><br><span class="line">    fd = fileno(<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">std</span> = create_stdio(config, iomod, fd, <span class="number">1</span>, <span class="string">"&lt;stderr&gt;"</span>,</span><br><span class="line">                       config-&gt;stdio_encoding,</span><br><span class="line">                       <span class="string">L"backslashreplace"</span>);</span><br><span class="line">    <span class="keyword">if</span> (PySys_SetObject(<span class="string">"__stderr__"</span>, <span class="built_in">std</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Py_DECREF(<span class="built_in">std</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_PySys_SetObjectId(&amp;PyId_stderr, <span class="built_in">std</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Py_DECREF(<span class="built_in">std</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(<span class="built_in">std</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyObject*</span><br><span class="line">create_stdio(<span class="keyword">const</span> PyConfig *config, PyObject* io,</span><br><span class="line">    <span class="keyword">int</span> fd, <span class="keyword">int</span> write_mode, <span class="keyword">const</span> <span class="keyword">char</span>* name,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">wchar_t</span>* encoding, <span class="keyword">const</span> <span class="keyword">wchar_t</span>* errors)</span><br><span class="line">&#123;</span><br><span class="line">    buf = _PyObject_CallMethodId(io, &amp;PyId_open, <span class="string">"isiOOOO"</span>,</span><br><span class="line">                                 fd, mode, buffering,</span><br><span class="line">                                 Py_None, Py_None, <span class="comment">/* encoding, errors */</span></span><br><span class="line">                                 Py_None, Py_False); <span class="comment">/* newline, closefd */</span></span><br><span class="line">    stream = _PyObject_CallMethodId(io, &amp;PyId_TextIOWrapper, <span class="string">"OOOsOO"</span>,</span><br><span class="line">                                    buf, encoding_str, errors_str,</span><br><span class="line">                                    newline, line_buffering, write_through);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>pylifecycle.c</code>中，<code>sys.stderr</code>被设置，最终调用了<code>create_stdio</code>设置了<code>stream</code>实例。其中，会调用<code>io</code>模块的<code>open</code>以及<code>TextIOWrapper</code>方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _iomodule.c</span></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">_io_open_impl(PyObject *<span class="keyword">module</span>, PyObject *file, <span class="keyword">const</span> <span class="keyword">char</span> *mode,</span><br><span class="line">              <span class="keyword">int</span> buffering, <span class="keyword">const</span> <span class="keyword">char</span> *encoding, <span class="keyword">const</span> <span class="keyword">char</span> *errors,</span><br><span class="line">              <span class="keyword">const</span> <span class="keyword">char</span> *newline, <span class="keyword">int</span> closefd, PyObject *opener)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Create the Raw file stream */</span></span><br><span class="line">    &#123;</span><br><span class="line">        PyObject *RawIO_class = (PyObject *)&amp;PyFileIO_Type;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MS_WINDOWS</span></span><br><span class="line">        <span class="keyword">const</span> PyConfig *config = _Py_GetConfig();</span><br><span class="line">        <span class="keyword">if</span> (!config-&gt;legacy_windows_stdio &amp;&amp; _PyIO_get_console_type(path_or_fd) != <span class="string">'\0'</span>) &#123;</span><br><span class="line">            RawIO_class = (PyObject *)&amp;PyWindowsConsoleIO_Type;</span><br><span class="line">            encoding = <span class="string">"utf-8"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        raw = PyObject_CallFunction(RawIO_class, <span class="string">"OsOO"</span>,</span><br><span class="line">                                    path_or_fd, rawmode,</span><br><span class="line">                                    closefd ? Py_True : Py_False,</span><br><span class="line">                                    opener);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* wraps into a buffered file */</span></span><br><span class="line">    &#123;</span><br><span class="line">        PyObject *Buffered_class;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (updating)</span><br><span class="line">            Buffered_class = (PyObject *)&amp;PyBufferedRandom_Type;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (creating || writing || appending)</span><br><span class="line">            Buffered_class = (PyObject *)&amp;PyBufferedWriter_Type;  <span class="comment">// hits here</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (reading)</span><br><span class="line">            Buffered_class = (PyObject *)&amp;PyBufferedReader_Type;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            PyErr_Format(PyExc_ValueError,</span><br><span class="line">                         <span class="string">"unknown mode: '%s'"</span>, mode);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buffer = PyObject_CallFunction(Buffered_class, <span class="string">"Oi"</span>, raw, buffering);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    result = buffer;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* if binary, returns the buffered file */</span></span><br><span class="line">    <span class="keyword">if</span> (binary) &#123;</span><br><span class="line">        Py_DECREF(modeobj);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以总的来看，在<code>windows</code>中，<code>stderr</code>实例的创建流程大致是这样：</p>
<ul>
<li>创建了一个<code>PyWindowsConsoleIO_Type</code>的实例<ul>
<li><code>PyWindowsConsoleIO_Type</code>实质是封装了和<code>windows</code>命令行终端交互的方法</li>
</ul>
</li>
<li>创建了一个<code>PyBufferedWriter_Type</code>实例去实现缓冲输出流<ul>
<li>该实例的<code>raw</code>属性即为<code>PyWindowsConsoleIO_Type</code>的实例</li>
</ul>
</li>
<li>创建了一个<code>TextIOWrapper</code>实例封装<code>PyBufferedWriter_Type</code>实例，得到<code>stderr</code>的<code>stream</code>实例</li>
</ul>
<p>当调用<code>stderr.write</code>和<code>stderr.flush</code>时，最终会调用<code>BufferedWriter</code>的<code>write</code>和<code>flush</code>。在<code>write</code>过程中会将数据写入缓冲区，而在<code>write</code>跟<code>flush</code>过程中都会调用<code>raw.write</code>方法尝试将缓冲区数据刷掉，并写入<code>windows</code>命令行。有兴趣的同学，可以深入研究<code>bufferedio.c</code>里面的内容。</p>
<h2 id="FileHandler"><a href="#FileHandler" class="headerlink" title="FileHandler"></a>FileHandler</h2><p><code>FileHandler</code>继承了<code>StreamHandler</code>，可以将日志记录打印到文件里面，其代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span><span class="params">(StreamHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename, mode=<span class="string">'a'</span>, encoding=None, delay=False, errors=None)</span>:</span></span><br><span class="line">        filename = os.fspath(filename)</span><br><span class="line">        self.baseFilename = os.path.abspath(filename)</span><br><span class="line">        self.mode = mode</span><br><span class="line">        self.encoding = encoding</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"b"</span> <span class="keyword">not</span> <span class="keyword">in</span> mode:</span><br><span class="line">            self.encoding = io.text_encoding(encoding)</span><br><span class="line">        self.errors = errors</span><br><span class="line">        self.delay = delay</span><br><span class="line">        self._builtin_open = open</span><br><span class="line">        <span class="keyword">if</span> delay:</span><br><span class="line">            Handler.__init__(self)</span><br><span class="line">            self.stream = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            StreamHandler.__init__(self, self._open())</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_open</span><span class="params">(self)</span>:</span></span><br><span class="line">        open_func = self._builtin_open</span><br><span class="line">        <span class="keyword">return</span> open_func(self.baseFilename, self.mode,</span><br><span class="line">                         encoding=self.encoding, errors=self.errors)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">emit</span><span class="params">(self, record)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.stream <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.stream = self._open()</span><br><span class="line">        StreamHandler.emit(self, record)</span><br></pre></td></tr></table></figure>
<p><code>FileHandler</code>为<code>StreamHandler</code>底层提供了一个内置<code>open</code>方法文件流。我们知道这样的文件流也会有<code>write</code>以及<code>flush</code>方法，所以显而易见日志会输出到对应的文件当中。</p>
<h2 id="TimedRotatingFileHandler"><a href="#TimedRotatingFileHandler" class="headerlink" title="TimedRotatingFileHandler"></a>TimedRotatingFileHandler</h2><p><code>TimedRotatingFileHandler</code>也是常用的日志<code>Handler</code>之一，它可以实现按规定的时间间隔打印各个时段的日志到不同文件中。其继承链如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># pprint.pprint(TimedRotatingFileHandler.__mro__)</span><br><span class="line">(&lt;class &apos;logging.handlers.TimedRotatingFileHandler&apos;&gt;,</span><br><span class="line"> &lt;class &apos;logging.handlers.BaseRotatingHandler&apos;&gt;,</span><br><span class="line"> &lt;class &apos;logging.FileHandler&apos;&gt;,</span><br><span class="line"> &lt;class &apos;logging.StreamHandler&apos;&gt;,</span><br><span class="line"> &lt;class &apos;logging.Handler&apos;&gt;,</span><br><span class="line"> &lt;class &apos;logging.Filterer&apos;&gt;,</span><br><span class="line"> &lt;class &apos;object&apos;&gt;)</span><br></pre></td></tr></table></figure>
<p>首先我们来看<code>BaseRotatingHandler</code>，它继承了<code>FileHandler</code>，其实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseRotatingHandler</span><span class="params">(logging.FileHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">emit</span><span class="params">(self, record)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> self.shouldRollover(record):</span><br><span class="line">                self.doRollover()</span><br><span class="line">            logging.FileHandler.emit(self, record)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            self.handleError(record)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, source, dest)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> callable(self.rotator):</span><br><span class="line">            <span class="keyword">if</span> os.path.exists(source):</span><br><span class="line">                os.rename(source, dest)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.rotator(source, dest)</span><br></pre></td></tr></table></figure>
<p><code>BaseRotatingHandler</code>在打印日志记录前，首先会通过<code>shouldRollover</code>方法根据日志记录信息判断是否要翻篇，如果需要的话就调用<code>doRollOver</code>方法翻篇，最后再调用<code>FileHandler</code>的<code>emit</code>方法。<code>shouldRollover</code>跟<code>doRollover</code>方法都需要子类自己实现。</p>
<p>同时，<code>BaseRotatingHandler</code>也提供了<code>rotate</code>方法调用<code>rotator</code>或者采用默认重命名的方式执行翻篇操作。</p>
<p>接下来我们再看<code>TimedRotatingFileHandler</code>的具体实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimedRotatingFileHandler</span><span class="params">(BaseRotatingHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename, when=<span class="string">'h'</span>, interval=<span class="number">1</span>, backupCount=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 encoding=None, delay=False, utc=False, atTime=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 errors=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> os.path.exists(filename):</span><br><span class="line">            t = os.stat(filename)[ST_MTIME]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t = int(time.time())</span><br><span class="line">        self.rolloverAt = self.computeRollover(t)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">computeRollover</span><span class="params">(self, currentTime)</span>:</span></span><br><span class="line">        result = currentTime + self.interval</span><br><span class="line">        <span class="keyword">if</span> self.when == <span class="string">'MIDNIGHT'</span> <span class="keyword">or</span> self.when.startswith(<span class="string">'W'</span>):</span><br><span class="line">            <span class="comment"># 这里忽略掉计算凌晨跟一周内特定日的情况</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shouldRollover</span><span class="params">(self, record)</span>:</span></span><br><span class="line">        t = int(time.time())</span><br><span class="line">        <span class="keyword">if</span> t &gt;= self.rolloverAt:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doRollover</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.stream:</span><br><span class="line">            self.stream.close()</span><br><span class="line">            self.stream = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># get the time that this sequence started at and make it a TimeTuple</span></span><br><span class="line">        currentTime = int(time.time())</span><br><span class="line">        dstNow = time.localtime(currentTime)[<span class="number">-1</span>]</span><br><span class="line">        t = self.rolloverAt - self.interval</span><br><span class="line">        <span class="keyword">if</span> self.utc:</span><br><span class="line">            timeTuple = time.gmtime(t)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            timeTuple = time.localtime(t)</span><br><span class="line">            dstThen = timeTuple[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> dstNow != dstThen:</span><br><span class="line">                <span class="keyword">if</span> dstNow:</span><br><span class="line">                    addend = <span class="number">3600</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    addend = <span class="number">-3600</span></span><br><span class="line">                timeTuple = time.localtime(t + addend)</span><br><span class="line">        dfn = self.rotation_filename(self.baseFilename + <span class="string">"."</span> +</span><br><span class="line">                                     time.strftime(self.suffix, timeTuple))</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(dfn):</span><br><span class="line">            os.remove(dfn)</span><br><span class="line">        self.rotate(self.baseFilename, dfn)</span><br><span class="line">        <span class="keyword">if</span> self.backupCount &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> self.getFilesToDelete():</span><br><span class="line">                os.remove(s)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.delay:</span><br><span class="line">            self.stream = self._open()</span><br><span class="line">        newRolloverAt = self.computeRollover(currentTime)</span><br><span class="line">        <span class="keyword">while</span> newRolloverAt &lt;= currentTime:</span><br><span class="line">            newRolloverAt = newRolloverAt + self.interval</span><br><span class="line">        <span class="comment">#If DST changes and midnight or weekly rollover, adjust for this.</span></span><br><span class="line">        <span class="keyword">if</span> (self.when == <span class="string">'MIDNIGHT'</span> <span class="keyword">or</span> self.when.startswith(<span class="string">'W'</span>)) <span class="keyword">and</span> <span class="keyword">not</span> self.utc:</span><br><span class="line">            dstAtRollover = time.localtime(newRolloverAt)[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> dstNow != dstAtRollover:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> dstNow:  <span class="comment"># DST kicks in before next rollover, so we need to deduct an hour</span></span><br><span class="line">                    addend = <span class="number">-3600</span></span><br><span class="line">                <span class="keyword">else</span>:           <span class="comment"># DST bows out before next rollover, so we need to add an hour</span></span><br><span class="line">                    addend = <span class="number">3600</span></span><br><span class="line">                newRolloverAt += addend</span><br><span class="line">        self.rolloverAt = newRolloverAt</span><br></pre></td></tr></table></figure>
<p>在初始化的过程中，首先会解析时间设定计算时间间隔<code>interval</code>，然后通过<code>computeRollover</code>初始化<code>rolloverAt</code>，也就是翻篇的时间点。在<code>emit</code>的时候，也会直接通过当前时间判断是否超过翻篇时间，超过的话，就会执行<code>doRollover</code>。</p>
<p><code>doRollover</code>总共做了这几件事情：</p>
<ul>
<li>关闭当前文件流</li>
<li>根据当前时间生成需要归档的日志文件名</li>
<li>执行翻篇，将当前日志文件重命名，归档标注为特定时间</li>
<li>删除冗余的旧文件</li>
<li>如果不是lazy-load，直接调用<code>_open</code>生成新的文件</li>
<li>计算新的翻篇时间点</li>
</ul>
<p>可以看到，<code>baseFilename</code>其实是个中间态的文件名，实质翻篇操作会是重命名文件，修改为带特定时间信息的文件名。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在<code>logging.handlers</code>里，除了上述三种<code>handler</code>外，还有许许多多的<code>handler</code>定义。有兴趣的同学可以自行挖掘！</p>
]]></content>
      <categories>
        <category>Hard Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>日志</tag>
        <tag>Handler</tag>
        <tag>stderr</tag>
        <tag>TimedRotatingFileHandler</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hard Python】【第四章-日志】1、Logger与Manager的源码实现</title>
    <url>/2022/04/09/hardpython/4_log_1/</url>
    <content><![CDATA[<p>python语言内置了一个强大的日志模块<code>logging</code>，也是python内部最为复杂的功能模块之一，通过这个模块我们能够实现不同样式的日志打印。关于<code>logging</code>模块的官方文档也非常完备：</p>
<ul>
<li>logging的用法<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvemgtY24vMy9ob3d0by9sb2dnaW5nLmh0bWwjbG9nZ2luZy1iYXNpYy10dXRvcmlhbA==" title="https://docs.python.org/zh-cn/3/howto/logging.html#logging-basic-tutorial">日志常用指引<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvemgtY24vMy9ob3d0by9sb2dnaW5nLWNvb2tib29rLmh0bWwjbG9nZ2luZy1jb29rYm9vaw==" title="https://docs.python.org/zh-cn/3/howto/logging-cookbook.html#logging-cookbook">日志操作手册<i class="fa fa-external-link"></i></span></li>
</ul>
</li>
<li>logging API<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvemgtY24vMy9saWJyYXJ5L2xvZ2dpbmcuaHRtbCM=" title="https://docs.python.org/zh-cn/3/library/logging.html#">logging日志记录工具<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvemgtY24vMy9saWJyYXJ5L2xvZ2dpbmcuY29uZmlnLmh0bWw=" title="https://docs.python.org/zh-cn/3/library/logging.config.html">logging config<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvemgtY24vMy9saWJyYXJ5L2xvZ2dpbmcuaGFuZGxlcnMuaHRtbA==" title="https://docs.python.org/zh-cn/3/library/logging.handlers.html">logging handlers<i class="fa fa-external-link"></i></span></li>
</ul>
</li>
</ul>
<p>为此，本文起我们对python的<code>logging</code>模块进行深入剖析，从而让大家能够更好地掌握python的<code>logging</code>模块。</p>
<a id="more"></a>
<h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>我们首先从一段最基本的代码入手：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_basic_config</span><span class="params">()</span>:</span></span><br><span class="line">    logging.basicConfig(stream=sys.stdout, level=logging.INFO)</span><br><span class="line">    logging.info(<span class="string">'helloworld'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test_basic_config()</span><br></pre></td></tr></table></figure>
<p>从语义上看，代码的含义是：设置日志基础配置为打印到标准输出流，只接受<code>INFO</code>级别以上的日志。很明显，打印出来的结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO:root:helloworld</span><br></pre></td></tr></table></figure>
<p>我们来看下在源代码里面具体做了什么。首先从<code>logging.basicConfig</code>看起，该方法为<code>logging</code>系统设定了基础配置。其代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># logging/__init__.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">basicConfig</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    _acquireLock()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        force = kwargs.pop(<span class="string">'force'</span>, <span class="literal">False</span>)</span><br><span class="line">        encoding = kwargs.pop(<span class="string">'encoding'</span>, <span class="literal">None</span>)</span><br><span class="line">        errors = kwargs.pop(<span class="string">'errors'</span>, <span class="string">'backslashreplace'</span>)</span><br><span class="line">        <span class="keyword">if</span> force:</span><br><span class="line">            <span class="keyword">for</span> h <span class="keyword">in</span> root.handlers[:]:</span><br><span class="line">                root.removeHandler(h)</span><br><span class="line">                h.close()</span><br><span class="line">        <span class="keyword">if</span> len(root.handlers) == <span class="number">0</span>:</span><br><span class="line">            handlers = kwargs.pop(<span class="string">"handlers"</span>, <span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">if</span> handlers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="string">"stream"</span> <span class="keyword">in</span> kwargs <span class="keyword">and</span> <span class="string">"filename"</span> <span class="keyword">in</span> kwargs:</span><br><span class="line">                    <span class="keyword">raise</span> ValueError(<span class="string">"'stream' and 'filename' should not be "</span></span><br><span class="line">                                     <span class="string">"specified together"</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="string">"stream"</span> <span class="keyword">in</span> kwargs <span class="keyword">or</span> <span class="string">"filename"</span> <span class="keyword">in</span> kwargs:</span><br><span class="line">                    <span class="keyword">raise</span> ValueError(<span class="string">"'stream' or 'filename' should not be "</span></span><br><span class="line">                                     <span class="string">"specified together with 'handlers'"</span>)</span><br><span class="line">            <span class="keyword">if</span> handlers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                filename = kwargs.pop(<span class="string">"filename"</span>, <span class="literal">None</span>)</span><br><span class="line">                mode = kwargs.pop(<span class="string">"filemode"</span>, <span class="string">'a'</span>)</span><br><span class="line">                <span class="keyword">if</span> filename:</span><br><span class="line">                    <span class="keyword">if</span> <span class="string">'b'</span> <span class="keyword">in</span> mode:</span><br><span class="line">                        errors = <span class="literal">None</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        encoding = io.text_encoding(encoding)</span><br><span class="line">                    h = FileHandler(filename, mode,</span><br><span class="line">                                    encoding=encoding, errors=errors)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stream = kwargs.pop(<span class="string">"stream"</span>, <span class="literal">None</span>)</span><br><span class="line">                    h = StreamHandler(stream)</span><br><span class="line">                handlers = [h]</span><br><span class="line">            dfs = kwargs.pop(<span class="string">"datefmt"</span>, <span class="literal">None</span>)</span><br><span class="line">            style = kwargs.pop(<span class="string">"style"</span>, <span class="string">'%'</span>)</span><br><span class="line">            <span class="keyword">if</span> style <span class="keyword">not</span> <span class="keyword">in</span> _STYLES:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">'Style must be one of: %s'</span> % <span class="string">','</span>.join(</span><br><span class="line">                                 _STYLES.keys()))</span><br><span class="line">            fs = kwargs.pop(<span class="string">"format"</span>, _STYLES[style][<span class="number">1</span>])</span><br><span class="line">            fmt = Formatter(fs, dfs, style)</span><br><span class="line">            <span class="keyword">for</span> h <span class="keyword">in</span> handlers:</span><br><span class="line">                <span class="keyword">if</span> h.formatter <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    h.setFormatter(fmt)</span><br><span class="line">                root.addHandler(h)</span><br><span class="line">            level = kwargs.pop(<span class="string">"level"</span>, <span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">if</span> level <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                root.setLevel(level)</span><br><span class="line">            <span class="keyword">if</span> kwargs:</span><br><span class="line">                keys = <span class="string">', '</span>.join(kwargs.keys())</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">'Unrecognised argument(s): %s'</span> % keys)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        _releaseLock()</span><br></pre></td></tr></table></figure>
<p>传入的参数是<code>unpacked mapping</code>式的<code>kwargs</code>，会在代码里面被<code>pop</code>出来然后根据实际配置值进行配置设定。我们先来看看其中具体由执行哪些逻辑：</p>
<ul>
<li>如果<code>force</code>参数被启用，会调用<code>root.removeHandler</code>方法清空<code>handlers</code></li>
<li><code>handlers</code>/<code>stream</code>/<code>filename</code>的共存检查<ul>
<li>可以推测到，这三个概念实际都指代日志的输出目标</li>
</ul>
</li>
<li>如果指定<code>filename</code>，就创建一个<code>FileHandler</code>实例<ul>
<li>写入模式、编码错误处理等参数也会从<code>kwargs</code>里取出，实际就是<code>open</code>里面的参数</li>
</ul>
</li>
<li>如果指定<code>stream</code>，就创建一个<code>StreamHandler</code>实例</li>
<li>根据<code>datefmt</code>、<code>style</code>、<code>format</code>配置，创建一个<code>Formatter</code>实例，给到所有的<code>handler</code>实例</li>
<li>根据<code>level</code>配置，设置<code>root</code>的<code>level</code>属性</li>
</ul>
<p>总的来看，这个流程出现了3个新概念：</p>
<ul>
<li><code>root</code>，实际是一个<code>RootLogger(WARNING)</code>实例</li>
<li><code>handler</code></li>
<li><code>formatter</code>：是<code>handler</code>的属性之一，用来格式化日志信息</li>
</ul>
<p>本篇文章里面我们首先看<code>root</code>，也就是<code>Logger</code>相关的内容。后面再看<code>handler</code>之类的例子。</p>
<h2 id="Logger的实现"><a href="#Logger的实现" class="headerlink" title="Logger的实现"></a>Logger的实现</h2><p>要看<code>Logger</code>，我们可以从<code>RootLogger</code>看起，其代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">root = RootLogger(WARNING)</span><br><span class="line">Logger.root = root</span><br><span class="line">Logger.manager = Manager(Logger.root)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootLogger</span><span class="params">(Logger)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, level)</span>:</span></span><br><span class="line">        Logger.__init__(self, <span class="string">"root"</span>, level)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getLogger, ()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getLogger</span><span class="params">(name=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> name <span class="keyword">or</span> isinstance(name, str) <span class="keyword">and</span> name == root.name:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">return</span> Logger.manager.getLogger(name)</span><br></pre></td></tr></table></figure>
<p><code>RootLogger</code>继承了<code>Logger</code>，<code>__init__</code>中实际上是创建了名为<code>root</code>的<code>Logger</code>。此外，<code>RootLogger</code>还定义了<code>__reduce__</code>函数用于在序列化/反序列化时支持实例的解析。</p>
<p>这里我们能够推测到，<code>Logger.manager</code>实例会对<code>Logger</code>实例进行管理。因此首先我们看下<code>Logger</code>本身，然后再看下<code>Manager</code>里面。</p>
<p>我们从打印日志的逻辑看起。假使我们调用<code>Logger</code>实例的<code>info</code>方法打印日志，实际会涉及到这些代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span><span class="params">(Filterer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(self, msg, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.isEnabledFor(INFO):</span><br><span class="line">            self._log(INFO, msg, args, **kwargs)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEnabledFor</span><span class="params">(self, level)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.disabled:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self._cache[level]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            _acquireLock()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> self.manager.disable &gt;= level:</span><br><span class="line">                    is_enabled = self._cache[level] = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    is_enabled = self._cache[level] = (</span><br><span class="line">                        level &gt;= self.getEffectiveLevel()</span><br><span class="line">                    )</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                _releaseLock()</span><br><span class="line">            <span class="keyword">return</span> is_enabled</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getEffectiveLevel</span><span class="params">(self)</span>:</span></span><br><span class="line">        logger = self</span><br><span class="line">        <span class="keyword">while</span> logger:</span><br><span class="line">            <span class="keyword">if</span> logger.level:</span><br><span class="line">                <span class="keyword">return</span> logger.level</span><br><span class="line">            logger = logger.parent</span><br><span class="line">        <span class="keyword">return</span> NOTSET</span><br></pre></td></tr></table></figure>
<p>在<code>info</code>逻辑开头，会调用<code>isEnabledFor</code>方法判断当前设置的日志级别<code>level</code>是否合法。判断的依据是先看<code>manager</code>的<code>disable</code>设定，然后再看自己是否有设定<code>level</code>，如果还没有的话就一直在父<code>logger</code>里面找，直到看到设定的<code>level</code>，然后进行大小比较。</p>
<p>从这里我们也可以看到，<code>logger</code>实例之间是会存在层级关系的。具体后面慢慢说。</p>
<p>之后就会调用<code>_log</code>方法真正打印日志，其实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span><span class="params">(Filterer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_log</span><span class="params">(self, level, msg, args, exc_info=None, extra=None, stack_info=False,</span></span></span><br><span class="line"><span class="function"><span class="params">             stacklevel=<span class="number">1</span>)</span>:</span></span><br><span class="line">        sinfo = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> _srcfile:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                fn, lno, func, sinfo = self.findCaller(stack_info, stacklevel)</span><br><span class="line">            <span class="keyword">except</span> ValueError: <span class="comment"># pragma: no cover</span></span><br><span class="line">                fn, lno, func = <span class="string">"(unknown file)"</span>, <span class="number">0</span>, <span class="string">"(unknown function)"</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># pragma: no cover</span></span><br><span class="line">            fn, lno, func = <span class="string">"(unknown file)"</span>, <span class="number">0</span>, <span class="string">"(unknown function)"</span></span><br><span class="line">        <span class="keyword">if</span> exc_info:</span><br><span class="line">            <span class="keyword">if</span> isinstance(exc_info, BaseException):</span><br><span class="line">                exc_info = (type(exc_info), exc_info, exc_info.__traceback__)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> isinstance(exc_info, tuple):</span><br><span class="line">                exc_info = sys.exc_info()</span><br><span class="line">        record = self.makeRecord(self.name, level, fn, lno, msg, args,</span><br><span class="line">                                 exc_info, func, extra, sinfo)</span><br><span class="line">        self.handle(record)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCaller</span><span class="params">(self, stack_info=False, stacklevel=<span class="number">1</span>)</span>:</span></span><br><span class="line">        f = currentframe()</span><br><span class="line">        <span class="keyword">if</span> f <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            f = f.f_back</span><br><span class="line">        orig_f = f</span><br><span class="line">        <span class="keyword">while</span> f <span class="keyword">and</span> stacklevel &gt; <span class="number">1</span>:</span><br><span class="line">            f = f.f_back</span><br><span class="line">            stacklevel -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> f:</span><br><span class="line">            f = orig_f</span><br><span class="line">        rv = <span class="string">"(unknown file)"</span>, <span class="number">0</span>, <span class="string">"(unknown function)"</span>, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> hasattr(f, <span class="string">"f_code"</span>):</span><br><span class="line">            co = f.f_code</span><br><span class="line">            filename = os.path.normcase(co.co_filename)</span><br><span class="line">            <span class="keyword">if</span> filename == _srcfile:</span><br><span class="line">                f = f.f_back</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            sinfo = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> stack_info:</span><br><span class="line">                sio = io.StringIO()</span><br><span class="line">                sio.write(<span class="string">'Stack (most recent call last):\n'</span>)</span><br><span class="line">                traceback.print_stack(f, file=sio)</span><br><span class="line">                sinfo = sio.getvalue()</span><br><span class="line">                <span class="keyword">if</span> sinfo[<span class="number">-1</span>] == <span class="string">'\n'</span>:</span><br><span class="line">                    sinfo = sinfo[:<span class="number">-1</span>]</span><br><span class="line">                sio.close()</span><br><span class="line">            rv = (co.co_filename, f.f_lineno, co.co_name, sinfo)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> rv</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">makeRecord</span><span class="params">(self, name, level, fn, lno, msg, args, exc_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                   func=None, extra=None, sinfo=None)</span>:</span></span><br><span class="line">        rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,</span><br><span class="line">                             sinfo)</span><br><span class="line">        <span class="keyword">if</span> extra <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> extra:</span><br><span class="line">                <span class="keyword">if</span> (key <span class="keyword">in</span> [<span class="string">"message"</span>, <span class="string">"asctime"</span>]) <span class="keyword">or</span> (key <span class="keyword">in</span> rv.__dict__):</span><br><span class="line">                    <span class="keyword">raise</span> KeyError(<span class="string">"Attempt to overwrite %r in LogRecord"</span> % key)</span><br><span class="line">                rv.__dict__[key] = extra[key]</span><br><span class="line">        <span class="keyword">return</span> rv</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self, record)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> self.disabled) <span class="keyword">and</span> self.filter(record):</span><br><span class="line">            self.callHandlers(record)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callHandlers</span><span class="params">(self, record)</span>:</span></span><br><span class="line">        c = self</span><br><span class="line">        found = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> c:</span><br><span class="line">            <span class="keyword">for</span> hdlr <span class="keyword">in</span> c.handlers:</span><br><span class="line">                found = found + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> record.levelno &gt;= hdlr.level:</span><br><span class="line">                    hdlr.handle(record)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> c.propagate:</span><br><span class="line">                c = <span class="literal">None</span>    <span class="comment">#break out</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                c = c.parent</span><br><span class="line">        <span class="keyword">if</span> (found == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">if</span> lastResort:</span><br><span class="line">                <span class="keyword">if</span> record.levelno &gt;= lastResort.level:</span><br><span class="line">                    lastResort.handle(record)</span><br><span class="line">            <span class="keyword">elif</span> raiseExceptions <span class="keyword">and</span> <span class="keyword">not</span> self.manager.emittedNoHandlerWarning:</span><br><span class="line">                sys.stderr.write(<span class="string">"No handlers could be found for logger"</span></span><br><span class="line">                                 <span class="string">" \"%s\"\n"</span> % self.name)</span><br><span class="line">                self.manager.emittedNoHandlerWarning = <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><code>_log</code>执行了三个步骤：</p>
<ul>
<li>通过<code>findCaller</code>，找到是哪个文件哪一行代码调用了打印日志<ul>
<li>方法是遍历栈帧，检查到第一个非<code>logging</code>源代码的调用，从而判断到为实际调用打印日志逻辑的一行</li>
</ul>
</li>
<li>通过<code>makeRecord</code>，为当前需要打印的日志创建了一个<code>LogRecord</code>实例<ul>
<li><code>LogRecord</code>实例存储了一行日志所需的所有信息，详细实现可以看类定义</li>
</ul>
</li>
<li><code>handle</code>创建的<code>LogRecord</code>实例<ul>
<li>首先通过<code>filter</code>方法看这个日志<code>record</code>能否被打印<ul>
<li><code>filter</code>的详细实现可以看<code>Filter</code>类定义</li>
</ul>
</li>
<li>通过<code>callHandlers</code>调用名下所有<code>handlers</code>处理<code>LogRecord</code>实例，将日志打印到不同的地方<ul>
<li>在遍历所有<code>handler</code>时也检查<code>handler</code>是否能够打印对应等级的日志</li>
<li>如果没有<code>handler</code>能打印日志，用特殊的<code>Logger</code>实例<code>lastResort</code>来兜底</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>所以我们总结一下<code>Logger</code>实例打印日志时的重点：</p>
<ul>
<li>日志记录的生产和消费是分离的</li>
<li>生产日志记录需要判断是否符合<code>Logger</code>及<code>Manager</code>实例的日志级别配置，可能会追溯到上层的<code>Logger</code>实例配置</li>
<li>消费日志记录首先看是否被<code>Logger</code>实例自己过滤掉，然后遍历所有消费者，如果满足日志级别条件即可开始打印操作</li>
</ul>
<h2 id="Manager的实现"><a href="#Manager的实现" class="headerlink" title="Manager的实现"></a>Manager的实现</h2><p><code>Logger</code>的差不多看完了，接下来我们看一下<code>Manager</code>，也就是<code>Logger</code>实例的管理器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, rootnode)</span>:</span></span><br><span class="line">        self.root = rootnode</span><br><span class="line">        self.disable = <span class="number">0</span></span><br><span class="line">        self.emittedNoHandlerWarning = <span class="literal">False</span></span><br><span class="line">        self.loggerDict = &#123;&#125;</span><br><span class="line">        self.loggerClass = <span class="literal">None</span></span><br><span class="line">        self.logRecordFactory = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>Manager在日志系统内是以单例的形式存在的，其包含如下属性：</p>
<ul>
<li><code>root</code>：根<code>Logger</code></li>
<li><code>disable</code>：禁用日志级别</li>
<li><code>loggerDict</code>：存储logger实例及对应名称的字典</li>
<li><code>loggerClass</code>：Logger实例的类</li>
<li><code>logRecordFactory</code>：日志记录的创建方法，前面有提</li>
</ul>
<p><code>Manager</code>最大的作用是管理<code>Logger</code>实例。通过<code>getLogger</code>方法，我们可以获得一个<code>Logger</code>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLogger</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        rv = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(name, str):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'A logger name must be a string'</span>)</span><br><span class="line">        _acquireLock()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">in</span> self.loggerDict:</span><br><span class="line">                rv = self.loggerDict[name]</span><br><span class="line">                <span class="keyword">if</span> isinstance(rv, PlaceHolder):</span><br><span class="line">                    ph = rv</span><br><span class="line">                    rv = (self.loggerClass <span class="keyword">or</span> _loggerClass)(name)</span><br><span class="line">                    rv.manager = self</span><br><span class="line">                    self.loggerDict[name] = rv</span><br><span class="line">                    self._fixupChildren(ph, rv)</span><br><span class="line">                    self._fixupParents(rv)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rv = (self.loggerClass <span class="keyword">or</span> _loggerClass)(name)</span><br><span class="line">                rv.manager = self</span><br><span class="line">                self.loggerDict[name] = rv</span><br><span class="line">                self._fixupParents(rv)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            _releaseLock()</span><br><span class="line">        <span class="keyword">return</span> rv</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_fixupParents</span><span class="params">(self, alogger)</span>:</span></span><br><span class="line">        name = alogger.name</span><br><span class="line">        i = name.rfind(<span class="string">"."</span>)</span><br><span class="line">        rv = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) <span class="keyword">and</span> <span class="keyword">not</span> rv:</span><br><span class="line">            substr = name[:i]</span><br><span class="line">            <span class="keyword">if</span> substr <span class="keyword">not</span> <span class="keyword">in</span> self.loggerDict:</span><br><span class="line">                self.loggerDict[substr] = PlaceHolder(alogger)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                obj = self.loggerDict[substr]</span><br><span class="line">                <span class="keyword">if</span> isinstance(obj, Logger):</span><br><span class="line">                    rv = obj</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">assert</span> isinstance(obj, PlaceHolder)</span><br><span class="line">                    obj.append(alogger)</span><br><span class="line">            i = name.rfind(<span class="string">"."</span>, <span class="number">0</span>, i - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rv:</span><br><span class="line">            rv = self.root</span><br><span class="line">        alogger.parent = rv</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_fixupChildren</span><span class="params">(self, ph, alogger)</span>:</span></span><br><span class="line">        name = alogger.name</span><br><span class="line">        namelen = len(name)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> ph.loggerMap.keys():</span><br><span class="line">            <span class="comment">#The if means ... if not c.parent.name.startswith(nm)</span></span><br><span class="line">            <span class="keyword">if</span> c.parent.name[:namelen] != name:</span><br><span class="line">                alogger.parent = c.parent</span><br><span class="line">                c.parent = alogger</span><br></pre></td></tr></table></figure>
<p>如果<code>Logger</code>名字没有注册，会触发懒加载<code>Logger</code>实例。在懒加载的过程最终，会设定该<code>Logger</code>实例所属的父级<code>Logger</code>实例。从<code>_fixupParents</code>方法可以清楚看到，通过<code>Logger</code>名字的.符号能够分隔<code>Logger</code>实例所在的层级。如果上一层<code>Logger</code>实例不存在，会用一个<code>PlaceHolder</code>实例代替，否则会直接赋值<code>rv</code>，<code>break</code>，然后设置<code>parent</code>。</p>
<p>如果<code>Logger</code>名字已经注册，且注册的只是一个<code>PlaceHolder</code>实例的话，还要额外通过<code>_fixupChildren</code>方法，将已定义的子<code>Logger</code>绑定到自己身上。</p>
<p>通过这样的实现，就实现了<code>Logger</code>实例的管理。</p>
]]></content>
      <categories>
        <category>Hard Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>日志</tag>
        <tag>logging</tag>
        <tag>Logger</tag>
        <tag>Manager</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】用行为树做游戏自动化测试的误区</title>
    <url>/2022/04/03/testlife/btree_autotest_talk/</url>
    <content><![CDATA[<p>在游戏自动化测试领域，行为树由于其强大的描述玩家（Agent）行为逻辑的功能，在很多场景的自动化测试都能得到应用。但是，如果对行为树的作用认识不足，很容易导致整一个自动化测试项目出现难以维护的窘境。因此，这篇文章谈一谈在游戏自动化测试里，用行为树做测试的一些误区。</p>
<a id="more"></a>
<p>首先第一点是，很多行为树的框架/GUI系统提供了强大的可视化编程的能力。但是如果真要用行为树框架去几乎完全替代纯代码编程，做很细致的的逻辑控制，这个想法是有误的。</p>
<p>行为树本身最方便的地方是能够通过可视化界面的方式去维护玩家行为（以业务逻辑的拆分抽象为基准），而不是维护程序行为（以函数/变量为基准）。针对前者的场景，如果没有行为树，一般的解决方法是先用其它流程图工具（或者手记）捋一下流程，然后再通过纯代码的方式设计接口流程，做流程图的复刻，而有了行为树工具，就可以在实现流程图编辑的基础上，实现自动生成基础代码，这样会极大提升业务实现的效率。而针对后者的场景，可视化编程相对于纯代码其实可维护性更差，编程效率更低——在对底层api都很熟悉的基础上，纯打字肯定比拖拽一堆控件还填一堆form来的快。</p>
<p>再者第二点是，行为树的滥用问题，不是所有自动化测试场景都可以用到行为树，而是要针对我们自动化测试的场景，做严格的系统分析，否则就会陷入为技术而技术的地狱。</p>
<p>这涉及到自动化测试的本质，自动化是手段，测试是目标。严格上来讲，通过自动化手段不仅可以实现功能测试，也可以实现数据收集的需求，结合其它工具，去辅助我们完整的测试工作。因此我们在做自动化的时候还是要首先关注我们的测试目标是什么，然后才是适不适合用行为树的问题。对于大部分的自动化工作，引入行为树框架会带来更多技术上的复杂度以及学习上的难度，其实是不适合的。只有一些需要玩家（不是程序）做大量行为决策的测试场景，用行为树才比较适合，比如比如说做任务、副本的跑测，或是PVP的AI实现。</p>
<p>最后一点是，在一个涉及到行为树的自动化测试设计当中，不应当将行为树看作为整个技术设计的核心。</p>
<p>这可以类比去做一个pyqt为基础的GUI软件，这个软件的核心应该是其内部的业务逻辑，而且在设计上也应当可以脱离GUI去运行，而pyqt-designer只能作为快速设计原型，生成基础代码的手段。行为树也是也是这样的作用，它能达到的目标是快速生成行为决策的描述以及各个行为的定义，行为的实现却是需要用户去详细编写的，而恰巧正是行为实现的内容才有比较大的维护量。因此我们在做游戏自动化测试时，建议是通过对玩家在游戏里不同的行为进行封装抽象，形成“行为库”，然后再去套用到不同场景的行为树设计上。把“行为库”做好，是自动化测试得以大量应用的关键。</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>行为树</tag>
        <tag>自动化测试</tag>
        <tag>游戏测试</tag>
        <tag>测试</tag>
        <tag>可视化编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hard Python】【第三章-GC】2、python的GC流程</title>
    <url>/2022/03/19/hardpython/3_gc_2/</url>
    <content><![CDATA[<p>除了通过引用计数直接销毁对象之外，<code>python</code>还是拥有内在<code>GC</code>机制的，并且也有完整的一套流程。</p>
<p>如果只有通过引用计数销毁对象这种机制，那么随便构造一个循环引用就会造成内存泄漏，比如下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_dump_gc</span><span class="params">()</span>:</span></span><br><span class="line">    gcobjs = gc.get_objects()</span><br><span class="line">    pprint.pprint(len(gcobjs))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_circle</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_test_internal</span><span class="params">()</span>:</span></span><br><span class="line">        _dump_gc()</span><br><span class="line">        a = []</span><br><span class="line">        b = []</span><br><span class="line">        a.append(b)</span><br><span class="line">        b.append(a)</span><br><span class="line">        _dump_gc()</span><br><span class="line"></span><br><span class="line">    _test_internal()</span><br><span class="line">    _dump_gc()</span><br><span class="line">    gc.collect()</span><br><span class="line">    _dump_gc()</span><br></pre></td></tr></table></figure>
<p>打印出来的结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13707</span><br><span class="line">13709</span><br><span class="line">13709</span><br><span class="line">13370</span><br></pre></td></tr></table></figure>
<p>很显然，当退出<code>_test_internal</code>作用域时，<code>gc</code>对象的数量没有变化，这就说明在<code>_test_internal</code>里创建的<code>a、b</code>两个对象没有被立即释放掉。如果注释掉两个<code>append</code>行，就能看到打印结果第三行变成了<code>13707</code>，说明<code>a、b</code>在退出函数时就被销毁了。</p>
<p>所以首先，我们从循环引用入手，来研究一下<code>python</code>的<code>gc</code>机制（好巧不巧的是，<code>python</code>的<code>gc</code>也是专门为循环引用而设置的）。调用<code>gc.collect</code>触发<code>gc</code>之后，会跑到<code>gc_collect_main</code>触发完整的<code>gc</code>流程。<code>gc_collect_main</code>是<code>python</code>整个<code>gc</code>流程的主入口，我们来看其中的代码：</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcmodule.c</span></span><br><span class="line"><span class="keyword">static</span> Py_ssize_t</span><br><span class="line">gc_collect_main(PyThreadState *tstate, <span class="keyword">int</span> generation,</span><br><span class="line">                Py_ssize_t *n_collected, Py_ssize_t *n_uncollectable,</span><br><span class="line">                <span class="keyword">int</span> nofail)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Py_ssize_t m = <span class="number">0</span>; <span class="comment">/* # objects collected */</span></span><br><span class="line">    Py_ssize_t n = <span class="number">0</span>; <span class="comment">/* # unreachable objects that couldn't be collected */</span></span><br><span class="line">    PyGC_Head *young; <span class="comment">/* the generation we are examining */</span></span><br><span class="line">    PyGC_Head *old; <span class="comment">/* next older generation */</span></span><br><span class="line">    PyGC_Head unreachable; <span class="comment">/* non-problematic unreachable trash */</span></span><br><span class="line">    PyGC_Head finalizers;  <span class="comment">/* objects with, &amp; reachable from, __del__ */</span></span><br><span class="line">    PyGC_Head *gc;</span><br><span class="line">    _PyTime_t t1 = <span class="number">0</span>;   <span class="comment">/* initialize to prevent a compiler warning */</span></span><br><span class="line">    GCState *gcstate = &amp;tstate-&gt;interp-&gt;gc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* update collection and allocation counters */</span></span><br><span class="line">    <span class="keyword">if</span> (generation+<span class="number">1</span> &lt; NUM_GENERATIONS)</span><br><span class="line">        gcstate-&gt;generations[generation+<span class="number">1</span>].count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= generation; i++)</span><br><span class="line">        gcstate-&gt;generations[i].count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* merge younger generations with one we are currently collecting */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; generation; i++) &#123;</span><br><span class="line">        gc_list_merge(GEN_HEAD(gcstate, i), GEN_HEAD(gcstate, generation));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* handy references */</span></span><br><span class="line">    young = GEN_HEAD(gcstate, generation);</span><br><span class="line">    <span class="keyword">if</span> (generation &lt; NUM_GENERATIONS<span class="number">-1</span>)</span><br><span class="line">        old = GEN_HEAD(gcstate, generation+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        old = young;</span><br><span class="line"></span><br><span class="line">    deduce_unreachable(young, &amp;unreachable);</span><br><span class="line"></span><br><span class="line">    untrack_tuples(young);</span><br><span class="line">    <span class="comment">/* Move reachable objects to next generation. */</span></span><br><span class="line">    <span class="keyword">if</span> (young != old) &#123;</span><br><span class="line">        <span class="keyword">if</span> (generation == NUM_GENERATIONS - <span class="number">2</span>) &#123;</span><br><span class="line">            gcstate-&gt;long_lived_pending += gc_list_size(young);</span><br><span class="line">        &#125;</span><br><span class="line">        gc_list_merge(young, old);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* We only un-track dicts in full collections, to avoid quadratic</span></span><br><span class="line"><span class="comment">           dict build-up. See issue #14775. */</span></span><br><span class="line">        untrack_dicts(young);</span><br><span class="line">        gcstate-&gt;long_lived_pending = <span class="number">0</span>;</span><br><span class="line">        gcstate-&gt;long_lived_total = gc_list_size(young);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All objects in unreachable are trash, but objects reachable from</span></span><br><span class="line"><span class="comment">     * legacy finalizers (e.g. tp_del) can't safely be deleted.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    gc_list_init(&amp;finalizers);</span><br><span class="line">    <span class="comment">// NEXT_MASK_UNREACHABLE is cleared here.</span></span><br><span class="line">    <span class="comment">// After move_legacy_finalizers(), unreachable is normal list.</span></span><br><span class="line">    move_legacy_finalizers(&amp;unreachable, &amp;finalizers);</span><br><span class="line">    <span class="comment">/* finalizers contains the unreachable objects with a legacy finalizer;</span></span><br><span class="line"><span class="comment">     * unreachable objects reachable *from* those are also uncollectable,</span></span><br><span class="line"><span class="comment">     * and we move those into the finalizers list too.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    move_legacy_finalizer_reachable(&amp;finalizers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clear weakrefs and invoke callbacks as necessary. */</span></span><br><span class="line">    m += handle_weakrefs(&amp;unreachable, old);</span><br><span class="line"></span><br><span class="line">    validate_list(old, collecting_clear_unreachable_clear);</span><br><span class="line">    validate_list(&amp;unreachable, collecting_set_unreachable_clear);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Call tp_finalize on objects which have one. */</span></span><br><span class="line">    finalize_garbage(tstate, &amp;unreachable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle any objects that may have resurrected after the call</span></span><br><span class="line"><span class="comment">     * to 'finalize_garbage' and continue the collection with the</span></span><br><span class="line"><span class="comment">     * objects that are still unreachable */</span></span><br><span class="line">    PyGC_Head final_unreachable;</span><br><span class="line">    handle_resurrected_objects(&amp;unreachable, &amp;final_unreachable, old);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Call tp_clear on objects in the final_unreachable set.  This will cause</span></span><br><span class="line"><span class="comment">    * the reference cycles to be broken.  It may also cause some objects</span></span><br><span class="line"><span class="comment">    * in finalizers to be freed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    m += gc_list_size(&amp;final_unreachable);</span><br><span class="line">    delete_garbage(tstate, gcstate, &amp;final_unreachable, old);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Append instances in the uncollectable set to a Python</span></span><br><span class="line"><span class="comment">     * reachable list of garbage.  The programmer has to deal with</span></span><br><span class="line"><span class="comment">     * this if they insist on creating this type of structure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    handle_legacy_finalizers(tstate, gcstate, &amp;finalizers, old);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clear free list only during the collection of the highest</span></span><br><span class="line"><span class="comment">     * generation */</span></span><br><span class="line">    <span class="keyword">if</span> (generation == NUM_GENERATIONS<span class="number">-1</span>) &#123;</span><br><span class="line">        clear_freelists(tstate-&gt;interp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_PyErr_Occurred(tstate)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nofail) &#123;</span><br><span class="line">            _PyErr_Clear(tstate);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            _PyErr_WriteUnraisableMsg(<span class="string">"in garbage collection"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update stats */</span></span><br><span class="line">    <span class="keyword">if</span> (n_collected) &#123;</span><br><span class="line">        *n_collected = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n_uncollectable) &#123;</span><br><span class="line">        *n_uncollectable = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gc_generation_stats</span> *<span class="title">stats</span> = &amp;<span class="title">gcstate</span>-&gt;<span class="title">generation_stats</span>[<span class="title">generation</span>];</span></span><br><span class="line">    stats-&gt;collections++;</span><br><span class="line">    stats-&gt;collected += m;</span><br><span class="line">    stats-&gt;uncollectable += n;</span><br><span class="line"></span><br><span class="line">    assert(!_PyErr_Occurred(tstate));</span><br><span class="line">    <span class="keyword">return</span> n + m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>gc_collect_main</code>总共执行了以下几个步骤，一个一个来说。</p>
<p>首先更新指定<code>generation</code>后的分配计数（+1），指定<code>generation</code>及以下的全部归0。这是因为<code>python</code>也自带了分代回收机制，<code>gc.collect</code>入参是<code>generation</code>，指定<code>generation</code>以下的全部都会被<code>gc</code>掉。</p>
<p><code>python</code>的<code>gc</code>分代总共是3代，而<code>gc.collect</code>默认值是2，也表示最高一代，通俗点讲就是<code>Full GC</code>。每一代的对象数目如果超过特定值，就会触发自动gc。</p>
<p>然后做的一个事情是，将指定<code>generation</code>前代的和当代的所有<code>GC_Head</code>全部串到一个链表上，这样只需要处理这一个链表就能回收所有东西。每个<code>python</code>对象都会自带<code>GC_Head</code>，串到特定<code>genenration</code>的链表中，用于在GC时候被识别到。</p>
<p>之后做的很关键的一步是<code>deduce_unreachable</code>，其作用是模拟去引用的流程，探测无法从<code>gc</code>根对象直接达到的对象，放到单独的<code>unreachable</code>列表中。并且在这一步会通过遍历对象之间的引用关系并-1引用的方式，从而将对象之间的循环引用暂时归零。<code>deduce_unreachable</code>的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">deduce_unreachable(PyGC_Head *base, PyGC_Head *unreachable) &#123;</span><br><span class="line">    validate_list(base, collecting_clear_unreachable_clear);</span><br><span class="line">    update_refs(base);  <span class="comment">// gc_prev is used for gc_refs</span></span><br><span class="line">    subtract_refs(base);</span><br><span class="line">    gc_list_init(unreachable);</span><br><span class="line">    move_unreachable(base, unreachable);  <span class="comment">// gc_prev is pointer again</span></span><br><span class="line">    validate_list(base, collecting_clear_unreachable_clear);</span><br><span class="line">    validate_list(unreachable, collecting_set_unreachable_set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好比一个场景：总共有4个<code>list</code>对象，分别为<code>l1</code>到<code>l4</code>，其中<code>l1</code>、<code>l2</code>循环引用，<code>l3</code>、<code>l4</code>循环引用，<code>l1</code>和<code>l2</code>与<code>l3</code>跟<code>l4</code>之间没有关联。之后若再有一个变量<code>a</code>引用了<code>l1</code>，那么经过<code>deduce_unreachable</code>之后，会呈现如下的结果：</p>
<ul>
<li>在<code>subtract_refs</code>步骤中，<code>l1</code>的引用数目变成1，<code>l2</code>、<code>l3</code>、<code>l4</code>变成0</li>
<li>在<code>move_unreachable</code>步骤中，发现<code>l1</code>引用数目为1，即将<code>l1</code>以及其引用到的所有变量标记为<code>reachable</code><ul>
<li>最后剩下来引用数仍然为0的<code>l3</code>、<code>l4</code>，放到<code>unreachable</code>链表中</li>
</ul>
</li>
</ul>
<p>经历<code>deduce_unreachable</code>步骤存活下来的<code>reachable</code>对象，会直接被移动到下一个<code>generation</code>。接下来只需要考虑对<code>unreachable</code>的对象进行销毁了。</p>
<p>接下来的操作是将<code>unreachable</code>链表中，会处理一些<code>C</code>层类型定义里含有旧版<code>tc_del</code>方法的类型的对象，这些对象及其直接或间接引用的对象全部都会被移动到单独的<code>finalizers</code>链表中，而这个链表中的对象会被单独维护，无法被回收。</p>
<p>在以前的版本中，如果<code>python</code>类型定义了<code>__del__</code>方法，那么这些类型的对象就会移动到<code>finalizers</code>链表中。直到<span class="exturl" data-url="aHR0cHM6Ly93d3cucHl0aG9uLm9yZy9kZXYvcGVwcy9wZXAtMDQ0Mi8=" title="https://www.python.org/dev/peps/pep-0442/">PEP442<i class="fa fa-external-link"></i></span>之后，<code>__del__</code>方法就对应了<code>C</code>层类型定义的另外一个<code>tc_finaliz</code>e方法了，因此包含<code>__del__</code>方法的类型的对象，不一定会移动到<code>finalizers</code>链表中，而是会在后面的步骤中触发<code>tc_finalize</code>逻辑。</p>
<p>再之后，针对剩下的<code>unreachable</code>对象，通过<code>handle_weakrefs</code>方法解除其它对象对其的弱引用。然后调用<code>finalize_garbage</code>销毁<code>unreachable</code>对象。<code>finalize_garbage</code>的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">finalize_garbage(PyThreadState *tstate, PyGC_Head *collectable)</span><br><span class="line">&#123;</span><br><span class="line">    destructor finalize;</span><br><span class="line">    PyGC_Head seen;</span><br><span class="line">    gc_list_init(&amp;seen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!gc_list_is_empty(collectable)) &#123;</span><br><span class="line">        PyGC_Head *gc = GC_NEXT(collectable);</span><br><span class="line">        PyObject *op = FROM_GC(gc);</span><br><span class="line">        gc_list_move(gc, &amp;seen);</span><br><span class="line">        <span class="keyword">if</span> (!_PyGCHead_FINALIZED(gc) &amp;&amp;</span><br><span class="line">                (finalize = Py_TYPE(op)-&gt;tp_finalize) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            _PyGCHead_SET_FINALIZED(gc);</span><br><span class="line">            Py_INCREF(op);</span><br><span class="line">            finalize(op);</span><br><span class="line">            assert(!_PyErr_Occurred(tstate));</span><br><span class="line">            Py_DECREF(op);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    gc_list_merge(&amp;seen, collectable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>finalize_garbage</code>实质是调用对象类型定义的<code>tp_finalize</code>方法析构对应的对象，并减少其引用为0从而释放对象内存。由于某些对象类型可能没有默认的<code>tp_finalize</code>方法，因此经过这一步骤之后，还会存留一些未销毁的对象。</p>
<p>针对未销毁的对象，之后会通过<code>handle_resurrected_objects</code>进行处理。在<code>handle_resurrected_objects</code>中会再一次执行<code>deduce_unreachable</code>模拟去引用操作，存活下来的<code>unreachable</code>对象就被移到下一个<code>generation</code>，而剩下的对象就会被移动到<code>final_unreachable</code>链表进行后面的销毁操作。</p>
<p>通过<code>delete_garbage</code>方法会对<code>final_unreachable</code>链表的对象进行销毁，其代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">delete_garbage(PyThreadState *tstate, GCState *gcstate,</span><br><span class="line">               PyGC_Head *collectable, PyGC_Head *old)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!_PyErr_Occurred(tstate));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!gc_list_is_empty(collectable)) &#123;</span><br><span class="line">        PyGC_Head *gc = GC_NEXT(collectable);</span><br><span class="line">        PyObject *op = FROM_GC(gc);</span><br><span class="line"></span><br><span class="line">        _PyObject_ASSERT_WITH_MSG(op, Py_REFCNT(op) &gt; <span class="number">0</span>,</span><br><span class="line">                                  <span class="string">"refcount is too small"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gcstate-&gt;debug &amp; DEBUG_SAVEALL) &#123;</span><br><span class="line">            assert(gcstate-&gt;garbage != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (PyList_Append(gcstate-&gt;garbage, op) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                _PyErr_Clear(tstate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            inquiry clear;</span><br><span class="line">            <span class="keyword">if</span> ((clear = Py_TYPE(op)-&gt;tp_clear) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                Py_INCREF(op);</span><br><span class="line">                (<span class="keyword">void</span>) clear(op);</span><br><span class="line">                <span class="keyword">if</span> (_PyErr_Occurred(tstate)) &#123;</span><br><span class="line">                    _PyErr_WriteUnraisableMsg(<span class="string">"in tp_clear of"</span>,</span><br><span class="line">                                              (PyObject*)Py_TYPE(op));</span><br><span class="line">                &#125;</span><br><span class="line">                Py_DECREF(op);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GC_NEXT(collectable) == gc) &#123;</span><br><span class="line">            <span class="comment">/* object is still alive, move it, it may die later */</span></span><br><span class="line">            gc_clear_collecting(gc);</span><br><span class="line">            gc_list_move(gc, old);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>delete_garbage</code>中，每一个对象都会调用其类型的<code>tp_clear</code>方法，减少对象引用数目为0，触发对象的销毁。</p>
<p>在<code>delete_garbage</code>之后，终于就会对先前单独拎出来的<code>finalizers</code>链表进行处理。<code>finalizers</code>链表中所有的内容都会通过<code>handle_legacy_finalizers</code>方法被移动到当前<code>gcstate</code>的<code>garbage</code>链表中单独维护，不会被销毁。</p>
<p>之后进行一些数据清理和数据统计逻辑，整个<code>gc</code>流程就完成了。</p>
]]></content>
      <categories>
        <category>Hard Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>gc</tag>
        <tag>分代回收</tag>
        <tag>循环引用</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hard Python】【第三章-GC】1、引用计数与内存释放机制</title>
    <url>/2022/03/12/hardpython/3_gc_1/</url>
    <content><![CDATA[<p>对于编程语言runtime来说，建立起良好运转GC机制是非常必要的，像<code>Java</code>和<code>Go</code>，其GC机制都经历了复杂的演化，当然同时也为编程语言带来了更好的性能，这也是为什么这两门语言能成为主流服务端语言的原因之一。</p>
<p>相对于<code>Java</code>和<code>Go</code>，<code>python</code>的GC机制是相对简约的，其中最基础的机制之一就是引用计数。当对象生成时引用计数为1；对象被其它对象引用时引用计数增加1；对象没有被引用，又退出作用域的话，引用计数归0；引用计数归0后，对象被销毁。</p>
<p>我们可以通过一个例子对引用计数机制进行研究：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_ref</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="string">'123456789123456789'</span></span><br><span class="line">    <span class="keyword">del</span> a</span><br></pre></td></tr></table></figure>
<p>其反编译的结果是：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8           0 LOAD_CONST               1 (&apos;123456789123456789&apos;)</span><br><span class="line">            2 STORE_FAST               0 (a)</span><br><span class="line"></span><br><span class="line">9           4 DELETE_FAST              0 (a)</span><br><span class="line">            6 LOAD_CONST               0 (None)</span><br><span class="line">            8 RETURN_VALUE</span><br></pre></td></tr></table></figure>
<p>在<code>STORE_FAST</code>和<code>DELETE_FAST</code>操作中，都用到了<code>SET_LOCAL</code>宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETLOCAL(i, value)      do &#123; PyObject *tmp = GETLOCAL(i); \</span></span><br><span class="line">                                     GETLOCAL(i) = value; \</span><br><span class="line">                                     Py_XDECREF(tmp); &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到<code>SET_LOCAL</code>的操作是：将对应<code>LOCAL</code>位置的旧值拷贝到<code>tmp</code>指针，让后将新值赋给对应<code>LOCAL</code>位置，最后减少旧值<code>tmp</code>指针的引用计数</p>
<p>对于<code>DELETE_FAST</code>操作，<code>SETLOCAL</code>的<code>value</code>参数是<code>NULL</code>，这样对应<code>LOCAL</code>位置指针被赋值为<code>NULL</code>，旧值减少引用计数，这样就触发后续一系列操作了。</p>
<p>当调用<code>Py_XDECREF</code>时，实际执行了如下的操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _Py_XDECREF(PyObject *op)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (op != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_DECREF(op);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_XDECREF(op) _Py_XDECREF(_PyObject_CAST(op))</span></span><br><span class="line"></span><br><span class="line"><span class="function">define <span class="title">Py_DECREF</span><span class="params">(op)</span> _<span class="title">Py_DECREF</span><span class="params">(__FILE__, __LINE__, _PyObject_CAST(op))</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _<span class="title">Py_DECREF</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> lineno, PyObject *op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Py_REF_DEBUG</span></span><br><span class="line">    _Py_RefTotal--;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (--op-&gt;ob_refcnt != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Py_REF_DEBUG</span></span><br><span class="line">        <span class="keyword">if</span> (op-&gt;ob_refcnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            _Py_NegativeRefcount(filename, lineno, op);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        _Py_Dealloc(op);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_Py_Dealloc(PyObject *op)</span><br><span class="line">&#123;</span><br><span class="line">    destructor dealloc = Py_TYPE(op)-&gt;tp_dealloc;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Py_TRACE_REFS</span></span><br><span class="line">    _Py_ForgetReference(op);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    (*dealloc)(op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，如果对象内部的<code>ob_refcnt</code>引用计数归0，就会触发<code>_Py_Dealloc</code>逻辑，清空给对象分配的内存。</p>
<p>针对<code>test_ref</code>的例子，会调用py3的字符串析构逻辑，也就是<code>unicode</code>的<code>dealloc</code>逻辑：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">unicode_dealloc(PyObject *unicode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (PyUnicode_CHECK_INTERNED(unicode)) &#123;</span><br><span class="line">    <span class="keyword">case</span> SSTATE_NOT_INTERNED:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SSTATE_INTERNED_MORTAL:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">Py_unicode_state</span> *<span class="title">state</span> = <span class="title">get_unicode_state</span>();</span></span><br><span class="line">        assert(Py_REFCNT(unicode) == <span class="number">0</span>);</span><br><span class="line">        Py_SET_REFCNT(unicode, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (PyDict_DelItem(state-&gt;interned, unicode) != <span class="number">0</span>) &#123;</span><br><span class="line">            _PyErr_WriteUnraisableMsg(<span class="string">"deletion of interned string failed"</span>,</span><br><span class="line">                                      <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        assert(Py_REFCNT(unicode) == <span class="number">1</span>);</span><br><span class="line">        Py_SET_REFCNT(unicode, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SSTATE_INTERNED_IMMORTAL:</span><br><span class="line">        _PyObject_ASSERT_FAILED_MSG(unicode, <span class="string">"Immortal interned string died"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        Py_UNREACHABLE();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_PyUnicode_HAS_WSTR_MEMORY(unicode)) &#123;</span><br><span class="line">        PyObject_Free(_PyUnicode_WSTR(unicode));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_PyUnicode_HAS_UTF8_MEMORY(unicode)) &#123;</span><br><span class="line">        PyObject_Free(_PyUnicode_UTF8(unicode));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_IS_COMPACT(unicode) &amp;&amp; _PyUnicode_DATA_ANY(unicode)) &#123;</span><br><span class="line">        PyObject_Free(_PyUnicode_DATA_ANY(unicode));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Py_TYPE(unicode)-&gt;tp_free(unicode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>unicode</code>的析构逻辑中，首先判断字符串是不是<code>intern</code>的（短字符串缓存），如果是的话会启用另外的析构逻辑，否则会跑到下面。最终调用的是<code>Py_TYPE(unicode)-&gt;tp_free(unicode)</code>逻辑。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">PyObject_Free(<span class="keyword">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    _PyObject.<span class="built_in">free</span>(_PyObject.ctx, ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// _PyObject.free(_PyObject.ctx, ptr)</span></span><br><span class="line"><span class="comment">// python_d.exe</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_PyMem_DebugFree(<span class="keyword">void</span> *ctx, <span class="keyword">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    _PyMem_DebugCheckGIL(__func__);</span><br><span class="line">    _PyMem_DebugRawFree(ctx, ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_PyMem_DebugRawFree(<span class="keyword">void</span> *ctx, <span class="keyword">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* PyMem_Free(NULL) has no effect */</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">debug_alloc_api_t</span> *api = (<span class="keyword">debug_alloc_api_t</span> *)ctx;</span><br><span class="line">    <span class="keyword">uint8_t</span> *q = (<span class="keyword">uint8_t</span> *)p - <span class="number">2</span>*SST;  <span class="comment">/* address returned from malloc */</span></span><br><span class="line">    <span class="keyword">size_t</span> nbytes;</span><br><span class="line"></span><br><span class="line">    _PyMem_DebugCheckAddress(__func__, api-&gt;api_id, p);</span><br><span class="line">    nbytes = <span class="keyword">read_size_t</span>(q);</span><br><span class="line">    nbytes += PYMEM_DEBUG_EXTRA_BYTES;</span><br><span class="line">    <span class="built_in">memset</span>(q, PYMEM_DEADBYTE, nbytes);</span><br><span class="line">    api-&gt;alloc.<span class="built_in">free</span>(api-&gt;alloc.ctx, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// api-&gt;alloc.free(api-&gt;alloc.ctx, q)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_PyObject_Free(<span class="keyword">void</span> *ctx, <span class="keyword">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* PyObject_Free(NULL) has no effect */</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(!pymalloc_free(ctx, p))) &#123;</span><br><span class="line">        <span class="comment">/* pymalloc didn't allocate this address */</span></span><br><span class="line">        PyMem_RawFree(p);</span><br><span class="line">        raw_allocated_blocks--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一路走下来，最终会调用<code>_PyObject_Free</code>去彻底释放这块内存，<code>_PyObject_Free</code>会尝试通过<code>pymalloc_free</code>和<code>PyMem_RawFree</code>两种方式对对象所占内存进行释放。其中前者是采用<code>python</code>自带的内存管理机制，后者是采用操作系统的<code>free</code>方法。</p>
<p>这里我们需要稍微了解一下<code>python</code>内存管理的机制。<code>python</code>内部维护了不同组相同大小块的内存池，其中有几个概念：</p>
<ul>
<li><code>arena</code>：管理一组<code>pool</code><ul>
<li>维护可用<code>pool</code>数量及<code>pool</code>总量</li>
<li>可以有多个<code>arena</code></li>
</ul>
</li>
<li><code>pool</code>：管理一组相同大小的<code>block</code>的链表<ul>
<li>正在使用中（<code>used</code>，非空，非满）的<code>pool</code>集合，会单独由<code>usedpools</code>数组管理</li>
<li>申请内存时，会优先从<code>usedpools</code>寻找可用<code>pool</code>。如果<code>block</code>数量不够，会新增<code>block</code></li>
<li>如果没有指定大小的<code>block</code>，会从<code>arena</code>新起一个<code>pool</code>然后分配对应<code>block</code></li>
<li>释放对象内存时，被释放的<code>block</code>被转移到单独的可用<code>block</code>链表</li>
</ul>
</li>
<li><code>block</code>：一个固定大小的内存块<ul>
<li>在<code>python</code>中，有不同的固定大小，以8/16字节对齐（<code>ALIGNMENT</code>宏）</li>
<li>针对不同大小的对象，分配不同大小的<code>block</code></li>
</ul>
</li>
</ul>
<p>了解了这些概念，再看<code>python</code>对象的内存回收逻辑，就很明白了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">pymalloc_free(<span class="keyword">void</span> *ctx, <span class="keyword">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">    assert(p != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    poolp pool = POOL_ADDR(p);</span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(!address_in_range(p, pool))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(pool-&gt;ref.count &gt; <span class="number">0</span>);            <span class="comment">/* else it was empty */</span></span><br><span class="line">    block *lastfree = pool-&gt;freeblock;</span><br><span class="line">    *(block **)p = lastfree;</span><br><span class="line">    pool-&gt;freeblock = (block *)p;</span><br><span class="line">    pool-&gt;ref.count--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(lastfree == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        insert_to_usedpool(pool);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LIKELY(pool-&gt;ref.count != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">/* pool isn't empty:  leave it in usedpools */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    insert_to_freepool(pool);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终我们可以看到，<code>pymalloc_free</code>主要做了以下几件事情，完成对象的内存释放：</p>
<ul>
<li>通过<code>POOL_ADDR</code>宏，找到指针<code>p</code>对应<code>pool</code>位置</li>
<li>将指针<code>p</code>对应的内存块放到<code>freeblock</code>链表头部</li>
<li>减少<code>pool</code>的引用数。如果归零，将<code>pool</code>放到对应<code>arena</code>的<code>freepools</code>里</li>
</ul>
]]></content>
      <categories>
        <category>Hard Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>gc</tag>
        <tag>引用计数</tag>
        <tag>内存管理</tag>
        <tag>内存池</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hard Python】【第二章-异步IO】3、async/await的源码实现</title>
    <url>/2022/02/26/hardpython/2_asyncio_3/</url>
    <content><![CDATA[<p>说完了<code>asyncio</code>事件循环是如何运行异步任务的，接下来back to basic，我们一起看看<code>async</code>和<code>await</code>两个原语具体代表了什么含义。</p>
<p>首先是<code>async</code>，<code>async</code>通常用来修饰一个函数，表示这个函数会返回一个协程。比如说：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">_coro_maker</span><span class="params">(i)</span>:</span></span><br><span class="line">    print(i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_async</span><span class="params">()</span>:</span></span><br><span class="line">    c = _coro_maker(<span class="number">1</span>)</span><br><span class="line">    asyncio.run(c)</span><br></pre></td></tr></table></figure>
<p>对<code>_coro_maker</code>进行反编译，得到这样的结果：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Disassembly of _coro_maker:</span><br><span class="line">              0 GEN_START                1</span><br><span class="line"></span><br><span class="line">  7           2 LOAD_GLOBAL              0 (print)</span><br><span class="line">              4 LOAD_FAST                0 (i)</span><br><span class="line">              6 LOAD_CONST               1 (1)</span><br><span class="line">              8 BINARY_ADD</span><br><span class="line">             10 CALL_FUNCTION            1</span><br><span class="line">             12 POP_TOP</span><br><span class="line">             14 LOAD_CONST               0 (None)</span><br><span class="line">             16 RETURN_VALUE</span><br></pre></td></tr></table></figure>
<p>可以看到，函数体内反编译的结果和普通def函数是一致的，唯一的不同是最开始加了<code>GEN_START</code>字节码。首先看<code>GEN_START</code>的实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">case TARGET(GEN_START): &#123;</span><br><span class="line">    PyObject *none = POP();</span><br><span class="line">    Py_DECREF(none);</span><br><span class="line">    <span class="keyword">if</span> (!Py_IsNone(none)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oparg &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            _PyErr_SetString(tstate, PyExc_SystemError,</span><br><span class="line">                <span class="string">"Illegal kind for GEN_START"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *gen_kind[<span class="number">3</span>] = &#123;</span><br><span class="line">                <span class="string">"generator"</span>,</span><br><span class="line">                <span class="string">"coroutine"</span>,</span><br><span class="line">                <span class="string">"async generator"</span></span><br><span class="line">            &#125;;</span><br><span class="line">            _PyErr_Format(tstate, PyExc_TypeError,</span><br><span class="line">                <span class="string">"can't send non-None value to a "</span></span><br><span class="line">                        <span class="string">"just-started %s"</span>,</span><br><span class="line">                        gen_kind[oparg]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>GEN_START</code>对于生成器、协程、<code>async</code>生成器都适用。对于<code>async def</code>函数其真实含义是调用<code>send(None)</code>以触发协程的开始。由于<code>async def</code>生成的协程没有<code>yield</code>值，因此会报<code>StopIteration</code>异常并给出协程的返回值。<br>​<br>总的来说，协程是一种特殊的<code>generator</code>，具备被<code>await</code>的效果。<br>​<br>那么接下来，该说<code>await</code>了。我们看一组代码示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">_coro_maker</span><span class="params">(i)</span>:</span></span><br><span class="line">    print(i + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">_test_await</span><span class="params">()</span>:</span></span><br><span class="line">    c = _coro_maker(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_await</span><span class="params">()</span>:</span></span><br><span class="line">    asyncio.run(_test_await())</span><br></pre></td></tr></table></figure>
<p>​<br>反编译<code>_test_await</code>的结果，得到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Disassembly of _test_await:</span><br><span class="line">              0 GEN_START                1</span><br><span class="line"></span><br><span class="line"> 27           2 LOAD_GLOBAL              0 (_coro_maker)</span><br><span class="line">              4 LOAD_CONST               1 (1)</span><br><span class="line">              6 CALL_FUNCTION            1</span><br><span class="line">              8 STORE_FAST               0 (c)</span><br><span class="line"></span><br><span class="line"> 28          10 LOAD_FAST                0 (c)</span><br><span class="line">             12 GET_AWAITABLE</span><br><span class="line">             14 LOAD_CONST               0 (None)</span><br><span class="line">             16 YIELD_FROM</span><br><span class="line">             18 POP_TOP</span><br><span class="line">             20 LOAD_CONST               0 (None)</span><br><span class="line">             22 RETURN_VALUE</span><br></pre></td></tr></table></figure>
<p>首先来看<code>GET_AWAITABLE</code>，其代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">case TARGET(GET_AWAITABLE): &#123;</span><br><span class="line">    PREDICTED(GET_AWAITABLE);</span><br><span class="line">    PyObject *iterable = TOP();</span><br><span class="line">    PyObject *iter = _PyCoro_GetAwaitableIter(iterable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iter == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> opcode_at_minus_3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((next_instr - first_instr) &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            opcode_at_minus_3 = _Py_OPCODE(next_instr[<span class="number">-3</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        format_awaitable_error(tstate, Py_TYPE(iterable),</span><br><span class="line">                               opcode_at_minus_3,</span><br><span class="line">                               _Py_OPCODE(next_instr[<span class="number">-2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Py_DECREF(iterable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iter != <span class="literal">NULL</span> &amp;&amp; PyCoro_CheckExact(iter)) &#123;</span><br><span class="line">        PyObject *yf = _PyGen_yf((PyGenObject*)iter);</span><br><span class="line">        <span class="keyword">if</span> (yf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* `iter` is a coroutine object that is being</span></span><br><span class="line"><span class="comment">               awaited, `yf` is a pointer to the current awaitable</span></span><br><span class="line"><span class="comment">               being awaited on. */</span></span><br><span class="line">            Py_DECREF(yf);</span><br><span class="line">            Py_CLEAR(iter);</span><br><span class="line">            _PyErr_SetString(tstate, PyExc_RuntimeError,</span><br><span class="line">                             <span class="string">"coroutine is being awaited already"</span>);</span><br><span class="line">            <span class="comment">/* The code below jumps to `error` if `iter` is NULL. */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SET_TOP(iter); <span class="comment">/* Even if it's NULL */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iter == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PREDICT(LOAD_CONST);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>GET_AWAITABLE</code>做了这样几件事情：</p>
<ul>
<li>通过<code>_PyCoro_GetAwaitableIter</code>获取一个<code>Awaitable</code>对象的迭代器<code>iter</code></li>
<li>检查<code>iter</code>是否合法，检查当前<code>Awaitable</code>对象是否已经被<code>await</code>了</li>
<li>将<code>iter</code>置于栈顶</li>
</ul>
<p><code>Awaitable</code>的<code>iter</code>到底是什么东西？我们来看<code>_PyCoro_GetAwaitableIter</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">_PyCoro_GetAwaitableIter(PyObject *o)</span><br><span class="line">&#123;</span><br><span class="line">    unaryfunc getter = <span class="literal">NULL</span>;</span><br><span class="line">    PyTypeObject *ot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyCoro_CheckExact(o) || gen_is_coroutine(o)) &#123;</span><br><span class="line">        <span class="comment">/* 'o' is a coroutine. */</span></span><br><span class="line">        Py_INCREF(o);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ot = Py_TYPE(o);</span><br><span class="line">    <span class="keyword">if</span> (ot-&gt;tp_as_async != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        getter = ot-&gt;tp_as_async-&gt;am_await;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getter != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyObject *res = (*getter)(o);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PyCoro_CheckExact(res) || gen_is_coroutine(res)) &#123;</span><br><span class="line">                <span class="comment">/* __await__ must return an *iterator*, not</span></span><br><span class="line"><span class="comment">                   a coroutine or another awaitable (see PEP 492) */</span></span><br><span class="line">                PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                                <span class="string">"__await__() returned a coroutine"</span>);</span><br><span class="line">                Py_CLEAR(res);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!PyIter_Check(res)) &#123;</span><br><span class="line">                PyErr_Format(PyExc_TypeError,</span><br><span class="line">                             <span class="string">"__await__() returned non-iterator "</span></span><br><span class="line">                             <span class="string">"of type '%.100s'"</span>,</span><br><span class="line">                             Py_TYPE(res)-&gt;tp_name);</span><br><span class="line">                Py_CLEAR(res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PyErr_Format(PyExc_TypeError,</span><br><span class="line">                 <span class="string">"object %.100s can't be used in 'await' expression"</span>,</span><br><span class="line">                 ot-&gt;tp_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中有重要的几句代码：</p>
<ul>
<li><code>if (PyCoro_CheckExact(o) || gen_is_coroutine(o)) return o</code></li>
<li><code>getter = ot-&gt;tp_as_async-&gt;am_await</code></li>
<li><code>PyObject *res = (*getter)(o)</code></li>
</ul>
<p>可以知晓，如果对象是协程的话会直接返回，不是协程的话看有无<code>ot-&gt;tp_as_async-&gt;am_await</code>接口支持。如果再追究的话，对于一般的生成器<code>PyGen_Type</code>，是没有这个接口的，所以是无法被<code>await</code>的。</p>
<p><code>GET_AWAITABLE</code>之后，接下来是<code>load</code>了一个<code>None</code>，然后<code>YIELD_FROM</code>。<code>YIELD_FROM</code>实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">case TARGET(YIELD_FROM): &#123;</span><br><span class="line">    PyObject *v = POP();</span><br><span class="line">    PyObject *receiver = TOP();</span><br><span class="line">    PySendResult gen_status;</span><br><span class="line">    <span class="keyword">if</span> (tstate-&gt;c_tracefunc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        gen_status = PyIter_Send(receiver, v, &amp;retval);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 省略一些代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(v);</span><br><span class="line">    <span class="keyword">if</span> (gen_status == PYGEN_ERROR) &#123;</span><br><span class="line">        assert (retval == <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (gen_status == PYGEN_RETURN) &#123;</span><br><span class="line">        assert (retval != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        Py_DECREF(receiver);</span><br><span class="line">        SET_TOP(retval);</span><br><span class="line">        retval = <span class="literal">NULL</span>;</span><br><span class="line">        DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    assert (gen_status == PYGEN_NEXT);</span><br><span class="line">    <span class="comment">/* receiver remains on stack, retval is value to be yielded */</span></span><br><span class="line">    <span class="comment">/* and repeat... */</span></span><br><span class="line">    assert(f-&gt;f_lasti &gt; <span class="number">0</span>);</span><br><span class="line">    f-&gt;f_lasti -= <span class="number">1</span>;</span><br><span class="line">    f-&gt;f_state = FRAME_SUSPENDED;</span><br><span class="line">    f-&gt;f_stackdepth = (<span class="keyword">int</span>)(stack_pointer - f-&gt;f_valuestack);</span><br><span class="line">    <span class="keyword">goto</span> exiting;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>YIELD_FROM</code>操作，实际上调用了<code>PyIter_Send(coro, None, &amp;retval)</code>。我们来看<code>PyIter_Send</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PySendResult</span><br><span class="line">PyIter_Send(PyObject *iter, PyObject *arg, PyObject **result)</span><br><span class="line">&#123;</span><br><span class="line">    _Py_IDENTIFIER(send);</span><br><span class="line">    assert(arg != <span class="literal">NULL</span>);</span><br><span class="line">    assert(result != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (Py_TYPE(iter)-&gt;tp_as_async &amp;&amp; Py_TYPE(iter)-&gt;tp_as_async-&gt;am_send) &#123;</span><br><span class="line">        PySendResult res = Py_TYPE(iter)-&gt;tp_as_async-&gt;am_send(iter, arg, result);</span><br><span class="line">        assert(_Py_CheckSlotResult(iter, <span class="string">"am_send"</span>, res != PYGEN_ERROR));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arg == Py_None &amp;&amp; PyIter_Check(iter)) &#123;</span><br><span class="line">        *result = Py_TYPE(iter)-&gt;tp_iternext(iter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        *result = _PyObject_CallMethodIdOneArg(iter, &amp;PyId_send, arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> PYGEN_NEXT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_PyGen_FetchStopIterationValue(result) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> PYGEN_RETURN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PYGEN_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对<code>AwaitableIter</code>，实际调用了<code>Py_TYPE(iter)-&gt;tp_as_async-&gt;am_send(iter, arg, result)</code>，对应的函数是这个：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> PySendResult</span><br><span class="line">PyGen_am_send(PyGenObject *gen, PyObject *arg, PyObject **result)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> gen_send_ex2(gen, arg, result, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里就很令人熟悉了，没错，<code>gen_send_ex2(coro, None, result, 0, 0)</code>就是<code>coro.send(None)</code>的逻辑</p>
<p>在<code>gen_send_ex2</code>中，函数体的返回值会正好赋到<code>result</code>上。再看<code>YIELD_FROM</code>里<code>if (gen_status == PYGEN_RETURN)</code>分支，最终的返回值就会放到栈顶。</p>
<p>当我们调用<code>xx = await Awaitable</code>时，我们也就能够把<code>Awaitable</code>的返回值赋给<code>xx</code>了。这样，<code>await</code>原语就实现了它的作用。</p>
]]></content>
      <categories>
        <category>Hard Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>异步</tag>
        <tag>asyncio</tag>
        <tag>async</tag>
        <tag>await</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hard Python】【第二章-异步IO】2、异步任务在事件循环中的执行</title>
    <url>/2022/02/20/hardpython/2_asyncio_2/</url>
    <content><![CDATA[<p>接续<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjIvMDIvMTIvaGFyZHB5dGhvbi8yX2FzeW5jaW9fMS8=" title="https://utmhikari.top/2022/02/12/hardpython/2_asyncio_1/">第一话<i class="fa fa-external-link"></i></span>的内容，事件循环在创建之后，又是如何运行协程任务以及异步IO任务的？<br>​<br>由<code>asyncio.run</code>的代码可知，<code>loop.run_until_complete</code>是运行协程的方法。其定义如下：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># base_events.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseEventLoop</span><span class="params">(events.AbstractEventLoop)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_until_complete</span><span class="params">(self, future)</span>:</span></span><br><span class="line">        self._check_closed()</span><br><span class="line">        self._check_running()</span><br><span class="line">        new_task = <span class="keyword">not</span> futures.isfuture(future)</span><br><span class="line">        future = tasks.ensure_future(future, loop=self)</span><br><span class="line">        <span class="keyword">if</span> new_task:</span><br><span class="line">            future._log_destroy_pending = <span class="literal">False</span></span><br><span class="line">        future.add_done_callback(_run_until_complete_cb)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.run_forever()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">if</span> new_task <span class="keyword">and</span> future.done() <span class="keyword">and</span> <span class="keyword">not</span> future.cancelled():</span><br><span class="line">                future.exception()</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            future.remove_done_callback(_run_until_complete_cb)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> future.done():</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">'Event loop stopped before Future completed.'</span>)</span><br><span class="line">        <span class="keyword">return</span> future.result()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># tasks.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ensure_future</span><span class="params">(coro_or_future, *, loop=None)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _ensure_future(coro_or_future, loop=loop)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_ensure_future</span><span class="params">(coro_or_future, *, loop=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> futures.isfuture(coro_or_future):</span><br><span class="line">        <span class="keyword">if</span> loop <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> loop <span class="keyword">is</span> <span class="keyword">not</span> futures._get_loop(coro_or_future):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'The future belongs to a different loop than '</span></span><br><span class="line">                            <span class="string">'the one specified as the loop argument'</span>)</span><br><span class="line">        <span class="keyword">return</span> coro_or_future</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> coroutines.iscoroutine(coro_or_future):</span><br><span class="line">        <span class="keyword">if</span> inspect.isawaitable(coro_or_future):</span><br><span class="line">            coro_or_future = _wrap_awaitable(coro_or_future)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'An asyncio.Future, a coroutine or an awaitable '</span></span><br><span class="line">                            <span class="string">'is required'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> loop <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        loop = events._get_event_loop(stacklevel=<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> loop.create_task(coro_or_future)</span><br></pre></td></tr></table></figure>
<p><code>run_until_complete</code>方法传入的协程会通过<code>tasks.ensure_future</code>方法被封装成一个<code>task</code>实例，从上述的代码可以看到，最终落实到了<code>loop.create_task</code>方法。<br>​</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># base_events.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseEventLoop</span><span class="params">(events.AbstractEventLoop)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_task</span><span class="params">(self, coro, *, name=None)</span>:</span></span><br><span class="line">        self._check_closed()</span><br><span class="line">        <span class="keyword">if</span> self._task_factory <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            task = tasks.Task(coro, loop=self, name=name)</span><br><span class="line">            <span class="keyword">if</span> task._source_traceback:</span><br><span class="line">                <span class="keyword">del</span> task._source_traceback[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            task = self._task_factory(self, coro)</span><br><span class="line">            tasks._set_task_name(task, name)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> task</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># task.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span><span class="params">(futures._PyFuture)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, coro, *, loop=None, name=None)</span>:</span></span><br><span class="line">        super().__init__(loop=loop)</span><br><span class="line">        <span class="keyword">if</span> self._source_traceback:</span><br><span class="line">            <span class="keyword">del</span> self._source_traceback[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> coroutines.iscoroutine(coro):</span><br><span class="line">            self._log_destroy_pending = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">f"a coroutine was expected, got <span class="subst">&#123;coro!r&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self._name = <span class="string">f'Task-<span class="subst">&#123;_task_name_counter()&#125;</span>'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._name = str(name)</span><br><span class="line"></span><br><span class="line">        self._must_cancel = <span class="literal">False</span></span><br><span class="line">        self._fut_waiter = <span class="literal">None</span></span><br><span class="line">        self._coro = coro</span><br><span class="line">        self._context = contextvars.copy_context()</span><br><span class="line"></span><br><span class="line">        self._loop.call_soon(self.__step, context=self._context)</span><br><span class="line">        _register_task(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># base_events.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseEventLoop</span><span class="params">(events.AbstractEventLoop)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call_soon</span><span class="params">(self, callback, *args, context=None)</span>:</span></span><br><span class="line">        self._check_closed()</span><br><span class="line">        <span class="keyword">if</span> self._debug:</span><br><span class="line">            self._check_thread()</span><br><span class="line">            self._check_callback(callback, <span class="string">'call_soon'</span>)</span><br><span class="line">        handle = self._call_soon(callback, args, context)</span><br><span class="line">        <span class="keyword">if</span> handle._source_traceback:</span><br><span class="line">            <span class="keyword">del</span> handle._source_traceback[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> handle</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_call_soon</span><span class="params">(self, callback, args, context)</span>:</span></span><br><span class="line">        handle = events.Handle(callback, args, self, context)</span><br><span class="line">        <span class="keyword">if</span> handle._source_traceback:</span><br><span class="line">            <span class="keyword">del</span> handle._source_traceback[<span class="number">-1</span>]</span><br><span class="line">        self._ready.append(handle)</span><br><span class="line">        <span class="keyword">return</span> handle</span><br></pre></td></tr></table></figure>
<p><code>loop.create_task</code>方法最终会生成一个<code>Task</code>实例。<code>Task</code>实例封装了协程以及其它一系列变量，最终调用<code>loop</code>的<code>call_soon</code>方法，传入了实例的<code>__step</code>函数。<code>call_soon</code>方法传入的函数，会通过<code>events.Handle</code>封装生成一个<code>handle</code>实例，并加入到事件循环的<code>_ready</code>队列中。<br>​</p>
<p><code>__step</code>方法会通过<code>coro.send(None)</code>或是<code>coro.throw(exc)</code>方法启动<code>Task</code>实例内部的协程并获取协程的返回结果，对于一般协程而言<code>coro.send(None)</code>会直接<code>throw</code>一个<code>StopIteration</code>异常，并在异常结果里附上协程返回值。当然，也有其它情况（比如<code>await</code>了一个<code>yield</code>多次的<code>Awaitable</code>实例）可能要多次<code>call_soon</code>协程<code>Task</code>的<code>__step</code>函数，相关的例子可以查看stackoverflow的<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzQ0NjkwNjAvcHl0aG9uLW5hdGl2ZS1jb3JvdXRpbmVzLWFuZC1zZW5k" title="https://stackoverflow.com/questions/34469060/python-native-coroutines-and-send">这篇文章<i class="fa fa-external-link"></i></span>。<br>​</p>
<p>在这之后，我们再回到<code>run_until_complete</code>方法，在<code>ensure_future</code>后，便调用<code>loop.run_forever</code>方法，启动事件循环。<br>​</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># windows_events.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProactorEventLoop</span><span class="params">(proactor_events.BaseProactorEventLoop)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_forever</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">assert</span> self._self_reading_future <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">            self.call_soon(self._loop_self_reading)</span><br><span class="line">            super().run_forever()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="keyword">if</span> self._self_reading_future <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                ov = self._self_reading_future._ov</span><br><span class="line">                self._self_reading_future.cancel()</span><br><span class="line">                <span class="keyword">if</span> ov <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    self._proactor._unregister(ov)</span><br><span class="line">                self._self_reading_future = <span class="literal">None</span></span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line"><span class="comment"># proactor_events.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseProactorEventLoop</span><span class="params">(base_events.BaseEventLoop)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_loop_self_reading</span><span class="params">(self, f=None)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> f <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                f.result()  <span class="comment"># may raise</span></span><br><span class="line">            <span class="keyword">if</span> self._self_reading_future <span class="keyword">is</span> <span class="keyword">not</span> f:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            f = self._proactor.recv(self._ssock, <span class="number">4096</span>)</span><br><span class="line">        <span class="keyword">except</span> exceptions.CancelledError:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">except</span> (SystemExit, KeyboardInterrupt):</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">except</span> BaseException <span class="keyword">as</span> exc:</span><br><span class="line">            self.call_exception_handler(&#123;</span><br><span class="line">                <span class="string">'message'</span>: <span class="string">'Error on reading from the event loop self pipe'</span>,</span><br><span class="line">                <span class="string">'exception'</span>: exc,</span><br><span class="line">                <span class="string">'loop'</span>: self,</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._self_reading_future = f</span><br><span class="line">            f.add_done_callback(self._loop_self_reading)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># base_events.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseEventLoop</span><span class="params">(events.AbstractEventLoop)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_forever</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._check_closed()</span><br><span class="line">        self._check_running()</span><br><span class="line">        self._set_coroutine_origin_tracking(self._debug)</span><br><span class="line">        self._thread_id = threading.get_ident()</span><br><span class="line"></span><br><span class="line">        old_agen_hooks = sys.get_asyncgen_hooks()</span><br><span class="line">        sys.set_asyncgen_hooks(firstiter=self._asyncgen_firstiter_hook,</span><br><span class="line">                               finalizer=self._asyncgen_finalizer_hook)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            events._set_running_loop(self)</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                self._run_once()</span><br><span class="line">                <span class="keyword">if</span> self._stopping:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._stopping = <span class="literal">False</span></span><br><span class="line">            self._thread_id = <span class="literal">None</span></span><br><span class="line">            events._set_running_loop(<span class="literal">None</span>)</span><br><span class="line">            self._set_coroutine_origin_tracking(<span class="literal">False</span>)</span><br><span class="line">            sys.set_asyncgen_hooks(*old_agen_hooks)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_run_once</span><span class="params">(self)</span>:</span></span><br><span class="line">        sched_count = len(self._scheduled)</span><br><span class="line">        <span class="keyword">if</span> (sched_count &gt; _MIN_SCHEDULED_TIMER_HANDLES <span class="keyword">and</span></span><br><span class="line">            self._timer_cancelled_count / sched_count &gt;</span><br><span class="line">                _MIN_CANCELLED_TIMER_HANDLES_FRACTION):</span><br><span class="line">            new_scheduled = []</span><br><span class="line">            <span class="keyword">for</span> handle <span class="keyword">in</span> self._scheduled:</span><br><span class="line">                <span class="keyword">if</span> handle._cancelled:</span><br><span class="line">                    handle._scheduled = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    new_scheduled.append(handle)</span><br><span class="line"></span><br><span class="line">            heapq.heapify(new_scheduled)</span><br><span class="line">            self._scheduled = new_scheduled</span><br><span class="line">            self._timer_cancelled_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> self._scheduled <span class="keyword">and</span> self._scheduled[<span class="number">0</span>]._cancelled:</span><br><span class="line">                self._timer_cancelled_count -= <span class="number">1</span></span><br><span class="line">                handle = heapq.heappop(self._scheduled)</span><br><span class="line">                handle._scheduled = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        timeout = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> self._ready <span class="keyword">or</span> self._stopping:</span><br><span class="line">            timeout = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> self._scheduled:</span><br><span class="line">            <span class="comment"># Compute the desired timeout.</span></span><br><span class="line">            when = self._scheduled[<span class="number">0</span>]._when</span><br><span class="line">            timeout = min(max(<span class="number">0</span>, when - self.time()), MAXIMUM_SELECT_TIMEOUT)</span><br><span class="line"></span><br><span class="line">        event_list = self._selector.select(timeout)</span><br><span class="line">        self._process_events(event_list)</span><br><span class="line"></span><br><span class="line">        end_time = self.time() + self._clock_resolution</span><br><span class="line">        <span class="keyword">while</span> self._scheduled:</span><br><span class="line">            handle = self._scheduled[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> handle._when &gt;= end_time:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            handle = heapq.heappop(self._scheduled)</span><br><span class="line">            handle._scheduled = <span class="literal">False</span></span><br><span class="line">            self._ready.append(handle)</span><br><span class="line"></span><br><span class="line">        ntodo = len(self._ready)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(ntodo):</span><br><span class="line">            handle = self._ready.popleft()</span><br><span class="line">            <span class="keyword">if</span> handle._cancelled:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> self._debug:</span><br><span class="line">                <span class="comment"># debug模式下代码，加了时间统计</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                handle._run()</span><br><span class="line">        handle = <span class="literal">None</span>  <span class="comment"># Needed to break cycles when an exception occurs.</span></span><br></pre></td></tr></table></figure>
<p><code>ProactorEventLoop</code>在调用<code>run_forever</code>时，首先会用<code>call_soon</code>方法将<code>_loop_self_reading</code>方法加入排期。<code>_loop_self_reading</code>方法会读取<code>proactor</code>中的<code>future</code>，并且将自己加入<code>future</code>的完成时回调，实现不间断地读取<code>future</code>实例。<br>​</p>
<p>之后，<code>ProactorEventLoop</code>调用了<code>BaseEventLoop</code>的<code>run_forever</code>方法，在其中会不断执行<code>_run_once</code>方法去一遍遍地迭代事件循环。一轮<code>_run_once</code>会做以下几件事情：</p>
<ul>
<li>清理<code>_scheduled</code>中被取消的定时任务</li>
<li><code>select</code>出事件列表并进行处理</li>
<li>从<code>_scheduled</code>取出到时的任务，加入到<code>_ready</code>列表中<ul>
<li>由上面的逻辑也可知，<code>call_soon</code>的任务也会被加入到<code>_ready</code>列表中</li>
</ul>
</li>
<li>从<code>_ready</code>列表中依次取出所有<code>handle</code>，调用<code>_run</code>方法运行</li>
</ul>
<p>通过这种机制，事件循环就能持续不断地运行任务。<br>​<br>由上述<code>_run_once</code>的定义也可知，在<code>select</code>事件列表一步会出现<code>IOCP</code>的身影，这是因为<code>BaseProactorEventLoop</code>的<code>selector</code>就是<code>proactor</code>，实际传入的就是<code>IOCP</code>实例，因此最终就是调用了<code>IOCP</code>实例的<code>select</code>方法。也是只有在这一步，才会去处理一些IO操作。<br>​<br>所以问题来了，针对IO操作，<code>asyncio</code>是如何进行调度的呢？我们首先看<code>IocpProactor.select</code>的实现：<br>​</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># windows_events.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IocpProactor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(self, timeout=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._results:</span><br><span class="line">            self._poll(timeout)</span><br><span class="line">        tmp = self._results</span><br><span class="line">        self._results = []</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_poll</span><span class="params">(self, timeout=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            ms = INFINITE</span><br><span class="line">        <span class="keyword">elif</span> timeout &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"negative timeout"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ms = math.ceil(timeout * <span class="number">1e3</span>)</span><br><span class="line">            <span class="keyword">if</span> ms &gt;= INFINITE:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">"timeout too big"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            status = _overlapped.GetQueuedCompletionStatus(self._iocp, ms)</span><br><span class="line">            <span class="keyword">if</span> status <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            ms = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            err, transferred, key, address = status</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                f, ov, obj, callback = self._cache.pop(address)</span><br><span class="line">            <span class="keyword">except</span> KeyError:</span><br><span class="line">                <span class="keyword">if</span> self._loop.get_debug():</span><br><span class="line">                    self._loop.call_exception_handler(&#123;</span><br><span class="line">                        <span class="string">'message'</span>: (<span class="string">'GetQueuedCompletionStatus() returned an '</span></span><br><span class="line">                                    <span class="string">'unexpected event'</span>),</span><br><span class="line">                        <span class="string">'status'</span>: (<span class="string">'err=%s transferred=%s key=%#x address=%#x'</span></span><br><span class="line">                                   % (err, transferred, key, address)),</span><br><span class="line">                    &#125;)</span><br><span class="line">                <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">0</span>, _overlapped.INVALID_HANDLE_VALUE):</span><br><span class="line">                    _winapi.CloseHandle(key)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> obj <span class="keyword">in</span> self._stopped_serving:</span><br><span class="line">                f.cancel()</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> f.done():</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    value = callback(transferred, key, ov)</span><br><span class="line">                <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">                    f.set_exception(e)</span><br><span class="line">                    self._results.append(f)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f.set_result(value)</span><br><span class="line">                    self._results.append(f)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Remove unregistered futures</span></span><br><span class="line">        <span class="keyword">for</span> ov <span class="keyword">in</span> self._unregistered:</span><br><span class="line">            self._cache.pop(ov.address, <span class="literal">None</span>)</span><br><span class="line">        self._unregistered.clear()</span><br></pre></td></tr></table></figure>
<p>在<code>IocpProactor._poll</code>中，会调用<code>GetQueuedCompletionStatus</code>去查询完成端口的结果。直到有结果出现，才会根据结果中缓存的<code>address</code>数据<code>pop</code>出缓存的回调并且执行。</p>
<p>我们通过剖析一个IO操作的例子，来观察其中具体的奥秘：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HOST, PORT = <span class="string">'127.0.0.1'</span>, <span class="number">31077</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">_svr_handler</span><span class="params">(reader: asyncio.StreamReader, writer: asyncio.StreamWriter)</span>:</span></span><br><span class="line">    data = <span class="keyword">await</span> reader.read(<span class="number">1024</span>)</span><br><span class="line">    msg = data.decode()</span><br><span class="line">    print(<span class="string">f'[Server] recv: <span class="subst">&#123;msg&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">    msg_back = <span class="string">''</span>.join([msg[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(msg) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>)])</span><br><span class="line">    print(<span class="string">f'[Server] send: <span class="subst">&#123;msg_back&#125;</span>'</span>)</span><br><span class="line">    writer.write(msg_back.encode())</span><br><span class="line">    <span class="keyword">await</span> writer.drain()</span><br><span class="line"></span><br><span class="line">    writer.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">_svr_task</span><span class="params">()</span>:</span></span><br><span class="line">    svr = <span class="keyword">await</span> asyncio.start_server(_svr_handler, host=HOST, port=PORT)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> svr:</span><br><span class="line">        <span class="keyword">await</span> svr.serve_forever()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_svr</span><span class="params">()</span>:</span></span><br><span class="line">    asyncio.run(_svr_task())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">_test_cli</span><span class="params">(msg: str)</span>:</span></span><br><span class="line">    reader, writer = <span class="keyword">await</span> asyncio.open_connection(HOST, PORT)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f'[Client] send: <span class="subst">&#123;msg&#125;</span>'</span>)</span><br><span class="line">    writer.write(msg.encode())</span><br><span class="line">    <span class="keyword">await</span> writer.drain()</span><br><span class="line"></span><br><span class="line">    data = <span class="keyword">await</span> reader.read(<span class="number">1024</span>)</span><br><span class="line">    print(<span class="string">f'[Client] recv: <span class="subst">&#123;data.decode()&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">    writer.close()</span><br><span class="line">    <span class="keyword">await</span> writer.wait_closed()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_cli</span><span class="params">()</span>:</span></span><br><span class="line">    p = Process(target=_svr, daemon=<span class="literal">True</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    _msg = <span class="string">'helloworld'</span></span><br><span class="line">    asyncio.run(_test_cli(_msg))</span><br><span class="line">    p.kill()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test_cli()</span><br></pre></td></tr></table></figure>
<p>这是一个很简单的<code>echo server</code>的实现，<code>client</code>发送给<code>server</code>信息，<code>server</code>返回信息的<code>reverse</code>。我们以<code>client</code>的写操作<code>writer.write</code>为例，看下IO事件是如何在事件循环里被处理的。<br>​</p>
<p>首先，<code>open_connection</code>函数创建了对特定<code>host</code>、<code>port</code>的连接，并返回连接流的<code>reader</code>跟<code>writer</code>。<br>​</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">open_connection</span><span class="params">(host=None, port=None, *,</span></span></span><br><span class="line"><span class="function"><span class="params">                          limit=_DEFAULT_LIMIT, **kwds)</span>:</span></span><br><span class="line">    loop = events.get_running_loop()</span><br><span class="line">    reader = StreamReader(limit=limit, loop=loop)</span><br><span class="line">    protocol = StreamReaderProtocol(reader, loop=loop)</span><br><span class="line">    transport, _ = <span class="keyword">await</span> loop.create_connection(</span><br><span class="line">        <span class="keyword">lambda</span>: protocol, host, port, **kwds)</span><br><span class="line">    writer = StreamWriter(transport, protocol, reader, loop)</span><br><span class="line">    <span class="keyword">return</span> reader, writer</span><br></pre></td></tr></table></figure>
<p>针对<code>reader</code>，首先会初始化一个<code>StreamReader</code>实例，再用<code>StreamReaderProtocol</code>对<code>reader</code>做进一步的封装。<br>​</p>
<p>针对<code>writer</code>，首先会通过<code>loop</code>的<code>create_connection</code>方法，针对本次连接创建<code>transport</code>实例，相当于一个通信管道的封装。<code>transport</code>实例会与先前创建的<code>StreamReaderProtocol</code>实例进行绑定。然后，再将创建的<code>transport</code>实例和<code>writer</code>绑定。<br>​</p>
<p>在<code>ProactorEventLoop</code>中，会这样创建<code>transport</code>实例：<br>​</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># proactor_events.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseProactorEventLoop</span><span class="params">(base_events.BaseEventLoop)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _ProactorSocketTransport(self, sock, protocol, waiter,</span><br><span class="line">                                        extra, server)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ProactorSocketTransport</span><span class="params">(_ProactorReadPipeTransport,</span></span></span><br><span class="line"><span class="class"><span class="params">                               _ProactorBaseWritePipeTransport,</span></span></span><br><span class="line"><span class="class"><span class="params">                               transports.Transport)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, loop, sock, protocol, waiter=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 extra=None, server=None)</span>:</span></span><br><span class="line">        super().__init__(loop, sock, protocol, waiter, extra, server)</span><br><span class="line">        base_events._set_nodelay(sock)</span><br></pre></td></tr></table></figure>
<p><code>_ProactorSocketTransport</code>实例会同时对<code>_ProactorReadPipeTransport</code>以及<code>_ProactorBaseWritePipeTransport</code>的初始化，因此会提供对管道读写的功能。其继承链如下：<br>​</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&lt;class &apos;asyncio.proactor_events._ProactorSocketTransport&apos;&gt;,</span><br><span class="line"> &lt;class &apos;asyncio.proactor_events._ProactorReadPipeTransport&apos;&gt;,</span><br><span class="line"> &lt;class &apos;asyncio.proactor_events._ProactorBaseWritePipeTransport&apos;&gt;,</span><br><span class="line"> &lt;class &apos;asyncio.proactor_events._ProactorBasePipeTransport&apos;&gt;,</span><br><span class="line"> &lt;class &apos;asyncio.transports._FlowControlMixin&apos;&gt;,</span><br><span class="line"> &lt;class &apos;asyncio.transports.Transport&apos;&gt;,</span><br><span class="line"> &lt;class &apos;asyncio.transports.ReadTransport&apos;&gt;,</span><br><span class="line"> &lt;class &apos;asyncio.transports.WriteTransport&apos;&gt;,</span><br><span class="line"> &lt;class &apos;asyncio.transports.BaseTransport&apos;&gt;,</span><br><span class="line"> &lt;class &apos;object&apos;&gt;)</span><br></pre></td></tr></table></figure>
<p>之后，当客户端开始写操作，调用<code>writer.write</code>时，实质是进行了以下操作：<br>​</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># proactor_events.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ProactorBaseWritePipeTransport</span><span class="params">(_ProactorBasePipeTransport,</span></span></span><br><span class="line"><span class="class"><span class="params">                                      transports.WriteTransport)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="comment"># 省略一些判断逻辑</span></span><br><span class="line">        <span class="comment"># Observable states:</span></span><br><span class="line">        <span class="comment"># 1. IDLE: _write_fut and _buffer both None</span></span><br><span class="line">        <span class="comment"># 2. WRITING: _write_fut set; _buffer None</span></span><br><span class="line">        <span class="comment"># 3. BACKED UP: _write_fut set; _buffer a bytearray</span></span><br><span class="line">        <span class="comment"># We always copy the data, so the caller can't modify it</span></span><br><span class="line">        <span class="comment"># while we're still waiting for the I/O to happen.</span></span><br><span class="line">        <span class="keyword">if</span> self._write_fut <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># IDLE -&gt; WRITING</span></span><br><span class="line">            <span class="keyword">assert</span> self._buffer <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">            <span class="comment"># Pass a copy, except if it's already immutable.</span></span><br><span class="line">            self._loop_writing(data=bytes(data))</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> self._buffer:  <span class="comment"># WRITING -&gt; BACKED UP</span></span><br><span class="line">            <span class="comment"># Make a mutable copy which we can extend.</span></span><br><span class="line">            self._buffer = bytearray(data)</span><br><span class="line">            self._maybe_pause_protocol()</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># BACKED UP</span></span><br><span class="line">            <span class="comment"># Append to buffer (also copies).</span></span><br><span class="line">            self._buffer.extend(data)</span><br><span class="line">            self._maybe_pause_protocol()</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_loop_writing</span><span class="params">(self, f=None, data=None)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> f <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self._write_fut <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> self._closing:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">assert</span> f <span class="keyword">is</span> self._write_fut</span><br><span class="line">            self._write_fut = <span class="literal">None</span></span><br><span class="line">            self._pending_write = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> f:</span><br><span class="line">                f.result()</span><br><span class="line">            <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                data = self._buffer</span><br><span class="line">                self._buffer = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                <span class="keyword">if</span> self._closing:</span><br><span class="line">                    self._loop.call_soon(self._call_connection_lost, <span class="literal">None</span>)</span><br><span class="line">                <span class="keyword">if</span> self._eof_written:</span><br><span class="line">                    self._sock.shutdown(socket.SHUT_WR)</span><br><span class="line">                self._maybe_resume_protocol()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._write_fut = self._loop._proactor.send(self._sock, data)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self._write_fut.done():</span><br><span class="line">                    <span class="keyword">assert</span> self._pending_write == <span class="number">0</span></span><br><span class="line">                    self._pending_write = len(data)</span><br><span class="line">                    self._write_fut.add_done_callback(self._loop_writing)</span><br><span class="line">                    self._maybe_pause_protocol()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self._write_fut.add_done_callback(self._loop_writing)</span><br><span class="line">            <span class="keyword">if</span> self._empty_waiter <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self._write_fut <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                self._empty_waiter.set_result(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">except</span> ConnectionResetError <span class="keyword">as</span> exc:</span><br><span class="line">            self._force_close(exc)</span><br><span class="line">        <span class="keyword">except</span> OSError <span class="keyword">as</span> exc:</span><br><span class="line">            self._fatal_error(exc, <span class="string">'Fatal write error on pipe transport'</span>)</span><br></pre></td></tr></table></figure>
<p>第一次<code>write</code>时，<code>write_future</code>以及<code>buffer</code>为空，因此触发了<code>_loop_writing</code>逻辑。在<code>_loop_writing</code>中，调用了<code>self._loop._proactor.send(self._sock, data)</code>生成了一个写操作的<code>future</code>。而<code>_proactor</code>，也就是在<code>ProactorEventLoop</code>里的<code>IocpProactor</code>实例了。<br>​</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># windows_events.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IocpProactor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(self, conn, buf, flags=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self._register_with_iocp(conn)</span><br><span class="line">        ov = _overlapped.Overlapped(NULL)</span><br><span class="line">        <span class="keyword">if</span> isinstance(conn, socket.socket):</span><br><span class="line">            ov.WSASend(conn.fileno(), buf, flags)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ov.WriteFile(conn.fileno(), buf)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">finish_send</span><span class="params">(trans, key, ov)</span>:</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">return</span> ov.getresult()</span><br><span class="line">            <span class="keyword">except</span> OSError <span class="keyword">as</span> exc:</span><br><span class="line">                <span class="keyword">if</span> exc.winerror <span class="keyword">in</span> (_overlapped.ERROR_NETNAME_DELETED,</span><br><span class="line">                                    _overlapped.ERROR_OPERATION_ABORTED):</span><br><span class="line">                    <span class="keyword">raise</span> ConnectionResetError(*exc.args)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self._register(ov, conn, finish_send)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_register_with_iocp</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> obj <span class="keyword">not</span> <span class="keyword">in</span> self._registered:</span><br><span class="line">            self._registered.add(obj)</span><br><span class="line">            _overlapped.CreateIoCompletionPort(obj.fileno(), self._iocp, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_register</span><span class="params">(self, ov, obj, callback)</span>:</span></span><br><span class="line">        self._check_closed()</span><br><span class="line"></span><br><span class="line">        f = _OverlappedFuture(ov, loop=self._loop)</span><br><span class="line">        <span class="keyword">if</span> f._source_traceback:</span><br><span class="line">            <span class="keyword">del</span> f._source_traceback[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ov.pending:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                value = callback(<span class="literal">None</span>, <span class="literal">None</span>, ov)</span><br><span class="line">            <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">                f.set_exception(e)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                f.set_result(value)</span><br><span class="line"></span><br><span class="line">        self._cache[ov.address] = (f, ov, obj, callback)</span><br><span class="line">        <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure>
<p>在<code>send</code>方法中，做了如下操作：<br>​</p>
<ul>
<li>通过<code>CreateIoCompletionPort</code>注册<code>socket</code>到完成端口</li>
<li>创建一个<code>Overlapped</code>实例，通过<code>WSASend</code>发送数据到<code>socket</code></li>
<li>创建一个关联<code>Overlapped</code>实例的<code>future</code>，并且判断<code>Overlapped</code>实例如果不在<code>pending</code>状态就直接执行回调。之后，缓存这个<code>future</code>实例到<code>_cache</code>中。</li>
</ul>
<p>​<br>在先前已经提到，事件循环执行时，<code>IocpProactor</code>实例会调用<code>_poll</code>方法，其中会采用<code>GetQueuedCompletionStatus</code>查询IO操作完成结果。如果发现有IO操作完成，就会从操作中提取<code>ov.address</code>并在<code>_cache</code>中<code>pop</code>出回调然后执行。这样通过<code>IOCP</code>模型加上事件循环（事件循环实质就是<code>IOCP</code>里头的<code>worker</code>），就把<code>writer.write</code>的操作从开始到完成的步骤给串起来了。<br>​<br>之后就是<code>await writer.drain</code>，实质是做了如下操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># streams.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamWriter</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">drain</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">await</span> self._protocol._drain_helper()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlowControlMixin</span><span class="params">(protocols.Protocol)</span>:</span>  <span class="comment"># 这个会被StreamReaderProtocol继承</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">_drain_helper</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._connection_lost:</span><br><span class="line">            <span class="keyword">raise</span> ConnectionResetError(<span class="string">'Connection lost'</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._paused:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        waiter = self._drain_waiter</span><br><span class="line">        <span class="keyword">assert</span> waiter <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> waiter.cancelled()</span><br><span class="line">        waiter = self._loop.create_future()</span><br><span class="line">        self._drain_waiter = waiter</span><br><span class="line">        <span class="keyword">await</span> waiter</span><br></pre></td></tr></table></figure>
<p><code>writer.drain</code>实质上是<code>await</code>了<code>StreamReaderProtocol</code>实例的<code>_drain_helper</code>协程，其中做了一些前置检查，然后依据当前事件循环设置了一个<code>_drain_waiter</code>的<code>future</code>实例，并<code>await</code>。为什么要这么做呢？<br>​<br>首先，我们可以观察得知，在<code>_run_once</code>的逻辑中，如果<code>_ready</code>队列有任务，或者是有<code>_scheduled</code>里头的定时任务，那么之后<code>IocpProactor._poll</code>里头的<code>GetQueuedCompletionStatus</code>就会有<code>timeout</code>，否则<code>GetQueuedCompletionStatus</code>对应的<code>timeout</code>就是<code>INFINITE</code>，会一直阻塞直到有IO事件完成。有兴趣的同学可以创建一个协程任务，里头<code>create_future</code>之后<code>await</code>下，一试便知。</p>
<p>然后，回到<code>_ProactorBaseWritePipeTransport</code>的<code>_loop_writing</code>方法。<code>_write_fut</code>被创建后，会直接添加<code>_loop_writing</code>为自己的完成回调。当<code>IocpProactor</code>实例由<code>GetQueuedCompletionStatus</code>获得一个完成事件之后，会取出来执行<code>ov.getresult()</code>（在<code>send</code>方法的<code>finish_send</code>里头）来获取结果，这个结果就会被放到<code>_write_fut</code>作为其最终的返回结果。此时<code>_write_fut</code>由于完成了，因此会调用自己的回调<code>_loop_writing</code>，但这个时候因为<code>buffer</code>里没有数据了，所以就会走到<code>_maybe_resume_protocol</code><br>​</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># transports.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_FlowControlMixin</span><span class="params">(Transport)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_maybe_resume_protocol</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> (self._protocol_paused <span class="keyword">and</span></span><br><span class="line">                self.get_write_buffer_size() &lt;= self._low_water):</span><br><span class="line">            self._protocol_paused = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self._protocol.resume_writing()</span><br><span class="line">            <span class="keyword">except</span> (SystemExit, KeyboardInterrupt):</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">            <span class="keyword">except</span> BaseException <span class="keyword">as</span> exc:</span><br><span class="line">                self._loop.call_exception_handler(&#123;</span><br><span class="line">                    <span class="string">'message'</span>: <span class="string">'protocol.resume_writing() failed'</span>,</span><br><span class="line">                    <span class="string">'exception'</span>: exc,</span><br><span class="line">                    <span class="string">'transport'</span>: self,</span><br><span class="line">                    <span class="string">'protocol'</span>: self._protocol,</span><br><span class="line">                &#125;)</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line"><span class="comment"># streams.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlowControlMixin</span><span class="params">(protocols.Protocol)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">resume_writing</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> self._paused</span><br><span class="line">        self._paused = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> self._loop.get_debug():</span><br><span class="line">            logger.debug(<span class="string">"%r resumes writing"</span>, self)</span><br><span class="line"></span><br><span class="line">        waiter = self._drain_waiter</span><br><span class="line">        <span class="keyword">if</span> waiter <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self._drain_waiter = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> waiter.done():</span><br><span class="line">                waiter.set_result(<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>在<code>writer.drain</code>中，我们实际上是一直在<code>await</code>这个<code>_drain_waiter</code>。在调用<code>_maybe_resume_protocol</code>之后，实际是走到了<code>StreamReaderProtocol</code>实例的<code>resume_writing</code>方法，在<code>FlowControlMixin</code>类被定义。这个方法执行了两个操作：<br>​</p>
<ul>
<li>将<code>_paused</code>状态置为<code>False</code><ul>
<li><code>_loop_writing</code>中，如果数据没发完，就会另外走到<code>_maybe_pause_protocol</code>，会把这个状态置为<code>true</code>。此时调用<code>await writer.drain</code>，就正好会走到了<code>await _drain_waiter</code></li>
</ul>
</li>
<li>将<code>_drain_waiter</code>设置完成。这样，<code>await writer.drain</code>就能完成了</li>
</ul>
<p>客户端的写操作，在事件循环里就是通过如上复杂的方式调度的。总的来说，是如下的步骤：<br>​</p>
<ul>
<li>用户调用<code>writer.write</code>将数据传进<code>transport</code>的写<code>buffer</code></li>
<li><code>transport</code>的<code>_loop_writing</code>发现<code>buffer</code>有数据，创建一个写<code>future</code><ul>
<li>通过<code>CreateIoCompletionPort</code>绑定<code>socket</code>跟完成端口</li>
<li>通过<code>WSASend</code>发送数据</li>
<li>设置一个回调用来取发送数据的结果</li>
<li>取出来的结果给到写<code>future</code></li>
<li>写<code>future</code>预先设置<code>_loop_writing</code>为完成回调，得到结果后执行下一轮<code>_loop_writing</code></li>
</ul>
</li>
<li>用户调用<code>await writer.drain</code><ul>
<li>写<code>future</code>在创建后，发现写<code>future</code>没有到完成状态，先调用<code>_maybe_pause_protocol</code>设置<code>protocol</code>的<code>_paused</code>为<code>True</code></li>
<li>在<code>writer.drain</code>里判断<code>protocol</code>为<code>_paused</code>，重置<code>_drain_waiter</code>为新的实例并<code>await</code></li>
<li>写操作完成，触发写<code>future</code>的回调<code>_loop_writing</code>。下一轮<code>_loop_writing</code>发现没有数据发送，调用<code>_maybe_resume_protocol</code>，设置<code>protocol</code>的<code>_paused</code>为<code>False</code>，并设置<code>_drain_waiter</code>为完成</li>
<li><code>_drain_waiter</code>完成，退出<code>await writer.drain</code></li>
</ul>
</li>
</ul>
<p>针对读操作，以及其它的IO操作，有兴趣的小伙伴可以深入研究^_^</p>
]]></content>
      <categories>
        <category>Hard Python</category>
      </categories>
      <tags>
        <tag>事件循环</tag>
        <tag>python</tag>
        <tag>异步</tag>
        <tag>asyncio</tag>
        <tag>proactor</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hard Python】【第二章-异步IO】1、asyncio事件循环的创建</title>
    <url>/2022/02/12/hardpython/2_asyncio_1/</url>
    <content><![CDATA[<p>python3中增加的重要特性之一即为<code>asyncio</code>，其提供了异步编程的原语支持，从而能够让python在事件驱动、协程协同等方面的编程场景大杀四方。</p>
<p>事件循环<code>EventLoop</code>是异步编程中的核心概念之一。python的异步IO，就从事件循环的实现开始讲起。</p>
<p>首先看一段示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">_test_run_main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">f'[test_run] <span class="subst">&#123;i&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_run</span><span class="params">()</span>:</span></span><br><span class="line">    coro = _test_run_main()</span><br><span class="line">    asyncio.run(coro)</span><br></pre></td></tr></table></figure>
<p>通过<code>async def</code>定义的函数，其返回值是一个异步协程<code>coroutine</code>。协程相当于是事件循环里的一个单位任务，通过<code>asyncio.run</code>接口就可以将其运行起来。因此我们先来看<code>asyncio.run</code>的实现：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(main, *, debug=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> events._get_running_loop() <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(</span><br><span class="line">            <span class="string">"asyncio.run() cannot be called from a running event loop"</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> coroutines.iscoroutine(main):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"a coroutine was expected, got &#123;!r&#125;"</span>.format(main))</span><br><span class="line"></span><br><span class="line">    loop = events.new_event_loop()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        events.set_event_loop(loop)</span><br><span class="line">        <span class="keyword">if</span> debug <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            loop.set_debug(debug)</span><br><span class="line">        <span class="keyword">return</span> loop.run_until_complete(main)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            _cancel_all_tasks(loop)</span><br><span class="line">            loop.run_until_complete(loop.shutdown_asyncgens())</span><br><span class="line">            loop.run_until_complete(loop.shutdown_default_executor())</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            events.set_event_loop(<span class="literal">None</span>)</span><br><span class="line">            loop.close()</span><br></pre></td></tr></table></figure>
<p>在<code>asyncio.run</code>中，首先会检查协程合法性以及当前线程是否有已在跑的事件循环，之后会新启动一个事件循环，并设置为当前线程在跑的事件循环，最后等待协程完成。完成后，会关闭事件循环，并取消当前线程事件循环的设置。</p>
<p>事件循环的诞生，便是从<code>new_event_loop</code>方法开始了。以windows为例，我们来看下当创建一个新的事件循环时，会发生哪些调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># runners.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_event_loop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> get_event_loop_policy().new_event_loop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># events.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_init_event_loop_policy</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> _event_loop_policy</span><br><span class="line">    <span class="keyword">with</span> _lock:</span><br><span class="line">        <span class="keyword">if</span> _event_loop_policy <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># pragma: no branch</span></span><br><span class="line">            <span class="keyword">from</span> . <span class="keyword">import</span> DefaultEventLoopPolicy</span><br><span class="line">            _event_loop_policy = DefaultEventLoopPolicy()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_event_loop_policy</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Get the current event loop policy."""</span></span><br><span class="line">    <span class="keyword">if</span> _event_loop_policy <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        _init_event_loop_policy()</span><br><span class="line">    <span class="keyword">return</span> _event_loop_policy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># windows_events.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowsProactorEventLoopPolicy</span><span class="params">(events.BaseDefaultEventLoopPolicy)</span>:</span></span><br><span class="line">    _loop_factory = ProactorEventLoop</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">DefaultEventLoopPolicy = WindowsProactorEventLoopPolicy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># events.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseDefaultEventLoopPolicy</span><span class="params">(AbstractEventLoopPolicy)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_event_loop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._loop_factory()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># windows_events.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProactorEventLoop</span><span class="params">(proactor_events.BaseProactorEventLoop)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, proactor=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> proactor <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            proactor = IocpProactor()</span><br><span class="line">        super().__init__(proactor)</span><br></pre></td></tr></table></figure>
<p>事件循环创建的策略有多种，在调用<code>new_event_loop</code>时，实质是执行默认事件循环策略的创建方法。以windows为例，默认策略是<code>ProactorEventLoop</code>。</p>
<p><code>proactor</code>模型本身为异步IO而生，其基本工作原理如下：</p>
<ul>
<li>用户态应用预先设定一组针对不同IO操作完成事件的回调（<code>Handler</code>），同时向内核注册一个完成事件的<code>dispatcher</code>（也就是<code>proactor</code>）</li>
<li>用户态线程发起异步IO操作后会即刻返回结果</li>
<li>IO操作在内核执行完成后会通知<code>proactor</code>，<code>proactor</code>根据完成事件的类型，触发对应的完成事件回调</li>
</ul>
<p>在windows下<code>ProactorEventLoop</code>实际是使用了<code>IOCP</code>模型，中文翻译叫IO完成端口，其基本工作原理如下：</p>
<ul>
<li>通过<code>CreateIoCompletionPort</code>创建完成端口<ul>
<li>完成端口，实质是一个用于缓存IO完成事件的队列</li>
</ul>
</li>
<li>创建一组<code>worker thread</code>关联完成端口</li>
<li>创建<code>listen server</code></li>
<li><code>listen server</code>在<code>accept</code>到客户端连接后，创建<code>PerHandleData</code>实例，将客户端<code>socket</code>与<code>PerHandleData</code>实例与完成端口关联起来。执行上述的关联后，可以通过<code>WSARecv</code>发起接收客户端数据的异步IO操作，然后继续<code>accept</code></li>
<li>在<code>worker thread</code>中，通过<code>GetQueueCompletionStatus</code>方法获取IO操作的完成结果。如<code>WSARecv</code>完成后，可以直接提取接收到的客户端数据，执行对应的操作</li>
<li><code>listen server</code>退出，通过<code>PostQueuedCompletionStatus</code>向完成端口发送特殊的数据包，用以让<code>worker thread</code>退出</li>
</ul>
<p>了解了<code>proactor</code>和<code>iocp</code>的基本工作原理后，我们就可以看python版<code>ProactorEventLoop</code>的具体实现了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># windows_events.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IocpProactor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, concurrency=<span class="number">0xffffffff</span>)</span>:</span></span><br><span class="line">        self._loop = <span class="literal">None</span></span><br><span class="line">        self._results = []</span><br><span class="line">        self._iocp = _overlapped.CreateIoCompletionPort(</span><br><span class="line">            _overlapped.INVALID_HANDLE_VALUE, NULL, <span class="number">0</span>, concurrency)</span><br><span class="line">        self._cache = &#123;&#125;</span><br><span class="line">        self._registered = weakref.WeakSet()</span><br><span class="line">        self._unregistered = []</span><br><span class="line">        self._stopped_serving = weakref.WeakSet()</span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProactorEventLoop</span><span class="params">(proactor_events.BaseProactorEventLoop)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, proactor=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> proactor <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            proactor = IocpProactor()</span><br><span class="line">        super().__init__(proactor)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment"># proactor_events.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseProactorEventLoop</span><span class="params">(base_events.BaseEventLoop)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, proactor)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        logger.debug(<span class="string">'Using proactor: %s'</span>, proactor.__class__.__name__)</span><br><span class="line">        self._proactor = proactor</span><br><span class="line">        self._selector = proactor   <span class="comment"># convenient alias</span></span><br><span class="line">        self._self_reading_future = <span class="literal">None</span></span><br><span class="line">        self._accept_futures = &#123;&#125;   <span class="comment"># socket file descriptor =&gt; Future</span></span><br><span class="line">        proactor.set_loop(self)</span><br><span class="line">        self._make_self_pipe()</span><br><span class="line">        <span class="keyword">if</span> threading.current_thread() <span class="keyword">is</span> threading.main_thread():</span><br><span class="line">            <span class="comment"># wakeup fd can only be installed to a file descriptor from the main thread</span></span><br><span class="line">            signal.set_wakeup_fd(self._csock.fileno())</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_make_self_pipe</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># A self-socket, really. :-)</span></span><br><span class="line">        self._ssock, self._csock = socket.socketpair()</span><br><span class="line">        self._ssock.setblocking(<span class="literal">False</span>)</span><br><span class="line">        self._csock.setblocking(<span class="literal">False</span>)</span><br><span class="line">        self._internal_fds += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># base_events.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseEventLoop</span><span class="params">(events.AbstractEventLoop)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._timer_cancelled_count = <span class="number">0</span></span><br><span class="line">        self._closed = <span class="literal">False</span></span><br><span class="line">        self._stopping = <span class="literal">False</span></span><br><span class="line">        self._ready = collections.deque()</span><br><span class="line">        self._scheduled = []</span><br><span class="line">        self._default_executor = <span class="literal">None</span></span><br><span class="line">        self._internal_fds = <span class="number">0</span></span><br><span class="line">        <span class="comment"># Identifier of the thread running the event loop, or None if the</span></span><br><span class="line">        <span class="comment"># event loop is not running</span></span><br><span class="line">        self._thread_id = <span class="literal">None</span></span><br><span class="line">        self._clock_resolution = time.get_clock_info(<span class="string">'monotonic'</span>).resolution</span><br><span class="line">        self._exception_handler = <span class="literal">None</span></span><br><span class="line">        self.set_debug(coroutines._is_debug_mode())</span><br><span class="line">        <span class="comment"># In debug mode, if the execution of a callback or a step of a task</span></span><br><span class="line">        <span class="comment"># exceed this duration in seconds, the slow callback/task is logged.</span></span><br><span class="line">        self.slow_callback_duration = <span class="number">0.1</span></span><br><span class="line">        self._current_handle = <span class="literal">None</span></span><br><span class="line">        self._task_factory = <span class="literal">None</span></span><br><span class="line">        self._coroutine_origin_tracking_enabled = <span class="literal">False</span></span><br><span class="line">        self._coroutine_origin_tracking_saved_depth = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># A weak set of all asynchronous generators that are</span></span><br><span class="line">        <span class="comment"># being iterated by the loop.</span></span><br><span class="line">        self._asyncgens = weakref.WeakSet()</span><br><span class="line">        <span class="comment"># Set to True when `loop.shutdown_asyncgens` is called.</span></span><br><span class="line">        self._asyncgens_shutdown_called = <span class="literal">False</span></span><br><span class="line">        <span class="comment"># Set to True when `loop.shutdown_default_executor` is called.</span></span><br><span class="line">        self._executor_shutdown_called = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>当<code>ProactorEventLoop</code>实例初始化时，会先创建<code>IocpProactor</code>实例，里面通过<code>CreateIoCompletionPort</code>创建了一个完成端口。之后再调用<code>BaseProactorEventLoop</code>的初始化函数。<code>BaseProactorEventLoop</code>先初始化<code>BaseEventLoop</code>，然后设置<code>proactor</code>，并创建了一组<code>socketpair</code>。</p>
<p>这样，事件循环的实例就被创建出来了。</p>
]]></content>
      <categories>
        <category>Hard Python</category>
      </categories>
      <tags>
        <tag>事件循环</tag>
        <tag>python</tag>
        <tag>asyncio</tag>
        <tag>proactor</tag>
        <tag>iocp</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hard Python】【第一章-多进程】3、Pool，多任务并行进程池</title>
    <url>/2022/01/30/hardpython/1_multiprocessing_3/</url>
    <content><![CDATA[<p>前面讲了进程创建与进程通信的内容，接下来讲一下多进程编程最能发挥的地方。对于同时运行多个同质任务来讲，采用<code>multiprocessing.Pool</code>进程池去管理是最方便的。<code>Pool</code>的用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool, process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_test_func</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    result = a + b</span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;os.getpid()&#125;</span>: <span class="subst">&#123;result&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_pool</span><span class="params">()</span>:</span></span><br><span class="line">    test_data = [(<span class="number">2</span> * i, <span class="number">2</span> * i + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>)]</span><br><span class="line">    <span class="keyword">with</span> Pool(<span class="number">4</span>) <span class="keyword">as</span> p:</span><br><span class="line">        pprint.pprint(process.active_children())</span><br><span class="line">        results = p.starmap(_test_func, test_data)  <span class="comment"># starmap指iterable的unpack，*args这样，详情看源码注释</span></span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;os.getpid()&#125;</span>: <span class="subst">&#123;results&#125;</span>'</span>)  <span class="comment"># 得到_test_func的所有结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test_pool()</span><br></pre></td></tr></table></figure>
<p>打印出来的结果，可能是这样子的：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&lt;SpawnProcess name=&apos;SpawnPoolWorker-4&apos; pid=7648 parent=2468 started daemon&gt;,</span><br><span class="line"> &lt;SpawnProcess name=&apos;SpawnPoolWorker-3&apos; pid=15812 parent=2468 started daemon&gt;,</span><br><span class="line"> &lt;SpawnProcess name=&apos;SpawnPoolWorker-1&apos; pid=3496 parent=2468 started daemon&gt;,</span><br><span class="line"> &lt;SpawnProcess name=&apos;SpawnPoolWorker-2&apos; pid=3120 parent=2468 started daemon&gt;]</span><br><span class="line">3496: 1</span><br><span class="line">3496: 5</span><br><span class="line">3496: 9</span><br><span class="line">3496: 13</span><br><span class="line">3496: 17</span><br><span class="line">3496: 21</span><br><span class="line">3496: 25</span><br><span class="line">3496: 29</span><br><span class="line">3496: 33</span><br><span class="line">3496: 37</span><br><span class="line">3496: 41</span><br><span class="line">3496: 45</span><br><span class="line">3496: 49</span><br><span class="line">3496: 53</span><br><span class="line">3496: 57</span><br><span class="line">3496: 61</span><br><span class="line">2468: [1, 5, 9, 13, 17, 21, 25, 29, 33, 37, 41, 45, 49, 53, 57, 61]</span><br></pre></td></tr></table></figure>
<p>我们可以在结果中看到这样的景象：</p>
<ul>
<li>当进入<code>with Pool</code>代码段时，进程池中的进程已经被预先创建了</li>
<li>总共16个任务，最后却只在进程池里单独1个进程中运行（小概率在2个进程中运行）</li>
</ul>
<p>具体缘由，我们一起来看<code>Pool</code>的代码实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, processes=None, initializer=None, initargs=<span class="params">()</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 maxtasksperchild=None, context=None)</span>:</span></span><br><span class="line">        <span class="comment"># 忽略一些初始变量设置</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># processes</span></span><br><span class="line">        self._processes = processes</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._repopulate_pool()</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> self._pool:</span><br><span class="line">                <span class="keyword">if</span> p.exitcode <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    p.terminate()</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> self._pool:</span><br><span class="line">                p.join()</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">        sentinels = self._get_sentinels()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># worker handler</span></span><br><span class="line">        self._worker_handler = threading.Thread(</span><br><span class="line">            target=Pool._handle_workers,</span><br><span class="line">            args=(self._cache, self._taskqueue, self._ctx, self.Process,</span><br><span class="line">                  self._processes, self._pool, self._inqueue, self._outqueue,</span><br><span class="line">                  self._initializer, self._initargs, self._maxtasksperchild,</span><br><span class="line">                  self._wrap_exception, sentinels, self._change_notifier)</span><br><span class="line">            )</span><br><span class="line">        self._worker_handler.daemon = <span class="literal">True</span></span><br><span class="line">        self._worker_handler._state = RUN</span><br><span class="line">        self._worker_handler.start()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># task handler</span></span><br><span class="line">        self._task_handler = threading.Thread(</span><br><span class="line">            target=Pool._handle_tasks,</span><br><span class="line">            args=(self._taskqueue, self._quick_put, self._outqueue,</span><br><span class="line">                  self._pool, self._cache)</span><br><span class="line">            )</span><br><span class="line">        self._task_handler.daemon = <span class="literal">True</span></span><br><span class="line">        self._task_handler._state = RUN</span><br><span class="line">        self._task_handler.start()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># result handler</span></span><br><span class="line">        self._result_handler = threading.Thread(</span><br><span class="line">            target=Pool._handle_results,</span><br><span class="line">            args=(self._outqueue, self._quick_get, self._cache)</span><br><span class="line">            )</span><br><span class="line">        self._result_handler.daemon = <span class="literal">True</span></span><br><span class="line">        self._result_handler._state = RUN</span><br><span class="line">        self._result_handler.start()</span><br></pre></td></tr></table></figure>
<p>一个<code>Pool</code>实例总共包含以下的内容：</p>
<ul>
<li><code>self._processes</code>：所有worker子进程实例</li>
<li><code>self._worker_handler</code>：管理worker子进程的线程</li>
<li><code>self._task_handler</code>：任务调度线程</li>
<li><code>self._result_handler</code>：结果收集线程</li>
</ul>
<p>上述所有的<code>worker</code>子进程跟管理线程在初始化的时候，都会被启动。首先我们来看<code>worker</code>进程的情况：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_repopulate_pool</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self._repopulate_pool_static(self._ctx, self.Process,</span><br><span class="line">                                        self._processes,</span><br><span class="line">                                        self._pool, self._inqueue,</span><br><span class="line">                                        self._outqueue, self._initializer,</span><br><span class="line">                                        self._initargs,</span><br><span class="line">                                        self._maxtasksperchild,</span><br><span class="line">                                        self._wrap_exception)</span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_repopulate_pool_static</span><span class="params">(ctx, Process, processes, pool, inqueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                            outqueue, initializer, initargs,</span></span></span><br><span class="line"><span class="function"><span class="params">                            maxtasksperchild, wrap_exception)</span>:</span></span><br><span class="line">    <span class="string">"""Bring the number of pool processes up to the specified number,</span></span><br><span class="line"><span class="string">    for use after reaping workers which have exited.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(processes - len(pool)):</span><br><span class="line">        w = Process(ctx, target=worker,</span><br><span class="line">                    args=(inqueue, outqueue,</span><br><span class="line">                          initializer,</span><br><span class="line">                          initargs, maxtasksperchild,</span><br><span class="line">                          wrap_exception))</span><br><span class="line">        w.name = w.name.replace(<span class="string">'Process'</span>, <span class="string">'PoolWorker'</span>)</span><br><span class="line">        w.daemon = <span class="literal">True</span></span><br><span class="line">        w.start()</span><br><span class="line">        pool.append(w)</span><br><span class="line">        util.debug(<span class="string">'added worker'</span>)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(inqueue, outqueue, initializer=None, initargs=<span class="params">()</span>, maxtasks=None,</span></span></span><br><span class="line"><span class="function"><span class="params">           wrap_exception=False)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> (maxtasks <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) <span class="keyword">and</span> <span class="keyword">not</span> (isinstance(maxtasks, int)</span><br><span class="line">                                       <span class="keyword">and</span> maxtasks &gt;= <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">raise</span> AssertionError(<span class="string">"Maxtasks &#123;!r&#125; is not valid"</span>.format(maxtasks))</span><br><span class="line">    put = outqueue.put</span><br><span class="line">    get = inqueue.get</span><br><span class="line">    <span class="keyword">if</span> hasattr(inqueue, <span class="string">'_writer'</span>):</span><br><span class="line">        inqueue._writer.close()</span><br><span class="line">        outqueue._reader.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> initializer <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        initializer(*initargs)</span><br><span class="line"></span><br><span class="line">    completed = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> maxtasks <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> (maxtasks <span class="keyword">and</span> completed &lt; maxtasks):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            task = get()</span><br><span class="line">        <span class="keyword">except</span> (EOFError, OSError):</span><br><span class="line">            util.debug(<span class="string">'worker got EOFError or OSError -- exiting'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> task <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            util.debug(<span class="string">'worker got sentinel -- exiting'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        job, i, func, args, kwds = task</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = (<span class="literal">True</span>, func(*args, **kwds))</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> wrap_exception <span class="keyword">and</span> func <span class="keyword">is</span> <span class="keyword">not</span> _helper_reraises_exception:</span><br><span class="line">                e = ExceptionWithTraceback(e, e.__traceback__)</span><br><span class="line">            result = (<span class="literal">False</span>, e)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            put((job, i, result))</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            wrapped = MaybeEncodingError(e, result[<span class="number">1</span>])</span><br><span class="line">            util.debug(<span class="string">"Possible encoding error while sending result: %s"</span> % (</span><br><span class="line">                wrapped))</span><br><span class="line">            put((job, i, (<span class="literal">False</span>, wrapped)))</span><br><span class="line"></span><br><span class="line">        task = job = result = func = args = kwds = <span class="literal">None</span></span><br><span class="line">        completed += <span class="number">1</span></span><br><span class="line">    util.debug(<span class="string">'worker exiting after %d tasks'</span> % completed)</span><br></pre></td></tr></table></figure>
<p><code>_repopulate_pool</code>是启动所有<code>worker</code>进程的出发点，顺流而下，所有<code>worker</code>进程最终会执行<code>worker</code>函数。<code>worker</code>函数有如下的步骤：</p>
<ul>
<li>执行<code>initializer(*initargs)</code>。在多进程的场景下，有很多模块到了子进程可能是未初始化的状态，而<code>initializer</code>就提供了一个在子进程中初始化某些模块或者变量的途径。</li>
<li>从<code>inqueue</code>中<code>get</code>一个<code>task</code>的实例，将其<code>unpack</code></li>
<li>执行<code>task</code>中的<code>func</code>，得到结果</li>
<li>将结果<code>put</code>到<code>outqueue</code></li>
</ul>
<p>然后我们再看下<code>_task_handler</code>，对应的函数是<code>Pool._handle_tasks</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_handle_tasks</span><span class="params">(taskqueue, put, outqueue, pool, cache)</span>:</span></span><br><span class="line">    thread = threading.current_thread()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> taskseq, set_length <span class="keyword">in</span> iter(taskqueue.get, <span class="literal">None</span>):</span><br><span class="line">        task = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># iterating taskseq cannot fail</span></span><br><span class="line">            <span class="keyword">for</span> task <span class="keyword">in</span> taskseq:</span><br><span class="line">                <span class="keyword">if</span> thread._state != RUN:</span><br><span class="line">                    util.debug(<span class="string">'task handler found thread._state != RUN'</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    put(task)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    job, idx = task[:<span class="number">2</span>]</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        cache[job]._set(idx, (<span class="literal">False</span>, e))</span><br><span class="line">                    <span class="keyword">except</span> KeyError:</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> set_length:</span><br><span class="line">                    util.debug(<span class="string">'doing set_length()'</span>)</span><br><span class="line">                    idx = task[<span class="number">1</span>] <span class="keyword">if</span> task <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">                    set_length(idx + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            task = taskseq = job = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        util.debug(<span class="string">'task handler got sentinel'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># tell result handler to finish when cache is empty</span></span><br><span class="line">        util.debug(<span class="string">'task handler sending sentinel to result handler'</span>)</span><br><span class="line">        outqueue.put(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># tell workers there is no more work</span></span><br><span class="line">        util.debug(<span class="string">'task handler sending sentinel to workers'</span>)</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> pool:</span><br><span class="line">            put(<span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">except</span> OSError:</span><br><span class="line">        util.debug(<span class="string">'task handler got OSError when sending sentinels'</span>)</span><br><span class="line"></span><br><span class="line">    util.debug(<span class="string">'task handler exiting'</span>)</span><br></pre></td></tr></table></figure>
<p><code>task_handler</code>负责从<code>taskqueue</code>中得到<code>task</code>实例，并<code>put</code>到<code>inqueue</code>中。当所有<code>task</code>实例推送完毕后，像<code>result_handler</code>和所有<code>worker process</code>推送了<code>None</code>实例。从先前<code>worker</code>的代码中可以知晓，当<code>inqueue</code>收到了<code>None</code>，就代表任务已经推送完毕，可以<code>break</code>退出了。而至于为何也给到<code>result_handler</code>一个<code>None</code>实例，我们就看下<code>result_handler</code>的代码，来分析其中具体的机制。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_handle_results</span><span class="params">(outqueue, get, cache)</span>:</span></span><br><span class="line">    thread = threading.current_thread()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            task = get()</span><br><span class="line">        <span class="keyword">except</span> (OSError, EOFError):</span><br><span class="line">            util.debug(<span class="string">'result handler got EOFError/OSError -- exiting'</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> thread._state != RUN:</span><br><span class="line">            <span class="keyword">assert</span> thread._state == TERMINATE, <span class="string">"Thread not in TERMINATE"</span></span><br><span class="line">            util.debug(<span class="string">'result handler found thread._state=TERMINATE'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> task <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            util.debug(<span class="string">'result handler got sentinel'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        job, i, obj = task</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cache[job]._set(i, obj)</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        task = job = obj = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> cache <span class="keyword">and</span> thread._state != TERMINATE:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            task = get()</span><br><span class="line">        <span class="keyword">except</span> (OSError, EOFError):</span><br><span class="line">            util.debug(<span class="string">'result handler got EOFError/OSError -- exiting'</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> task <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            util.debug(<span class="string">'result handler ignoring extra sentinel'</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        job, i, obj = task</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cache[job]._set(i, obj)</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        task = job = obj = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> hasattr(outqueue, <span class="string">'_reader'</span>):</span><br><span class="line">        util.debug(<span class="string">'ensuring that outqueue is not full'</span>)</span><br><span class="line">        <span class="comment"># If we don't make room available in outqueue then</span></span><br><span class="line">        <span class="comment"># attempts to add the sentinel (None) to outqueue may</span></span><br><span class="line">        <span class="comment"># block.  There is guaranteed to be no more than 2 sentinels.</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> outqueue._reader.poll():</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                get()</span><br><span class="line">        <span class="keyword">except</span> (OSError, EOFError):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    util.debug(<span class="string">'result handler exiting: len(cache)=%s, thread._state=%s'</span>,</span><br><span class="line">          len(cache), thread._state)</span><br></pre></td></tr></table></figure>
<p>在<code>handle_results</code>的主循环中，会不断地从<code>outqueue</code>里<code>get</code>结果，然后放到<code>cache</code>中。参考<code>worker</code>进程的实现中我们可以知晓，从<code>outqueue</code>里获取的结果即是<code>worker</code>任务执行后的返回值。</p>
<p>当所有<code>task</code>在<code>handle_tasks</code>线程被消费完之后，<code>handle_tasks</code>线程会在<code>outqueue</code>里<code>put</code>一个<code>None</code>值。<code>handle_results</code>线程接收到<code>None</code>值后，直到<code>cache</code>为空或者<code>Pool</code>被终止（TERMINATE）为止，都会继续接收子进程任务执行结果并存到<code>cache</code>里。<code>cache</code>为空或者<code>Pool</code>被终止之后，<code>handle_results</code>线程会清空<code>outqueue</code>，然后退出。</p>
<p>从<code>worker</code>、<code>task</code>、<code>result</code>线程的作用可以看到，<code>inqueue</code>、<code>outqueue</code>、<code>cache</code>是连接用户业务线程和子进程之间的桥梁。<code>inqueue</code>和<code>outqueue</code>的作用在前面的叙述中已经非常清楚，一个用来上传任务，一个用来下发执行结果。因此最终，我们还是要深入研究一下<code>cache</code>的运行机制。</p>
<p>首先我们还是回顾一开始给的例子，<code>test_pool</code>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_pool</span><span class="params">()</span>:</span></span><br><span class="line">    test_data = [(<span class="number">2</span> * i, <span class="number">2</span> * i + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>)]</span><br><span class="line">    <span class="keyword">with</span> Pool(<span class="number">4</span>) <span class="keyword">as</span> p:</span><br><span class="line">        pprint.pprint(process.active_children())</span><br><span class="line">        results = p.starmap(_test_func, test_data)  <span class="comment"># starmap指iterable的unpack，*args这样，详情看源码注释</span></span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;os.getpid()&#125;</span>: <span class="subst">&#123;results&#125;</span>'</span>)  <span class="comment"># 得到_test_func的所有结果</span></span><br></pre></td></tr></table></figure>
<p><code>test_pool</code>函数调用了<code>starmap</code>，<code>starmap</code>方法需要给定一个任务函数以及一组参数，和<code>map</code>不同的是，<code>starmap</code>指代的参数是带星的（<code>*args</code>），因此在调用任务函数时会<code>unpack</code>对应的参数。</p>
<p><code>starmap</code>之后，涉及到的方法定义如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">starmapstar</span><span class="params">(args)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(itertools.starmap(args[<span class="number">0</span>], args[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">starmap</span><span class="params">(self, func, iterable, chunksize=None)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Like `map()` method but the elements of the `iterable` are expected to</span></span><br><span class="line"><span class="string">    be iterables as well and will be unpacked as arguments. Hence</span></span><br><span class="line"><span class="string">    `func` and (a, b) becomes func(a, b).</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">return</span> self._map_async(func, iterable, starmapstar, chunksize).get()</span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_tasks</span><span class="params">(func, it, size)</span>:</span></span><br><span class="line">    it = iter(it)</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        x = tuple(itertools.islice(it, size))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> x:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> (func, x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_guarded_task_generation</span><span class="params">(self, result_job, func, iterable)</span>:</span></span><br><span class="line">    <span class="string">'''Provides a generator of tasks for imap and imap_unordered with</span></span><br><span class="line"><span class="string">    appropriate handling for iterables which throw exceptions during</span></span><br><span class="line"><span class="string">    iteration.'''</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        i = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(iterable):</span><br><span class="line">            <span class="keyword">yield</span> (result_job, i, func, (x,), &#123;&#125;)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">yield</span> (result_job, i+<span class="number">1</span>, _helper_reraises_exception, (e,), &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_map_async</span><span class="params">(self, func, iterable, mapper, chunksize=None, callback=None,</span></span></span><br><span class="line"><span class="function"><span class="params">        error_callback=None)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Helper function to implement map, starmap and their async counterparts.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    self._check_running()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> hasattr(iterable, <span class="string">'__len__'</span>):</span><br><span class="line">        iterable = list(iterable)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> chunksize <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        chunksize, extra = divmod(len(iterable), len(self._pool) * <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">if</span> extra:</span><br><span class="line">            chunksize += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> len(iterable) == <span class="number">0</span>:</span><br><span class="line">        chunksize = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    task_batches = Pool._get_tasks(func, iterable, chunksize)</span><br><span class="line">    result = MapResult(self, chunksize, len(iterable), callback,</span><br><span class="line">                       error_callback=error_callback)</span><br><span class="line">    self._taskqueue.put(</span><br><span class="line">        (</span><br><span class="line">            self._guarded_task_generation(result._job,</span><br><span class="line">                                          mapper,</span><br><span class="line">                                          task_batches),</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>各类<code>map/map_async</code>方法，最终都会落实到<code>_map_async</code>方法。在<code>_map_async</code>方法中会做以下几件事情：</p>
<ul>
<li>计算<code>chunksize</code>，即每<code>batch</code>子任务的数量</li>
<li>通过<code>_get_tasks</code>函数，获取传递子任务<code>batch</code>的<code>generator</code></li>
<li>生成<code>MapResult</code>实例<code>result</code></li>
<li>在<code>taskqueue</code>中放入<code>_guarded_task_generation</code>的任务<code>generator</code>实例</li>
</ul>
<p>每个子进程最终会调用<code>mapper(task_batch)</code>，相当于是<code>list(itertools.starmap(func, task_batch))</code>，也就是单个子进程会执行一个<code>batch</code>的任务，然后返回一组这个<code>batch</code>的执行结果。</p>
<p>从这个角度推论，假设每个任务函数执行要1s，总共16个子任务，<code>chunksize</code>是14，<code>pool</code>的<code>size</code>是2，那么一执行起来，前2秒的话2个子进程都会打印执行结果，然后接下来12秒就只有第1个子进程打印结果了。这是因为，第1个子进程一批被分了14个，第2个子进程一批就被分了剩下2个。如果其它变量不变，<code>pool</code>的<code>size</code>是3，那么打印的效果也和<code>size</code>为2的时候一样，这是因为<code>chunksize</code>太大，前2个子进程已经瓜分了所有子任务（14、2），第3个子进程啥任务都分不到了。</p>
<p>所以<code>chunksize</code>的设定，也是一门学问。实际使用<code>pool</code>的时候要注意这个坑。</p>
<p>接下来注意力转到<code>MapResult</code>实例<code>result</code>上，也是在这个地方会对任务缓存<code>cache</code>做一些操作。首先我们看<code>MapResult</code>的定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">job_counter = itertools.count()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplyResult</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pool, callback, error_callback)</span>:</span></span><br><span class="line">        self._pool = pool</span><br><span class="line">        self._event = threading.Event()</span><br><span class="line">        self._job = next(job_counter)</span><br><span class="line">        self._cache = pool._cache</span><br><span class="line">        self._callback = callback</span><br><span class="line">        self._error_callback = error_callback</span><br><span class="line">        self._cache[self._job] = self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ready</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._event.is_set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">successful</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.ready():</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"&#123;0!r&#125; not ready"</span>.format(self))</span><br><span class="line">        <span class="keyword">return</span> self._success</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">(self, timeout=None)</span>:</span></span><br><span class="line">        self._event.wait(timeout)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, timeout=None)</span>:</span></span><br><span class="line">        self.wait(timeout)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.ready():</span><br><span class="line">            <span class="keyword">raise</span> TimeoutError</span><br><span class="line">        <span class="keyword">if</span> self._success:</span><br><span class="line">            <span class="keyword">return</span> self._value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> self._value</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapResult</span><span class="params">(ApplyResult)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pool, chunksize, length, callback, error_callback)</span>:</span></span><br><span class="line">        ApplyResult.__init__(self, pool, callback,</span><br><span class="line">                             error_callback=error_callback)</span><br><span class="line">        self._success = <span class="literal">True</span></span><br><span class="line">        self._value = [<span class="literal">None</span>] * length</span><br><span class="line">        self._chunksize = chunksize</span><br><span class="line">        <span class="keyword">if</span> chunksize &lt;= <span class="number">0</span>:</span><br><span class="line">            self._number_left = <span class="number">0</span></span><br><span class="line">            self._event.set()</span><br><span class="line">            <span class="keyword">del</span> self._cache[self._job]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._number_left = length//chunksize + bool(length % chunksize)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_set</span><span class="params">(self, i, success_result)</span>:</span></span><br><span class="line">        self._number_left -= <span class="number">1</span></span><br><span class="line">        success, result = success_result</span><br><span class="line">        <span class="keyword">if</span> success <span class="keyword">and</span> self._success:</span><br><span class="line">            self._value[i*self._chunksize:(i+<span class="number">1</span>)*self._chunksize] = result</span><br><span class="line">            <span class="keyword">if</span> self._number_left == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> self._callback:</span><br><span class="line">                    self._callback(self._value)</span><br><span class="line">                <span class="keyword">del</span> self._cache[self._job]</span><br><span class="line">                self._event.set()</span><br><span class="line">                self._pool = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> success <span class="keyword">and</span> self._success:</span><br><span class="line">                <span class="comment"># only store first exception</span></span><br><span class="line">                self._success = <span class="literal">False</span></span><br><span class="line">                self._value = result</span><br><span class="line">            <span class="keyword">if</span> self._number_left == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># only consider the result ready once all jobs are done</span></span><br><span class="line">                <span class="keyword">if</span> self._error_callback:</span><br><span class="line">                    self._error_callback(self._value)</span><br><span class="line">                <span class="keyword">del</span> self._cache[self._job]</span><br><span class="line">                self._event.set()</span><br><span class="line">                self._pool = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>针对<code>starmap</code>而言，在<code>worker</code>中，执行了一批子任务之后，会调用<code>put((job, i, result))</code>返回独立的<code>job_id</code>、任务组编号、子任务批次的结果集。我们需要注意到，在<code>result</code>初始化时侯，会通过<code>[None] * length</code>占位所有的结果（<code>self._values</code>），并且在缓存中设置本次<code>job</code>（<code>ApplyResult</code>中<code>self._cache[self._job] = self</code>），然后在<code>handle_results</code>线程中<code>_set</code>结果时，调用了<code>MapResult._set</code>，会根据任务组编号<code>i</code>把对应位置的结果替代。直到所有批次的结果集执行结果返回后，最终会清楚缓存中的这次<code>starmap</code>的<code>job_id</code>，然后调用<code>self._event.set()</code></p>
<p><code>starmap</code>函数会阻塞，直到所有结果返回。实现阻塞操作的方式，即是用了<code>threading.Event()</code>。<code>starmap</code>返回的是<code>result.get()</code>，在<code>get</code>的实现里，会调用<code>self._event.wait</code>，也就是阻塞，直到<code>self._event.set</code>。这样，只有所有结果返回，<code>starmap</code>才会返回。如果大家日常开发中，有这种等待直到执行成功的业务需求，不妨尝试用<code>threading.Event()</code>，比<code>sleep</code>轮询的方式优雅的多。</p>
<p>说到底，<code>Pool</code>为多进程编程提供了灵活的任务调度模型。日常如果需要用到进程池做并行操作，用原生的<code>multiprocessing.Pool</code>就是不二选择。</p>
<p>当然，并行任务还有一种选择方案实用<code>ProcessPoolExecutor</code>，比原生的<code>Pool</code>稍微轻量级一点。<code>ProcessPoolExecutor</code>的机理实现，也可以参考<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM4NDI1MDEvYXJ0aWNsZS9kZXRhaWxzLzExNzcxNzIwMA==" title="https://blog.csdn.net/u013842501/article/details/117717200">这篇文档<i class="fa fa-external-link"></i></span>。</p>
]]></content>
      <categories>
        <category>Hard Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>并行</tag>
        <tag>multiprocessing</tag>
        <tag>pool</tag>
        <tag>进程池</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hard Python】【第一章-多进程】2、Pipe和Queue，进程间通信</title>
    <url>/2022/01/22/hardpython/1_multiprocessing_2/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjIvMDEvMTYvaGFyZHB5dGhvbi8xX211bHRpcHJvY2Vzc2luZ18xLw==" title="https://utmhikari.top/2022/01/16/hardpython/1_multiprocessing_1/">第一话<i class="fa fa-external-link"></i></span>详细讲解了Process新进程是如何被创建的，接下来就来讲一下进程之间有什么通信的方法。</p>
<p>要在<code>multiprocessing</code>中实现进程间通信，最直接的方法是采用<code>Pipe</code>或者<code>Queue</code>。其用法如下：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Pipe, Queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> mp_module <span class="keyword">import</span> log, seg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_test_queue</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg = q.get()</span><br><span class="line">        <span class="keyword">if</span> msg == <span class="string">'quit'</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            log(<span class="string">f'recv: <span class="subst">&#123;msg&#125;</span>'</span>)</span><br><span class="line">    log(<span class="string">'child process end~'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_queue</span><span class="params">()</span>:</span></span><br><span class="line">    seg(<span class="string">'test queue start'</span>)</span><br><span class="line">    q = Queue()</span><br><span class="line">    p = Process(target=_test_queue, args=(q,))</span><br><span class="line">    p.start()</span><br><span class="line">    cmds = [<span class="string">'helloworld'</span>, <span class="string">'testmsg'</span>, <span class="string">'quit'</span>]</span><br><span class="line">    <span class="keyword">for</span> cmd <span class="keyword">in</span> cmds:</span><br><span class="line">        log(<span class="string">f'send: <span class="subst">&#123;cmd&#125;</span>'</span>)</span><br><span class="line">        q.put(cmd)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">not</span> p.is_alive()</span><br><span class="line">    seg(<span class="string">'test queue end'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_test_pipe</span><span class="params">(r)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg = r.recv()</span><br><span class="line">        <span class="keyword">if</span> msg == <span class="string">'quit'</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            log(<span class="string">f'recv: <span class="subst">&#123;msg&#125;</span>'</span>)</span><br><span class="line">    log(<span class="string">'child process end~'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_pipe</span><span class="params">()</span>:</span></span><br><span class="line">    seg(<span class="string">'test pipe start'</span>)</span><br><span class="line">    r, w = Pipe()</span><br><span class="line">    p = Process(target=_test_pipe, args=(r,))</span><br><span class="line">    p.start()</span><br><span class="line">    cmds = [<span class="string">'helloworld'</span>, <span class="string">'testmsg'</span>, <span class="string">'quit'</span>]</span><br><span class="line">    <span class="keyword">for</span> cmd <span class="keyword">in</span> cmds:</span><br><span class="line">        log(<span class="string">f'send: <span class="subst">&#123;cmd&#125;</span>'</span>)</span><br><span class="line">        w.send(cmd)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">not</span> p.is_alive()</span><br><span class="line">    seg(<span class="string">'test pipe end'</span>)</span><br></pre></td></tr></table></figure>
<p>形式上非常简单。<code>Pipe</code>创建了一对<code>reader</code>跟<code>writer</code>，将<code>reader</code>传入子进程，主进程在<code>writer</code>写入数据，子进程即能通过<code>reader</code>读取到；<code>Queue</code>则更为方便，其实例能够直接传入子进程。主进程调用<code>put</code>即可写入数据，子进程调用<code>get</code>即可获取数据。</p>
<p>首先我们先看<code>Pipe</code>在windows下的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Pipe</span><span class="params">(duplex=True)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Returns pair of connection objects at either end of a pipe</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    address = arbitrary_address(<span class="string">'AF_PIPE'</span>)</span><br><span class="line">    <span class="keyword">if</span> duplex:</span><br><span class="line">        openmode = _winapi.PIPE_ACCESS_DUPLEX</span><br><span class="line">        access = _winapi.GENERIC_READ | _winapi.GENERIC_WRITE</span><br><span class="line">        obsize, ibsize = BUFSIZE, BUFSIZE</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        openmode = _winapi.PIPE_ACCESS_INBOUND</span><br><span class="line">        access = _winapi.GENERIC_WRITE</span><br><span class="line">        obsize, ibsize = <span class="number">0</span>, BUFSIZE</span><br><span class="line"></span><br><span class="line">    h1 = _winapi.CreateNamedPipe(</span><br><span class="line">        address, openmode | _winapi.FILE_FLAG_OVERLAPPED |</span><br><span class="line">        _winapi.FILE_FLAG_FIRST_PIPE_INSTANCE,</span><br><span class="line">        _winapi.PIPE_TYPE_MESSAGE | _winapi.PIPE_READMODE_MESSAGE |</span><br><span class="line">        _winapi.PIPE_WAIT,</span><br><span class="line">        <span class="number">1</span>, obsize, ibsize, _winapi.NMPWAIT_WAIT_FOREVER,</span><br><span class="line">        <span class="comment"># default security descriptor: the handle cannot be inherited</span></span><br><span class="line">        _winapi.NULL</span><br><span class="line">        )</span><br><span class="line">    h2 = _winapi.CreateFile(</span><br><span class="line">        address, access, <span class="number">0</span>, _winapi.NULL, _winapi.OPEN_EXISTING,</span><br><span class="line">        _winapi.FILE_FLAG_OVERLAPPED, _winapi.NULL</span><br><span class="line">        )</span><br><span class="line">    _winapi.SetNamedPipeHandleState(</span><br><span class="line">        h2, _winapi.PIPE_READMODE_MESSAGE, <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    overlapped = _winapi.ConnectNamedPipe(h1, overlapped=<span class="literal">True</span>)</span><br><span class="line">    _, err = overlapped.GetOverlappedResult(<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">assert</span> err == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    c1 = PipeConnection(h1, writable=duplex)</span><br><span class="line">    c2 = PipeConnection(h2, readable=duplex)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c1, c2</span><br></pre></td></tr></table></figure>
<p><code>h1</code>与<code>h2</code>互为服务端/客户端的关系。<code>h1</code>通过<code>CreateNamedPipe</code>创建，之后<code>h2</code>通过<code>CreateFile</code>连接到<code>h1</code>的<code>NamedPipe</code>上。之后用<code>PipeConnection</code>封装<code>h1</code>和<code>h2</code>两端，返回<code>reader</code>跟<code>writer</code>。当然，两个管道入口是否双工也是可选项。</p>
<p>经过<code>PipeConnection</code>的封装，管道即拥有了发送或接收<code>python</code>对象的方法。<code>python</code>对象的序列化/反序列化会用内置库<code>pickle</code>来支持。被<code>pickle</code>的对象会保留特定的信息，比如某个模块<code>def</code>的函数，在<code>pickle</code>时除了对函数本身进行序列化外，也会封存函数所属模块的信息。在<code>unpickle</code>时，如果找不到对应模块的信息，就会报错。因此多进程之间通信python对象时，需要留意序列化/反序列化后对应对象的取值/模块环境等情况。<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvemgtY24vMy9saWJyYXJ5L3BpY2tsZS5odG1s" title="https://docs.python.org/zh-cn/3/library/pickle.html">pickle的官方文档<i class="fa fa-external-link"></i></span>给到了我们足够的信息去了解这些机制。</p>
<p>接下来我们转向<code>Queue</code>的实现。相对于<code>Pipe</code>，<code>Queue</code>是对其的封装，并提供了更多的功能。这里我们完整列举一下<code>Queue</code>的关键代码：：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maxsize=<span class="number">0</span>, *, ctx)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> maxsize &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">from</span> .synchronize <span class="keyword">import</span> SEM_VALUE_MAX <span class="keyword">as</span> maxsize</span><br><span class="line">        self._maxsize = maxsize</span><br><span class="line">        self._reader, self._writer = connection.Pipe(duplex=<span class="literal">False</span>)</span><br><span class="line">        self._rlock = ctx.Lock()</span><br><span class="line">        self._opid = os.getpid()</span><br><span class="line">        <span class="keyword">if</span> sys.platform == <span class="string">'win32'</span>:</span><br><span class="line">            self._wlock = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._wlock = ctx.Lock()</span><br><span class="line">        self._sem = ctx.BoundedSemaphore(maxsize)</span><br><span class="line">        self._ignore_epipe = <span class="literal">False</span></span><br><span class="line">        self._reset()</span><br><span class="line">        <span class="keyword">if</span> sys.platform != <span class="string">'win32'</span>:</span><br><span class="line">            register_after_fork(self, Queue._after_fork)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getstate__</span><span class="params">(self)</span>:</span></span><br><span class="line">        context.assert_spawning(self)</span><br><span class="line">        <span class="keyword">return</span> (self._ignore_epipe, self._maxsize, self._reader, self._writer,</span><br><span class="line">                self._rlock, self._wlock, self._sem, self._opid)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setstate__</span><span class="params">(self, state)</span>:</span></span><br><span class="line">        (self._ignore_epipe, self._maxsize, self._reader, self._writer,</span><br><span class="line">         self._rlock, self._wlock, self._sem, self._opid) = state</span><br><span class="line">        self._reset()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_reset</span><span class="params">(self, after_fork=False)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> after_fork:</span><br><span class="line">            self._notempty._at_fork_reinit()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._notempty = threading.Condition(threading.Lock())</span><br><span class="line">        self._buffer = collections.deque()</span><br><span class="line">        self._thread = <span class="literal">None</span></span><br><span class="line">        self._jointhread = <span class="literal">None</span></span><br><span class="line">        self._joincancelled = <span class="literal">False</span></span><br><span class="line">        self._closed = <span class="literal">False</span></span><br><span class="line">        self._close = <span class="literal">None</span></span><br><span class="line">        self._send_bytes = self._writer.send_bytes</span><br><span class="line">        self._recv_bytes = self._reader.recv_bytes</span><br><span class="line">        self._poll = self._reader.poll</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, obj, block=True, timeout=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._closed:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f"Queue <span class="subst">&#123;self!r&#125;</span> is closed"</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._sem.acquire(block, timeout):</span><br><span class="line">            <span class="keyword">raise</span> Full</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> self._notempty:</span><br><span class="line">            <span class="keyword">if</span> self._thread <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                self._start_thread()</span><br><span class="line">            self._buffer.append(obj)</span><br><span class="line">            self._notempty.notify()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, block=True, timeout=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._closed:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f"Queue <span class="subst">&#123;self!r&#125;</span> is closed"</span>)</span><br><span class="line">        <span class="keyword">if</span> block <span class="keyword">and</span> timeout <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">with</span> self._rlock:</span><br><span class="line">                res = self._recv_bytes()</span><br><span class="line">            self._sem.release()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> block:</span><br><span class="line">                deadline = time.monotonic() + timeout</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self._rlock.acquire(block, timeout):</span><br><span class="line">                <span class="keyword">raise</span> Empty</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> block:</span><br><span class="line">                    timeout = deadline - time.monotonic()</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> self._poll(timeout):</span><br><span class="line">                        <span class="keyword">raise</span> Empty</span><br><span class="line">                <span class="keyword">elif</span> <span class="keyword">not</span> self._poll():</span><br><span class="line">                    <span class="keyword">raise</span> Empty</span><br><span class="line">                res = self._recv_bytes()</span><br><span class="line">                self._sem.release()</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self._rlock.release()</span><br><span class="line">        <span class="keyword">return</span> _ForkingPickler.loads(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._closed = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._reader.close()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            close = self._close</span><br><span class="line">            <span class="keyword">if</span> close:</span><br><span class="line">                self._close = <span class="literal">None</span></span><br><span class="line">                close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_start_thread</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._buffer.clear()</span><br><span class="line">        self._thread = threading.Thread(</span><br><span class="line">            target=Queue._feed,</span><br><span class="line">            args=(self._buffer, self._notempty, self._send_bytes,</span><br><span class="line">                  self._wlock, self._writer.close, self._ignore_epipe,</span><br><span class="line">                  self._on_queue_feeder_error, self._sem),</span><br><span class="line">            name=<span class="string">'QueueFeederThread'</span></span><br><span class="line">        )</span><br><span class="line">        self._thread.daemon = <span class="literal">True</span></span><br><span class="line">        self._thread.start()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._joincancelled:</span><br><span class="line">            self._jointhread = Finalize(</span><br><span class="line">                self._thread, Queue._finalize_join,</span><br><span class="line">                [weakref.ref(self._thread)],</span><br><span class="line">                exitpriority=<span class="number">-5</span></span><br><span class="line">                )</span><br><span class="line">        self._close = Finalize(</span><br><span class="line">            self, Queue._finalize_close,</span><br><span class="line">            [self._buffer, self._notempty],</span><br><span class="line">            exitpriority=<span class="number">10</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_feed</span><span class="params">(buffer, notempty, send_bytes, writelock, close, ignore_epipe,</span></span></span><br><span class="line"><span class="function"><span class="params">              onerror, queue_sem)</span>:</span></span><br><span class="line">        debug(<span class="string">'starting thread to feed data to pipe'</span>)</span><br><span class="line">        nacquire = notempty.acquire</span><br><span class="line">        nrelease = notempty.release</span><br><span class="line">        nwait = notempty.wait</span><br><span class="line">        bpopleft = buffer.popleft</span><br><span class="line">        sentinel = _sentinel</span><br><span class="line">        <span class="keyword">if</span> sys.platform != <span class="string">'win32'</span>:</span><br><span class="line">            wacquire = writelock.acquire</span><br><span class="line">            wrelease = writelock.release</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            wacquire = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                nacquire()</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> buffer:</span><br><span class="line">                        nwait()</span><br><span class="line">                <span class="keyword">finally</span>:</span><br><span class="line">                    nrelease()</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">                        obj = bpopleft()</span><br><span class="line">                        <span class="keyword">if</span> obj <span class="keyword">is</span> sentinel:</span><br><span class="line">                            debug(<span class="string">'feeder thread got sentinel -- exiting'</span>)</span><br><span class="line">                            close()</span><br><span class="line">                            <span class="keyword">return</span></span><br><span class="line">                        obj = _ForkingPickler.dumps(obj)</span><br><span class="line">                        <span class="keyword">if</span> wacquire <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                            send_bytes(obj)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            wacquire()</span><br><span class="line">                            <span class="keyword">try</span>:</span><br><span class="line">                                send_bytes(obj)</span><br><span class="line">                            <span class="keyword">finally</span>:</span><br><span class="line">                                wrelease()</span><br><span class="line">                <span class="keyword">except</span> IndexError:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="keyword">if</span> ignore_epipe <span class="keyword">and</span> getattr(e, <span class="string">'errno'</span>, <span class="number">0</span>) == errno.EPIPE:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">if</span> is_exiting():</span><br><span class="line">                    info(<span class="string">'error in queue thread: %s'</span>, e)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    queue_sem.release()</span><br><span class="line">                    onerror(e, obj)</span><br></pre></td></tr></table></figure>
<p>在<code>Queue</code>的<code>__init__</code>函数中，构造了这么些对象：</p>
<ul>
<li><code>self._maxsize</code>：<code>Queue</code>队列的最大长度</li>
<li><code>self._reader</code>, <code>self._writer</code>：<code>pipe</code>的两端</li>
<li><code>self._rlock</code>：<code>self._reader</code>的读锁</li>
<li><code>self._wlock</code>：<code>self._writer</code>的写锁</li>
<li><code>self._sem</code>：以<code>self._maxsize</code>为基准的信号量，用来记录队列填满情况</li>
<li><code>self._notempty</code>：队列非空的条件变量。如果队列为空，需要<code>wait</code></li>
<li><code>self._buffer</code>：存储<code>python</code>对象的队列<code>deque</code></li>
<li><code>self._thread</code>：消费线程，用于消费<code>self._buffer</code>中的内容并发送到<code>pipe</code>中</li>
<li><code>self._jointhread</code>：关闭消费线程的<code>finalizer</code></li>
<li><code>self._close</code>：关闭<code>pipe</code>的<code>finalizer</code></li>
</ul>
<p>其中还要留意一点是，<code>Queue</code>实例本身是要传给<code>Process</code>实例，并在另一个进程被反序列化一次。因此为了保证序列化/反序列化之后部分状态得到保留（比如<code>pipe</code>），<code>Queue</code>的类定义中采用了<code>__getstate__</code>和<code>__setstate__</code>两个钩子去实现实例内部状态的存储与读取。这个特性在<code>pickle</code>的官方文档内有详细的说明。</p>
<p>大致了解了这些对象的含义后，接下来，就详细把<code>Queue</code>的工作流程列一下：</p>
<ul>
<li>用户调用<code>put</code>，信号量<code>self._sem</code>增加一个占位，之后发现消费线程未启动，通过<code>self._start_thread</code>启动消费线程<code>Queue._feed</code></li>
<li>消费线程进入循环，发现队列<code>self._buffer</code>为空，条件变量<code>self._notempty</code>进入<code>wait</code></li>
<li><code>self._start_thread</code>之后，将<code>python</code>对象推入<code>self._buffer</code>，并<code>notify</code>条件变量<code>self._notempty</code><ul>
<li>这一步很有概率发生在上一步之前，不过无所谓了</li>
</ul>
</li>
<li><code>_feed</code>退出<code>wait</code>状态，<code>pop</code>出<code>python</code>对象，然后将其<code>pickle</code>，最后调用<code>self._writer._send_bytes</code>发送序列化之后的数据到<code>pipe</code>内<ul>
<li>这里注意，如果<code>python</code>对象是<code>object()</code>，会触发<code>self._writer.close</code>。因此实际业务代码中最好不要出现发送<code>object()</code>的情况</li>
</ul>
</li>
<li>用户调用<code>get</code>，通过<code>self._reader</code>读取<code>pipe</code>中的数据，并且让信号量<code>self._sem</code>释放一个占位。之后对数据进行反序列化，得到发送过来的对象</li>
<li>用户调用<code>close</code>，首先关闭<code>self._reader</code>，然后在<code>self._writer</code>中发送一个<code>object()</code>。<code>_feed</code>会一直消费队列，直到检测到最后的<code>object()</code>，终于触发<code>self._writer</code>的关闭。这样<code>pipe</code>的两端就都关闭，并且<code>buffer</code>里也没有任何其它数据了。</li>
<li>用户调用<code>join_thread</code>，触发<code>self._thread.join()</code>，关闭消费线程</li>
</ul>
<p>在<code>multiprocessing</code>当中，<code>Queue</code>还有两种变体，分别为<code>SimpleQueue</code>和<code>JoinableQueue</code>。<code>SimpleQueue</code>没有提供<code>blocking</code>或<code>timeout</code>的功能，只是简单创建一对<code>pipe</code>交换序列化的数据。<code>JoinableQueue</code>则是在<code>Queue</code>的基础上增加了<code>join</code>的功能，其实现上是增加了一个初始值0的信号量<code>_unfinished_tasks</code>以及一个条件变量<code>_cond</code>。<code>JoinableQueue</code>在调用<code>join</code>时，如果<code>_unfinished_tasks</code>信号量不为0会进入<code>_cond.wait</code>，这是因为每次<code>put</code>的时候<code>_unfinished_tasks</code>信号量会<code>release</code>一次，只有用户每次<code>get</code>之后显式调用<code>JoinableQueue.task_done</code>才能<code>acquire</code>一次信号量，最终使得<code>_unfinished_tasks</code>信号量归零并<code>notify_all</code>所有<code>join</code>的调用。</p>
<p>最后，进程间通信的方法说到底，除了<code>Pipe</code>跟<code>Queue</code>外，采用<code>Manager</code>共享内存或者直接用<code>socket</code>网络通信都是ok的方式。当然，如果是在单节点上面，并且是一个内聚的<code>python</code>项目的话，<code>Queue</code>是不二选择。</p>
]]></content>
      <categories>
        <category>Hard Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>multiprocessing</tag>
        <tag>pipe</tag>
        <tag>queue</tag>
        <tag>进程通信</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hard Python】【第一章-多进程】1、Process，新进程的诞生</title>
    <url>/2022/01/16/hardpython/1_multiprocessing_1/</url>
    <content><![CDATA[<p>在python中，如果要做多任务并行的编程，必须要掌握<code>multiprocessing</code>库的相关运用。在python的<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvemgtY24vMy9saWJyYXJ5L211bHRpcHJvY2Vzc2luZy5odG1s" title="https://docs.python.org/zh-cn/3/library/multiprocessing.html">multiprocessing官方文档<i class="fa fa-external-link"></i></span>中，已然详细给出了<code>multiprocessing</code>库的相关用法。多进程编程其实还是有很多坑存在的，为了进一步探索python多进程的机制，提升对python多进程编程的理解，本篇文章会对多进程模块的实现进行一次详细的剖析。</p>
<p>多进程编程的第一话，首先来聊聊一个新的python子进程是如何诞生的。</p>
<p>首先我们需要了解这么一个事情，python创建的进程之间模块状态是相互隔离的。在多进程的场景下，代码中定义的各种变量，其值并不一定会共享。我们举个例子：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这只是另外一个模块，里头有个变量FLAG，默认是0，init之后是-1</span></span><br><span class="line"><span class="keyword">import</span> mp_module</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># mp_module.py</span></span><br><span class="line"><span class="string">FLAG = -1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def get_flag():</span></span><br><span class="line"><span class="string">    return FLAG</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def init_flag():</span></span><br><span class="line"><span class="string">    global FLAG</span></span><br><span class="line"><span class="string">    FLAG = 1</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_test_module_isolation</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> multiprocessing <span class="keyword">import</span> process</span><br><span class="line">    parent = process.parent_process()</span><br><span class="line">    <span class="keyword">if</span> parent:</span><br><span class="line">        print(<span class="string">f'[<span class="subst">&#123;os.getpid()&#125;</span>] <span class="subst">&#123;parent.pid&#125;</span>'</span>)</span><br><span class="line">    print(<span class="string">f'[<span class="subst">&#123;os.getpid()&#125;</span>] [<span class="subst">&#123;threading.current_thread()&#125;</span>] <span class="subst">&#123;mp_module.get_flag()&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_module_isolation</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">f'main process pid: <span class="subst">&#123;os.getpid()&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">    p = mp.Process(target=_test_module_isolation)</span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line">    _test_module_isolation()</span><br><span class="line">    p.join()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    mp.set_start_method(<span class="string">'spawn'</span>)</span><br><span class="line">    mp_module.init_flag()</span><br><span class="line">    test_module_isolation()</span><br></pre></td></tr></table></figure>
<p>在函数<code>test_module_isolation</code>中，首先是调用<code>mp_module.init_flag()</code>改变了<code>mp_module</code>模块一个变量的值，之后同时在主进程和新起的进程调用了<code>_test_module_isolation()</code>去打印<code>mp_module</code>中的变量。结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main process pid: 14836</span><br><span class="line">[14836] [&lt;_MainThread(MainThread, started 20244)&gt;] 1</span><br><span class="line">[22212] 14836</span><br><span class="line">[22212] [&lt;_MainThread(MainThread, started 23804)&gt;] -1</span><br></pre></td></tr></table></figure>
<p>可以看到，主进程（14836）中打印出来的变量是初始化过的，而子进程（22212）打印出来的变量是没有经过初始化的。</p>
<p>通过<code>Process</code>实例创建出来的进程对象，调用<code>start</code>方法即可启动新进程，执行<code>target</code>对应的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># BaseProcess.start</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        Start child process</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">    self._check_closed()</span><br><span class="line">    <span class="keyword">assert</span> self._popen <span class="keyword">is</span> <span class="literal">None</span>, <span class="string">'cannot start a process twice'</span></span><br><span class="line">    <span class="keyword">assert</span> self._parent_pid == os.getpid(), \</span><br><span class="line">    <span class="string">'can only start a process object created by current process'</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">not</span> _current_process._config.get(<span class="string">'daemon'</span>), \</span><br><span class="line">    <span class="string">'daemonic processes are not allowed to have children'</span></span><br><span class="line">    _cleanup()</span><br><span class="line">    self._popen = self._Popen(self)</span><br><span class="line">    self._sentinel = self._popen.sentinel</span><br><span class="line">    <span class="comment"># Avoid a refcycle if the target function holds an indirect</span></span><br><span class="line">    <span class="comment"># reference to the process object (see bpo-30775)</span></span><br><span class="line">    <span class="keyword">del</span> self._target, self._args, self._kwargs</span><br><span class="line">    _children.add(self)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Process._Popen</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpawnProcess</span><span class="params">(process.BaseProcess)</span>:</span></span><br><span class="line">    _start_method = <span class="string">'spawn'</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_Popen</span><span class="params">(process_obj)</span>:</span></span><br><span class="line">        <span class="keyword">from</span> .popen_spawn_win32 <span class="keyword">import</span> Popen</span><br><span class="line">        <span class="keyword">return</span> Popen(process_obj)</span><br></pre></td></tr></table></figure>
<p>创建进程的方式有多种，其中<code>spawn</code>模式为windows/linux系统下均兼容的，且为windows的默认模式。在<code>Process._Popen</code>中，会通过<code>_default_context.get_context()</code>获取当前的进程启动模式。</p>
<p>以windows下的<code>spawn</code>模式为例，我们看下进程启动的代码的实现。主要逻辑分布在3个地方：</p>
<ul>
<li><code>popen_spawn_win32.Popen</code></li>
<li><code>multiprocessing/spawn.py</code></li>
<li><code>process.BaseProcess</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># popen_fork.Popen</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Popen</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, process_obj)</span>:</span></span><br><span class="line">        util._flush_std_streams()</span><br><span class="line">        self.returncode = <span class="literal">None</span></span><br><span class="line">        self.finalizer = <span class="literal">None</span></span><br><span class="line">        self._launch(process_obj)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># popen_spawn_win32.Popen</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Popen</span><span class="params">(object)</span>:</span></span><br><span class="line">    method = <span class="string">'spawn'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, process_obj)</span>:</span></span><br><span class="line">        prep_data = spawn.get_preparation_data(process_obj._name)</span><br><span class="line"></span><br><span class="line">        rhandle, whandle = _winapi.CreatePipe(<span class="literal">None</span>, <span class="number">0</span>)</span><br><span class="line">        wfd = msvcrt.open_osfhandle(whandle, <span class="number">0</span>)</span><br><span class="line">        cmd = spawn.get_command_line(parent_pid=os.getpid(),</span><br><span class="line">                                     pipe_handle=rhandle)</span><br><span class="line">        cmd = <span class="string">' '</span>.join(<span class="string">'"%s"'</span> % x <span class="keyword">for</span> x <span class="keyword">in</span> cmd)</span><br><span class="line"></span><br><span class="line">        python_exe = spawn.get_executable()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> WINENV <span class="keyword">and</span> _path_eq(python_exe, sys.executable):</span><br><span class="line">            python_exe = sys._base_executable</span><br><span class="line">            env = os.environ.copy()</span><br><span class="line">            env[<span class="string">"__PYVENV_LAUNCHER__"</span>] = sys.executable</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            env = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> open(wfd, <span class="string">'wb'</span>, closefd=<span class="literal">True</span>) <span class="keyword">as</span> to_child:</span><br><span class="line">            <span class="comment"># start process</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                hp, ht, pid, tid = _winapi.CreateProcess(</span><br><span class="line">                    python_exe, cmd,</span><br><span class="line">                    <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">False</span>, <span class="number">0</span>, env, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">                _winapi.CloseHandle(ht)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                _winapi.CloseHandle(rhandle)</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># set attributes of self</span></span><br><span class="line">            self.pid = pid</span><br><span class="line">            self.returncode = <span class="literal">None</span></span><br><span class="line">            self._handle = hp</span><br><span class="line">            self.sentinel = int(hp)</span><br><span class="line">            self.finalizer = util.Finalize(self, _close_handles,</span><br><span class="line">                                           (self.sentinel, int(rhandle)))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># send information to child</span></span><br><span class="line">            set_spawning_popen(self)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                reduction.dump(prep_data, to_child)</span><br><span class="line">                reduction.dump(process_obj, to_child)</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                set_spawning_popen(<span class="literal">None</span>)</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line"><span class="comment"># multiprocessing/spawn.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_command_line</span><span class="params">(**kwds)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> getattr(sys, <span class="string">'frozen'</span>, <span class="literal">False</span>):</span><br><span class="line">        <span class="keyword">return</span> ([sys.executable, <span class="string">'--multiprocessing-fork'</span>] +</span><br><span class="line">                [<span class="string">'%s=%r'</span> % item <span class="keyword">for</span> item <span class="keyword">in</span> kwds.items()])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        prog = <span class="string">'from multiprocessing.spawn import spawn_main; spawn_main(%s)'</span></span><br><span class="line">        prog %= <span class="string">', '</span>.join(<span class="string">'%s=%r'</span> % item <span class="keyword">for</span> item <span class="keyword">in</span> kwds.items())</span><br><span class="line">        opts = util._args_from_interpreter_flags()</span><br><span class="line">        <span class="keyword">return</span> [_python_exe] + opts + [<span class="string">'-c'</span>, prog, <span class="string">'--multiprocessing-fork'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spawn_main</span><span class="params">(pipe_handle, parent_pid=None, tracker_fd=None)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> is_forking(sys.argv), <span class="string">"Not forking"</span></span><br><span class="line">    <span class="keyword">if</span> sys.platform == <span class="string">'win32'</span>:</span><br><span class="line">        <span class="keyword">import</span> msvcrt</span><br><span class="line">        <span class="keyword">import</span> _winapi</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> parent_pid <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            source_process = _winapi.OpenProcess(</span><br><span class="line">                _winapi.SYNCHRONIZE | _winapi.PROCESS_DUP_HANDLE,</span><br><span class="line">                <span class="literal">False</span>, parent_pid)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            source_process = <span class="literal">None</span></span><br><span class="line">        new_handle = reduction.duplicate(pipe_handle,</span><br><span class="line">                                         source_process=source_process)</span><br><span class="line">        fd = msvcrt.open_osfhandle(new_handle, os.O_RDONLY)</span><br><span class="line">        parent_sentinel = source_process</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">from</span> . <span class="keyword">import</span> resource_tracker</span><br><span class="line">        resource_tracker._resource_tracker._fd = tracker_fd</span><br><span class="line">        fd = pipe_handle</span><br><span class="line">        parent_sentinel = os.dup(pipe_handle)</span><br><span class="line">    exitcode = _main(fd, parent_sentinel)</span><br><span class="line">    sys.exit(exitcode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_main</span><span class="params">(fd, parent_sentinel)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> os.fdopen(fd, <span class="string">'rb'</span>, closefd=<span class="literal">True</span>) <span class="keyword">as</span> from_parent:</span><br><span class="line">        process.current_process()._inheriting = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            preparation_data = reduction.pickle.load(from_parent)</span><br><span class="line">            prepare(preparation_data)</span><br><span class="line">            self = reduction.pickle.load(from_parent)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="keyword">del</span> process.current_process()._inheriting</span><br><span class="line">    <span class="keyword">return</span> self._bootstrap(parent_sentinel)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># process.BaseProcess</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseProcess</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_bootstrap</span><span class="params">(self, parent_sentinel=None)</span>:</span></span><br><span class="line">        <span class="comment"># 忽略</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 忽略，设置一些参数</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.run()</span><br><span class="line">                exitcode = <span class="number">0</span></span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                util._exit_function()</span><br><span class="line">        <span class="keyword">except</span> SystemExit <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> e.code <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                exitcode = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> isinstance(e.code, int):</span><br><span class="line">                exitcode = e.code</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sys.stderr.write(str(e.code) + <span class="string">'\n'</span>)</span><br><span class="line">                exitcode = <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            exitcode = <span class="number">1</span></span><br><span class="line">            <span class="comment"># 忽略，打印错误信息</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            threading._shutdown()</span><br><span class="line">            util.info(<span class="string">'process exiting with exitcode %d'</span> % exitcode)</span><br><span class="line">            util._flush_std_streams()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> exitcode</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._target:</span><br><span class="line">            self._target(*self._args, **self._kwargs)</span><br></pre></td></tr></table></figure>
<p>这里经历了以下几个步骤：</p>
<ul>
<li>用<code>_winapi.CreatePipe</code>创建一对用于进程间通信的<code>handle</code><ul>
<li><code>rhandle</code>会传给子进程，<code>whandle</code>会被主进程用于给子进程发送数据</li>
</ul>
</li>
<li>获取构建子进程运行时环境所需要的准备数据<code>prep_data</code><ul>
<li>包括<code>sys.argv</code>、<code>sys.path</code>、日志配置、初始化<code>__main__</code>模块的文件路径等</li>
</ul>
</li>
<li>通过<code>spawn.get_command_line</code>初始化<code>spawn</code>进程所需的命令<ul>
<li>从函数定义中可以看到，子进程执行的命令中会调用<code>spawn.spawn_main</code>函数</li>
</ul>
</li>
<li>调用<code>_winapi.CreateProcess</code>生成子进程</li>
<li>通过<code>whandle</code>转换后的fd向子进程写入序列化后的准备数据以及自身<code>Process</code>实例数据</li>
<li>子进程在<code>spawn_main</code>函数将传入的<code>rhandle</code>转化为fd，在<code>_main</code>函数中接收主进程传入的数据，并执行对应操作<ul>
<li>接收<code>prep_data</code>，初始化子进程运行时环境。其中会重新执行原来<code>__main__</code>模块对应的代码块<ul>
<li>这里注意，子进程执行原来<code>__main__</code>模块的代码块，是以<code>__mp_main__</code>这个模块名执行的。因此，原来代码里头<code>if __name__ == &#39;__main__&#39;</code>下面的都执行不到。所以，子进程跑不到<code>mp_module.init_flag()</code>，里面的<code>flag</code>值当然没有被初始化。如果要让<code>flag</code>被初始化的话，相信聪明的你知道怎么做。</li>
</ul>
</li>
<li>执行<code>Process</code>实例的<code>_bootstrap</code>函数。<code>_bootstrap</code>函数最终调用<code>run</code>函数，执行<code>_target</code>对应的内容</li>
</ul>
</li>
</ul>
<p>这样，新的python进程就被创建并开始运行了。</p>
]]></content>
      <categories>
        <category>Hard Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>multiprocessing</tag>
        <tag>Process</tag>
        <tag>多进程</tag>
        <tag>spawn</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hard Python】前言</title>
    <url>/2022/01/08/hardpython/preface/</url>
    <content><![CDATA[<p>写完Medium Python之后，不知不觉就有开始继续写Hard Python的冲动。择日不如撞日，心动不如行动，2022年开篇，果断将Hard Python提上日程。</p>
<p>截至2021年底，python依旧是最热门的语言之一，随着3.10、3.11及后续版本的发布，python的runtime在功能及性能上都会有较大的提升。时至今日，提到技术应用最广泛的语言，除了python，还会有另外的吗？排除区块链、游戏、音视频里较为深度的领域，基本上各种技术业务场景，都会有python的影子。</p>
<p>可以说，python是编程界的一把瑞士军刀。如果我们能更加深入的了解python各个重点模块的技术原理，不仅对于我们理解这门语言以及编程语言相关技术有益处，并且以后我们在面对一些python的编程场景时也会更加得心应手。</p>
<p>在先前已经写过两个python系列，分别是<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wL2NhdGVnb3JpZXMvRWFzeS1QeXRob24v" title="https://utmhikari.top/categories/Easy-Python/">Easy Python<i class="fa fa-external-link"></i></span>以及<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wL2NhdGVnb3JpZXMvTWVkaXVtLVB5dGhvbi8=" title="https://utmhikari.top/categories/Medium-Python/">Medium Python<i class="fa fa-external-link"></i></span>。在Easy Python中，对python的各种基础概念以及实用场景介绍了相关案例；而在Medium Python中，通过源码分析的方式，剖析了python内部某些语言特性的实现，讲述了许多python相关的冷知识。这次Hard Python，还是回归本源，将会挑选一些python内部比较重点的基础模块进行深入剖析讲解，争取让每一位阅读本系列文章的同学对python这门语言有更加全新的理解。</p>
<p>话不多说，准备上菜！</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>第一章：多线程<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjIvMDEvMTYvaGFyZHB5dGhvbi8xX211bHRpcHJvY2Vzc2luZ18xLw==" title="https://utmhikari.top/2022/01/16/hardpython/1_multiprocessing_1/">1、Process，新进程的诞生<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjIvMDEvMjIvaGFyZHB5dGhvbi8xX211bHRpcHJvY2Vzc2luZ18yLw==" title="https://utmhikari.top/2022/01/22/hardpython/1_multiprocessing_2/">2、Pipe和Queue，进程间通信<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjIvMDEvMzAvaGFyZHB5dGhvbi8xX211bHRpcHJvY2Vzc2luZ18zLw==" title="https://utmhikari.top/2022/01/30/hardpython/1_multiprocessing_3/">3、Pool，多任务并行进程池<i class="fa fa-external-link"></i></span></li>
</ul>
</li>
<li>第二章：异步IO<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjIvMDIvMTIvaGFyZHB5dGhvbi8yX2FzeW5jaW9fMS8=" title="https://utmhikari.top/2022/02/12/hardpython/2_asyncio_1/">1、asyncio事件循环的创建<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjIvMDIvMjAvaGFyZHB5dGhvbi8yX2FzeW5jaW9fMi8=" title="https://utmhikari.top/2022/02/20/hardpython/2_asyncio_2/">2、异步任务在事件循环中的执行<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjIvMDIvMjYvaGFyZHB5dGhvbi8yX2FzeW5jaW9fMy8=" title="https://utmhikari.top/2022/02/26/hardpython/2_asyncio_3/">3、async/await的源码实现<i class="fa fa-external-link"></i></span></li>
</ul>
</li>
<li>第三章：GC<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjIvMDMvMTIvaGFyZHB5dGhvbi8zX2djXzEv" title="https://utmhikari.top/2022/03/12/hardpython/3_gc_1/">1、引用计数与内存释放机制<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjIvMDMvMTkvaGFyZHB5dGhvbi8zX2djXzIv" title="https://utmhikari.top/2022/03/19/hardpython/3_gc_2/">2、python的GC流程<i class="fa fa-external-link"></i></span></li>
</ul>
</li>
<li>第四章：日志<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjIvMDQvMDkvaGFyZHB5dGhvbi80X2xvZ18xLw==" title="https://utmhikari.top/2022/04/09/hardpython/4_log_1/">1、Logger与Manager的源码实现<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjIvMDQvMTYvaGFyZHB5dGhvbi80X2xvZ18yLw==" title="https://utmhikari.top/2022/04/16/hardpython/4_log_2/">2、日志消费者Handler的实现<i class="fa fa-external-link"></i></span></li>
</ul>
</li>
<li>第五章：字符串<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjIvMDUvMDgvaGFyZHB5dGhvbi81X3N0cl8xLw==" title="https://utmhikari.top/2022/05/08/hardpython/5_str_1/">1、unicode，py3的字符串实现<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjIvMDUvMTQvaGFyZHB5dGhvbi81X3N0cl8yLw==" title="https://utmhikari.top/2022/05/14/hardpython/5_str_2/">2、re，正则表达式源码详解<i class="fa fa-external-link"></i></span></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Hard Python</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>源码分析</tag>
        <tag>python</tag>
        <tag>Medium Python</tag>
        <tag>Easy Python</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python随笔】如何提取python函数的接口定义信息</title>
    <url>/2021/12/12/pythonnotes/function_info/</url>
    <content><![CDATA[<p>在某些python框架底层的开发需求中，需要通过一些类似反射的手段，提取函数接口的信息，从而对一系列函数接口进行管理。本篇文章就来粗浅谈一下，如何提取python函数的接口定义信息。</p>
<h2 id="function对象的信息"><a href="#function对象的信息" class="headerlink" title="function对象的信息"></a>function对象的信息</h2><p>首先我们拿一个函数来试试手：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myprinter</span><span class="params">(s: str, /, e: str = <span class="string">'\n'</span>, *, prefix: Any = <span class="string">''</span>)</span> -&gt; Tuple[bool, str]:</span></span><br><span class="line">    <span class="string">"""hello world"""</span></span><br><span class="line">    msg = str(prefix) + s + e</span><br><span class="line">    print(msg, end=<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span>, msg</span><br></pre></td></tr></table></figure>
<p>这个函数<code>myprinter</code>采用了新的语法糖<code>/</code>以及<code>*</code>，<code>/</code>的左边表示强制位置参数（positional-only arguments），<code>*</code>的右边表示强制关键字参数（keyword-only arguments），而两者中间的参数在使用时以位置参数或者是关键字参数的形式表达都可以。</p>
<p>要提取这个函数的信息，我们首先要知道函数本身也是一种对象。因此，可以用到<code>dir</code>函数，遍历这个对象的属性，从而提取所有属性的值。</p>
<p>通过<code>dir</code>导出函数对象的属性与值，打印的结果如下：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&apos;__annotations__&apos;: &#123;&apos;e&apos;: &lt;class &apos;str&apos;&gt;,</span><br><span class="line">                     &apos;prefix&apos;: typing.Any,</span><br><span class="line">                     &apos;return&apos;: typing.Tuple[bool, str],</span><br><span class="line">                     &apos;s&apos;: &lt;class &apos;str&apos;&gt;&#125;,</span><br><span class="line"> &apos;__call__&apos;: &lt;method-wrapper &apos;__call__&apos; of function object at 0x000001C78C54F040&gt;,</span><br><span class="line"> &apos;__class__&apos;: &lt;class &apos;function&apos;&gt;,</span><br><span class="line"> &apos;__closure__&apos;: None,</span><br><span class="line"> &apos;__code__&apos;: &lt;code object myprinter at 0x000001C78CC823A0, file &quot;H:\Projects\Python\playground\datastruct\functionobj.py&quot;, line 11&gt;,</span><br><span class="line"> &apos;__defaults__&apos;: (&apos;\n&apos;,),</span><br><span class="line"> &apos;__delattr__&apos;: &lt;method-wrapper &apos;__delattr__&apos; of function object at 0x000001C78C54F040&gt;,</span><br><span class="line"> &apos;__dict__&apos;: &#123;&#125;,</span><br><span class="line"> &apos;__dir__&apos;: [函数对象的属性列表，其实就打印的这些，不再重复列举了],</span><br><span class="line"> &apos;__doc__&apos;: &apos;hello world&apos;,</span><br><span class="line"> &apos;__eq__&apos;: &lt;method-wrapper &apos;__eq__&apos; of function object at 0x000001C78C54F040&gt;,</span><br><span class="line"> &apos;__format__&apos;: &lt;built-in method __format__ of function object at 0x000001C78C54F040&gt;,</span><br><span class="line"> &apos;__ge__&apos;: &lt;method-wrapper &apos;__ge__&apos; of function object at 0x000001C78C54F040&gt;,</span><br><span class="line"> &apos;__get__&apos;: &lt;method-wrapper &apos;__get__&apos; of function object at 0x000001C78C54F040&gt;,</span><br><span class="line"> &apos;__getattribute__&apos;: &lt;method-wrapper &apos;__getattribute__&apos; of function object at 0x000001C78C54F040&gt;,</span><br><span class="line"> &apos;__globals__&apos;: &#123;函数对应的全局环境情况，不一一列举了&#125;,</span><br><span class="line"> &apos;__gt__&apos;: &lt;method-wrapper &apos;__gt__&apos; of function object at 0x000001C78C54F040&gt;,</span><br><span class="line"> &apos;__hash__&apos;: 122285281028,</span><br><span class="line"> &apos;__init__&apos;: None,</span><br><span class="line"> &apos;__init_subclass__&apos;: None,</span><br><span class="line"> &apos;__kwdefaults__&apos;: &#123;&apos;prefix&apos;: &apos;&apos;&#125;,</span><br><span class="line"> &apos;__le__&apos;: &lt;method-wrapper &apos;__le__&apos; of function object at 0x000001C78C54F040&gt;,</span><br><span class="line"> &apos;__lt__&apos;: &lt;method-wrapper &apos;__lt__&apos; of function object at 0x000001C78C54F040&gt;,</span><br><span class="line"> &apos;__module__&apos;: &apos;__main__&apos;,</span><br><span class="line"> &apos;__name__&apos;: &apos;myprinter&apos;,</span><br><span class="line"> &apos;__ne__&apos;: &lt;method-wrapper &apos;__ne__&apos; of function object at 0x000001C78C54F040&gt;,</span><br><span class="line"> &apos;__new__&apos;: &lt;built-in method __new__ of type object at 0x00007FFF57678C50&gt;,</span><br><span class="line"> &apos;__qualname__&apos;: &apos;myprinter&apos;,</span><br><span class="line"> &apos;__reduce__&apos;: &lt;built-in method __reduce__ of function object at 0x000001C78C54F040&gt;,</span><br><span class="line"> &apos;__reduce_ex__&apos;: &lt;built-in method __reduce_ex__ of function object at 0x000001C78C54F040&gt;,</span><br><span class="line"> &apos;__repr__&apos;: &apos;&lt;function myprinter at 0x000001C78C54F040&gt;&apos;,</span><br><span class="line"> &apos;__setattr__&apos;: &lt;method-wrapper &apos;__setattr__&apos; of function object at 0x000001C78C54F040&gt;,</span><br><span class="line"> &apos;__sizeof__&apos;: 120,</span><br><span class="line"> &apos;__str__&apos;: &apos;&lt;function myprinter at 0x000001C78C54F040&gt;&apos;,</span><br><span class="line"> &apos;__subclasshook__&apos;: NotImplemented&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到里面的一些关键属性：</p>
<ul>
<li><code>__name__</code>：函数名字。</li>
<li><code>__qualname__</code>：函数的合法名称<ul>
<li>比如在<code>class A</code>中定义一个函数<code>f</code>，那么<code>A.f.__name__</code>是<code>f</code>，而<code>A.f.__qualname__</code>是<code>A.f</code></li>
</ul>
</li>
<li><code>__doc__</code>：函数注释文本</li>
<li><code>__annotations__</code>：函数参数注释信息<ul>
<li>一般开发时候注释信息都是参数名以及对应的数据类型，因此有了这个就可以对函数的入参进行合法校验。当然，明显也利好一些IoC机制的底层开发的需求。</li>
<li>返回值对应的数据类型，可以在<code>return</code>这个key下找</li>
</ul>
</li>
<li><code>__defaults__</code>：位置参数/非强制关键字参数的默认值的tuple</li>
<li><code>__kwdefaults__</code>：强制关键字参数的默认值的dict</li>
<li><code>__module__</code>：函数所属的模块</li>
<li><code>__code__</code>：函数所包含的代码段对象</li>
</ul>
<p>除了通过<code>dir</code>的方式获取这些关键属性之外，通过<code>inspect</code>库的<code>getmembers</code>函数也可以实现类似的效果。对于<code>inspect</code>库的用法，可以参考<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9saWJyYXJ5L2luc3BlY3QuaHRtbA==" title="https://docs.python.org/3/library/inspect.html">官方文档<i class="fa fa-external-link"></i></span>。</p>
<h2 id="参数数据结构类型信息"><a href="#参数数据结构类型信息" class="headerlink" title="参数数据结构类型信息"></a>参数数据结构类型信息</h2><p>在上述的<code>__annotations__</code>属性中，我们能够提取到标注的参数数据结构类型。对于<code>str</code>、<code>int</code>这种一般型数据就直接标注对应的类型；而对于一些泛型则需要标注为<code>typing</code>，比如说<code>typing.Dict</code>、<code>typing.Any</code>等等。</p>
<p>针对<code>typing</code>的用法，可以参考<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9saWJyYXJ5L3R5cGluZy5odG1s" title="https://docs.python.org/3/library/typing.html">官方文档<i class="fa fa-external-link"></i></span>。不过本文计划进一步探索<code>typing</code>对象的相关信息。</p>
<p>我们用一段代码就能粗略对<code>typing</code>的各类对象信息看个明白：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'typing.Dict:'</span>)</span><br><span class="line">dtype = typing.Dict[str, typing.Union[</span><br><span class="line">    typing.List[int],</span><br><span class="line">    typing.Tuple[bool, str],</span><br><span class="line">    typing.Callable[[float, int], typing.NoReturn]</span><br><span class="line">]]</span><br><span class="line">pprint.pprint(dtype.__dict__)</span><br><span class="line">print(<span class="string">'typing.Union:'</span>)</span><br><span class="line">utype = dtype.__dict__[<span class="string">'__args__'</span>][<span class="number">1</span>]</span><br><span class="line">pprint.pprint(utype.__dict__)</span><br><span class="line">print(<span class="string">'typing.List:'</span>)</span><br><span class="line">ltype = utype.__dict__[<span class="string">'__args__'</span>][<span class="number">0</span>]</span><br><span class="line">pprint.pprint(ltype.__dict__)</span><br><span class="line">print(<span class="string">'typing.Tuple:'</span>)</span><br><span class="line">ttype = utype.__dict__[<span class="string">'__args__'</span>][<span class="number">1</span>]</span><br><span class="line">pprint.pprint(ttype.__dict__)</span><br><span class="line">print(<span class="string">'typing.Callable:'</span>)</span><br><span class="line">ftype = utype.__dict__[<span class="string">'__args__'</span>][<span class="number">2</span>]</span><br><span class="line">pprint.pprint(ftype.__dict__)</span><br><span class="line">print(<span class="string">'typing.NoReturn:'</span>)</span><br><span class="line">norettype = ftype.__dict__[<span class="string">'__args__'</span>][<span class="number">-1</span>]</span><br><span class="line">print(norettype._name)</span><br><span class="line">print(isinstance(norettype, typing._SpecialForm))</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typing.Dict:</span><br><span class="line">&#123;&apos;__args__&apos;: (&lt;class &apos;str&apos;&gt;,</span><br><span class="line">              typing.Union[typing.List[int], typing.Tuple[bool, str], typing.Callable[[float, int], typing.NoReturn]]),</span><br><span class="line"> &apos;__origin__&apos;: &lt;class &apos;dict&apos;&gt;,</span><br><span class="line"> &apos;__parameters__&apos;: (),</span><br><span class="line"> &apos;__slots__&apos;: None,</span><br><span class="line"> &apos;_inst&apos;: False,</span><br><span class="line"> &apos;_name&apos;: &apos;Dict&apos;&#125;</span><br><span class="line">typing.Union:</span><br><span class="line">&#123;&apos;__args__&apos;: (typing.List[int],</span><br><span class="line">              typing.Tuple[bool, str],</span><br><span class="line">              typing.Callable[[float, int], typing.NoReturn]),</span><br><span class="line"> &apos;__module__&apos;: &apos;typing&apos;,</span><br><span class="line"> &apos;__origin__&apos;: typing.Union,</span><br><span class="line"> &apos;__parameters__&apos;: (),</span><br><span class="line"> &apos;__slots__&apos;: None,</span><br><span class="line"> &apos;_inst&apos;: True,</span><br><span class="line"> &apos;_name&apos;: None&#125;</span><br><span class="line">typing.List:</span><br><span class="line">&#123;&apos;__args__&apos;: (&lt;class &apos;int&apos;&gt;,),</span><br><span class="line"> &apos;__origin__&apos;: &lt;class &apos;list&apos;&gt;,</span><br><span class="line"> &apos;__parameters__&apos;: (),</span><br><span class="line"> &apos;__slots__&apos;: None,</span><br><span class="line"> &apos;_inst&apos;: False,</span><br><span class="line"> &apos;_name&apos;: &apos;List&apos;&#125;</span><br><span class="line">typing.Tuple:</span><br><span class="line">&#123;&apos;__args__&apos;: (&lt;class &apos;bool&apos;&gt;, &lt;class &apos;str&apos;&gt;),</span><br><span class="line"> &apos;__origin__&apos;: &lt;class &apos;tuple&apos;&gt;,</span><br><span class="line"> &apos;__parameters__&apos;: (),</span><br><span class="line"> &apos;__slots__&apos;: None,</span><br><span class="line"> &apos;_inst&apos;: False,</span><br><span class="line"> &apos;_name&apos;: &apos;Tuple&apos;&#125;</span><br><span class="line">typing.Callable:</span><br><span class="line">&#123;&apos;__args__&apos;: (&lt;class &apos;float&apos;&gt;, &lt;class &apos;int&apos;&gt;, typing.NoReturn),</span><br><span class="line"> &apos;__origin__&apos;: &lt;class &apos;collections.abc.Callable&apos;&gt;,</span><br><span class="line"> &apos;__parameters__&apos;: (),</span><br><span class="line"> &apos;__slots__&apos;: None,</span><br><span class="line"> &apos;_inst&apos;: True,</span><br><span class="line"> &apos;_name&apos;: &apos;Callable&apos;&#125;</span><br><span class="line">typing.NoReturn:</span><br><span class="line">NoReturn</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>对于一些容器类型的对象，通过<code>__dict__[&#39;__args__&#39;]</code>就能够获得里面的数据类型标注，从而对容器对象合法性进行检查。对于一些隶属于<code>typing._SpecialForm</code>的对象，比如<code>Any</code>、<code>NoReturn</code>等，可以通过<code>_name</code>属性来判断具体是哪个。</p>
<h2 id="函数体对象的信息"><a href="#函数体对象的信息" class="headerlink" title="函数体对象的信息"></a>函数体对象的信息</h2><p><code>code</code>对象（函数的函数体）的信息，从上面的属性导出情况可知，我们可以通过<code>__code__</code>来获取函数的函数体对象。</p>
<p>通过<code>dir</code>或者<code>inspect</code>等方式，可以导出<code>code</code>对象的属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">codeobj = myprinter.__code__</span><br><span class="line">pprint.pprint(objdict(codeobj))</span><br></pre></td></tr></table></figure>
<p>打印结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&apos;__class__&apos;: &lt;class &apos;code&apos;&gt;,</span><br><span class="line"> &apos;__delattr__&apos;: &lt;method-wrapper &apos;__delattr__&apos; of code object at 0x0000012FB44A2500&gt;,</span><br><span class="line"> &apos;__dir__&apos;: [忽略],</span><br><span class="line"> &apos;__doc__&apos;: &apos;code(argcount, posonlyargcount, kwonlyargcount, nlocals, &apos;</span><br><span class="line">            &apos;stacksize,\n&apos;</span><br><span class="line">            &apos;      flags, codestring, constants, names, varnames, filename, &apos;</span><br><span class="line">            &apos;name,\n&apos;</span><br><span class="line">            &apos;      firstlineno, lnotab[, freevars[, cellvars]])\n&apos;</span><br><span class="line">            &apos;\n&apos;</span><br><span class="line">            &apos;Create a code object.  Not for the faint of heart.&apos;,</span><br><span class="line"> &apos;__eq__&apos;: &lt;method-wrapper &apos;__eq__&apos; of code object at 0x0000012FB44A2500&gt;,</span><br><span class="line"> &apos;__format__&apos;: &lt;built-in method __format__ of code object at 0x0000012FB44A2500&gt;,</span><br><span class="line"> &apos;__ge__&apos;: &lt;method-wrapper &apos;__ge__&apos; of code object at 0x0000012FB44A2500&gt;,</span><br><span class="line"> &apos;__getattribute__&apos;: &lt;method-wrapper &apos;__getattribute__&apos; of code object at 0x0000012FB44A2500&gt;,</span><br><span class="line"> &apos;__gt__&apos;: &lt;method-wrapper &apos;__gt__&apos; of code object at 0x0000012FB44A2500&gt;,</span><br><span class="line"> &apos;__hash__&apos;: -7836529936335626281,</span><br><span class="line"> &apos;__init__&apos;: None,</span><br><span class="line"> &apos;__init_subclass__&apos;: None,</span><br><span class="line"> &apos;__le__&apos;: &lt;method-wrapper &apos;__le__&apos; of code object at 0x0000012FB44A2500&gt;,</span><br><span class="line"> &apos;__lt__&apos;: &lt;method-wrapper &apos;__lt__&apos; of code object at 0x0000012FB44A2500&gt;,</span><br><span class="line"> &apos;__ne__&apos;: &lt;method-wrapper &apos;__ne__&apos; of code object at 0x0000012FB44A2500&gt;,</span><br><span class="line"> &apos;__new__&apos;: &lt;built-in method __new__ of type object at 0x00007FFF5766F870&gt;,</span><br><span class="line"> &apos;__reduce__&apos;: &lt;built-in method __reduce__ of code object at 0x0000012FB44A2500&gt;,</span><br><span class="line"> &apos;__reduce_ex__&apos;: &lt;built-in method __reduce_ex__ of code object at 0x0000012FB44A2500&gt;,</span><br><span class="line"> &apos;__repr__&apos;: &apos;&lt;code object myprinter at 0x0000012FB44A2500, file &apos;</span><br><span class="line">             &apos;&quot;H:\\Projects\\Python\\playground\\datastruct\\functionobj.py&quot;, &apos;</span><br><span class="line">             &apos;line 12&gt;&apos;,</span><br><span class="line"> &apos;__setattr__&apos;: &lt;method-wrapper &apos;__setattr__&apos; of code object at 0x0000012FB44A2500&gt;,</span><br><span class="line"> &apos;__sizeof__&apos;: 176,</span><br><span class="line"> &apos;__str__&apos;: &apos;&lt;code object myprinter at 0x0000012FB44A2500, file &apos;</span><br><span class="line">            &apos;&quot;H:\\Projects\\Python\\playground\\datastruct\\functionobj.py&quot;, &apos;</span><br><span class="line">            &apos;line 12&gt;&apos;,</span><br><span class="line"> &apos;__subclasshook__&apos;: NotImplemented,</span><br><span class="line"> &apos;co_argcount&apos;: 2,</span><br><span class="line"> &apos;co_cellvars&apos;: (),</span><br><span class="line"> &apos;co_code&apos;: b&apos;t\x00|\x02\x83\x01|\x00\x17\x00|\x01\x17\x00&#125;\x03t\x01|\x03&apos;</span><br><span class="line">            b&apos;d\x01d\x02\x8d\x02\x01\x00d\x03|\x03f\x02S\x00&apos;,</span><br><span class="line"> &apos;co_consts&apos;: (&apos;hello world&apos;, &apos;&apos;, (&apos;end&apos;,), True),</span><br><span class="line"> &apos;co_filename&apos;: &apos;H:\\Projects\\Python\\playground\\datastruct\\functionobj.py&apos;,</span><br><span class="line"> &apos;co_firstlineno&apos;: 12,</span><br><span class="line"> &apos;co_flags&apos;: 67,</span><br><span class="line"> &apos;co_freevars&apos;: (),</span><br><span class="line"> &apos;co_kwonlyargcount&apos;: 1,</span><br><span class="line"> &apos;co_lnotab&apos;: b&apos;\x00\x02\x10\x01\x0c\x01&apos;,</span><br><span class="line"> &apos;co_name&apos;: &apos;myprinter&apos;,</span><br><span class="line"> &apos;co_names&apos;: (&apos;str&apos;, &apos;print&apos;),</span><br><span class="line"> &apos;co_nlocals&apos;: 4,</span><br><span class="line"> &apos;co_posonlyargcount&apos;: 1,</span><br><span class="line"> &apos;co_stacksize&apos;: 4,</span><br><span class="line"> &apos;co_varnames&apos;: (&apos;s&apos;, &apos;e&apos;, &apos;prefix&apos;, &apos;msg&apos;),</span><br><span class="line"> &apos;replace&apos;: &lt;code object myprinter at 0x0000012FB44CAA80, file &quot;H:\Projects\Python\playground\datastruct\functionobj.py&quot;, line 12&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>其中一些关键属性如下（同样在<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9saWJyYXJ5L2luc3BlY3QuaHRtbA==" title="https://docs.python.org/3/library/inspect.html">inspect的文档<i class="fa fa-external-link"></i></span>中能查到）：</p>
<ul>
<li><code>co_argcount</code>：参数个数（不包括强制关键字参数，以及带星号的参数）</li>
<li><code>co_filename</code>: 所属文件</li>
<li><code>co_firstlineno</code>：第一行行号</li>
<li><code>co_kwonlyargcount</code>：强制关键字参数个数</li>
<li><code>co_name</code>：函数体的名字</li>
<li><code>co_varnames</code>：参数与变量的名字的tuple</li>
</ul>
]]></content>
      <categories>
        <category>Python随笔</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>反射</tag>
        <tag>inspect</tag>
        <tag>dir</tag>
        <tag>typing</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏开发】踩坑UE4的Python脚本插件</title>
    <url>/2021/11/21/gamedev/ue4_python_script_plugin/</url>
    <content><![CDATA[<p>UE4以C++为基础，在游戏开发需求当中，官方推崇的是Blueprint可视化编程，而除此之外像UnLua、puerts等解决方案也提供了lua、ts等其它脚本语言的支持。至于python，UE4本身就有插件支持，叫做<code>PythonScriptPlugin</code>，启用插件后，在编辑器里，可以输入python代码执行一系列命令。在最新的4.27版本中，python的版本是3.7.7。</p>
<p>回到正题，之所以这篇文章标题叫踩坑，是因为真的踩坑了——尝试用<code>PythonScriptPlugin</code>来编写UE4的游戏逻辑，最终放弃。<code>PythonScriptPlugin</code>适合做一些驱动编辑器的操作，或者是做一些静态资源检查相关的工作（其实这个插件真名就叫<code>Python Editor Script Plugin</code>），如果用它来写游戏逻辑的话，很多必须的内容都难以支持。但不管怎么说，既然踩坑了还是要分享点东西出来，因此这篇文章先粗浅谈一下<code>PythonScriptPlugin</code>的工作流。</p>
<a id="more"></a>
<p><code>PythonScriptPlugin</code>的使用方法，基本可以参考官方文档：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vNC4yNy9lbi1VUy9Qcm9kdWN0aW9uUGlwZWxpbmVzL1NjcmlwdGluZ0FuZEF1dG9tYXRpb24vUHl0aG9uLw==" title="https://docs.unrealengine.com/4.27/en-US/ProductionPipelines/ScriptingAndAutomation/Python/">Scripting the Editor using Python<i class="fa fa-external-link"></i></span></p>
<p>一些必须的步骤有：</p>
<ul>
<li>插件中，启用<code>Python Editor Script Plugin</code></li>
<li>项目设置的Python插件设置里面，<code>sys.path</code>增加自己脚本的目录</li>
<li>项目设置的Python插件设置里面，启用开发者模式，重启后在<code>Intermediate/PythonStubs</code>能够看到导出的<code>unreal.py</code><ul>
<li>将<code>unreal.py</code>放到自己脚本目录下，其它<code>.py</code>脚本就可以通过<code>import unreal</code>来调用UE相关的库了</li>
<li><code>unreal.py</code>内容非常大，ide需要配置intellisense相关设置</li>
</ul>
</li>
</ul>
<p>如果要在游戏逻辑里执行python命令，尤其是在C++里的话（蓝图已经有支持了），需要在<code>Build.cs</code>的<code>PublicDependencyModuleNames</code>加上<code>PythonScriptPlugin</code></p>
<p>在C++执行python代码的话，可以这样子做：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里笔者单独写了个GameInstanceSubsystem封装了相关方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"IPythonScriptPlugin.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> UPyEnvGameInstanceSubsystem::ExecPyCmd(<span class="keyword">const</span> FString&amp; Cmd)</span><br><span class="line">&#123;</span><br><span class="line">    IPythonScriptPlugin* ScriptPlugin = GetScriptPlugin();</span><br><span class="line">    <span class="keyword">if</span> (!_IsScriptPluginAvailable(ScriptPlugin))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ScriptPlugin-&gt;ExecPythonCommand(*Cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IPythonScriptPlugin* UPyEnvGameInstanceSubsystem::GetScriptPlugin()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> IPythonScriptPlugin::Get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> UPyEnvGameInstanceSubsystem::_IsScriptPluginAvailable(IPythonScriptPlugin* ScriptPlugin)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ScriptPlugin != <span class="literal">nullptr</span> &amp;&amp; ScriptPlugin-&gt;IsPythonAvailable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的代码执行可以通过<code>IPythonScriptPlugin</code>的<code>ExecPyCmd</code>实现。如果说要获取执行结果，可以调用<code>IPythonScriptPlugin</code>的<code>ExecPythonCommandEx</code>方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Engine\Plugins\Experimental\PythonScriptPlugin\Source\PythonScriptPlugin\Private\PythonScriptPlugin.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> FPythonScriptPlugin::ExecPythonCommandEx(FPythonCommandEx&amp; InOutPythonCommand)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> WITH_PYTHON</span></span><br><span class="line">    <span class="keyword">if</span> (!IsPythonAvailable())</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        InOutPythonCommand.CommandResult = TEXT(<span class="string">"Python is not available!"</span>);</span><br><span class="line">        ensureAlwaysMsgf(<span class="literal">false</span>, TEXT(<span class="string">"%s"</span>), *InOutPythonCommand.CommandResult);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> WITH_PYTHON</span></span><br><span class="line">    <span class="keyword">if</span> (InOutPythonCommand.ExecutionMode == EPythonCommandExecutionMode::ExecuteFile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// We may have been passed literal code or a file</span></span><br><span class="line">        <span class="comment">// To work out which, extract the first token and see if it's a .py file</span></span><br><span class="line">        <span class="comment">// If it is, treat the remaining text as arguments to the file</span></span><br><span class="line">        <span class="comment">// Otherwise, treat it as literal code</span></span><br><span class="line">        FString ExtractedFilename;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> TCHAR* Tmp = *InOutPythonCommand.Command;</span><br><span class="line">            ExtractedFilename = FParse::Token(Tmp, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (FPaths::GetExtension(ExtractedFilename) == TEXT(<span class="string">"py"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> RunFile(*ExtractedFilename, *InOutPythonCommand.Command, InOutPythonCommand);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> RunString(InOutPythonCommand);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> RunString(InOutPythonCommand);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// WITH_PYTHON</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> FPythonScriptPlugin::RunString(FPythonCommandEx&amp; InOutPythonCommand)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Execute Python code within this block</span></span><br><span class="line">    &#123;</span><br><span class="line">        FPyScopedGIL GIL;</span><br><span class="line">        TGuardValue&lt;<span class="keyword">bool</span>&gt; UnattendedScriptGuard(GIsRunningUnattendedScript, GIsRunningUnattendedScript || EnumHasAnyFlags(InOutPythonCommand.Flags, EPythonCommandFlags::Unattended));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> PyExecMode = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (InOutPythonCommand.ExecutionMode)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> EPythonCommandExecutionMode::ExecuteFile:</span><br><span class="line">            PyExecMode = Py_file_input;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EPythonCommandExecutionMode::ExecuteStatement:</span><br><span class="line">            PyExecMode = Py_single_input;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EPythonCommandExecutionMode::EvaluateStatement:</span><br><span class="line">            PyExecMode = Py_eval_input;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            checkf(<span class="literal">false</span>, TEXT(<span class="string">"Invalid EPythonCommandExecutionMode!"</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FDelegateHandle LogCaptureHandle = PyCore::GetPythonLogCapture().AddLambda([&amp;InOutPythonCommand](EPythonLogOutputType InLogType, <span class="keyword">const</span> TCHAR* InLogString) &#123; InOutPythonCommand.LogOutput.Add(FPythonLogOutputEntry&#123; InLogType, InLogString &#125;); &#125;);</span><br><span class="line">        FPyObjectPtr PyResult = FPyObjectPtr::StealReference(EvalString(*InOutPythonCommand.Command, TEXT(<span class="string">"&lt;string&gt;"</span>), PyExecMode));</span><br><span class="line">        PyCore::GetPythonLogCapture().Remove(LogCaptureHandle);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (PyResult)</span><br><span class="line">        &#123;</span><br><span class="line">            InOutPythonCommand.CommandResult = PyUtil::PyObjectToUEStringRepr(PyResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (PyUtil::LogPythonError(&amp;InOutPythonCommand.CommandResult))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FPyWrapperTypeReinstancer::Get().ProcessPending();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行时候传入<code>FPythonCommandEx</code>结构体，其<code>CommandResult</code>属性会存储执行的结果。如果要传入结果的话，得选择<code>EPythonCommandExecutionMode::EvaluateStatement</code>执行模式。而最终传入的结果，是python数据的<code>repr</code>，并非兼容成UE4的数据结构。</p>
<p>总结起来可以看到，直接用<code>PythonScriptPlugin</code>写游戏是不大现实，有几个点还要解决：</p>
<ul>
<li>python与C++之间的相互通信，数据结构兼容。只有<code>string repr</code>是肯定不行的= =</li>
<li>游戏最终呈现的性能</li>
<li>多平台发布</li>
<li>开发效率（至少自己16G烂本本干不动，还不如纯C++）</li>
<li>etc</li>
</ul>
<p>不过原生作为面向UE4编辑器工作的脚本插件，<code>PythonScriptPlugin</code>应当有其用武之地。后面有空再慢慢探索。</p>
]]></content>
      <categories>
        <category>游戏开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>UE4</tag>
        <tag>C++</tag>
        <tag>PythonScriptPlugin</tag>
        <tag>UE4编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title>【Medium Python】最终话：如何彻底理解with关键字的用法？</title>
    <url>/2021/11/13/mediumpython/v/</url>
    <content><![CDATA[<p>Medium Python终于来到了最终话。经历了前四话的撰写，笔者决定以第五话作为收尾，故这段时间一直在思考python里还有什么内容是我们常见但值得推敲且有应用意义的点。绞尽脑汁，最终得到了今天这个主题：<code>with</code>关键字。</p>
<p><code>with</code>关键字的含义，是笔者接触python以来希望彻底搞懂的问题之一，也是一定会困惑大量玩python的同学的问题之一。相信每一个玩过python的同学都接触过<code>with</code>语法，比如<code>with open(xxx) as f</code>的文件操作，或者是<code>with lock</code>这样的加解锁操作，这些东西每个python教程里都有。但是<code>with</code>语法具体表示什么，具体能够翻译成怎样的简单语法，基本没啥人能够说的清楚，说的科学。即便在网上有许多文章在剖析这一点，提到了许多诸如“上下文管理（<code>context manager</code>）”、“异常处理”、“<code>__enter__</code>、<code>__exit__</code>”之类的词汇，但是就正因为缺少些硬核的东西，比如源码分析，导致许多个文章的内容都很水，看了也不能完完全全的明白，实际写代码的时候也觉得难以彻底掌握。</p>
<p>因此，为了把这件事情说明白，本文决定继续源码分析的套路，让大伙儿彻底理解<code>with</code>关键字是怎么一回事。老样子，一切的吹水都没有源码分析来的实在。看完这篇文章，其它关于<code>with</code>的文章都可以统统无视了。</p>
<h2 id="with代码测试"><a href="#with代码测试" class="headerlink" title="with代码测试"></a>with代码测试</h2><p>首先我们上一段测试代码：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock, Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_seg</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">'\n'</span>.join([<span class="string">'='</span> * <span class="number">40</span>, str(msg), <span class="string">'='</span> * <span class="number">40</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_fopen</span><span class="params">()</span>:</span></span><br><span class="line">    filename = <span class="string">'1.log'</span></span><br><span class="line">    <span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">        print(f.read())</span><br><span class="line">        f.close()</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_NUM_THREADS = <span class="number">3</span></span><br><span class="line">_LOCK = Lock()</span><br><span class="line">_CNT = <span class="number">0</span></span><br><span class="line">_MAX_CNT = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_test_thread_lock_task</span><span class="params">()</span>:</span></span><br><span class="line">    thread_name = threading.current_thread().name</span><br><span class="line">    <span class="keyword">global</span> _CNT</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">with</span> _LOCK:</span><br><span class="line">            <span class="keyword">if</span> _CNT &lt; _MAX_CNT:</span><br><span class="line">                _CNT += <span class="number">1</span></span><br><span class="line">                print(<span class="string">'[%s] count: %d'</span> % (thread_name, _CNT))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">'[%s] count reached max: %d'</span> % (thread_name, _MAX_CNT))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_thread_lock</span><span class="params">()</span>:</span></span><br><span class="line">    sys.setswitchinterval(<span class="number">0.001</span>)</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(_NUM_THREADS):</span><br><span class="line">        threads.append(Thread(target=_test_thread_lock_task, name=<span class="string">'Thread-%d'</span> % (i + <span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(_NUM_THREADS):</span><br><span class="line">        threads[i].start()</span><br><span class="line">    time.sleep(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(_NUM_THREADS):</span><br><span class="line">        threads[i].join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test_thread_lock()</span><br><span class="line">    test_fopen()</span><br><span class="line">    _seg(<span class="string">'disassemble test_fopen'</span>)</span><br><span class="line">    dis.dis(test_fopen)</span><br><span class="line">    _seg(<span class="string">'disassemble _test_thread_lock_task'</span>)</span><br><span class="line">    dis.dis(_test_thread_lock_task)</span><br></pre></td></tr></table></figure>
<p>这段测试代码包含了两个我们常见的<code>with</code>操作：文件读写和线程加锁。<code>test_fopen</code>是读文件内容，<code>test_thread_lock</code>是不同线程交替增加<code>_CNT</code>的操作。在代码里面，再次出现了我们的老同志：反编译库<code>dis</code>，这是为了用来解析每一个函数具体包含哪些操作码，以能够让我们快速定位对应操作的源代码实现。每个被<code>dis</code>的函数，在<code>with</code>的最后都有<code>pass</code>操作，这是为了更加方便看到在退出<code>with</code>范围时，代码实际做了哪些附加操作（嗯，这些<code>pass</code>是实际调试之后才加的）。</p>
<p>以文件读写<code>test_fopen</code>为例，我们看下反编译之后的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13           0 LOAD_CONST               1 (&apos;1.log&apos;)</span><br><span class="line">             2 STORE_FAST               0 (filename)</span><br><span class="line"></span><br><span class="line">14           4 LOAD_GLOBAL              0 (open)</span><br><span class="line">             6 LOAD_FAST                0 (filename)</span><br><span class="line">             8 CALL_FUNCTION            1</span><br><span class="line">            10 SETUP_WITH              36 (to 48)</span><br><span class="line">            12 STORE_FAST               1 (f)</span><br><span class="line"></span><br><span class="line">15          14 LOAD_GLOBAL              1 (print)</span><br><span class="line">            16 LOAD_FAST                1 (f)</span><br><span class="line">            18 LOAD_METHOD              2 (read)</span><br><span class="line">            20 CALL_METHOD              0</span><br><span class="line">            22 CALL_FUNCTION            1</span><br><span class="line">            24 POP_TOP</span><br><span class="line"></span><br><span class="line">16          26 LOAD_FAST                1 (f)</span><br><span class="line">            28 LOAD_METHOD              3 (close)</span><br><span class="line">            30 CALL_METHOD              0</span><br><span class="line">            32 POP_TOP</span><br><span class="line"></span><br><span class="line">18          34 POP_BLOCK</span><br><span class="line">            36 LOAD_CONST               0 (None)</span><br><span class="line">            38 DUP_TOP</span><br><span class="line">            40 DUP_TOP</span><br><span class="line">            42 CALL_FUNCTION            3</span><br><span class="line">            44 POP_TOP</span><br><span class="line">            46 JUMP_FORWARD            16 (to 64)</span><br><span class="line">       &gt;&gt;   48 WITH_EXCEPT_START</span><br><span class="line">            50 POP_JUMP_IF_TRUE        54</span><br><span class="line">            52 RERAISE</span><br><span class="line">       &gt;&gt;   54 POP_TOP</span><br><span class="line">            56 POP_TOP</span><br><span class="line">            58 POP_TOP</span><br><span class="line">            60 POP_EXCEPT</span><br><span class="line">            62 POP_TOP</span><br><span class="line">       &gt;&gt;   64 LOAD_CONST               0 (None)</span><br><span class="line">            66 RETURN_VALUE</span><br></pre></td></tr></table></figure>
<p>我们看到，在<code>with</code>的一行（14），多了<code>SETUP_WITH</code>的操作指令，而在即将退出<code>with</code>代码块的<code>pass</code>一行（18），出现了大量指令，并且有点类似于异常处理的内容。那么这里到底蕴含了什么信息呢？<br>那么首先，我们从<code>SETUP_WITH</code>——<code>with</code>代码块的初始化操作开始看起。</p>
<h2 id="with代码块的初始化"><a href="#with代码块的初始化" class="headerlink" title="with代码块的初始化"></a>with代码块的初始化</h2><p>我们在<code>EvalFrame</code>的循环中，先找到<code>SETUP_WITH</code>对应的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ceval.c</span></span><br><span class="line"></span><br><span class="line">case TARGET(SETUP_WITH): &#123;</span><br><span class="line">    _Py_IDENTIFIER(__enter__);</span><br><span class="line">    _Py_IDENTIFIER(__exit__);</span><br><span class="line">    PyObject *mgr = TOP();</span><br><span class="line">    PyObject *enter = special_lookup(tstate, mgr, &amp;PyId___enter__);</span><br><span class="line">    PyObject *res;</span><br><span class="line">    <span class="keyword">if</span> (enter == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    PyObject *<span class="built_in">exit</span> = special_lookup(tstate, mgr, &amp;PyId___exit__);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exit</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_DECREF(enter);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    SET_TOP(<span class="built_in">exit</span>);</span><br><span class="line">    Py_DECREF(mgr);</span><br><span class="line">    res = _PyObject_CallNoArg(enter);</span><br><span class="line">    Py_DECREF(enter);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    <span class="comment">/* Setup the finally block before pushing the result</span></span><br><span class="line"><span class="comment">               of __enter__ on the stack. */</span></span><br><span class="line">    PyFrame_BlockSetup(f, SETUP_FINALLY, INSTR_OFFSET() + oparg,</span><br><span class="line">                       STACK_LEVEL());</span><br><span class="line"></span><br><span class="line">    PUSH(res);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>SETUP_WITH</code>操作的步骤如下：</p>
<ul>
<li>一开始，寻找<code>with</code>对应实例的<code>__enter__</code>以及<code>__exit__</code>方法（绑定实例的），如果两者有其一找不到的话都会直接跳到<code>error</code>报错。</li>
<li>设置<code>__exit__</code>为栈顶</li>
<li>直接调用<code>instance.__enter__()</code></li>
<li>进行BlockSetup：<code>PyFrame_BlockSetup(f, SETUP_FINALLY, INSTR_OFFSET() + oparg, STACK_LEVEL())</code></li>
<li>将<code>__enter__</code>的返回值<code>PUSH</code>到栈上</li>
</ul>
<p>在<code>test_fopen</code>里面，<code>__enter__</code>函数对应的是<code>iobase_enter</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// iobase.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">iobase_enter(PyObject *self, PyObject *args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (iobase_check_closed(self))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    Py_INCREF(self);</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在<code>__enter__</code>函数中会检测这个<code>io</code>对象是否已经<code>close</code>掉，如果<code>close</code>掉的话会返回<code>NULL</code>，正常的话返回<code>io</code>对象。如果<code>__enter__</code>返回<code>NULL</code>，在<code>SETUP_WITH</code>里面，就<code>goto</code>到<code>error</code>逻辑了。</p>
<p>之后我们再看一下<code>BlockSetup</code>语句，其中会调用<code>PyFrame_BlockSetup</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameobject.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">PyFrame_BlockSetup(PyFrameObject *f, <span class="keyword">int</span> type, <span class="keyword">int</span> handler, <span class="keyword">int</span> level)</span><br><span class="line">&#123;</span><br><span class="line">    PyTryBlock *b;</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;f_iblock &gt;= CO_MAXBLOCKS) &#123;</span><br><span class="line">        Py_FatalError(<span class="string">"block stack overflow"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    b = &amp;f-&gt;f_blockstack[f-&gt;f_iblock++];</span><br><span class="line">    b-&gt;b_type = type;</span><br><span class="line">    b-&gt;b_level = level;</span><br><span class="line">    b-&gt;b_handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PyFrame_BlockSetup</code>的本质是设置了一个<code>PyTryBlock</code>。如果进一步检索<code>PyFrame_BlockSetup</code>的引用的话，会发现<code>SETUP_FINALLY</code>这个操作本质就是调用了这个函数。而<code>SETUP_FINALLY</code>本身，比如在<code>try/except/finally</code>结构里，不论是<code>except</code>还是<code>finally</code>，都用的这个字节码。</p>
<p><code>PyTryBlock</code>除了在<code>try/except/finally</code>结构中有使用之外，在循环<code>loop</code>的时候也会用到，其三个属性的意义分别为：</p>
<ul>
<li><code>b_type</code>：当前代码块<code>block</code>的类型（<code>SETUP_FINALLY</code>）</li>
<li><code>b_handler</code>：处理错误信息的<code>handler</code>的指令位置（<code>INSTR_OFFSET() + oparg</code>）</li>
<li><code>b_level</code>：比如出现<code>exception</code>的场景下，要对栈做恢复，pop一系列栈上的value时，用来参考的栈高度（<code>STACK_LEVEL()</code>）</li>
</ul>
<p>我们进一步看<code>PyTryBlock</code>跟<code>FrameObject</code>的定义及注释，也可以证实这些信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameobject.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> b_type;                 <span class="comment">/* what kind of block this is */</span></span><br><span class="line">    <span class="keyword">int</span> b_handler;              <span class="comment">/* where to jump to find handler */</span></span><br><span class="line">    <span class="keyword">int</span> b_level;                <span class="comment">/* value stack level to pop to */</span></span><br><span class="line">&#125; PyTryBlock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> *<span class="title">f_back</span>;</span>      <span class="comment">/* previous frame, or NULL */</span></span><br><span class="line">    PyCodeObject *f_code;       <span class="comment">/* code segment */</span></span><br><span class="line">    PyObject *f_builtins;       <span class="comment">/* builtin symbol table (PyDictObject) */</span></span><br><span class="line">    PyObject *f_globals;        <span class="comment">/* global symbol table (PyDictObject) */</span></span><br><span class="line">    PyObject *f_locals;         <span class="comment">/* local symbol table (any mapping) */</span></span><br><span class="line">    PyObject **f_valuestack;    <span class="comment">/* points after the last local */</span></span><br><span class="line">    <span class="comment">/* Next free slot in f_valuestack.  Frame creation sets to f_valuestack.</span></span><br><span class="line"><span class="comment">       Frame evaluation usually NULLs it, but a frame that yields sets it</span></span><br><span class="line"><span class="comment">       to the current stack top. */</span></span><br><span class="line">    PyObject **f_stacktop;</span><br><span class="line">    PyObject *f_trace;          <span class="comment">/* Trace function */</span></span><br><span class="line">    <span class="keyword">char</span> f_trace_lines;         <span class="comment">/* Emit per-line trace events? */</span></span><br><span class="line">    <span class="keyword">char</span> f_trace_opcodes;       <span class="comment">/* Emit per-opcode trace events? */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Borrowed reference to a generator, or NULL */</span></span><br><span class="line">    PyObject *f_gen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f_lasti;                <span class="comment">/* Last instruction if called */</span></span><br><span class="line">    <span class="comment">/* Call PyFrame_GetLineNumber() instead of reading this field</span></span><br><span class="line"><span class="comment">       directly.  As of 2.3 f_lineno is only valid when tracing is</span></span><br><span class="line"><span class="comment">       active (i.e. when f_trace is set).  At other times we use</span></span><br><span class="line"><span class="comment">       PyCode_Addr2Line to calculate the line from the current</span></span><br><span class="line"><span class="comment">       bytecode index. */</span></span><br><span class="line">    <span class="keyword">int</span> f_lineno;               <span class="comment">/* Current line number */</span></span><br><span class="line">    <span class="keyword">int</span> f_iblock;               <span class="comment">/* index in f_blockstack */</span></span><br><span class="line">    <span class="keyword">char</span> f_executing;           <span class="comment">/* whether the frame is still executing */</span></span><br><span class="line">    PyTryBlock f_blockstack[CO_MAXBLOCKS]; <span class="comment">/* for try and loop blocks */</span></span><br><span class="line">    PyObject *f_localsplus[<span class="number">1</span>];  <span class="comment">/* locals+stack, dynamically sized */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有了<code>PyTryBlock</code>存储一系列栈上信息，就可以保证<code>with</code>结构下的代码块在结束之后，整个栈上的状态能够恢复到<code>with</code>之前的状态。注意这个时候栈顶上是<code>__exit__</code>函数，这样如果之后恢复栈，然后push一系列错误信息，我们的<code>__exit__</code>函数就能处理对应的错误信息了。</p>
<p><code>BlockSetup</code>之后，就是把<code>__enter__</code>的返回值推进栈里，交由后面的<code>STORE</code>指令存储到<code>locals</code>里面。比如我们在<code>python</code>中编写的<code>with a as b</code>这种形式，最后我们取到的<code>b</code>，就是<code>__enter__</code>的返回值了。</p>
<h2 id="with代码块的退出以及异常处理"><a href="#with代码块的退出以及异常处理" class="headerlink" title="with代码块的退出以及异常处理"></a>with代码块的退出以及异常处理</h2><p>执行完<code>with</code>一行的代码之后，我们开始执行<code>with</code>代码块里面的内容。<code>with</code>代码块执行完之后，当退出之时，也会执行一系列行为。<br>从上面的字节码结果中也可以看到，有非常长的一串，这里也再列出来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18          34 POP_BLOCK</span><br><span class="line">            36 LOAD_CONST               0 (None)</span><br><span class="line">            38 DUP_TOP</span><br><span class="line">            40 DUP_TOP</span><br><span class="line">            42 CALL_FUNCTION            3</span><br><span class="line">            44 POP_TOP</span><br><span class="line">            46 JUMP_FORWARD            16 (to 64)</span><br><span class="line">       &gt;&gt;   48 WITH_EXCEPT_START</span><br><span class="line">            50 POP_JUMP_IF_TRUE        54</span><br><span class="line">            52 RERAISE</span><br><span class="line">       &gt;&gt;   54 POP_TOP</span><br><span class="line">            56 POP_TOP</span><br><span class="line">            58 POP_TOP</span><br><span class="line">            60 POP_EXCEPT</span><br><span class="line">            62 POP_TOP</span><br><span class="line">       &gt;&gt;   64 LOAD_CONST               0 (None)</span><br><span class="line">            66 RETURN_VALUE</span><br></pre></td></tr></table></figure>
<p>退出<code>with</code>的一刻，需要考虑两种情况：有异常和没有异常。当没有异常的时候下来，会到字节码的34~46。34先<code>POP_BLOCK</code>退出代码块，然后之后有一个<code>CALL_FUNCTION</code>操作：由于先前讲到栈顶已经被设置成了<code>__exit__</code>函数，那么这里相当于再顶了3个<code>None</code>，然后执行了<code>instance.__exit__(None, None, None)</code>。之后就走到64，退出这个<code>with</code>流程了。<br>​</p>
<p>而当有异常时，我们会跳到48：<code>WITH_EXCEPT_START</code>，这一块在前面<code>SETUP_WITH</code>的字节码有标注：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 SETUP_WITH              36 (to 48)</span><br></pre></td></tr></table></figure>
<p>如果说<code>with</code>结构最终走到了<code>WITH_EXCEPT_START</code>的分支，那么在此之前一定已经执行了某些抛异常（比如<code>raise</code>）且没有捕获的操作。为了模拟这个场景，我们在<code>with</code>代码块中加一行代码<code>raise Exception</code>，来看下抛异常时候的情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_with_except</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'./1.log'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        print(f.read())</span><br><span class="line">        <span class="keyword">raise</span> KeyError(<span class="string">'haha'</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    dis.dis(test_with_except)</span><br><span class="line">    test_with_except()</span><br></pre></td></tr></table></figure>
<p>用<code>dis</code>得到的反编译结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5           0 LOAD_GLOBAL              0 (open)</span><br><span class="line">            2 LOAD_CONST               1 (&apos;./1.log&apos;)</span><br><span class="line">            4 CALL_FUNCTION            1</span><br><span class="line">            6 SETUP_WITH              36 (to 44)</span><br><span class="line">            8 STORE_FAST               0 (f)</span><br><span class="line"></span><br><span class="line">6          10 LOAD_GLOBAL              1 (print)</span><br><span class="line">           12 LOAD_FAST                0 (f)</span><br><span class="line">           14 LOAD_METHOD              2 (read)</span><br><span class="line">           16 CALL_METHOD              0</span><br><span class="line">           18 CALL_FUNCTION            1</span><br><span class="line">           20 POP_TOP</span><br><span class="line"></span><br><span class="line">7          22 LOAD_GLOBAL              3 (KeyError)</span><br><span class="line">           24 LOAD_CONST               2 (&apos;haha&apos;)</span><br><span class="line">           26 CALL_FUNCTION            1</span><br><span class="line">           28 RAISE_VARARGS            1</span><br><span class="line"></span><br><span class="line">8          30 POP_BLOCK</span><br><span class="line">           32 LOAD_CONST               0 (None)</span><br><span class="line">           34 DUP_TOP</span><br><span class="line">           36 DUP_TOP</span><br><span class="line">           38 CALL_FUNCTION            3</span><br><span class="line">           40 POP_TOP</span><br><span class="line">           42 JUMP_FORWARD            16 (to 60)</span><br><span class="line">      &gt;&gt;   44 WITH_EXCEPT_START</span><br><span class="line">           46 POP_JUMP_IF_TRUE        50</span><br><span class="line">           48 RERAISE</span><br><span class="line">      &gt;&gt;   50 POP_TOP</span><br><span class="line">           52 POP_TOP</span><br><span class="line">           54 POP_TOP</span><br><span class="line">           56 POP_EXCEPT</span><br><span class="line">           58 POP_TOP</span><br><span class="line">      &gt;&gt;   60 LOAD_CONST               0 (None)</span><br><span class="line">           62 RETURN_VALUE</span><br></pre></td></tr></table></figure>
<p>我们可以从中看到，当<code>raise</code>异常时，会执行<code>RAISE_VARARGS 1</code>的指令。我们先来看<code>RAISE_VARARGS</code>对应的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ceval.c</span></span><br><span class="line"></span><br><span class="line">case TARGET(RAISE_VARARGS): &#123;</span><br><span class="line">    PyObject *cause = <span class="literal">NULL</span>, *exc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">switch</span> (oparg) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            cause = POP(); <span class="comment">/* cause */</span></span><br><span class="line">            <span class="comment">/* fall through */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            exc = POP(); <span class="comment">/* exc */</span></span><br><span class="line">            <span class="comment">/* fall through */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> (do_raise(tstate, exc, cause)) &#123;</span><br><span class="line">                <span class="keyword">goto</span> exception_unwind;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            _PyErr_SetString(tstate, PyExc_SystemError,</span><br><span class="line">                             <span class="string">"bad RAISE_VARARGS oparg"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>RAISE_VARARGS</code>中，<code>case</code>对应的指令会顺着往下走，直到<code>case 0</code>的<code>do_raise</code>逻辑里面。<code>do_raise</code>是抛异常的实际操作，里面会检查抛出的异常类型以及参数是否合理，之后再设置当前线程的异常类型<code>type</code>以及异常值<code>value</code><br><code>RAISE_VARARGS</code>最后会跳到<code>error</code>以及<code>exception_unwind</code>代码段：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ceval.c</span></span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">        <span class="comment">/* Double-check exception status. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NDEBUG</span></span><br><span class="line">        <span class="keyword">if</span> (!_PyErr_Occurred(tstate)) &#123;</span><br><span class="line">            _PyErr_SetString(tstate, PyExc_SystemError,</span><br><span class="line">                             <span class="string">"error return without exception set"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        assert(_PyErr_Occurred(tstate));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Log traceback info. */</span></span><br><span class="line">        PyTraceBack_Here(f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tstate-&gt;c_tracefunc != <span class="literal">NULL</span>)</span><br><span class="line">            call_exc_trace(tstate-&gt;c_tracefunc, tstate-&gt;c_traceobj,</span><br><span class="line">                           tstate, f);</span><br><span class="line"></span><br><span class="line">exception_unwind:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暂时忽略下面</span></span><br></pre></td></tr></table></figure>
<p>在<code>error</code>段中，会提取当前<code>frame</code>上的异常<code>traceback</code>信息，然后就直接到了<code>exception_unwind</code>段。<code>exception_unwind</code>段会恢复栈上的信息，其逻辑如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ceval.c</span></span><br><span class="line"></span><br><span class="line">exception_unwind:</span><br><span class="line">        <span class="comment">/* Unwind stacks if an exception occurred */</span></span><br><span class="line">  <span class="keyword">while</span> (f-&gt;f_iblock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* Pop the current block. */</span></span><br><span class="line">            PyTryBlock *b = &amp;f-&gt;f_blockstack[--f-&gt;f_iblock];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (b-&gt;b_type == EXCEPT_HANDLER) &#123;</span><br><span class="line">                UNWIND_EXCEPT_HANDLER(b);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            UNWIND_BLOCK(b);</span><br><span class="line">            <span class="keyword">if</span> (b-&gt;b_type == SETUP_FINALLY) &#123;</span><br><span class="line">                PyObject *exc, *val, *tb;</span><br><span class="line">                <span class="keyword">int</span> handler = b-&gt;b_handler;</span><br><span class="line">                _PyErr_StackItem *exc_info = tstate-&gt;exc_info;</span><br><span class="line">                <span class="comment">/* Beware, this invalidates all b-&gt;b_* fields */</span></span><br><span class="line">                PyFrame_BlockSetup(f, EXCEPT_HANDLER, <span class="number">-1</span>, STACK_LEVEL());</span><br><span class="line">                PUSH(exc_info-&gt;exc_traceback);</span><br><span class="line">                PUSH(exc_info-&gt;exc_value);</span><br><span class="line">                <span class="keyword">if</span> (exc_info-&gt;exc_type != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    PUSH(exc_info-&gt;exc_type);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Py_INCREF(Py_None);</span><br><span class="line">                    PUSH(Py_None);</span><br><span class="line">                &#125;</span><br><span class="line">                _PyErr_Fetch(tstate, &amp;exc, &amp;val, &amp;tb);</span><br><span class="line">                <span class="comment">/* Make the raw exception data</span></span><br><span class="line"><span class="comment">                   available to the handler,</span></span><br><span class="line"><span class="comment">                   so a program can emulate the</span></span><br><span class="line"><span class="comment">                   Python main loop. */</span></span><br><span class="line">                _PyErr_NormalizeException(tstate, &amp;exc, &amp;val, &amp;tb);</span><br><span class="line">                <span class="keyword">if</span> (tb != <span class="literal">NULL</span>)</span><br><span class="line">                    PyException_SetTraceback(val, tb);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    PyException_SetTraceback(val, Py_None);</span><br><span class="line">                Py_INCREF(exc);</span><br><span class="line">                exc_info-&gt;exc_type = exc;</span><br><span class="line">                Py_INCREF(val);</span><br><span class="line">                exc_info-&gt;exc_value = val;</span><br><span class="line">                exc_info-&gt;exc_traceback = tb;</span><br><span class="line">                <span class="keyword">if</span> (tb == <span class="literal">NULL</span>)</span><br><span class="line">                    tb = Py_None;</span><br><span class="line">                Py_INCREF(tb);</span><br><span class="line">                PUSH(tb);</span><br><span class="line">                PUSH(val);</span><br><span class="line">                PUSH(exc);</span><br><span class="line">                JUMPTO(handler);</span><br><span class="line">                <span class="keyword">if</span> (_Py_TracingPossible(ceval2)) &#123;</span><br><span class="line">                    <span class="keyword">int</span> needs_new_execution_window = (f-&gt;f_lasti &lt; instr_lb || f-&gt;f_lasti &gt;= instr_ub);</span><br><span class="line">                    <span class="keyword">int</span> needs_line_update = (f-&gt;f_lasti == instr_lb || f-&gt;f_lasti &lt; instr_prev);</span><br><span class="line">                    <span class="comment">/* Make sure that we trace line after exception if we are in a new execution</span></span><br><span class="line"><span class="comment">                     * window or we don't need a line update and we are not in the first instruction</span></span><br><span class="line"><span class="comment">                     * of the line. */</span></span><br><span class="line">                    <span class="keyword">if</span> (needs_new_execution_window || (!needs_line_update &amp;&amp; instr_lb &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">                        instr_prev = INT_MAX;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* Resume normal execution */</span></span><br><span class="line">                <span class="keyword">goto</span> main_loop;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">/* unwind stack */</span></span><br></pre></td></tr></table></figure>
<p>由于我们先前执行过了<code>PyFrame_BlockSetup(f, SETUP_FINALLY, INSTR_OFFSET() + oparg, STACK_LEVEL())</code>，最终代码会运行到<code>if (b-&gt;b_type == SETUP_FINALLY)</code>对应的段落。在其中进行了以下步骤：</p>
<ul>
<li><code>PyFrame_BlockSetup(f, EXCEPT_HANDLER, -1, STACK_LEVEL())</code>：设定了一个新的代码块，标识为<code>EXCEPT_HANDLER</code></li>
<li>将异常栈（串连异常信息的链）当前最顶端的异常信息push到栈中</li>
<li>将当前需要<code>raise</code>的异常信息push到栈中<ul>
<li>这个场景下，应当和异常栈最顶端的一样</li>
<li>注意<code>_PyErr_Fetch</code>会将表示当前线程要抛出的异常的几个变量（<code>curexc_type</code>、<code>curexc_value</code>、<code>curexc_traceback</code>）重置为<code>NULL</code>。这样如果当前异常得到妥善处理掉，后面执行时候发现线程里面这些变量是<code>NULL</code>，也不会触发程序终止打印异常。</li>
<li><code>_PyErr_Fetch</code>相反的操作叫做<code>_PyErr_Restore</code>，相当于设定当前线程已经出现异常。</li>
</ul>
</li>
</ul>
<p>进行了这个操作之后，现在栈上应当至少有7个元素，自顶而下是：</p>
<ul>
<li>前3个是当前需要<code>raise</code>的异常信息</li>
<li>中间3个是异常栈最顶端的异常信息</li>
<li>然后第7个就是<code>__exit__</code>函数</li>
</ul>
<p>之后通过<code>JUMPTO(handler)</code>、<code>goto main_loop</code>，就走到了<code>WITH_EXCEPT_START</code>逻辑</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ceval.c</span></span><br><span class="line"></span><br><span class="line">case TARGET(WITH_EXCEPT_START): &#123;</span><br><span class="line">    <span class="comment">/* At the top of the stack are 7 values:</span></span><br><span class="line"><span class="comment">       - (TOP, SECOND, THIRD) = exc_info()</span></span><br><span class="line"><span class="comment">       - (FOURTH, FIFTH, SIXTH) = previous exception for EXCEPT_HANDLER</span></span><br><span class="line"><span class="comment">       - SEVENTH: the context.__exit__ bound method</span></span><br><span class="line"><span class="comment">       We call SEVENTH(TOP, SECOND, THIRD).</span></span><br><span class="line"><span class="comment">       Then we push again the TOP exception and the __exit__ return value.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    PyObject *exit_func;</span><br><span class="line">    PyObject *exc, *val, *tb, *res;</span><br><span class="line"></span><br><span class="line">    exc = TOP();</span><br><span class="line">    val = SECOND();</span><br><span class="line">    tb = THIRD();</span><br><span class="line">    assert(exc != Py_None);</span><br><span class="line">    assert(!PyLong_Check(exc));</span><br><span class="line">    exit_func = PEEK(<span class="number">7</span>);</span><br><span class="line">    PyObject *<span class="built_in">stack</span>[<span class="number">4</span>] = &#123;<span class="literal">NULL</span>, exc, val, tb&#125;;</span><br><span class="line">    res = PyObject_Vectorcall(exit_func, <span class="built_in">stack</span> + <span class="number">1</span>,</span><br><span class="line">                              <span class="number">3</span> | PY_VECTORCALL_ARGUMENTS_OFFSET, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">    PUSH(res);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>WITH_EXCEPT_START</code>的逻辑里，直接调用了<code>instance.__exit__(exc_type, exc_value, exc_traceback)</code>，然后把结果再推到栈上。这样栈上就有8个元素了。<br>以先前的<code>with open(xxx) as f</code>为例，其<code>__exit__</code>函数对应了<code>iobase_exit</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// iobase.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">iobase_exit(PyObject *self, PyObject *args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyObject_CallMethodNoArgs(self, _PyIO_str_close);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个函数会返回<code>f.close</code>的返回值，其实就是<code>None</code>，并且对异常信息（包在<code>args</code>里）没有任何处理。<br><code>__exit__</code>函数的返回值有什么用处呢？我们看到紧接着的操作是<code>POP_JUMP_IF_TRUE</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ceval.c</span></span><br><span class="line"></span><br><span class="line">case TARGET(POP_JUMP_IF_TRUE): &#123;</span><br><span class="line">    PREDICTED(POP_JUMP_IF_TRUE);</span><br><span class="line">    PyObject *cond = POP();</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">if</span> (cond == Py_False) &#123;</span><br><span class="line">        Py_DECREF(cond);</span><br><span class="line">        FAST_DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cond == Py_True) &#123;</span><br><span class="line">        Py_DECREF(cond);</span><br><span class="line">        JUMPTO(oparg);</span><br><span class="line">        FAST_DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    err = PyObject_IsTrue(cond);</span><br><span class="line">    Py_DECREF(cond);</span><br><span class="line">    <span class="keyword">if</span> (err &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        JUMPTO(oparg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，一开始我们会<code>POP</code>出来栈顶的值，也就是<code>__exit__</code>的返回值，然后再根据这个返回值走下面的逻辑。如果这个返回值可以作为真值（比如1、有内容的<code>list</code>/<code>dict</code>）的话，就跳到指定的指令，如果不是真值（比如<code>None</code>、0、空的<code>list</code>/<code>dict</code>）的话，就接续下去。因此结合先前反编译操作码的结果来看，会是这样的效果：</p>
<ul>
<li>如果<code>__exit__</code>返回真值，则走后面的<code>POP</code>一堆东西的逻辑（50）<ul>
<li>理论上，不会结束程序，打不打印异常看你在<code>__exit__</code>里有没有操作了</li>
</ul>
</li>
<li>如果<code>__exit__</code>返回非真值，就走下面的<code>RERAISE</code>指令（48），结束程序打印异常</li>
</ul>
<p>首先来看<code>RERAISE</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">case TARGET(RERAISE): &#123;</span><br><span class="line">    PyObject *exc = POP();</span><br><span class="line">    PyObject *val = POP();</span><br><span class="line">    PyObject *tb = POP();</span><br><span class="line">    assert(PyExceptionClass_Check(exc));</span><br><span class="line">    _PyErr_Restore(tstate, exc, val, tb);</span><br><span class="line">    <span class="keyword">goto</span> exception_unwind;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RERAISE</code>实际把栈顶3个待<code>raise</code>的异常信息POP出来，并通过<code>_PyErr_Restore</code>重新设置当前线程出现的异常信息，然后又走到了<code>exception_unwind</code>。在<code>exception_unwind</code>的遍历代码块的<code>while</code>循环中，首先识别到先前<code>BlockSetup</code>的<code>EXCEPT_HANDLER</code>代码段，调用<code>UNWIND_EXCEPT_HANDLER</code>把先前<code>PUSH</code>的异常栈顶的异常信息全给<code>POP</code>了，之后由于没有任何<code>SETUP_FINALLY</code>的标记，整个遍历代码块就结束了，最终就会把栈里剩下的值（<code>__exit__</code>）清掉，退出代码执行。<br>代码执行完毕之后，由于表示当前线程要抛出的异常的几个变量被<code>_PyErr_Restore</code>设置了，最终就会触发程序终止，并在<code>stderr</code>打印异常信息。</p>
<p>然后我们再看<code>__exit__</code>返回真值情况下那一堆<code>POP</code>操作，大概是这样：</p>
<ul>
<li>首先是3个<code>POP_TOP</code>，把待<code>raise</code>的异常信息<code>POP</code>掉</li>
<li>然后是<code>POP_EXCEPT</code>，一方面会退出前面设置的<code>EXCEPT_HANDLER</code>代码段，另一方面会把先前<code>PUSH</code>进去的那个时刻的异常栈顶的信息给POP出来，并重新设置到异常栈顶上，保证异常信息恢复原样</li>
<li>最后又来一个<code>POP_TOP</code>，就是把<code>__exit__</code>给POP掉</li>
</ul>
<p>这样，整个<code>with</code>代码块的部分就执行完成了！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>with</code>关键字分析了那么久，大家也能够看的明白，<code>with</code>本身其实相当于<code>try/except/finally</code>结构的变体。剖析<code>with</code>结构的同时，也不得不需要参考异常处理相关的代码逻辑。这篇文章与其说在讲<code>with</code>，不如说在讲一些异常处理相关的实现。<br>​<br>从上面的分析结果，我们就可以得出来：<br>​<br>比如一个python代码段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> a <span class="keyword">as</span> b:</span><br><span class="line">    xxx</span><br><span class="line">    yyy</span><br><span class="line">    zzz</span><br></pre></td></tr></table></figure>
<p>就能够被简单地翻译为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = a.__enter__()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    xxx</span><br><span class="line">    yyy</span><br><span class="line">    zzz</span><br><span class="line"><span class="keyword">except</span> exception_type, exception_value, exception_traceback:</span><br><span class="line">    <span class="comment"># handle exception</span></span><br><span class="line">    ok = a.__exit__(exception_type, exception_value, exception_traceback)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok:</span><br><span class="line">        <span class="comment"># RERAISE</span></span><br><span class="line">        <span class="keyword">raise</span> (exception_type, exception_value, exception_traceback)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># normal ending</span></span><br><span class="line">    a.__exit__(<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>翻译成这样，每一个学过一点python的同学都会很清楚地理解吧！</p>
<p>那么，如果我们要自己编写支持with语法的程序，可以参考下面的python代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithTester</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__flag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__flag = <span class="number">1</span></span><br><span class="line">        print(<span class="string">'[WithTester] triggered enter: %d'</span> % self.__flag)</span><br><span class="line">        <span class="keyword">return</span> self.__flag + <span class="number">99</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        self.__flag = <span class="number">0</span></span><br><span class="line">        print(<span class="string">'[WithTester] triggered exit: %d\n%s'</span> % (</span><br><span class="line">            self.__flag,</span><br><span class="line">            pprint.pformat(&#123;</span><br><span class="line">                <span class="string">'exc_type'</span>: exc_type,</span><br><span class="line">                <span class="string">'exc_val'</span>: exc_val,</span><br><span class="line">                <span class="string">'exc_tb'</span>: exc_tb</span><br><span class="line">            &#125;)</span><br><span class="line">        ))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'a true value'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    wt = WithTester()</span><br><span class="line">    <span class="keyword">with</span> wt <span class="keyword">as</span> f:</span><br><span class="line">        print(type(f))</span><br><span class="line">        print(f)</span><br><span class="line">        print(<span class="string">'haha'</span>)</span><br><span class="line">        <span class="keyword">raise</span> KeyError(<span class="string">'hehe'</span>)</span><br></pre></td></tr></table></figure>
<p>支持<code>with</code>的实例，需要有只带<code>self</code>一个参数的<code>__enter__</code>函数，以及带<code>self</code>以及异常类型、异常值、异常traceback三个参数的<code>__exit__</code>函数。通过上面“代码翻译”的样式，不难看出，执行<code>main</code>函数会输出这样的结果，不带<code>Exception</code>报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[WithTester] triggered enter: 1</span><br><span class="line">&lt;class &apos;int&apos;&gt;</span><br><span class="line">100</span><br><span class="line">haha</span><br><span class="line">[WithTester] triggered exit: 0</span><br><span class="line">&#123;&apos;exc_tb&apos;: &lt;traceback object at 0x000001D64D6F58C0&gt;,</span><br><span class="line"> &apos;exc_type&apos;: &lt;class &apos;KeyError&apos;&gt;,</span><br><span class="line"> &apos;exc_val&apos;: KeyError(&apos;hehe&apos;)&#125;</span><br></pre></td></tr></table></figure>
<p>看到了吧！<code>with</code>关键字的含义，就是这样简单。<br>​</p>
<h2 id="写在最后的话"><a href="#写在最后的话" class="headerlink" title="写在最后的话"></a>写在最后的话</h2><p>相信通过Medium Python系列的讲解，大家应该会对python语言本身有了新的理解吧！在最后，笔者也推荐一本书：《Python源码剖析》，是一本老书，基于python2.5的，但是在python已经到3.10的今天，读起来仍然令人大开眼界。这个系列的许多分析，都参考了这本书的分析方法以及结论。</p>
<p>​<br>知识是永远没有尽头的！做这个系列的过程中，笔者是一次又一次地在体验着这样的真理。今后的将来，希望大家一起勉励！<br>​</p>
]]></content>
      <categories>
        <category>Medium Python</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>python</tag>
        <tag>with</tag>
        <tag>字节码</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>【Medium Python】第四话：类属性和实例属性是怎样的关系？</title>
    <url>/2021/11/06/mediumpython/iv/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>提到编程不得不提到面向对象，一个说烂了的话题，几十年来一直都有人在争论面向对象的好坏。从宏观角度来说，一个庞大的程序本质是对业务中实体集合以及其中的关系的模拟，虽然解决实体的关系问题，用面向过程、组合等方式去体现比较方便，但要解决实体概念的抽象，就需要面向对象的编程基础。因此，面向对象在编程中是非常重要的一部分思想，不能随随便便被否定或者忽略。</p>
<p>​<br>面向对象的灵魂在于对类（class）概念的剖析，而python中也有对类的支持，虽然不像其它静态语言有比较强的约束，但如果想将代码组织成面向对象式的话也是完全满足的。在平常python的交流以及面试的过程中，也会涉及到许多关于类的问题，比如最常见的就是阐述类与实例的关系。要理解类与实例的关系，从类属性和实例属性切入是为最直观的。因此，今天这篇文章就来讲讲python里类属性和实例属性的二三事。<br>​</p>
<h2 id="在类和实例中访问属性"><a href="#在类和实例中访问属性" class="headerlink" title="在类和实例中访问属性"></a>在类和实例中访问属性</h2><p>首先上一段测试代码：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_seg</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">'\n'</span>.join([<span class="string">'='</span> * <span class="number">40</span>, str(msg), <span class="string">'='</span> * <span class="number">40</span> ]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeadmasterDescriptor</span>:</span></span><br><span class="line">    headmaster: str = <span class="string">'Dumbledore'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;HeadmasterDescriptor %s&gt;'</span> % self.headmaster</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, obj, value)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;HeadmasterDescriptor&gt; set new headmaster: %s'</span> % value)</span><br><span class="line">        self.headmaster = str(value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    headmaster = HeadmasterDescriptor()</span><br><span class="line">    students = set()</span><br><span class="line">    teacher = <span class="string">'Snape'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name: str, gender: str, age: int)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> gender <span class="keyword">in</span> [<span class="string">'male'</span>, <span class="string">'female'</span>]</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">        <span class="comment"># add to students</span></span><br><span class="line">        self.students.add(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;Student&gt; remove student %s'</span> % self.name)</span><br><span class="line">        self.students.remove(self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># ============================== test #1 start ==================================</span></span><br><span class="line">    student_1 = Student(name=<span class="string">'conan'</span>, gender=<span class="string">'male'</span>, age=<span class="number">18</span>)</span><br><span class="line">    student_2 = Student(name=<span class="string">'saki'</span>, gender=<span class="string">'female'</span>, age=<span class="number">15</span>)</span><br><span class="line">    print_seg(<span class="string">'test #1 start'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># students</span></span><br><span class="line">    print(<span class="string">'[student-1] students: %s'</span> % student_1.students)</span><br><span class="line">    print(<span class="string">'[student-2] students: %s'</span> % student_2.students)</span><br><span class="line">    print(<span class="string">'[Student] students: %s'</span> % Student.students)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># dir</span></span><br><span class="line">    print(<span class="string">'[student-1] dir: %s'</span> % dir(student_1))</span><br><span class="line">    print(<span class="string">'[Student] dir: %s'</span> % dir(student_1))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># instance attributes</span></span><br><span class="line">    print(<span class="string">'[student-1] name: %s'</span> % student_1.name)</span><br><span class="line">    print(<span class="string">'[student-2] gender: %s'</span> % student_2.gender)</span><br><span class="line">    print(<span class="string">'[student-2] age: %s'</span> % getattr(student_2, <span class="string">'age'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># headmaster</span></span><br><span class="line">    print(<span class="string">'[student-1] old headmaster: %s'</span> % getattr(student_1, <span class="string">'headmaster'</span>))</span><br><span class="line">    print(<span class="string">'[student-2] old headmaster: %s'</span> % student_2.headmaster)</span><br><span class="line">    print(<span class="string">'[Student] new headmaster: %s'</span> % Student.headmaster)</span><br><span class="line">    print(<span class="string">'%s, %s'</span> % (id(student_2.headmaster), id(Student.headmaster)))</span><br><span class="line">    student_1.headmaster = <span class="string">'Alan Tam'</span></span><br><span class="line">    print(<span class="string">'[student-1] new headmaster: %s'</span> % student_1.headmaster)</span><br><span class="line">    print(<span class="string">'[student-2] new headmaster: %s'</span> % student_2.headmaster)</span><br><span class="line">    print(<span class="string">'[Student] new headmaster: %s'</span> % getattr(Student, <span class="string">'headmaster'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># remove student</span></span><br><span class="line">    <span class="keyword">del</span> student_1</span><br><span class="line">    print(<span class="string">'[student-2] students: %s'</span> % student_2.students)</span><br><span class="line">    print(<span class="string">'[Student] students: %s'</span> % Student.students)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set teacher</span></span><br><span class="line">    print(<span class="string">'[student-2] teacher: %s'</span> % student_2.teacher)</span><br><span class="line">    print(<span class="string">'[Student] teacher: %s'</span> % Student.teacher)</span><br><span class="line">    student_2.teacher = <span class="string">'Jodie'</span></span><br><span class="line">    print(<span class="string">'[student-2] teacher: %s'</span> % student_2.teacher)</span><br><span class="line">    print(<span class="string">'[Student] teacher: %s'</span> % Student.teacher)</span><br><span class="line"></span><br><span class="line">    print_seg(<span class="string">'test#1 end'</span>)</span><br><span class="line">    <span class="comment"># ============================== test #1 end ==================================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>这一段代码构造了这样的场景：</p>
<ul>
<li>首先创建两个学生，创建的过程中将学生名加入到集合<code>students</code></li>
<li>用<code>dir</code>打印学生实例<code>student-1</code>及学生类<code>Student</code>的属性&amp;方法，再通过点或者<code>getattr</code>的方式访问实例属性</li>
<li>更换<code>headmaster</code></li>
<li>删除<code>student_1</code></li>
<li>更换<code>teacher</code></li>
</ul>
<p>我们看到打印的结果是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">========================================</span><br><span class="line">test #1 start</span><br><span class="line">========================================</span><br><span class="line">[student-1] students: &#123;&apos;saki&apos;, &apos;conan&apos;&#125;</span><br><span class="line">[student-2] students: &#123;&apos;saki&apos;, &apos;conan&apos;&#125;</span><br><span class="line">[Student] students: &#123;&apos;saki&apos;, &apos;conan&apos;&#125;</span><br><span class="line">[student-1] dir: [&apos;__class__&apos;, &apos;__del__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;age&apos;, &apos;gender&apos;, &apos;headmaster&apos;, &apos;name&apos;, &apos;students&apos;, &apos;teacher&apos;]</span><br><span class="line">[Student] dir: [&apos;__class__&apos;, &apos;__del__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;age&apos;, &apos;gender&apos;, &apos;headmaster&apos;, &apos;name&apos;, &apos;students&apos;, &apos;teacher&apos;]</span><br><span class="line">[student-1] name: conan</span><br><span class="line">[student-2] gender: female</span><br><span class="line">[student-2] age: 15</span><br><span class="line">[student-1] old headmaster: &lt;HeadmasterDescriptor Dumbledore&gt;</span><br><span class="line">[student-2] old headmaster: &lt;HeadmasterDescriptor Dumbledore&gt;</span><br><span class="line">[Student] new headmaster: &lt;HeadmasterDescriptor Dumbledore&gt;</span><br><span class="line">1999801558000, 1999801558000</span><br><span class="line">&lt;HeadmasterDescriptor&gt; set new headmaster: Alan Tam</span><br><span class="line">[student-1] new headmaster: &lt;HeadmasterDescriptor Alan Tam&gt;</span><br><span class="line">[student-2] new headmaster: &lt;HeadmasterDescriptor Alan Tam&gt;</span><br><span class="line">[Student] new headmaster: &lt;HeadmasterDescriptor Alan Tam&gt;</span><br><span class="line">&lt;Student&gt; remove student conan</span><br><span class="line">[student-2] students: &#123;&apos;saki&apos;&#125;</span><br><span class="line">[Student] students: &#123;&apos;saki&apos;&#125;</span><br><span class="line">[student-2] teacher: Snape</span><br><span class="line">[Student] teacher: Snape</span><br><span class="line">[student-2] teacher: Jodie</span><br><span class="line">[Student] teacher: Snape</span><br><span class="line">========================================</span><br><span class="line">test#1 end</span><br><span class="line">========================================</span><br><span class="line">&lt;Student&gt; remove student saki</span><br></pre></td></tr></table></figure>
<p>可以看到：</p>
<ul>
<li>创建两个学生的时候，<code>student</code>的名字被加入到了类属性<code>students</code>中。不论在类还是还是在实例去访问<code>students</code>，都能得到相同的结果。</li>
<li>通过<code>getattr</code>或者带点的方法，能够正常访问到类或者实例的属性。</li>
<li>更换<code>headmaster</code>。<ul>
<li><code>headmaster</code>是一个带<code>getter</code>跟<code>setter</code>的<code>descriptor</code></li>
<li>所谓<code>descriptor</code>，可以简单理解为一个支持根据不同访问方式做出特定行为的特殊属性。我们对<code>headmaster</code>执行<code>get</code>操作，获得的是<code>__get__</code>方法的返回结果，当对<code>headmaster</code>赋新值时，如果发现了带<code>__set__</code>的<code>descriptor</code>，就会触发这个逻辑，改变类属性<code>headmaster</code>这个<code>descriptor</code>里面维护的值。</li>
<li>否则，属性在类里没有被定义成为<code>descriptor</code>，且在实例里面有定义的话，修改操作只会改实例本身维护的属性值，就像下面的<code>teacher</code>一样。</li>
</ul>
</li>
<li>删除<code>student_1</code>，触发了类定义的<code>__del__</code>函数，将<code>student_1</code>的名字从<code>students</code>里面移除</li>
<li><code>student_2</code>更换<code>teacher</code>，只更换了自己的，类属性里面还是默认原来的。</li>
</ul>
<p>从表现上来看，类相对于实例更多是起到一个模板的作用，每一个实例类似于<code>fork</code>了一个类，然后在<code>__init__</code>中添加属于自己的属性。如果一个实例要访问某个属性，这个属性在<code>__init__</code>里面没有定义到的话，就会下一步从自己的类里寻找属性。如果还找不到，就得从父类里找了，就到了（多重）继承相关的话题。</p>
<p>所以，为什么会有这样的呈现呢？接下来我们深入源码，一探究竟。<br>获取类的属性，其字节码为<code>LOAD_ATTR</code>。经过一番深入，最终会落实到<code>_PyObject_GenericGetAttrWithDict</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// object.c</span></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">_PyObject_GenericGetAttrWithDict(PyObject *obj, PyObject *name,</span><br><span class="line">                                 PyObject *dict, <span class="keyword">int</span> suppress)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Make sure the logic of _PyObject_GetMethod is in sync with</span></span><br><span class="line"><span class="comment">       this method.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       When suppress=1, this function suppress AttributeError.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    PyTypeObject *tp = Py_TYPE(obj);</span><br><span class="line">    PyObject *descr = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *res = <span class="literal">NULL</span>;</span><br><span class="line">    descrgetfunc f;</span><br><span class="line">    Py_ssize_t dictoffset;</span><br><span class="line">    PyObject **dictptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!PyUnicode_Check(name))&#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">"attribute name must be string, not '%.200s'"</span>,</span><br><span class="line">                     Py_TYPE(name)-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tp-&gt;tp_dict == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PyType_Ready(tp) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    descr = _PyType_Lookup(tp, name);</span><br><span class="line"></span><br><span class="line">    f = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (descr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_INCREF(descr);</span><br><span class="line">        f = Py_TYPE(descr)-&gt;tp_descr_get;</span><br><span class="line">        <span class="keyword">if</span> (f != <span class="literal">NULL</span> &amp;&amp; PyDescr_IsData(descr)) &#123;</span><br><span class="line">            res = f(descr, obj, (PyObject *)Py_TYPE(obj));</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="literal">NULL</span> &amp;&amp; suppress &amp;&amp;</span><br><span class="line">                    PyErr_ExceptionMatches(PyExc_AttributeError)) &#123;</span><br><span class="line">                PyErr_Clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dict == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Inline _PyObject_GetDictPtr */</span></span><br><span class="line">        dictoffset = tp-&gt;tp_dictoffset;</span><br><span class="line">        <span class="keyword">if</span> (dictoffset != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dictoffset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Py_ssize_t tsize = Py_SIZE(obj);</span><br><span class="line">                <span class="keyword">if</span> (tsize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    tsize = -tsize;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">size_t</span> size = _PyObject_VAR_SIZE(tp, tsize);</span><br><span class="line">                _PyObject_ASSERT(obj, size &lt;= PY_SSIZE_T_MAX);</span><br><span class="line"></span><br><span class="line">                dictoffset += (Py_ssize_t)size;</span><br><span class="line">                _PyObject_ASSERT(obj, dictoffset &gt; <span class="number">0</span>);</span><br><span class="line">                _PyObject_ASSERT(obj, dictoffset % SIZEOF_VOID_P == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dictptr = (PyObject **) ((<span class="keyword">char</span> *)obj + dictoffset);</span><br><span class="line">            dict = *dictptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dict != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_INCREF(dict);</span><br><span class="line">        res = PyDict_GetItemWithError(dict, name);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_INCREF(res);</span><br><span class="line">            Py_DECREF(dict);</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Py_DECREF(dict);</span><br><span class="line">            <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (suppress &amp;&amp; PyErr_ExceptionMatches(PyExc_AttributeError)) &#123;</span><br><span class="line">                    PyErr_Clear();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">goto</span> done;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        res = f(descr, obj, (PyObject *)Py_TYPE(obj));</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="literal">NULL</span> &amp;&amp; suppress &amp;&amp;</span><br><span class="line">                PyErr_ExceptionMatches(PyExc_AttributeError)) &#123;</span><br><span class="line">            PyErr_Clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (descr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        res = descr;</span><br><span class="line">        descr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!suppress) &#123;</span><br><span class="line">        PyErr_Format(PyExc_AttributeError,</span><br><span class="line">                     <span class="string">"'%.50s' object has no attribute '%U'"</span>,</span><br><span class="line">                     tp-&gt;tp_name, name);</span><br><span class="line">    &#125;</span><br><span class="line">  done:</span><br><span class="line">    Py_XDECREF(descr);</span><br><span class="line">    Py_DECREF(name);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这段代码以及其中的部分函数调用定义，可以知悉，获取属性有以下的优先级：</p>
<ul>
<li>首先在类继承链搜索是否有对应名字的<code>descriptor</code>。如果有带<code>__get__</code>的<code>descriptor</code>，且包含<code>__set__</code>的话（<code>PyDescr_IsData</code>的判断），优先选择这个<code>descriptor</code></li>
<li>其次是在实例的<code>__dict__</code>中寻找属性<ul>
<li>有兴趣的同学可以在上面的测试代码中给实例和类加上<code>__dict__</code>，看一下输出结果</li>
</ul>
</li>
<li>然后如果这个<code>descriptor</code>是有带<code>__get__</code>的，就通过这个<code>descriptor</code>的<code>__get__</code>方法获取这个属性值</li>
<li>最后如果没有带<code>__get__</code>的，那可能这只是个普通实例，不算严格意义上的<code>descriptor</code>（比如<code>Student.teacher</code>），就返回对应的值即可</li>
</ul>
<p>类的继承链，可以通过类的<code>__mro__</code>属性获得到，是用C3线性化算法得到的。有兴趣的同学可以了解背后的原理以及代码实现。python的多重继承，就是基于这一套机制。<br>由先前代码的例子我们可以看到带<code>__get__</code>、<code>__set__</code>的<code>descriptor</code>确实从类、实例里都获得的是同一个<code>descriptor</code>。<br>​<br>同样，当设置属性时，最终会调用<code>_PyObject_GenericSetAttrWithDict</code>（<code>object.c</code>里，这里不放源码了，有兴趣自行查阅）。其中的优先级是：</p>
<ul>
<li>在继承链查找属性有带<code>__set__</code>的<code>descriptor</code>，直接调用<code>descriptor.__set__</code></li>
<li>如果没有，就在实例的<code>__dict__</code>里直接设置属性</li>
</ul>
<p>​</p>
<h2 id="在类方法中访问实例属性"><a href="#在类方法中访问实例属性" class="headerlink" title="在类方法中访问实例属性"></a>在类方法中访问实例属性</h2><p>在类定义里面我们通常会加各式各样的函数（方法），在方法的定义里面也会大量访问<code>self</code>的属性。但我们要知道，python是一个动态语言，函数定义里的<code>self</code>，并不一定只能是这个类的实例。不仅传进子类实例是可以的，而是只要满足函数里面属性的访问的类实例，都行。</p>
<p>如果有学过golang，或是了解过组合、ecs的概念的同学都会一下明白——如果一个东西，它皮肤是土黄色无花纹，体型大，跑得快，牙齿锋利，肉食，有金黄色的头发，那么它应当是个雄狮。就算世界上可能有其它动物也满足这些条件，但如果我们只关心这些特征属性，那就可以一视同仁。类方法也是这样，如果没有对实例类型的约束，只有对实例属性的约束，那么只要满足这些属性的实例，都可以成为类方法的参数。我们看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name: str, age: int)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name: str, gender: str, age: int)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> gender <span class="keyword">in</span> [<span class="string">'male'</span>, <span class="string">'female'</span>]</span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'class: %s, name: %s, age: %s'</span> % (</span><br><span class="line">            self.__class__.__name__,</span><br><span class="line">            self.name,</span><br><span class="line">            self.age</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Student(name=<span class="string">'haha'</span>, gender=<span class="string">'male'</span>, age=<span class="number">18</span>)</span><br><span class="line">    s.output()</span><br><span class="line">    Student.output(s)</span><br><span class="line">    Student.output(Lion(name=<span class="string">'simba'</span>, age=<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p>重点在于最后一句：<code>Student.output(Lion(name=&#39;simba&#39;, age=5))</code>——这句话是成立的，从打印的结果来看也没有报错。而同时，<code>s.output()</code>和<code>Student.output(s)</code>则呈现了相同的效果。</p>
<p>我们打印<code>s.output()</code>以及<code>Student.output(s)</code>的<code>opcode</code>结果（上面代码稍微改了点内容，比如实例<code>s</code>变成了<code>student</code>），可以发现其中的不同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">29          26 LOAD_FAST                0 (student)</span><br><span class="line">            28 LOAD_METHOD              2 (output)</span><br><span class="line">            30 CALL_METHOD              0</span><br><span class="line">            32 POP_TOP</span><br><span class="line"></span><br><span class="line">30          34 LOAD_GLOBAL              0 (Student)</span><br><span class="line">            36 LOAD_METHOD              2 (output)</span><br><span class="line">            38 LOAD_FAST                0 (student)</span><br><span class="line">            40 CALL_METHOD              1</span><br><span class="line">            42 POP_TOP</span><br></pre></td></tr></table></figure>
<p>调用<code>student.output</code>时，直接<code>LOAD_METHOD</code>后就<code>call</code>了；而调用<code>Student.output</code>时，还要<code>load</code>一个参数<code>student</code>（当然，也可以是其它实例）再<code>call</code>。<code>opcode</code>的呈现和源代码是一致的。</p>
<p>我们首先看<code>LOAD_METHOD</code>对应的内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">case TARGET(LOAD_METHOD): &#123;</span><br><span class="line">    <span class="comment">/* Designed to work in tandem with CALL_METHOD. */</span></span><br><span class="line">    PyObject *name = GETITEM(names, oparg);</span><br><span class="line">    PyObject *obj = TOP();</span><br><span class="line">    PyObject *meth = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> meth_found = _PyObject_GetMethod(obj, name, &amp;meth);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (meth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Most likely attribute wasn't found. */</span></span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (meth_found) &#123;</span><br><span class="line">        <span class="comment">/* We can bypass temporary bound method object.</span></span><br><span class="line"><span class="comment">                   meth is unbound method and obj is self.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                   meth | self | arg1 | ... | argN</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">        SET_TOP(meth);</span><br><span class="line">        PUSH(obj);  <span class="comment">// self</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* meth is not an unbound method (but a regular attr, or</span></span><br><span class="line"><span class="comment">                   something was returned by a descriptor protocol).  Set</span></span><br><span class="line"><span class="comment">                   the second element of the stack to NULL, to signal</span></span><br><span class="line"><span class="comment">                   CALL_METHOD that it's not a method call.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                   NULL | meth | arg1 | ... | argN</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">        SET_TOP(<span class="literal">NULL</span>);</span><br><span class="line">        Py_DECREF(obj);</span><br><span class="line">        PUSH(meth);</span><br><span class="line">    &#125;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LOAD_METHOD</code>会落实到<code>_PyObject_GetMethod</code>方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method)</span><br><span class="line">&#123;</span><br><span class="line">    PyTypeObject *tp = Py_TYPE(obj);</span><br><span class="line">    PyObject *descr;</span><br><span class="line">    descrgetfunc f = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject **dictptr, *dict;</span><br><span class="line">    PyObject *attr;</span><br><span class="line">    <span class="keyword">int</span> meth_found = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    assert(*method == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Py_TYPE(obj)-&gt;tp_getattro != PyObject_GenericGetAttr</span><br><span class="line">            || !PyUnicode_Check(name)) &#123;</span><br><span class="line">        *method = PyObject_GetAttr(obj, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tp-&gt;tp_dict == <span class="literal">NULL</span> &amp;&amp; PyType_Ready(tp) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    descr = _PyType_Lookup(tp, name);</span><br><span class="line">    <span class="keyword">if</span> (descr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_INCREF(descr);</span><br><span class="line">        <span class="keyword">if</span> (_PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_METHOD_DESCRIPTOR)) &#123;</span><br><span class="line">            meth_found = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f = Py_TYPE(descr)-&gt;tp_descr_get;</span><br><span class="line">            <span class="keyword">if</span> (f != <span class="literal">NULL</span> &amp;&amp; PyDescr_IsData(descr)) &#123;</span><br><span class="line">                *method = f(descr, obj, (PyObject *)Py_TYPE(obj));</span><br><span class="line">                Py_DECREF(descr);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dictptr = _PyObject_GetDictPtr(obj);</span><br><span class="line">    <span class="keyword">if</span> (dictptr != <span class="literal">NULL</span> &amp;&amp; (dict = *dictptr) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_INCREF(dict);</span><br><span class="line">        attr = PyDict_GetItemWithError(dict, name);</span><br><span class="line">        <span class="keyword">if</span> (attr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_INCREF(attr);</span><br><span class="line">            *method = attr;</span><br><span class="line">            Py_DECREF(dict);</span><br><span class="line">            Py_XDECREF(descr);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Py_DECREF(dict);</span><br><span class="line">            <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">                Py_XDECREF(descr);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (meth_found) &#123;</span><br><span class="line">        *method = descr;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *method = f(descr, obj, (PyObject *)Py_TYPE(obj));</span><br><span class="line">        Py_DECREF(descr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (descr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *method = descr;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PyErr_Format(PyExc_AttributeError,</span><br><span class="line">                 <span class="string">"'%.50s' object has no attribute '%U'"</span>,</span><br><span class="line">                 tp-&gt;tp_name, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_PyObject_GetMethod</code>包含了多处判断。对于<code>student.output</code>和<code>Student.output</code>，走到了不同的分支：</p>
<ul>
<li>当调用<code>student.output</code>时，通过<code>_PyType_Lookup(tp, name)</code>找到了<code>output</code>函数（<code>PyFunction_Type</code>）的<code>descriptor</code>，调用<code>tp_descr_get</code>对应的方法<ul>
<li>最终回到<code>LOAD_METHOD</code>，走到<code>if (meth_found)</code>对应的分支</li>
<li>栈顶是<code>student</code>实例，然后是<code>output</code>方法</li>
</ul>
</li>
<li>当调用<code>Student.output</code>时，由于<code>Student</code>是一个<code>type</code>，<code>Py_TYPE(obj)-&gt;tp_getattro</code>是<code>PyType_Type</code>里面的<code>type_getattro</code>而不是<code>PyObject_GenericGetAttr</code>，且<code>name</code>合法，所以直接用<code>PyObject_GetAttr(obj, name)</code>找到了对应的<code>output</code>方法<ul>
<li>最终回到<code>LOAD_METHOD</code>，走到<code>if (meth_found)</code>的<code>else</code>对应的分支</li>
<li>栈顶是<code>output</code>方法，然后是<code>NULL</code></li>
</ul>
</li>
</ul>
<p><code>LOAD_METHOD</code>之后就是<code>CALL_METHOD</code>，这个时候我们要记得<code>Student.output</code>是有传参的，因此还会额外<code>push</code>一个<code>student</code>到栈上。之后，我们再来看<code>CALL_METHOD</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">case TARGET(CALL_METHOD): &#123;</span><br><span class="line">    <span class="comment">/* Designed to work in tamdem with LOAD_METHOD. */</span></span><br><span class="line">    PyObject **sp, *res, *meth;</span><br><span class="line"></span><br><span class="line">    sp = stack_pointer;</span><br><span class="line"></span><br><span class="line">    meth = PEEK(oparg + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (meth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* `meth` is NULL when LOAD_METHOD thinks that it's not</span></span><br><span class="line"><span class="comment">                   a method call.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                   Stack layout:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                       ... | NULL | callable | arg1 | ... | argN</span></span><br><span class="line"><span class="comment">                                                            ^- TOP()</span></span><br><span class="line"><span class="comment">                                               ^- (-oparg)</span></span><br><span class="line"><span class="comment">                                    ^- (-oparg-1)</span></span><br><span class="line"><span class="comment">                             ^- (-oparg-2)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                   `callable` will be POPed by call_function.</span></span><br><span class="line"><span class="comment">                   NULL will will be POPed manually later.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">        res = call_function(tstate, &amp;sp, oparg, <span class="literal">NULL</span>);</span><br><span class="line">        stack_pointer = sp;</span><br><span class="line">        (<span class="keyword">void</span>)POP(); <span class="comment">/* POP the NULL. */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* This is a method call.  Stack layout:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                     ... | method | self | arg1 | ... | argN</span></span><br><span class="line"><span class="comment">                                                        ^- TOP()</span></span><br><span class="line"><span class="comment">                                           ^- (-oparg)</span></span><br><span class="line"><span class="comment">                                    ^- (-oparg-1)</span></span><br><span class="line"><span class="comment">                           ^- (-oparg-2)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                  `self` and `method` will be POPed by call_function.</span></span><br><span class="line"><span class="comment">                  We'll be passing `oparg + 1` to call_function, to</span></span><br><span class="line"><span class="comment">                  make it accept the `self` as a first argument.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">        res = call_function(tstate, &amp;sp, oparg + <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">        stack_pointer = sp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PUSH(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>CALL_METHOD</code>中会对栈做检查。如果不出意外，栈上自顶向下应该是这样的结构（看下<code>LOAD_METHOD</code>跟<code>CALL_METHOD</code>的注释就能明白）：</p>
<ul>
<li><code>student.output</code>：参数N~参数1（假使有的话），<code>student</code>实例，<code>output</code>方法</li>
<li><code>Student.output</code>：参数N+1~参数2（假使有的话），<code>student</code>实例（参数1），<code>output</code>方法，<code>NULL</code></li>
</ul>
<p>最终都会调用<code>call_function</code>，而两者最终的效果都是<code>Student.output(student, *args, **kwargs)</code>了。<br>因此我们可以看到，假使在<code>Student.output</code>传参另外一个类的实例，如果调用到相关属性的话，最终还是会在另外一个类的实例里面调用<code>PyObject_GenericGetAttrWithDict</code>。这个方法是通用的，并约束为单一的类，所以这才能解释<code>Student.output(Lion(name=&#39;simba&#39;, age=5))</code>为什么成立（当然，现实编程不建议这样写哦！有其它更好的workaround提升代码可读性）。</p>
<h2 id="descriptor属性的应用：property"><a href="#descriptor属性的应用：property" class="headerlink" title="descriptor属性的应用：property"></a>descriptor属性的应用：property</h2><p>在上两个小节当中，我们多次提到了<code>descriptor</code>这个概念。在平时的python编程中，我们基本上很难接触到<code>descriptor</code>，但在python的内部实现中，<code>descriptor</code>是非常核心的一部分，可以说是一种为了适配python的类属性访问接口而生的数据结构。因此，每个修习python的同学，都有必要了解这个概念。</p>
<p>就说一些常见的内置类属性定义，像是<code>property</code>、<code>classmethod</code>、<code>staticmethod</code>，虽然它们以装饰器的形式呈现在我们的程序里，但它们的实质，都是<code>descriptor</code>。这也是<code>descriptor</code>的魔力所在。</p>
<p>本文以<code>property</code>为例解析下<code>descriptor</code>的应用。首先来看测试代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, first_name=<span class="string">''</span>, last_name=<span class="string">''</span>)</span>:</span></span><br><span class="line">        self.__first_name = first_name</span><br><span class="line">        self.__last_name = last_name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__first_name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @first_name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first_name</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        print(<span class="string">'[%s] change first name to %s'</span> % (id(self), value))</span><br><span class="line">        self.__first_name = str(value)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">last_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__last_name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @last_name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">last_name</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        print(<span class="string">'[%s] change last name to %s'</span> % (id(self), value))</span><br><span class="line">        self.__last_name = str(value)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">full_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'%s %s'</span> % (self.first_name, self.last_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    h = Human(first_name=<span class="string">'James'</span>, last_name=<span class="string">'Bond'</span>)</span><br><span class="line">    h1 = Human(first_name=<span class="string">'Anatoli'</span>, last_name=<span class="string">'Todorov'</span>)</span><br><span class="line">    print(<span class="string">'first name: %s'</span> % h.first_name)</span><br><span class="line">    print(<span class="string">'last name: %s'</span> % h.last_name)</span><br><span class="line">    print(<span class="string">'full name: %s'</span> % h.full_name)</span><br><span class="line">    h.first_name = <span class="string">'Jiss'</span></span><br><span class="line">    h1.last_name = <span class="string">'Toledo'</span></span><br><span class="line">    print(<span class="string">'[h] first name: %s'</span> % h.first_name)</span><br><span class="line">    print(<span class="string">'[h] full name: %s'</span> % h.full_name)</span><br><span class="line">    print(<span class="string">'[h1] last name: %s'</span> % h1.last_name)</span><br><span class="line">    print(<span class="string">'[h1] full name: %s'</span> % h1.full_name)</span><br><span class="line">    print(<span class="string">'[Human] first name: %s'</span> % Human.first_name)</span><br><span class="line">    print(<span class="string">'[Human] last name: %s'</span> % Human.last_name)</span><br><span class="line">    print(<span class="string">'[Human] full name: %s'</span> % Human.full_name)</span><br><span class="line">    print(<span class="string">'[h] dict: %s'</span> % h.__dict__)</span><br><span class="line">    print(<span class="string">'[h1] dict: %s'</span> % h1.__dict__)</span><br><span class="line">    print(<span class="string">'[Human] dict: %s'</span> % pprint.pformat(Human.__dict__))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>打印出来的结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">first name: James</span><br><span class="line">last name: Bond</span><br><span class="line">full name: James Bond</span><br><span class="line">[1661162208128] change first name to Jiss</span><br><span class="line">[1661162208032] change last name to Toledo</span><br><span class="line">[h] first name: Jiss</span><br><span class="line">[h] full name: Jiss Bond</span><br><span class="line">[h1] last name: Toledo</span><br><span class="line">[h1] full name: Anatoli Toledo</span><br><span class="line">[Human] first name: &lt;property object at 0x00000182C4FB7B80&gt;</span><br><span class="line">[Human] last name: &lt;property object at 0x00000182C4FB7BD0&gt;</span><br><span class="line">[Human] full name: &lt;property object at 0x00000182C4F9E220&gt;</span><br><span class="line">[h] dict: &#123;&apos;_Human__first_name&apos;: &apos;Jiss&apos;, &apos;_Human__last_name&apos;: &apos;Bond&apos;&#125;</span><br><span class="line">[h1] dict: &#123;&apos;_Human__first_name&apos;: &apos;Anatoli&apos;, &apos;_Human__last_name&apos;: &apos;Toledo&apos;&#125;</span><br><span class="line">[Human] dict: mappingproxy(&#123;&apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;Human&apos; objects&gt;,</span><br><span class="line">              &apos;__doc__&apos;: None,</span><br><span class="line">              &apos;__init__&apos;: &lt;function Human.__init__ at 0x00000182C4FB3B80&gt;,</span><br><span class="line">              &apos;__module__&apos;: &apos;__main__&apos;,</span><br><span class="line">              &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;Human&apos; objects&gt;,</span><br><span class="line">              &apos;first_name&apos;: &lt;property object at 0x00000182C4FB7B80&gt;,</span><br><span class="line">              &apos;full_name&apos;: &lt;property object at 0x00000182C4F9E220&gt;,</span><br><span class="line">              &apos;last_name&apos;: &lt;property object at 0x00000182C4FB7BD0&gt;&#125;)</span><br></pre></td></tr></table></figure>
<p><code>property</code>常用于一些私有变量定义的规范化，这里我们从实例的<code>__dict__</code>也可以额外看到带两个下划线前缀的私有变量在代码编译时就已经被偷偷地改名了（有兴趣的同学可以了解下<code>_Py_Mangle</code>）。在类里面，所有<code>property</code>相关的属性都是<code>property object</code>；而在实例里面，所有<code>property</code>相关的属性相互独立，并且是特定的值。</p>
<p><code>property</code>是如何实现这个效果的？我们需要进入源码一探究竟。</p>
<p>首先我们看<code>property</code>对应的类型定义<code>PyProperty_Type</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyTypeObject PyProperty_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">"property"</span>,                                 <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(propertyobject),                     <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    <span class="comment">/* methods */</span></span><br><span class="line">    property_dealloc,                           <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_vectorcall_offset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_async */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_repr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |</span><br><span class="line">        Py_TPFLAGS_BASETYPE,                    <span class="comment">/* tp_flags */</span></span><br><span class="line">    property_init__doc__,                       <span class="comment">/* tp_doc */</span></span><br><span class="line">    property_traverse,                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    (inquiry)property_clear,                    <span class="comment">/* tp_clear */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    property_methods,                           <span class="comment">/* tp_methods */</span></span><br><span class="line">    property_members,                           <span class="comment">/* tp_members */</span></span><br><span class="line">    property_getsetlist,                        <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    property_descr_get,                         <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    property_descr_set,                         <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    property_init,                              <span class="comment">/* tp_init */</span></span><br><span class="line">    PyType_GenericAlloc,                        <span class="comment">/* tp_alloc */</span></span><br><span class="line">    PyType_GenericNew,                          <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_GC_Del,                            <span class="comment">/* tp_free */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从定义中我们可以看到，<code>PyProperty_Type</code>的<code>tp_descr_get</code>和<code>tp_descr_set</code>都有对应的回调函数，因此任何一个<code>property</code>的实例都可以当作是一个<code>descriptor</code></p>
<p>我们创建一个<code>property</code>实例的时候，是采用装饰器的写法，解析出来就是类似于<code>property(function)</code>的形式。因此，我们需要再看一下<code>property</code>实例创建的过程。</p>
<p><code>property</code>本身是一个<code>type object</code>，创建实例的时候，是按照<code>property(function)</code>的写法来解析，这就相当于把<code>property</code>当成一个函数来看待。我们可以首先看下<code>type object</code>的类<code>PyType_Type</code>的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyTypeObject PyType_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">"type"</span>,                                     <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyHeapTypeObject),                   <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyMemberDef),                        <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    (destructor)type_dealloc,                   <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    offsetof(PyTypeObject, tp_vectorcall),      <span class="comment">/* tp_vectorcall_offset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_async */</span></span><br><span class="line">    (reprfunc)type_repr,                        <span class="comment">/* tp_repr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_hash */</span></span><br><span class="line">    (ternaryfunc)type_call,                     <span class="comment">/* tp_call */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_str */</span></span><br><span class="line">    (getattrofunc)type_getattro,                <span class="comment">/* tp_getattro */</span></span><br><span class="line">    (setattrofunc)type_setattro,                <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |</span><br><span class="line">    Py_TPFLAGS_BASETYPE | Py_TPFLAGS_TYPE_SUBCLASS |</span><br><span class="line">    Py_TPFLAGS_HAVE_VECTORCALL,                 <span class="comment">/* tp_flags */</span></span><br><span class="line">    type_doc,                                   <span class="comment">/* tp_doc */</span></span><br><span class="line">    (traverseproc)type_traverse,                <span class="comment">/* tp_traverse */</span></span><br><span class="line">    (inquiry)type_clear,                        <span class="comment">/* tp_clear */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    offsetof(PyTypeObject, tp_weaklist),        <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    type_methods,                               <span class="comment">/* tp_methods */</span></span><br><span class="line">    type_members,                               <span class="comment">/* tp_members */</span></span><br><span class="line">    type_getsets,                               <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    offsetof(PyTypeObject, tp_dict),            <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    type_init,                                  <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    type_new,                                   <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_GC_Del,                            <span class="comment">/* tp_free */</span></span><br><span class="line">    (inquiry)type_is_gc,                        <span class="comment">/* tp_is_gc */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>易知，如果把<code>type object</code>当作函数（严格意义上讲，叫做可调用的，<code>callable</code>）看待，会触发<code>tp_call</code>对应的<code>type_call</code>函数。<code>type_call</code>函数这里就不列出来了，因为只有两步是最为关键的：</p>
<ul>
<li><code>obj = type-&gt;tp_new(type, args, kwds)</code></li>
<li><code>res = type-&gt;tp_init(obj, args, kwds)</code></li>
</ul>
<p>也就是说，要创建<code>property</code>实例，需要找到<code>property</code>的<code>tp_new</code>对应的函数先弄一个空的实例，然后再找<code>tp_init</code>对应的函数初始化实例。由<code>PyProperty_Type</code>的定义可知，<code>property</code>的<code>tp_new</code>对应的是<code>PyType_GenericNew</code>，简单分配了内存空间；而<code>tp_init</code>则对应<code>property_init</code>，<code>property_init</code>实质的实现是<code>property_init_impl</code>，因此我们直接看<code>property_init_impl</code>的定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">property_init_impl(propertyobject *self, PyObject *fget, PyObject *fset,</span><br><span class="line">                   PyObject *fdel, PyObject *doc)</span><br><span class="line"><span class="comment">/*[clinic end generated code: output=01a960742b692b57 input=dfb5dbbffc6932d5]*/</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fget == Py_None)</span><br><span class="line">        fget = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (fset == Py_None)</span><br><span class="line">        fset = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (fdel == Py_None)</span><br><span class="line">        fdel = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    Py_XINCREF(fget);</span><br><span class="line">    Py_XINCREF(fset);</span><br><span class="line">    Py_XINCREF(fdel);</span><br><span class="line">    Py_XINCREF(doc);</span><br><span class="line"></span><br><span class="line">    Py_XSETREF(self-&gt;prop_get, fget);</span><br><span class="line">    Py_XSETREF(self-&gt;prop_set, fset);</span><br><span class="line">    Py_XSETREF(self-&gt;prop_del, fdel);</span><br><span class="line">    Py_XSETREF(self-&gt;prop_doc, doc);</span><br><span class="line">    self-&gt;getter_doc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if no docstring given and the getter has one, use that one */</span></span><br><span class="line">    <span class="keyword">if</span> ((doc == <span class="literal">NULL</span> || doc == Py_None) &amp;&amp; fget != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _Py_IDENTIFIER(__doc__);</span><br><span class="line">        PyObject *get_doc;</span><br><span class="line">        <span class="keyword">int</span> rc = _PyObject_LookupAttrId(fget, &amp;PyId___doc__, &amp;get_doc);</span><br><span class="line">        <span class="keyword">if</span> (rc &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Py_IS_TYPE(self, &amp;PyProperty_Type)) &#123;</span><br><span class="line">            Py_XSETREF(self-&gt;prop_doc, get_doc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* If this is a property subclass, put __doc__</span></span><br><span class="line"><span class="comment">               in dict of the subclass instance instead,</span></span><br><span class="line"><span class="comment">               otherwise it gets shadowed by __doc__ in the</span></span><br><span class="line"><span class="comment">               class's dict. */</span></span><br><span class="line">            <span class="keyword">int</span> err = _PyObject_SetAttrId((PyObject *)self, &amp;PyId___doc__, get_doc);</span><br><span class="line">            Py_DECREF(get_doc);</span><br><span class="line">            <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        self-&gt;getter_doc = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>property</code>实例初始化，传入的参数是<code>fget</code>、<code>fset</code>、<code>fdel</code>、<code>doc</code>，从<code>property_init_impl</code>中我们易知，四个参数最终会放到<code>prop_get</code>、<code>prop_set</code>、<code>prop_del</code>、<code>prop_doc</code>中。一般我们用<code>property</code>装饰器包裹的函数，就对应了<code>fget</code>。<br>​<br>在先前的“访问属性”中，我们了解到如果一个类实例访问属性，第一优先级是判断继承链上是不是有名字对应了一个<code>data-descriptor</code>（同时包含<code>__get__</code>与<code>__set__</code>）。从上面的例子我们最终会发现在类里面定义了<code>first_name</code>之类的<code>property object</code>，而<code>property object</code>的类型<code>PyProperty_Type</code>就是同时拥有<code>tp_descr_get</code>跟<code>tp_descr_set</code>，可以当作一个<code>data-descriptor</code>，因此在<code>_PyObject_GenericGetAttrWithDict</code>中，会直接走到<code>f(descr, obj, (PyObject *)Py_TYPE(obj))</code>这一个逻辑来返回结果。转换一下函数里面涉及的变量名，就变成了<code>tp_descr_get(property实例, 类实例, 类)</code></p>
<p><code>property</code>的<code>tp_descr_get</code>对应的是<code>property_descr_get</code>，我们看下其中的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">property_descr_get(PyObject *self, PyObject *obj, PyObject *type)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span> || obj == Py_None) &#123;</span><br><span class="line">        Py_INCREF(self);</span><br><span class="line">        <span class="keyword">return</span> self;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    propertyobject *gs = (propertyobject *)self;</span><br><span class="line">    <span class="keyword">if</span> (gs-&gt;prop_get == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_AttributeError, <span class="string">"unreadable attribute"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> PyObject_CallOneArg(gs-&gt;prop_get, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，<code>getter</code>的逻辑最终会调用<code>property object</code>的<code>prop_get</code>，传参<code>obj</code>。显然，这个<code>prop_get</code>就是我们用<code>property</code>包裹的<code>fget</code>函数，而<code>obj</code>就是类实例，我们的<code>fget</code>函数第一个参数就是<code>self</code>。那么显然，我们就直接通过<code>fget</code>获取了类实例对应的属性。<br>​<br>至此我们也可以发现，在上面的python测试代码中，<code>h.first_name</code>和<code>Human.first_name.fget(h)</code>，两者就是相同的表达。再引申一下，假使有个类的实例叫做<code>fakehuman</code>，它包含一个属性叫做<code>_Human__first_name</code>（记得上面说的，双下划线的变量会被改名），那么<code>Human.first_name.fget(fakehuman)</code>这个表达式也是通过的！</p>
<p><code>property</code>的<code>setter</code>也是一样的套路，最终会落实到<code>property_descr_set</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">property_descr_set(PyObject *self, PyObject *obj, PyObject *value)</span><br><span class="line">&#123;</span><br><span class="line">    propertyobject *gs = (propertyobject *)self;</span><br><span class="line">    PyObject *func, *res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">NULL</span>)</span><br><span class="line">        func = gs-&gt;prop_del;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        func = gs-&gt;prop_set;</span><br><span class="line">    <span class="keyword">if</span> (func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_AttributeError,</span><br><span class="line">                        value == <span class="literal">NULL</span> ?</span><br><span class="line">                        <span class="string">"can't delete attribute"</span> :</span><br><span class="line">                <span class="string">"can't set attribute"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">NULL</span>)</span><br><span class="line">        res = PyObject_CallOneArg(func, obj);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        res = PyObject_CallFunctionObjArgs(func, obj, value, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    Py_DECREF(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>property_descr_set</code>里可以看出，当<code>value</code>为<code>NULL</code>（不是传进python的<code>None</code>哈），就会调用<code>prop_del</code>对应的<code>deleter</code>（删除属性用<code>del</code>，对应<code>opcode</code>为<code>DELETE_ATTR</code>，实质就是设置<code>attr</code>为<code>NULL</code>）；当<code>value</code>为非<code>null</code>的时候，就会调用<code>prop_set</code>对应的<code>setter</code>。这样，一个属性<code>setter</code>跟<code>deleter</code>的的需求也就轻而易举地被满足了。<br>​</p>
<p>从<code>property</code>的实现可以看到，<code>descriptor</code>相当于在属性本身和用户访问之间起到了一层桥梁的作用，是非常灵活巧妙的构思。而<code>classmethod</code>、<code>staticmethod</code>，本质上也是<code>non-data-descriptor</code>（不带<code>setter</code>），有兴趣的同学也可以深入研究。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过类/实例属性之间的联系，对python的类和实例之间的关系做了剖析，并引申了python内部实现中重要的一个概念——<code>descriptor</code>。在三个月前，笔者甚至根本不知道<code>descriptor</code>是什么东西，而经过了这一段时间的学习，也对python类/实例属性实现机制有了全新的理解。希望大家阅读此文，也能有所收获。</p>
]]></content>
      <categories>
        <category>Medium Python</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>python</tag>
        <tag>descriptor</tag>
        <tag>类</tag>
        <tag>property</tag>
      </tags>
  </entry>
  <entry>
    <title>【Medium Python】第三话：python多线程为什么不能并行？</title>
    <url>/2021/10/30/mediumpython/iii/</url>
    <content><![CDATA[<p>python的多线程，这是个老生常谈的话题了，网上资料也一大把。python默认的<code>threading</code>模块对多线程提供了支持，但实际多个<code>threading.Thread</code>实例无法并行运行（不是无法并发哦！）。<br>​<br>一句话概括答案：<strong>python的线程实质是操作系统原生的线程，而每个线程要执行python代码的话，需要获得对应代码解释器的锁GIL。一般我们运行python程序都只有一个解释器，这样不同线程需要获得同一个锁才能执行各自的代码，互斥了，于是代码就不能同时运行了。</strong><br>​<br>好的，接下来我们细细讲解这句话背后的故事：</p>
<h2 id="多线程并行测试"><a href="#多线程并行测试" class="headerlink" title="多线程并行测试"></a>多线程并行测试</h2><p>首先我们通过一些代码来测试多线程是否真的并行：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COUNT = int(<span class="number">1e8</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_count_task</span><span class="params">(start, end)</span>:</span></span><br><span class="line">    start_time = datetime.datetime.now()</span><br><span class="line">    <span class="keyword">while</span> start &lt; end:</span><br><span class="line">        start += <span class="number">1</span></span><br><span class="line">    duration = datetime.datetime.now() - start_time</span><br><span class="line">    cur_thread_name = threading.current_thread().name</span><br><span class="line">    print(<span class="string">'[THREAD] [%s] %.4f seconds'</span> % (cur_thread_name, duration.total_seconds()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increment_singlethread</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'[SINGLE_THREAD] start by count pair: (%d, %d)'</span> % (<span class="number">0</span>, COUNT))</span><br><span class="line">    start_time = datetime.datetime.now()</span><br><span class="line">    _count_task(<span class="number">0</span>, COUNT)</span><br><span class="line">    duration = datetime.datetime.now() - start_time</span><br><span class="line">    print(<span class="string">'[SINGLE_THREAD] %.4f seconds'</span> % duration.total_seconds())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NUM_THREADS = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_counts</span><span class="params">()</span>:</span></span><br><span class="line">    segs = [<span class="number">0</span>]</span><br><span class="line">    div, mod = int(COUNT / NUM_THREADS), int(COUNT % NUM_THREADS)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(NUM_THREADS):</span><br><span class="line">        segs.append(div)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(mod):</span><br><span class="line">        segs[i + <span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(segs)):</span><br><span class="line">        segs[i] += segs[i - <span class="number">1</span>]</span><br><span class="line">    cnts = []</span><br><span class="line">    segs[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(NUM_THREADS):</span><br><span class="line">        cnts.append((segs[i] + <span class="number">1</span>, segs[i + <span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">return</span> cnts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increment_multithread</span><span class="params">()</span>:</span></span><br><span class="line">    cnts = _get_counts()</span><br><span class="line">    print(<span class="string">'[MULTI_THREAD] start by counts: %s'</span> % cnts)</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(NUM_THREADS):</span><br><span class="line">        threads.append(threading.Thread(</span><br><span class="line">            target=_count_task,</span><br><span class="line">            args=cnts[i],</span><br><span class="line">            name=<span class="string">'Task-%d'</span> % i</span><br><span class="line">        ))</span><br><span class="line">    start_time = datetime.datetime.now()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(NUM_THREADS):</span><br><span class="line">        threads[i].start()</span><br><span class="line">    time.sleep(<span class="number">0</span>)  <span class="comment"># yield exexcution to task threads</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(NUM_THREADS):</span><br><span class="line">        threads[i].join()</span><br><span class="line">    duration = datetime.datetime.now() - start_time</span><br><span class="line">    print(<span class="string">'[MULTI_THREAD] %.4f seconds'</span> % duration.total_seconds())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    increment_singlethread()</span><br><span class="line">    increment_multithread()</span><br></pre></td></tr></table></figure>
<p>这是个测试代码，总共执行COUNT次+=1的操作，一个是单线程，一个是多线程。出来的结果，两种方式没有明显的时间上的差异：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[SINGLE_THREAD] start by count pair: (0, 100000000)</span><br><span class="line">[THREAD] [MainThread] 7.1221 seconds</span><br><span class="line">[SINGLE_THREAD] 7.1221 seconds</span><br><span class="line">[MULTI_THREAD] start by counts: [(0, 20000000), (20000001, 40000000), (40000001, 60000000), (60000001, 80000000), (80000001, 100000000)]</span><br><span class="line">[THREAD] [Task-3] 5.8285 seconds</span><br><span class="line">[THREAD] [Task-0] 6.0101 seconds</span><br><span class="line">[THREAD] [Task-4] 6.6114 seconds</span><br><span class="line">[THREAD] [Task-1] 6.9136 seconds</span><br><span class="line">[THREAD] [Task-2] 6.9735 seconds</span><br><span class="line">[MULTI_THREAD] 7.0034 seconds</span><br></pre></td></tr></table></figure>
<p>这也侧面证明了基于<code>threading.Thread</code>的多线程并非完全并行运行的。为了深入确认这个问题，我们需要看下python内部的线程运行的机制</p>
<h2 id="线程是如何启动的"><a href="#线程是如何启动的" class="headerlink" title="线程是如何启动的"></a>线程是如何启动的</h2><p>我们首先看下线程启动的过程，直接从<code>Thread</code>类的<code>start</code>方法开始：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span>:</span></span><br><span class="line">    <span class="string">"""A class that represents a thread of control.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This class can be safely subclassed in a limited fashion. There are two ways</span></span><br><span class="line"><span class="string">    to specify the activity: by passing a callable object to the constructor, or</span></span><br><span class="line"><span class="string">    by overriding the run() method in a subclass.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Start the thread's activity.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        It must be called at most once per thread object. It arranges for the</span></span><br><span class="line"><span class="string">        object's run() method to be invoked in a separate thread of control.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This method will raise a RuntimeError if called more than once on the</span></span><br><span class="line"><span class="string">        same thread object.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._initialized:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">"thread.__init__() not called"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self._started.is_set():</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">"threads can only be started once"</span>)</span><br><span class="line">        <span class="keyword">with</span> _active_limbo_lock:</span><br><span class="line">            _limbo[self] = self</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            _start_new_thread(self._bootstrap, ())</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">with</span> _active_limbo_lock:</span><br><span class="line">                <span class="keyword">del</span> _limbo[self]</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        self._started.wait()</span><br></pre></td></tr></table></figure>
<p><code>start</code>方法中，从行为上来看是这么一个逻辑：</p>
<ul>
<li>首先会检查<code>Thread</code>实例是否已经初始化，是否没有启动过</li>
<li>然后会把自己加入到<code>_limbo</code>中</li>
<li>调用启动线程的方法<code>_start_new_thread</code>，把自己的<code>_bootstrap</code>方法也带进去<ul>
<li><code>_bootstrap</code>是python端最终开始线程任务所调用的逻辑，是在新线程里运行的！后面会慢慢看到</li>
</ul>
</li>
<li>等待<code>self._started</code>（一个Event实例）的信号</li>
</ul>
<p>首先来看<code>_limbo</code>的作用。玩游戏玩多的同学都知道，<code>limbo</code>叫做“地狱边境”，如果再查下字典的话，我们可以将之简单理解为“准备态”。先记录线程为“准备态”，然后才会开始真正执行线程启动的过程。线程启动的过程是在C层进行的，我们点进<code>_start_new_thread</code>的定义就能看到python层是没有对应的代码的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _threadmodule.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">thread_PyThread_start_new_thread(PyObject *self, PyObject *fargs)</span><br><span class="line">&#123;</span><br><span class="line">    _PyRuntimeState *runtime = &amp;_PyRuntime;</span><br><span class="line">    PyObject *func, *args, *keyw = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bootstate</span> *<span class="title">boot</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ident;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 解包function跟args并检查合法性</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_UnpackTuple(fargs, <span class="string">"start_new_thread"</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">                           &amp;func, &amp;args, &amp;keyw))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!PyCallable_Check(func)) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                        <span class="string">"first arg must be callable"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!PyTuple_Check(args)) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                        <span class="string">"2nd arg must be a tuple"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (keyw != <span class="literal">NULL</span> &amp;&amp; !PyDict_Check(keyw)) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                        <span class="string">"optional 3rd arg must be a dictionary"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PyInterpreterState *interp = _PyInterpreterState_GET();</span><br><span class="line">    <span class="keyword">if</span> (interp-&gt;config._isolated_interpreter) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_RuntimeError,</span><br><span class="line">                        <span class="string">"thread is not supported for isolated subinterpreters"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置bootstate实例</span></span><br><span class="line">    boot = PyMem_NEW(struct bootstate, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (boot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    boot-&gt;interp = _PyInterpreterState_GET();</span><br><span class="line">    boot-&gt;func = func;</span><br><span class="line">    boot-&gt;args = args;</span><br><span class="line">    boot-&gt;keyw = keyw;</span><br><span class="line">    boot-&gt;tstate = _PyThreadState_Prealloc(boot-&gt;interp);</span><br><span class="line">    boot-&gt;runtime = runtime;</span><br><span class="line">    <span class="keyword">if</span> (boot-&gt;tstate == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyMem_DEL(boot);</span><br><span class="line">        <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(func);</span><br><span class="line">    Py_INCREF(args);</span><br><span class="line">    Py_XINCREF(keyw);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 启动线程，传参t_bootstrap跟bootstate实例</span></span><br><span class="line">    ident = PyThread_start_new_thread(t_bootstrap, (<span class="keyword">void</span>*) boot);</span><br><span class="line">    <span class="keyword">if</span> (ident == PYTHREAD_INVALID_THREAD_ID) &#123;</span><br><span class="line">        PyErr_SetString(ThreadError, <span class="string">"can't start new thread"</span>);</span><br><span class="line">        Py_DECREF(func);</span><br><span class="line">        Py_DECREF(args);</span><br><span class="line">        Py_XDECREF(keyw);</span><br><span class="line">        PyThreadState_Clear(boot-&gt;tstate);</span><br><span class="line">        PyMem_DEL(boot);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PyLong_FromUnsignedLong(ident);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python中的<code>_start_new_thread</code>，对应了C层的<code>thread_PyThread_start_new_thread</code>，而<code>thread_PyThread_start_new_thread</code>传入的两个参数<code>self</code>跟<code>fargs</code>，则对应python代码里的<code>self._bootstrap</code>跟空的tuple。<code>_start_new_thread</code>的大致步骤如下：</p>
<ul>
<li>解包<code>fargs</code>，并检查合法性。这里由于进了空的tuple，所以暂时不需要过多分析。</li>
<li>设置<code>bootstate</code>实例<code>boot</code><ul>
<li>一个<code>bootstate</code>是<code>fargs</code>以及对应的<code>thread state</code>、<code>intepreter state</code>以及<code>runtime state</code>的打包，囊括了启动新线程需要有的信息</li>
</ul>
</li>
<li>调用<code>PyThread_start_new_thread</code>函数，把<code>bootstate</code>实例以及一个回调函数<code>t_bootstrap</code>传进去<ul>
<li>其返回值是线程的实例ID，在python端，我们也可以通过线程实例的<code>ident</code>属性得到。</li>
<li><code>t_bootstrap</code>回调函数，是需要在新启动的子线程里运行的！</li>
</ul>
</li>
</ul>
<p><code>PyThread_start_new_thread</code>函数，根据不同操作系统环境有不同的定义。以windows环境为例，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// thread_nt.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* thunker to call adapt between the function type used by the system's</span></span><br><span class="line"><span class="comment">thread start function and the internally used one. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> __stdcall</span><br><span class="line">bootstrap(<span class="keyword">void</span> *call)</span><br><span class="line">&#123;</span><br><span class="line">    callobj *obj = (callobj*)call;</span><br><span class="line">    <span class="keyword">void</span> (*func)(<span class="keyword">void</span>*) = obj-&gt;func;</span><br><span class="line">    <span class="keyword">void</span> *arg = obj-&gt;arg;</span><br><span class="line">    HeapFree(GetProcessHeap(), <span class="number">0</span>, obj);</span><br><span class="line">    func(arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span></span><br><span class="line">PyThread_start_new_thread(<span class="keyword">void</span> (*func)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hThread;</span><br><span class="line">    <span class="keyword">unsigned</span> threadID;</span><br><span class="line">    callobj *obj;</span><br><span class="line"></span><br><span class="line">    dprintf((<span class="string">"%lu: PyThread_start_new_thread called\n"</span>,</span><br><span class="line">             PyThread_get_thread_ident()));</span><br><span class="line">    <span class="keyword">if</span> (!initialized)</span><br><span class="line">        PyThread_init_thread();</span><br><span class="line"></span><br><span class="line">    obj = (callobj*)HeapAlloc(GetProcessHeap(), <span class="number">0</span>, <span class="keyword">sizeof</span>(*obj));</span><br><span class="line">    <span class="keyword">if</span> (!obj)</span><br><span class="line">        <span class="keyword">return</span> PYTHREAD_INVALID_THREAD_ID;</span><br><span class="line">    obj-&gt;func = func;</span><br><span class="line">    obj-&gt;arg = arg;</span><br><span class="line">    PyThreadState *tstate = _PyThreadState_GET();</span><br><span class="line">    <span class="keyword">size_t</span> stacksize = tstate ? tstate-&gt;interp-&gt;pythread_stacksize : <span class="number">0</span>;</span><br><span class="line">    hThread = (HANDLE)_beginthreadex(<span class="number">0</span>,</span><br><span class="line">                      Py_SAFE_DOWNCAST(stacksize, Py_ssize_t, <span class="keyword">unsigned</span> <span class="keyword">int</span>),</span><br><span class="line">                      bootstrap, obj,</span><br><span class="line">                      <span class="number">0</span>, &amp;threadID);</span><br><span class="line">    <span class="keyword">if</span> (hThread == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* I've seen errno == EAGAIN here, which means "there are</span></span><br><span class="line"><span class="comment">         * too many threads".</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> e = errno;</span><br><span class="line">        dprintf((<span class="string">"%lu: PyThread_start_new_thread failed, errno %d\n"</span>,</span><br><span class="line">                 PyThread_get_thread_ident(), e));</span><br><span class="line">        threadID = (<span class="keyword">unsigned</span>)<span class="number">-1</span>;</span><br><span class="line">        HeapFree(GetProcessHeap(), <span class="number">0</span>, obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        dprintf((<span class="string">"%lu: PyThread_start_new_thread succeeded: %p\n"</span>,</span><br><span class="line">                 PyThread_get_thread_ident(), (<span class="keyword">void</span>*)hThread));</span><br><span class="line">        CloseHandle(hThread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> threadID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数<code>func</code>和<code>arg</code>，对应的是<code>t_bootstrap</code>回调跟<code>bootstate</code>实例。为了适配<code>windows</code>下的<code>_beginthreadex</code>接口定义，<code>t_bootstrap</code>跟<code>bootstate</code>实例又打包成<code>callobj</code>，作为<code>bootstrap</code>函数（适配用）的参数，随<code>bootstrap</code>一起入参<code>_beginthreadex</code>。</p>
<p><strong>这时候我们已经可以确定，python启动的新线程是操作系统的原生线程。</strong></p>
<p>新线程诞生时，调用了<code>bootstrap</code>，在<code>bootstrap</code>里拆包<code>callobj</code>，调用<code>func(arg)</code>，也就是<code>t_bootstrap(boot)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _threadmodule.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">t_bootstrap(<span class="keyword">void</span> *boot_raw)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bootstate</span> *<span class="title">boot</span> = (<span class="title">struct</span> <span class="title">bootstate</span> *) <span class="title">boot_raw</span>;</span></span><br><span class="line">    PyThreadState *tstate;</span><br><span class="line">    PyObject *res;</span><br><span class="line"></span><br><span class="line">    tstate = boot-&gt;tstate;</span><br><span class="line">    tstate-&gt;thread_id = PyThread_get_thread_ident();  <span class="comment">// reset thread ID</span></span><br><span class="line">    _PyThreadState_Init(tstate);</span><br><span class="line">    PyEval_AcquireThread(tstate);  <span class="comment">// take gil for executing thread task</span></span><br><span class="line">    tstate-&gt;interp-&gt;num_threads++;</span><br><span class="line">    res = PyObject_Call(boot-&gt;func, boot-&gt;args, boot-&gt;keyw);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PyErr_ExceptionMatches(PyExc_SystemExit))</span><br><span class="line">            <span class="comment">/* SystemExit is ignored silently */</span></span><br><span class="line">            PyErr_Clear();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            _PyErr_WriteUnraisableMsg(<span class="string">"in thread started by"</span>, boot-&gt;func);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Py_DECREF(res);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(boot-&gt;func);</span><br><span class="line">    Py_DECREF(boot-&gt;args);</span><br><span class="line">    Py_XDECREF(boot-&gt;keyw);</span><br><span class="line">    PyMem_DEL(boot_raw);</span><br><span class="line">    tstate-&gt;interp-&gt;num_threads--;</span><br><span class="line">    PyThreadState_Clear(tstate);</span><br><span class="line">    _PyThreadState_DeleteCurrent(tstate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bpo-44434: Don't call explicitly PyThread_exit_thread(). On Linux with</span></span><br><span class="line">    <span class="comment">// the glibc, pthread_exit() can abort the whole process if dlopen() fails</span></span><br><span class="line">    <span class="comment">// to open the libgcc_s.so library (ex: EMFILE error).</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到<code>t_bootstrap</code>中，我们发现，最终<code>t_bootstrap</code>会取出来<code>boot</code>的<code>func</code>&amp;<code>args</code>，然后调用<code>PyObject_Call</code>调用<code>func(args)</code>。回到前面去看，这个<code>func(args)</code>就是python端的<code>self._bootstrap()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_bootstrap</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Wrapper around the real bootstrap code that ignores</span></span><br><span class="line">        <span class="comment"># exceptions during interpreter cleanup.  Those typically</span></span><br><span class="line">        <span class="comment"># happen when a daemon thread wakes up at an unfortunate</span></span><br><span class="line">        <span class="comment"># moment, finds the world around it destroyed, and raises some</span></span><br><span class="line">        <span class="comment"># random exception *** while trying to report the exception in</span></span><br><span class="line">        <span class="comment"># _bootstrap_inner() below ***.  Those random exceptions</span></span><br><span class="line">        <span class="comment"># don't help anybody, and they confuse users, so we suppress</span></span><br><span class="line">        <span class="comment"># them.  We suppress them only when it appears that the world</span></span><br><span class="line">        <span class="comment"># indeed has already been destroyed, so that exceptions in</span></span><br><span class="line">        <span class="comment"># _bootstrap_inner() during normal business hours are properly</span></span><br><span class="line">        <span class="comment"># reported.  Also, we only suppress them for daemonic threads;</span></span><br><span class="line">        <span class="comment"># if a non-daemonic encounters this, something else is wrong.</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._bootstrap_inner()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">if</span> self._daemonic <span class="keyword">and</span> _sys <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">   </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">_bootstrap_inner</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._set_ident()</span><br><span class="line">            self._set_tstate_lock()</span><br><span class="line">            <span class="keyword">if</span> _HAVE_THREAD_NATIVE_ID:</span><br><span class="line">                self._set_native_id()</span><br><span class="line">            self._started.set()</span><br><span class="line">            <span class="keyword">with</span> _active_limbo_lock:</span><br><span class="line">                _active[self._ident] = self</span><br><span class="line">                <span class="keyword">del</span> _limbo[self]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> _trace_hook:</span><br><span class="line">                _sys.settrace(_trace_hook)</span><br><span class="line">            <span class="keyword">if</span> _profile_hook:</span><br><span class="line">                _sys.setprofile(_profile_hook)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.run()</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                self._invoke_excepthook(self)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="keyword">with</span> _active_limbo_lock:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="comment"># We don't call self._delete() because it also</span></span><br><span class="line">                    <span class="comment"># grabs _active_limbo_lock.</span></span><br><span class="line">                    <span class="keyword">del</span> _active[get_ident()]</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>在<code>self._bootstrap_inner()</code>中，大致有以下步骤：</p>
<ul>
<li>notify <code>self._started</code>，这样先前python端的<code>start</code>函数流程就完成了</li>
<li>把自己从准备态<code>_limbo</code>中移除，并把自己加到<code>active</code>态里</li>
<li>执行<code>self.run</code>，开始线程逻辑</li>
</ul>
<p>这样，python中新线程启动的全貌就展现在我们面前了。除了线程的来源外，很多关于线程相关的基础问题（比如为啥不能直接执行<code>self.run</code>），答案也都一目了然</p>
<h2 id="线程执行代码的过程"><a href="#线程执行代码的过程" class="headerlink" title="线程执行代码的过程"></a>线程执行代码的过程</h2><p>在先前一小节我们知晓了python新的线程从何而来，然而，只有通过剖析线程执行代码的过程，我们才可以明确为什么python线程不能并行运行。</p>
<p>一个线程执行其任务，最终还是要落实到<code>run</code>方法上来。首先我们通过python自带的反编译库<code>dis</code>来看下Thread的run函数对应的操作码（opcode），这样就通过python内部对应opcode的执行逻辑来进一步分析：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Method representing the thread's activity.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        You may override this method in a subclass. The standard run() method</span></span><br><span class="line"><span class="string">        invokes the callable object passed to the object's constructor as the</span></span><br><span class="line"><span class="string">        target argument, if any, with sequential and keyword arguments taken</span></span><br><span class="line"><span class="string">        from the args and kwargs arguments, respectively.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> self._target:</span><br><span class="line">                self._target(*self._args, **self._kwargs)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># Avoid a refcycle if the thread is running a function with</span></span><br><span class="line">            <span class="comment"># an argument that has a member that points to the thread.</span></span><br><span class="line">            <span class="keyword">del</span> self._target, self._args, self._kwargs</span><br></pre></td></tr></table></figure>
<p>其中真正执行函数的一行<code>self._target(*self._args, **self._kwargs)</code>，对应的opcodes是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">910           8 LOAD_FAST                0 (self)</span><br><span class="line">             10 LOAD_ATTR                0 (_target)</span><br><span class="line">             12 LOAD_FAST                0 (self)</span><br><span class="line">             14 LOAD_ATTR                1 (_args)</span><br><span class="line">             16 BUILD_MAP                0</span><br><span class="line">             18 LOAD_FAST                0 (self)</span><br><span class="line">             20 LOAD_ATTR                2 (_kwargs)</span><br><span class="line">             22 DICT_MERGE               1</span><br><span class="line">             24 CALL_FUNCTION_EX         1</span><br><span class="line">             26 POP_TOP</span><br><span class="line">        &gt;&gt;   28 POP_BLOCK</span><br></pre></td></tr></table></figure>
<p>很明显，<code>CALL_FUNCTION_EX</code>——调用函数，就是我们需要找到的opcode。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ceval.c</span></span><br><span class="line">PyObject* _Py_HOT_FUNCTION</span><br><span class="line">_PyEval_EvalFrameDefault(PyThreadState *tstate, PyFrameObject *f, <span class="keyword">int</span> throwflag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 省略超多行</span></span><br><span class="line">    <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">        <span class="comment">// 省略超多行</span></span><br><span class="line">        case TARGET(CALL_FUNCTION_EX): &#123;</span><br><span class="line">            <span class="comment">// 检查函数跟参数</span></span><br><span class="line">            PREDICTED(CALL_FUNCTION_EX);</span><br><span class="line">            PyObject *func, *callargs, *kwargs = <span class="literal">NULL</span>, *result;</span><br><span class="line">            <span class="keyword">if</span> (oparg &amp; <span class="number">0x01</span>) &#123;</span><br><span class="line">                kwargs = POP();</span><br><span class="line">                <span class="keyword">if</span> (!PyDict_CheckExact(kwargs)) &#123;</span><br><span class="line">                    PyObject *d = PyDict_New();</span><br><span class="line">                    <span class="keyword">if</span> (d == <span class="literal">NULL</span>)</span><br><span class="line">                        <span class="keyword">goto</span> error;</span><br><span class="line">                    <span class="keyword">if</span> (_PyDict_MergeEx(d, kwargs, <span class="number">2</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Py_DECREF(d);</span><br><span class="line">                        format_kwargs_error(tstate, SECOND(), kwargs);</span><br><span class="line">                        Py_DECREF(kwargs);</span><br><span class="line">                        <span class="keyword">goto</span> error;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Py_DECREF(kwargs);</span><br><span class="line">                    kwargs = d;</span><br><span class="line">                &#125;</span><br><span class="line">                assert(PyDict_CheckExact(kwargs));</span><br><span class="line">            &#125;</span><br><span class="line">            callargs = POP();</span><br><span class="line">            func = TOP();</span><br><span class="line">            <span class="keyword">if</span> (!PyTuple_CheckExact(callargs)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (check_args_iterable(tstate, func, callargs) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Py_DECREF(callargs);</span><br><span class="line">                    <span class="keyword">goto</span> error;</span><br><span class="line">                &#125;</span><br><span class="line">                Py_SETREF(callargs, PySequence_Tuple(callargs));</span><br><span class="line">                <span class="keyword">if</span> (callargs == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">goto</span> error;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            assert(PyTuple_CheckExact(callargs));</span><br><span class="line">            <span class="comment">// 调用函数</span></span><br><span class="line">            result = do_call_core(tstate, func, callargs, kwargs);</span><br><span class="line">            Py_DECREF(func);</span><br><span class="line">            Py_DECREF(callargs);</span><br><span class="line">            Py_XDECREF(kwargs);</span><br><span class="line"></span><br><span class="line">            SET_TOP(result);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">            DISPATCH();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略超多行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略超多行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>ceval.c</code>中，超大函数<code>_PyEval_EvalFrameDefault</code>就是用来解析opcode的方法，在这个函数里可以检索opcode研究对应的逻辑。找到<code>CALL_FUNCTION_EX</code>对应的逻辑，我们可以分析函数调用的过程，顺藤摸瓜，最终会落实到这里：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call.c</span></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">_PyObject_Call(PyThreadState *tstate, PyObject *callable,</span><br><span class="line">               PyObject *args, PyObject *kwargs)</span><br><span class="line">&#123;</span><br><span class="line">    ternaryfunc call;</span><br><span class="line">    PyObject *result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* PyObject_Call() must not be called with an exception set,</span></span><br><span class="line"><span class="comment">       because it can clear it (directly or indirectly) and so the</span></span><br><span class="line"><span class="comment">       caller loses its exception */</span></span><br><span class="line">    assert(!_PyErr_Occurred(tstate));</span><br><span class="line">    assert(PyTuple_Check(args));</span><br><span class="line">    assert(kwargs == <span class="literal">NULL</span> || PyDict_Check(kwargs));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyVectorcall_Function(callable) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> PyVectorcall_Call(callable, args, kwargs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        call = Py_TYPE(callable)-&gt;tp_call;</span><br><span class="line">        <span class="keyword">if</span> (call == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            _PyErr_Format(tstate, PyExc_TypeError,</span><br><span class="line">                          <span class="string">"'%.200s' object is not callable"</span>,</span><br><span class="line">                          Py_TYPE(callable)-&gt;tp_name);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_Py_EnterRecursiveCall(tstate, <span class="string">" while calling a Python object"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = (*call)(callable, args, kwargs);</span><br><span class="line"></span><br><span class="line">        _Py_LeaveRecursiveCall(tstate);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _Py_CheckFunctionResult(tstate, callable, result, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>_PyObject_Call</code>中，调用函数的方式最后都以通用的形式（<code>vectorcall</code>以及<code>Py_TYPE(callable)-&gt;tp_call</code>）呈现，这说明入参不同的<code>callable</code>，可能需要不同的caller方法来handle。基于此，我们可以通过直接debug线程类Thread的<code>run</code>方法（在主线程直接跑就行了），来观察线程run函数调用的过程。测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_stat</span><span class="params">(a, b)</span>:</span> print(a + b)</span><br><span class="line">t = Thread(target=_stat, args=(<span class="number">2</span>, <span class="number">5</span>))</span><br><span class="line">t.run()</span><br></pre></td></tr></table></figure>
<p><code>t.run</code>中的<code>self._target(*self._args, **self._kwargs)</code>一行触发了<code>_PyObject_Call</code>中<code>PyVectorcall_Call</code>分支。一路step into下去，最终来到了<code>_PyEval_EvalFrame</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> PyObject*</span><br><span class="line">_PyEval_EvalFrame(PyThreadState *tstate, PyFrameObject *f, <span class="keyword">int</span> throwflag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tstate-&gt;interp-&gt;eval_frame(tstate, f, throwflag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>frame</code>就是python函数调用栈上面的单位实例（类似于lua的<code>callinfo</code>），包含了一个函数调用的相关信息。<code>eval_frame</code>就是对<code>frame</code>保存的<code>code</code>（代码）实例解析并执行。解释器用的是<code>tstate-&gt;interp</code>，从先前线程启动的逻辑来看，在<code>thread_PyThread_start_new_thread</code>里，主线程就把自己的<code>interp</code>给到子线程了，所以不管创建多少个线程，所有线程都共用一套解释器。那解释器的<code>eval_frame</code>是什么呢？兜兜转转，又回到了超大函数<code>_PyEval_EvalFrameDefault</code>。</p>
<p>从<code>_PyEval_EvalFrameDefault</code>的<code>main_loop</code>这个goto记号往下，就是无限循环处理opcode了。但在switch opcode之前，有一个判断逻辑：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ceval.c</span></span><br><span class="line">PyObject* _Py_HOT_FUNCTION</span><br><span class="line">_PyEval_EvalFrameDefault(PyThreadState *tstate, PyFrameObject *f, <span class="keyword">int</span> throwflag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 省略上面</span></span><br><span class="line">main_loop:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 省略上面</span></span><br><span class="line">  <span class="keyword">if</span> (_Py_atomic_load_relaxed(eval_breaker)) &#123;</span><br><span class="line">            opcode = _Py_OPCODE(*next_instr);</span><br><span class="line">            <span class="keyword">if</span> (opcode == SETUP_FINALLY ||</span><br><span class="line">                opcode == SETUP_WITH ||</span><br><span class="line">                opcode == BEFORE_ASYNC_WITH ||</span><br><span class="line">                opcode == YIELD_FROM) &#123;</span><br><span class="line">                <span class="comment">/* Few cases where we skip running signal handlers and other</span></span><br><span class="line"><span class="comment">                   pending calls:</span></span><br><span class="line"><span class="comment">                   - If we're about to enter the 'with:'. It will prevent</span></span><br><span class="line"><span class="comment">                     emitting a resource warning in the common idiom</span></span><br><span class="line"><span class="comment">                     'with open(path) as file:'.</span></span><br><span class="line"><span class="comment">                   - If we're about to enter the 'async with:'.</span></span><br><span class="line"><span class="comment">                   - If we're about to enter the 'try:' of a try/finally (not</span></span><br><span class="line"><span class="comment">                     *very* useful, but might help in some cases and it's</span></span><br><span class="line"><span class="comment">                     traditional)</span></span><br><span class="line"><span class="comment">                   - If we're resuming a chain of nested 'yield from' or</span></span><br><span class="line"><span class="comment">                     'await' calls, then each frame is parked with YIELD_FROM</span></span><br><span class="line"><span class="comment">                     as its next opcode. If the user hit control-C we want to</span></span><br><span class="line"><span class="comment">                     wait until we've reached the innermost frame before</span></span><br><span class="line"><span class="comment">                     running the signal handler and raising KeyboardInterrupt</span></span><br><span class="line"><span class="comment">                     (see bpo-30039).</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">goto</span> fast_next_opcode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (eval_frame_handle_pending(tstate) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略下面</span></span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// 省略下面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码首先会判断代码解释是否达到中断条件<code>eval_breaker</code>，如果达到了的话，可能会走到<code>eval_frame_handle_pending</code>处理中断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ceval.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Handle signals, pending calls, GIL drop request</span></span><br><span class="line"><span class="comment">   and asynchronous exception */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">eval_frame_handle_pending(PyThreadState *tstate)</span><br><span class="line">&#123;</span><br><span class="line">    _PyRuntimeState * <span class="keyword">const</span> runtime = &amp;_PyRuntime;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ceval_runtime_state</span> *<span class="title">ceval</span> = &amp;<span class="title">runtime</span>-&gt;<span class="title">ceval</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pending signals */</span></span><br><span class="line">    <span class="keyword">if</span> (_Py_atomic_load_relaxed(&amp;ceval-&gt;signals_pending)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (handle_signals(tstate) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pending calls */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ceval_state</span> *<span class="title">ceval2</span> = &amp;<span class="title">tstate</span>-&gt;<span class="title">interp</span>-&gt;<span class="title">ceval</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (_Py_atomic_load_relaxed(&amp;ceval2-&gt;pending.calls_to_do)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (make_pending_calls(tstate) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* GIL drop request */</span></span><br><span class="line">    <span class="keyword">if</span> (_Py_atomic_load_relaxed(&amp;ceval2-&gt;gil_drop_request)) &#123;</span><br><span class="line">        <span class="comment">/* Give another thread a chance */</span></span><br><span class="line">        <span class="keyword">if</span> (_PyThreadState_Swap(&amp;runtime-&gt;gilstate, <span class="literal">NULL</span>) != tstate) &#123;</span><br><span class="line">            Py_FatalError(<span class="string">"tstate mix-up"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        drop_gil(ceval, ceval2, tstate);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Other threads may run now */</span></span><br><span class="line"></span><br><span class="line">        take_gil(tstate);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_PyThreadState_Swap(&amp;runtime-&gt;gilstate, tstate) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_FatalError(<span class="string">"orphan tstate"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for asynchronous exception. */</span></span><br><span class="line">    <span class="keyword">if</span> (tstate-&gt;async_exc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyObject *exc = tstate-&gt;async_exc;</span><br><span class="line">        tstate-&gt;async_exc = <span class="literal">NULL</span>;</span><br><span class="line">        UNSIGNAL_ASYNC_EXC(tstate-&gt;interp);</span><br><span class="line">        _PyErr_SetNone(tstate, exc);</span><br><span class="line">        Py_DECREF(exc);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MS_WINDOWS</span></span><br><span class="line">    <span class="comment">// bpo-42296: On Windows, _PyEval_SignalReceived() can be called in a</span></span><br><span class="line">    <span class="comment">// different thread than the Python thread, in which case</span></span><br><span class="line">    <span class="comment">// _Py_ThreadCanHandleSignals() is wrong. Recompute eval_breaker in the</span></span><br><span class="line">    <span class="comment">// current Python thread with the correct _Py_ThreadCanHandleSignals()</span></span><br><span class="line">    <span class="comment">// value. It prevents to interrupt the eval loop at every instruction if</span></span><br><span class="line">    <span class="comment">// the current Python thread cannot handle signals (if</span></span><br><span class="line">    <span class="comment">// _Py_ThreadCanHandleSignals() is false).</span></span><br><span class="line">    COMPUTE_EVAL_BREAKER(tstate-&gt;interp, ceval, ceval2);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>eval_frame_handle_pending</code>处理了多种opcode解析中断的场景。在这里我们可以看到，不论是哪个线程跑到这里，如果遇到了<code>gil_drop_request</code>，就得<code>drop_gil</code>给到其他线程，之后再尝试<code>take_gil</code>，重新竞争解释器锁。<br>在先前讲解线程启动逻辑的时候，新线程调用的<code>t_bootstrap</code>函数里，有一句<code>PyEval_AcquireThread(tstate)</code>，这里面就包含了<code>take_gil</code>的逻辑。我们可以看一下<code>take_gil</code>到底干了什么事情：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ceval_gil.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take the GIL.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The function saves errno at entry and restores its value at exit.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   tstate must be non-NULL. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">take_gil(PyThreadState *tstate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 省略上面</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!_Py_atomic_load_relaxed(&amp;gil-&gt;locked)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> _ready;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (_Py_atomic_load_relaxed(&amp;gil-&gt;locked)) &#123;</span><br><span class="line">        <span class="comment">// 没有拿到gil的情况</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> saved_switchnum = gil-&gt;switch_number;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> interval = (gil-&gt;interval &gt;= <span class="number">1</span> ? gil-&gt;interval : <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> timed_out = <span class="number">0</span>;</span><br><span class="line">        COND_TIMED_WAIT(gil-&gt;cond, gil-&gt;mutex, interval, timed_out);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If we timed out and no switch occurred in the meantime, it is time</span></span><br><span class="line"><span class="comment">           to ask the GIL-holding thread to drop it. */</span></span><br><span class="line">        <span class="keyword">if</span> (timed_out &amp;&amp;</span><br><span class="line">            _Py_atomic_load_relaxed(&amp;gil-&gt;locked) &amp;&amp;</span><br><span class="line">            gil-&gt;switch_number == saved_switchnum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tstate_must_exit(tstate)) &#123;</span><br><span class="line">                MUTEX_UNLOCK(gil-&gt;mutex);</span><br><span class="line">                PyThread_exit_thread();</span><br><span class="line">            &#125;</span><br><span class="line">            assert(is_tstate_valid(tstate));</span><br><span class="line"></span><br><span class="line">            SET_GIL_DROP_REQUEST(interp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">_ready:</span><br><span class="line">    <span class="comment">// 省略FORCE_SWITCHING宏相关代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* We now hold the GIL */</span></span><br><span class="line">    _Py_atomic_store_relaxed(&amp;gil-&gt;locked, <span class="number">1</span>);</span><br><span class="line">    _Py_ANNOTATE_RWLOCK_ACQUIRED(&amp;gil-&gt;locked, <span class="comment">/*is_write=*/</span><span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tstate != (PyThreadState*)_Py_atomic_load_relaxed(&amp;gil-&gt;last_holder)) &#123;</span><br><span class="line">        _Py_atomic_store_relaxed(&amp;gil-&gt;last_holder, (<span class="keyword">uintptr_t</span>)tstate);</span><br><span class="line">        ++gil-&gt;switch_number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略FORCE_SWITCHING宏相关代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略下面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到这段逻辑：当<code>gil</code>一直被占时，就会进入while循环的<code>COND_TIMED_WAIT</code>，等待<code>gil-&gt;cond</code>的信号。这个信号的通知逻辑是在<code>drop_gil</code>的里面的，也就是说如果另一个线程执行了<code>drop_gil</code>就会触发这个信号，而由于python的线程是操作系统原生线程，因此我们如果深挖<code>COND_TIMED_WAIT</code>内部的实现也可以看到实质上是操作系统在调度信号触发后线程的唤醒。<code>COND_TIMED_WAIT</code>的时长是<code>gil-&gt;interval</code>（也就是<code>sys.getswitchinterval()</code>，线程切换时间），过了这段时间还是原来线程hold住<code>gil</code>的话，就强制触发<code>SET_GIL_DROP_REQUEST</code>逻辑</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">SET_GIL_DROP_REQUEST(PyInterpreterState *interp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ceval_state</span> *<span class="title">ceval2</span> = &amp;<span class="title">interp</span>-&gt;<span class="title">ceval</span>;</span></span><br><span class="line">    _Py_atomic_store_relaxed(&amp;ceval2-&gt;gil_drop_request, <span class="number">1</span>);</span><br><span class="line">    _Py_atomic_store_relaxed(&amp;ceval2-&gt;eval_breaker, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到<code>SET_GIL_DROP_REQUEST</code>强制激活<code>gil_drop_request</code>跟<code>eval_breaker</code>，这样持有GIL的线程在<code>EvalFrame</code>的时候发现满足<code>eval_breaker</code>，就会走<code>eval_frame_handle_pending</code>的逻辑，里面再判断有<code>gil_drop_request</code>之后，就调用<code>drop_gil</code>把解释器锁释放出来。这样，另一个线程在执行<code>SET_GIL_DROP_REQUEST</code>之后的某次<code>COND_TIMED_WAIT</code>时候，就有可能提前被signal到，之后又发现<code>gil</code>没有被locked，于是就能够继续下面的逻辑，持有GIL了。最后，另一个线程拿到了代码的执行权，而原先丢掉GIL的线程，在<code>eval_frame_handle_pending</code>再次调用<code>take_gil</code>，反过来走在了竞争代码执行权的路上。循环往复，如是而已。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对线程启动机制、代码运行机制以及基于GIL的线程调度机制的剖析，我们可以“一图流”，解释“python多线程为什么不能并行”这个问题：</p>
<p><img src="/uploads/mediumpython/iii/threads.png" alt="threads" title="&#39;threads&#39;"></p>
]]></content>
      <categories>
        <category>Medium Python</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>python</tag>
        <tag>GIL</tag>
        <tag>多线程</tag>
        <tag>opcode</tag>
      </tags>
  </entry>
  <entry>
    <title>【Medium Python】第二话：dict的keys()返回了什么数据类型？</title>
    <url>/2021/10/23/mediumpython/ii/</url>
    <content><![CDATA[<p>在python3里面，我们经常会用<code>if k in d.keys()</code>来判断某个key是不是在某个dict里面，或者是用<code>a_dict.keys() - b_dict.keys()</code>来获取两个字典之间keys的差集。那么这里就有一个问题，dict的<code>keys()</code>返回了什么数据类型呢？</p>
<p>list？set？两者都是错误答案。Don’t say so much，打印一下type，发现是这么个数据类型：<code>&lt;class &#39;dict_keys&#39;&gt;</code></p>
<h2 id="dict-keys是什么东西？"><a href="#dict-keys是什么东西？" class="headerlink" title="dict_keys是什么东西？"></a>dict_keys是什么东西？</h2><p>在python dict数据结构定义中（<code>dictobject.c</code>），可以看到<code>dict_keys</code>的定义</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dictobject.c</span></span><br><span class="line"></span><br><span class="line">PyTypeObject PyDictKeys_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">"dict_keys"</span>,                                <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(_PyDictViewObject),                  <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    <span class="comment">/* methods */</span></span><br><span class="line">    (destructor)dictview_dealloc,               <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_vectorcall_offset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_async */</span></span><br><span class="line">    (reprfunc)dictview_repr,                    <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;dictviews_as_number,                       <span class="comment">/* tp_as_number */</span></span><br><span class="line">    &amp;dictkeys_as_sequence,                      <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,<span class="comment">/* tp_flags */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_doc */</span></span><br><span class="line">    (traverseproc)dictview_traverse,            <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    dictview_richcompare,                       <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    (getiterfunc)dictkeys_iter,                 <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    dictkeys_methods,                           <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>dict_keys</code>数据结构的size，是以<code>_PyDictViewObject</code>为准的。<code>_PyDictViewObject</code>从语义上看是dict的一个视图，从逻辑上看只包含了一个对应dict的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dictobject.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    PyDictObject *dv_dict;</span><br><span class="line">&#125; _PyDictViewObject;</span><br></pre></td></tr></table></figure>
<p>如何理解<code>DictView</code>的设计？其实这种相当于一个dict实例的代理（Agent/Proxy），用户（开发者）侧请求对应的操作（in、运算符等），代理侧来给出一个最有效率的方案。举一些例子：</p>
<h3 id="in操作"><a href="#in操作" class="headerlink" title="in操作"></a>in操作</h3><p>in涉及到<code>for k in d.keys()</code>跟<code>has_key = (k in d.keys())</code>两种形式，对应迭代遍历跟包含两种操作。<br><code>for k in d.keys()</code>操作对应的是<code>PyDictKeys_Type</code>里的<code>dictkeys_iter</code>函数，返回了这个<code>DictView</code>视图对应的dict的key的iterator，类型为<code>PyDictIterKey_Type</code>。在迭代遍历时候，会一直调用<code>PyDictIterKey_Type</code>里定义的<code>dictiter_iternextkey</code>执行迭代过程中的next操作，从而一个个地获得dict里所有key。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dictobject.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dict的key的iterator的定义，这里只节选一部分</span></span><br><span class="line">PyTypeObject PyDictIterKey_Type = &#123;</span><br><span class="line">    <span class="string">"dict_keyiterator"</span>,                         <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(dictiterobject),                     <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    PyObject_SelfIter,                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    (iternextfunc)dictiter_iternextkey,         <span class="comment">/* tp_iternext */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>has_key = (k in d.keys())</code>对应的是包含操作，在<code>PyDictKeys_Type</code>里面，对应的是<code>dictkeys_as_sequence</code>的<code>dictkeys_contains</code>回调。在上一讲<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjEvMTAvMTcvbWVkaXVtcHl0aG9uL2kv" title="https://utmhikari.top/2021/10/17/mediumpython/i/">list可变、tuple不可变<i class="fa fa-external-link"></i></span>中已经提到，python里面实现对特定数据的多种操作，实际上会尝试将数据看成sequence、mapping等形式，执行对应数据形式中定义的回调函数，而这里便是将keys看作是sequence，执行<code>sq_contains</code>对应的回调，表示一个是否包含的判断。<code>dictkeys_contains</code>实质上调用的是dict自己的contains操作，也就是说<code>k in d.keys()</code>和<code>k in d</code>这两种写法，实质上是等价的</p>
<h3 id="运算符操作"><a href="#运算符操作" class="headerlink" title="运算符操作"></a>运算符操作</h3><p>dict_keys支持多种运算符操作。比如我们在对比作为counter的dict时（不是内置的Counter类），会用keys相减的方式来得到两次统计里新增/删除的key。相减的操作，比如<code>a.keys() - b.keys()</code>，会执行将keys看作为number时的<code>dictviews_sub</code>函数。在函数内部的实现里，会首先将<code>a.keys()</code>转化为一个set，然后调用set数据结构的<code>difference_update</code>函数，逐步remove掉右侧<code>b.keys()</code>里面的元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dictobject.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyObject*</span><br><span class="line">dictviews_sub(PyObject *self, PyObject *other)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *result = dictviews_to_set(self);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _Py_IDENTIFIER(difference_update);</span><br><span class="line">    PyObject *tmp = _PyObject_CallMethodIdOneArg(</span><br><span class="line">            result, &amp;PyId_difference_update, other);</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_DECREF(result);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Py_DECREF(tmp);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，<code>dictviews_sub</code>内部指定了一个标识符<code>PyId_difference_update</code>，通过<code>_PyObject_CallMethodIdOneArg</code>函数去调用<code>result</code>实例里标识为<code>PyId_difference_update</code>的函数，入参为<code>other</code>。这样调用接口的方式，在python里称之为<span class="exturl" data-url="aHR0cHM6Ly93d3cucHl0aG9uLm9yZy9kZXYvcGVwcy9wZXAtMDU5MC8=" title="https://www.python.org/dev/peps/pep-0590/">vectorcall<i class="fa fa-external-link"></i></span>，是3.9完全应用的cpython的特性，相对于以前的版本，显著优化了cpython内部不同数据结构间函数调用的效率。有兴趣的同学可以深入了解。</p>
<p>如果是类似=、&gt;、&lt;之类的操作，dict_keys也是支持的，我们可以在<code>dictview_richcompare</code>函数中看到这些比较符对应的计算方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dictobject.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">dictview_richcompare(PyObject *self, PyObject *other, <span class="keyword">int</span> op)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t len_self, len_other;</span><br><span class="line">    <span class="keyword">int</span> ok;</span><br><span class="line">    PyObject *result;</span><br><span class="line"></span><br><span class="line">    assert(self != <span class="literal">NULL</span>);</span><br><span class="line">    assert(PyDictViewSet_Check(self));</span><br><span class="line">    assert(other != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!PyAnySet_Check(other) &amp;&amp; !PyDictViewSet_Check(other))</span><br><span class="line">        Py_RETURN_NOTIMPLEMENTED;</span><br><span class="line"></span><br><span class="line">    len_self = PyObject_Size(self);</span><br><span class="line">    <span class="keyword">if</span> (len_self &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    len_other = PyObject_Size(other);</span><br><span class="line">    <span class="keyword">if</span> (len_other &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ok = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(op) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> Py_NE:</span><br><span class="line">    <span class="keyword">case</span> Py_EQ:</span><br><span class="line">        <span class="keyword">if</span> (len_self == len_other)</span><br><span class="line">            ok = all_contained_in(self, other);</span><br><span class="line">        <span class="keyword">if</span> (op == Py_NE &amp;&amp; ok &gt;= <span class="number">0</span>)</span><br><span class="line">            ok = !ok;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> Py_LT:</span><br><span class="line">        <span class="keyword">if</span> (len_self &lt; len_other)</span><br><span class="line">            ok = all_contained_in(self, other);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> Py_LE:</span><br><span class="line">          <span class="keyword">if</span> (len_self &lt;= len_other)</span><br><span class="line">              ok = all_contained_in(self, other);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> Py_GT:</span><br><span class="line">        <span class="keyword">if</span> (len_self &gt; len_other)</span><br><span class="line">            ok = all_contained_in(other, self);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> Py_GE:</span><br><span class="line">        <span class="keyword">if</span> (len_self &gt;= len_other)</span><br><span class="line">            ok = all_contained_in(other, self);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ok &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    result = ok ? Py_True : Py_False;</span><br><span class="line">    Py_INCREF(result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果两个dict的keys相等，则这两组keys需要长度一样，并且包含相同的元素（类似于set相等）<br>如果是比大小，比如<code>a.keys()</code>要比<code>b.keys()</code>大的话，除了<code>a.keys()</code>长度比<code>b.keys()</code>大之外，还需要<code>a.keys()</code>包含<code>b.keys()</code>所有的元素才行。所以大小于号主要体现的是包含/被包含的关系。</p>
<h2 id="View概念的其它应用"><a href="#View概念的其它应用" class="headerlink" title="View概念的其它应用"></a>View概念的其它应用</h2><p>在dict里，除了<code>keys()</code>之外，dict的<code>values()</code>、<code>items()</code>，返回的实际上也是<code>DictView</code>的视图结构，定义的方式也基本上相似，但也有少许区别。比如<code>values()</code>，由于没有指定<code>tp_richcompare</code>，所以无法将两组<code>values</code>进行大小或==的比较（都会返回false）<br>​</p>
<p>在python里有很多地方应用了视图的概念/手法。如果硬要套View这个单词的话，就还有这么一个地方应用到了，叫做<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvemgtY24vMy9jLWFwaS9tZW1vcnl2aWV3Lmh0bWw=" title="https://docs.python.org/zh-cn/3/c-api/memoryview.html">memoryview<i class="fa fa-external-link"></i></span>。<code>memoryview</code>在业务代码中不常用，主要的作用是提供一块内存的“代理”，让调用方安全地对一个数据实例的内存进行信息读取及管理操作。比如我们对各种数据做<code>pickle.dumps</code>序列化后，通过<code>memoryview</code>，就能看到序列化后的数据在内存里的组成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memoryview_test</span><span class="params">()</span>:</span></span><br><span class="line">    s = <span class="string">'1234567890'</span></span><br><span class="line">    mem_view = memoryview(pickle.dumps(s))</span><br><span class="line">    print(len(mem_view))</span><br><span class="line">    print([chr(item) <span class="keyword">for</span> item <span class="keyword">in</span> mem_view])</span><br><span class="line">    s = [<span class="string">'1234'</span>, <span class="string">'56'</span>, <span class="string">'7890'</span>]</span><br><span class="line">    mem_view = memoryview(pickle.dumps(s))</span><br><span class="line">    print(len(mem_view))</span><br><span class="line">    print([chr(item) <span class="keyword">for</span> item <span class="keyword">in</span> mem_view])</span><br><span class="line">    s = [<span class="string">'12345'</span>, <span class="string">'67890'</span>]</span><br><span class="line">    mem_view = memoryview(pickle.dumps(s))</span><br><span class="line">    print(len(mem_view))</span><br><span class="line">    print([chr(item) <span class="keyword">for</span> item <span class="keyword">in</span> mem_view])</span><br><span class="line">    </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">25</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">    '\x80', '\x04', '\x95',</span></span><br><span class="line"><span class="string">    '\x0e', '\x00', '\x00', '\x00', '\x00', '\x00', '\x00', '\x00', '\x8c', '\n',</span></span><br><span class="line"><span class="string">    '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '\x94', '.'</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">20</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">    '\x80', '\x04', '\x95',</span></span><br><span class="line"><span class="string">    '\t', '\x00', '\x00', '\x00', '\x00', '\x00', '\x00', '\x00', '\x8c', '\x05',</span></span><br><span class="line"><span class="string">    '5', '4', '3', '2', '1', '\x94', '.'</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">35</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">    '\x80', '\x04', '\x95', '\x18', </span></span><br><span class="line"><span class="string">    '\x00', '\x00', '\x00', '\x00', '\x00', '\x00', '\x00', ']', '\x94', '(', </span></span><br><span class="line"><span class="string">    '\x8c', '\x04', '1', '2', '3', '4', </span></span><br><span class="line"><span class="string">    '\x94', '\x8c', '\x02', '5', '6', </span></span><br><span class="line"><span class="string">    '\x94', '\x8c', '\x04', '7', '8', '9', '0', </span></span><br><span class="line"><span class="string">    '\x94', 'e', '.'</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">32</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">    '\x80', '\x04', '\x95', '\x15', </span></span><br><span class="line"><span class="string">    '\x00', '\x00', '\x00', '\x00', '\x00', '\x00', '\x00', ']', '\x94', '(', </span></span><br><span class="line"><span class="string">    '\x8c', '\x05', '1', '2', '3', '4', '5', </span></span><br><span class="line"><span class="string">    '\x94', '\x8c', '\x05', '6', '7', '8', '9', '0', </span></span><br><span class="line"><span class="string">    '\x94', 'e', '.'</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Medium Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>DictView</tag>
        <tag>dict</tag>
        <tag>C</tag>
        <tag>dict_keys</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】一种解决redis源码编译时jemalloc报No such file or directory错误的方法</title>
    <url>/2021/10/19/geekdaily/redis_make_jemalloc_error/</url>
    <content><![CDATA[<p>在用源码编译redis的过程中，可能会报jemalloc出错，提示No such file or directory的问题，导致构建不能继续。一种常见的，在网上流传的方法是<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDcwODgxNzEvZXJyb3ItamVtYWxsb2MtamVtYWxsb2MtaC1uby1zdWNoLWZpbGUtb3ItZGlyZWN0b3J5LXdoZW4tbWFraW5nLXJlZGlz" title="https://stackoverflow.com/questions/47088171/error-jemalloc-jemalloc-h-no-such-file-or-directory-when-making-redis">调整MALLOC参数为libc<i class="fa fa-external-link"></i></span>，但这并不是唯一解，不能一概而论。</p>
<p>以笔者的例子，笔者采用windows装CLion并用Remote Development连接linux虚拟机的方式来编译redis源码，版本为6.2.6，在构建的过程中也报了jemalloc出No such file or directory的问题。在笔者的场景下，仔细查看日志，会出现许多<code>Permission Denied</code>的字样，这说明有许多脚本没有执行权限。经过一番研究，执行下面俩操作之后，<code>distclean</code>一下，就能成功再次编译redis。</p>
<ul>
<li>在<code>src</code>目录下，<code>chmod +x ./mkreleasehdr.sh</code>，增加这个脚本的执行权限</li>
<li>在<code>deps</code>目录下，<code>chmod -R 777 jemalloc</code>，把jemalloc目录下所有文件权限都提上来</li>
</ul>
<p>暂时研究到的是这些，如果真是因为权限问题，且还有漏网之鱼的话，极端一点可以把整个redis源码目录权限都提上来。反正都可以试试看。</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>redis</tag>
        <tag>编译</tag>
        <tag>jemalloc</tag>
        <tag>远程开发</tag>
      </tags>
  </entry>
  <entry>
    <title>【Medium Python】第一话：为什么list“可变”，而tuple“不可变”？</title>
    <url>/2021/10/17/mediumpython/i/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>python面试有一道很基础的问题：list（列表）和tuple（元组）有什么不同？基本上只要背过题库的同学都知道，list（里面的元素）是可变的，tuple（里面的元素）是不可变的。</p>
<p>我们尝试在python解释器中改变tuple的元素（赋另一个值），会有以下的表现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tuple_check</span><span class="params">()</span>:</span></span><br><span class="line">    tp = (<span class="string">'123'</span>, <span class="number">123</span>)</span><br><span class="line">    tp[<span class="number">1</span>] = <span class="number">13</span></span><br><span class="line">    </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "H:/Projects/Python/playground/main.py", line 20, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    tuple_check()</span></span><br><span class="line"><span class="string">  File "H:/Projects/Python/playground/main.py", line 10, in tuple_check</span></span><br><span class="line"><span class="string">    tp[2] = 13</span></span><br><span class="line"><span class="string">TypeError: 'tuple' object does not support item assignment</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>可以看到赋值操作报错，tuple不支持再次赋值，体现了其“不可变”的特性。</p>
<p>但是，不支持赋值/不可变的原因，到底是什么呢？不是说不支持就不支持吧！难道也没有支持的可能？</p>
<p>这个问题要给出清晰的答案可并不容易，如果你直接检索网上资料的话，会发现很多文章都在说重复的话，没有什么深入的挖掘，导致这个问题无从解释。于是，今天这篇文章，就给大家把这个问题讲的干脆一点。</p>
<p>以及，看完这篇文章之后，网上那些车轱辘话大家也就没有必要再看了。</p>
<a id="more"></a>
<h2 id="赋值操作的源码分析"><a href="#赋值操作的源码分析" class="headerlink" title="赋值操作的源码分析"></a>赋值操作的源码分析</h2><p>从官网的<span class="exturl" data-url="aHR0cHM6Ly93d3cucHl0aG9uLm9yZy9kb3dubG9hZHMvc291cmNlLw==" title="https://www.python.org/downloads/source/">Python-Source-Release<i class="fa fa-external-link"></i></span>页面中，我们能够下载到Python各个版本的源代码（笔者下载了3.9.7）。在源码的<code>PCBuild</code>文件夹下，有Visual Studio专属的<code>pcbuild.sln</code>项目文件，打开它就能看到python各个库的源代码的集合，以及各种文档和编译构建脚本。准备好了环境，就可以开始研究了。</p>
<p>以上述的赋值操作为例，通过检索<code>object does not support item assignment</code>字样，我们可以定位到对应的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/abstract.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">PyObject_SetItem(PyObject *o, PyObject *key, PyObject *value)</span><br><span class="line">&#123;</span><br><span class="line">    PyMappingMethods *m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || key == <span class="literal">NULL</span> || value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        null_error();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m = Py_TYPE(o)-&gt;tp_as_mapping;</span><br><span class="line">    <span class="keyword">if</span> (m &amp;&amp; m-&gt;mp_ass_subscript)</span><br><span class="line">        <span class="keyword">return</span> m-&gt;mp_ass_subscript(o, key, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Py_TYPE(o)-&gt;tp_as_sequence) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_PyIndex_Check(key)) &#123;</span><br><span class="line">            Py_ssize_t key_value;</span><br><span class="line">            key_value = PyNumber_AsSsize_t(key, PyExc_IndexError);</span><br><span class="line">            <span class="keyword">if</span> (key_value == <span class="number">-1</span> &amp;&amp; PyErr_Occurred())</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> PySequence_SetItem(o, key_value, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Py_TYPE(o)-&gt;tp_as_sequence-&gt;sq_ass_item) &#123;</span><br><span class="line">            type_error(<span class="string">"sequence index must be "</span></span><br><span class="line">                       <span class="string">"integer, not '%.200s'"</span>, key);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    type_error(<span class="string">"'%.200s' object does not support item assignment"</span>, o);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PyObject_SetItem</code>函数涉及到<code>PyObject *o</code>、<code>PyObject* key</code>、<code>PyObject *value</code>三个入参，分别对应我们的tuple实例、索引以及待赋的值。这个函数是一个通用的接口，我们可以看到函数内首先尝试将实例o看作为<code>mapping</code>或者是<code>sequence</code>（<code>tp_as_mapping</code>、<code>tp_as_sequence</code>）。如果能作为<code>mapping</code>，就看是否能执行<code>mp_ass_subscript</code>回调实现赋值；如果作为<code>sequence</code>，会检查<code>key</code>并尝试执行<code>PySequence_SetItem</code>函数，在这个函数里也会尝试执行<code>Py_TYPE(o)-&gt;tp_as_sequence-&gt;sq_ass_item</code>回调实现赋值。<br>​</p>
<p>在研究tuple之前，我们可以通过对list实例进行断点调试，追踪list赋值操作的执行链路。断点直接断在<code>PyObject_SetItem</code>里面即可，测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">lst[<span class="number">2</span>] = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>不出意外的话执行到第二行就会切到debug，一行一行下去，可以看到list实例赋值能够走到这里：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">m = Py_TYPE(o)-&gt;tp_as_mapping;</span><br><span class="line">if (m &amp;&amp; m-&gt;mp_ass_subscript)</span><br><span class="line">    return m-&gt;mp_ass_subscript(o, key, value);</span><br></pre></td></tr></table></figure>
<p>step into进去，可以看到list实例作为<code>mapping</code>的<code>mp_ass_subscript</code>回调，对应的是<code>list_ass_subscript</code>函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/listobject.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">list_ass_subscript(PyListObject* self, PyObject* item, PyObject* value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_PyIndex_Check(item)) &#123;</span><br><span class="line">        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span> &amp;&amp; PyErr_Occurred())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            i += PyList_GET_SIZE(self);</span><br><span class="line">        <span class="keyword">return</span> list_ass_item(self, i, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PySlice_Check(item)) &#123;</span><br><span class="line">        <span class="comment">// 这里是对切片赋值，[a:b]这种。太长了先忽略掉= =</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                     <span class="string">"list indices must be integers or slices, not %.200s"</span>,</span><br><span class="line">                     Py_TYPE(item)-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">list_ass_item(PyListObject *a, Py_ssize_t i, PyObject *v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!valid_index(i, Py_SIZE(a))) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_IndexError,</span><br><span class="line">                        <span class="string">"list assignment index out of range"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> list_ass_slice(a, i, i+<span class="number">1</span>, v);</span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    Py_SETREF(a-&gt;ob_item[i], v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>list_ass_subscript</code>函数会判断索引<code>key</code>的合法性并转换负值索引，然后调用<code>list_ass_item</code>处理赋值操作。<code>list_ass_item</code>也会再次检查索引边界，然后在list实例对应索引的位置赋新值，并调整引用计数。这样，list赋值操作就完成了。</p>
<h2 id="tuple为什么不可变"><a href="#tuple为什么不可变" class="headerlink" title="tuple为什么不可变"></a>tuple为什么不可变</h2><p>list可以对其中的元素赋值，tuple不行。从源码的角度，list能够作为<code>mapping</code>，有<code>list_ass_subscript</code>函数用于对元素赋值，那tuple呢？我们同样可以断tuple的赋值操作，可以看到最终还是落到<code>PyObject_SetItem</code>的“<code>object does not support item assignment</code>”一行<br>​</p>
<p>打开list这个类在C层的源代码，我们能够看到list这个数据类型的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/listobject.c</span></span><br><span class="line"></span><br><span class="line">PyTypeObject PyList_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">"list"</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyListObject),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (destructor)list_dealloc,                   <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_vectorcall_offset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_async */</span></span><br><span class="line">    (reprfunc)list_repr,                        <span class="comment">/* tp_repr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_number */</span></span><br><span class="line">    &amp;list_as_sequence,                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    &amp;list_as_mapping,                           <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    PyObject_HashNotImplemented,                <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |</span><br><span class="line">        Py_TPFLAGS_BASETYPE | Py_TPFLAGS_LIST_SUBCLASS, <span class="comment">/* tp_flags */</span></span><br><span class="line">    list___init____doc__,                       <span class="comment">/* tp_doc */</span></span><br><span class="line">    (traverseproc)list_traverse,                <span class="comment">/* tp_traverse */</span></span><br><span class="line">    (inquiry)_list_clear,                       <span class="comment">/* tp_clear */</span></span><br><span class="line">    list_richcompare,                           <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    list_iter,                                  <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    list_methods,                               <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    (initproc)list___init__,                    <span class="comment">/* tp_init */</span></span><br><span class="line">    PyType_GenericAlloc,                        <span class="comment">/* tp_alloc */</span></span><br><span class="line">    PyType_GenericNew,                          <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_GC_Del,                            <span class="comment">/* tp_free */</span></span><br><span class="line">    .tp_vectorcall = list_vectorcall,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyMappingMethods list_as_mapping = &#123;</span><br><span class="line">    (lenfunc)list_length,</span><br><span class="line">    (binaryfunc)list_subscript,</span><br><span class="line">    (objobjargproc)list_ass_subscript</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    lenfunc mp_length;</span><br><span class="line">    binaryfunc mp_subscript;</span><br><span class="line">    objobjargproc mp_ass_subscript;</span><br><span class="line">&#125; PyMappingMethods;</span><br></pre></td></tr></table></figure>
<p>可以看到，在list类型定义中，<code>tp_as_mapping-&gt;list_as_mapping</code>已经包含了<code>PyMappingMethods</code>所定义的<code>mp_length</code>、<code>mp_subscript</code>以及<code>mp_ass_subscript</code>三个回调，而最后一个就是赋值操作所对应的回调。反观tuple的类型定义，这一块是缺失的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/tupleobject.c</span></span><br><span class="line"></span><br><span class="line">PyTypeObject PyTuple_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">"tuple"</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyTupleObject) - <span class="keyword">sizeof</span>(PyObject *),</span><br><span class="line">    <span class="keyword">sizeof</span>(PyObject *),</span><br><span class="line">    (destructor)tupledealloc,                   <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_vectorcall_offset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_async */</span></span><br><span class="line">    (reprfunc)tuplerepr,                        <span class="comment">/* tp_repr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_number */</span></span><br><span class="line">    &amp;tuple_as_sequence,                         <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    &amp;tuple_as_mapping,                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)tuplehash,                        <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |</span><br><span class="line">        Py_TPFLAGS_BASETYPE | Py_TPFLAGS_TUPLE_SUBCLASS, <span class="comment">/* tp_flags */</span></span><br><span class="line">    tuple_new__doc__,                           <span class="comment">/* tp_doc */</span></span><br><span class="line">    (traverseproc)tupletraverse,                <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    tuplerichcompare,                           <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    tuple_iter,                                 <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    tuple_methods,                              <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    tuple_new,                                  <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_GC_Del,                            <span class="comment">/* tp_free */</span></span><br><span class="line">    .tp_vectorcall = tuple_vectorcall,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PySequenceMethods tuple_as_sequence = &#123;</span><br><span class="line">    (lenfunc)tuplelength,                       <span class="comment">/* sq_length */</span></span><br><span class="line">    (binaryfunc)tupleconcat,                    <span class="comment">/* sq_concat */</span></span><br><span class="line">    (ssizeargfunc)tuplerepeat,                  <span class="comment">/* sq_repeat */</span></span><br><span class="line">    (ssizeargfunc)tupleitem,                    <span class="comment">/* sq_item */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* sq_slice */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* sq_ass_item */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* sq_ass_slice */</span></span><br><span class="line">    (objobjproc)tuplecontains,                  <span class="comment">/* sq_contains */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyMappingMethods tuple_as_mapping = &#123;</span><br><span class="line">    (lenfunc)tuplelength,</span><br><span class="line">    (binaryfunc)tuplesubscript,</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>PyMappingMethods</code>中，tuple作为<code>mapping</code>没有指定<code>mp_ass_subscript</code>，作为<code>sequence</code>也没有指定<code>sq_ass_item</code>、<code>sq_ass_slice</code>。所以自然而然，原生不支持赋值操作<br>​</p>
<p>所以，list元素可变而tuple元素不可变，要解释这个问题可以这样阐述：<strong>tuple作为<code>mapping</code>或者<code>sequence</code>，没有指定赋值操作的回调函数，所以其元素不可变。而list有对应的操作回调支持，所以可变。</strong><br>​</p>
<h2 id="tuple的元素能够“可变”吗？"><a href="#tuple的元素能够“可变”吗？" class="headerlink" title="tuple的元素能够“可变”吗？"></a>tuple的元素能够“可变”吗？</h2><p>当然可以，但是需要魔改Python源代码。我们可以仿写<code>list_ass_subscript</code>去实现tuple的赋值操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/tupleobject.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =========================== 以下是魔改代码 =============================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">tuple_ass_item(PyTupleObject* a, Py_ssize_t i, PyObject* v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!((<span class="keyword">size_t</span>)i &lt; (<span class="keyword">size_t</span>)Py_SIZE(a)))</span><br><span class="line">    &#123;</span><br><span class="line">        PyErr_SetString(PyExc_IndexError,</span><br><span class="line">            <span class="string">"tuple assignment index out of range"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PyErr_SetString(PyExc_IndexError,</span><br><span class="line">            <span class="string">"tuple assignment does not support null value"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    Py_SETREF(a-&gt;ob_item[i], v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">tuple_ass_subscript(PyTupleObject* self, PyObject* item, PyObject* value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_PyIndex_Check(item))</span><br><span class="line">    &#123;</span><br><span class="line">        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span> &amp;&amp; PyErr_Occurred())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i += PyTuple_GET_SIZE(self);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tuple_ass_item(self, i, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">            <span class="string">"tuple index must be integer! not %.200s"</span>,</span><br><span class="line">            Py_TYPE(item)-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =========================== 以上是魔改代码 =============================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyMappingMethods tuple_as_mapping = &#123;</span><br><span class="line">    (lenfunc)tuplelength,</span><br><span class="line">    (binaryfunc)tuplesubscript,</span><br><span class="line">    <span class="comment">// 0</span></span><br><span class="line">    (objobjargproc)tuple_ass_subscript  <span class="comment">// 这里原来是0，现在得是tuple_ass_subscript</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们就加上tuple作为<code>mapping</code>时候的赋值操作即可，代码逻辑也和list的基本一样。编译新的python试试看吧</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tp = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">tp[<span class="number">2</span>] = <span class="number">5</span></span><br><span class="line">print(tp)  <span class="comment"># (1, 2, 5)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Medium Python</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>python</tag>
        <tag>list</tag>
        <tag>tuple</tag>
        <tag>元组</tag>
      </tags>
  </entry>
  <entry>
    <title>【Medium Python】前言</title>
    <url>/2021/10/10/mediumpython/preface/</url>
    <content><![CDATA[<p>python作为最流行的语言之一，我们对python的认知到底有多少呢？大胆猜测，95%的同学对python的了解都不超过5%吧！不用说python的c源码了，就算是python每个标准库的.py源码，都有很少人去关心。结论就是，我们对python本身的理解是远远不够的，比想象中还不够！当然，这也可能是python的语言特性导致的吧，在设计方面就不需要我们去多想。</p>
<p>python的岗位众多，网上的教材跟面试题也很多，然而很多都是八股文，浅尝辄止，鲜有深度的挖掘，让人知其然而不知其所以然，处处透露着对技术的不敬！想想看，游戏程序员学lua，一些C Library的实现、Lua底层机理都需要熟悉，python比lua应用会更加广泛，为什么就不可以去熟悉类似的东西呢？python的应用场景那么多，不去深入了解这门语言的实现，怎么能够更好掌控这门语言？怎么可能做出更加优秀的产品？</p>
<p>因此笔者决定，从一些所谓的python面试题出发，通过源码分析的方法，挖掘其思路与实现，让更多人对python有更加深入的了解。这个系列，会把一些本该属于python教程里的东西给展现出来，取名就叫做Medium Python——因为笔者刚出道（谈恋爱）时，已经写过<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wL2NhdGVnb3JpZXMvRWFzeS1QeXRob24v" title="https://utmhikari.top/categories/Easy-Python/">Easy Python<i class="fa fa-external-link"></i></span>，里面罗列了些python的简单知识。至于未来有没有Hard Python，到时候再说吧！</p>
<h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjEvMTAvMTcvbWVkaXVtcHl0aG9uL2kv" title="https://utmhikari.top/2021/10/17/mediumpython/i/">【Medium Python】第一话：为什么list“可变”，而tuple“不可变”？<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjEvMTAvMjMvbWVkaXVtcHl0aG9uL2lpLw==" title="https://utmhikari.top/2021/10/23/mediumpython/ii/">【Medium Python】第二话：dict的keys()返回了什么数据类型？<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjEvMTAvMzAvbWVkaXVtcHl0aG9uL2lpaS8=" title="https://utmhikari.top/2021/10/30/mediumpython/iii/">【Medium Python】第三话：python多线程为什么不能并行？<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjEvMTEvMDYvbWVkaXVtcHl0aG9uL2l2Lw==" title="https://utmhikari.top/2021/11/06/mediumpython/iv/">【Medium Python】第四话：类属性和实例属性是怎样的关系？<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjEvMTEvMTMvbWVkaXVtcHl0aG9uL3Yv" title="https://utmhikari.top/2021/11/13/mediumpython/v/">【Medium Python】最终话：如何彻底理解with关键字的用法？<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Medium Python</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>源码分析</tag>
        <tag>python</tag>
        <tag>面试</tag>
        <tag>Easy Python</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python随笔】如何访问类实例里带双下划线的属性</title>
    <url>/2021/10/06/pythonnotes/attr_with_underscore/</url>
    <content><![CDATA[<p>学过python的我们都知道在python的类实例instance的<code>__init__</code>函数里，可以初始化这个instance的属性。属性的命名有许多种，比如有一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self._gender = gender</span><br><span class="line">        self.__age = age</span><br></pre></td></tr></table></figure>
<p>这三种属性名分别是：不带下划线、带一个下划线、带两个下划线</p>
<p>假设有一个类<code>Student</code>的实例<code>student</code>，我们通过访问<code>student.name</code>、<code>student._gender</code>，是能够获得对应属性值的，但访问<code>student.__age</code>却报了如下错误：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AttributeError: &apos;Student&apos; object has no attribute &apos;__age&apos;</span><br></pre></td></tr></table></figure>
<p>这是为什么呢？难道在外面就不能访问这个<code>__age</code>属性了吗？</p>
<p>首先，要做到访问<code>__age</code>属性，最符合编程意图的方法就是加一个与<code>age</code>关联的<code>property</code>来访问。但本文不采用这种方法，本文提供一个直接访问<code>__age</code>属性的方法。</p>
<p>我们可以打印<code>student.__dict__</code>，来查看<code>student</code>实例的属性表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&apos;name&apos;: &apos;haha&apos;, &apos;_gender&apos;: &apos;male&apos;, &apos;_Student__age&apos;: 12&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现，属性表里没有<code>__age</code>属性，而多了一个<code>_Student__age</code>属性。为什么会这样呢？这是因为在代码编译器期有<code>name mangling</code>机制，用中文翻译叫做“命名混淆”比较贴切，python编译器识别了带双下划线的类实例属性，就会在前面加一个下划线+类名的前缀，于是属性名就变成了<code>_Student__age</code>。</p>
<p>通过访问<code>student._Student__age</code>，我们就能得到<code>__age</code>属性了。这便是直接访问双下划线属性的方法。</p>
]]></content>
      <categories>
        <category>Python随笔</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>下划线</tag>
        <tag>name mangling</tag>
        <tag>属性</tag>
        <tag>instance</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python随笔】用C++编写Python的扩展模块</title>
    <url>/2021/10/05/pythonnotes/python_c_extension/</url>
    <content><![CDATA[<p>近期笔者在研究python内部部分模块的实现机理，研究着研究着就开始硬刚C源码了。想着先前工作或是日常也没有体验过用C++编写python库，于是就刚好学习了一下。</p>
<p>用C或者C++编写python的扩展库，建议用Visual Studio宇宙第一IDE，一来能够同时支持python跟C，二来调试功能非常强大。入门上手的话，可以参考下面的文档：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvemgtY24vMy9leHRlbmRpbmcvaW5kZXguaHRtbA==" title="https://docs.python.org/zh-cn/3/extending/index.html">官网文档：扩展和嵌入 Python 解释器<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdmlzdWFsc3R1ZGlvL3B5dGhvbi93b3JraW5nLXdpdGgtYy1jcHAtcHl0aG9uLWluLXZpc3VhbC1zdHVkaW8/dmlldz12cy0yMDE5" title="https://docs.microsoft.com/en-us/visualstudio/python/working-with-c-cpp-python-in-visual-studio?view=vs-2019">VS文档：Create a C++ extension for Python<i class="fa fa-external-link"></i></span></li>
</ul>
<p>编写的库叫做<code>cplayground</code>，只包含一个hack函数<code>tuple_setitem</code>——强行设置tuple的元素（python默认是不支持的）。我们可以来看这样的python扩展用C++该如何实现：</p>
<a id="more"></a>
<p>首先参考上面的VS文档<code>Create a C++ extension for Python</code>，部署基础环境，一个Solution里需要包含用于测试的Python Project以及用来编写扩展的C++ Project。环境部署有几个要点需要注意：</p>
<ul>
<li>由于是编写扩展，需要编译为dll，文件后缀名为.pyd</li>
<li>确认下libs有没有debug库，没有的话Preprocessor跟Code Generation的设置都不能带debug</li>
<li>python项目的Debug设置里，解释器参数加上<code>-i</code>，且启用native code debugging，这样才能在python跟c代码打断点调试</li>
<li>可以写一个最简的框架先尝试build成功，并且能顺利装到对应python的packages里，跑通整个流程先<ul>
<li><code>setup.py</code>中注意模块名字要全部对应上</li>
</ul>
</li>
</ul>
<p>值得一提的是，如果VS没有预装python发行版本，VS自带的python环境管理模块也能检测到你以前另外安装的python，所以不用担心python环境方面的问题。</p>
<p>搭好整个框架流程之后，我们可以实现<code>tuple_setitem</code>具体的逻辑了。整个cpp代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cplayground.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PY_SSIZE_T_CLEAN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* tuple_setitem: a hack method to set item of tuple */</span></span><br><span class="line">PyObject*</span><br><span class="line">tuple_setitem(PyObject* self, PyObject* args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// parse args</span></span><br><span class="line">    PyObject *tuple, *value;</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTuple(args, <span class="string">"OiO"</span>, &amp;tuple, &amp;idx, &amp;value))</span><br><span class="line">    &#123;</span><br><span class="line">        Py_RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// check tuple</span></span><br><span class="line">    <span class="keyword">if</span> (!PyTuple_Check(tuple))</span><br><span class="line">    &#123;</span><br><span class="line">        PyErr_Format(</span><br><span class="line">            PyExc_TypeError,</span><br><span class="line">            <span class="string">"invalid tuple, %.200s"</span>,</span><br><span class="line">            Py_TYPE(tuple)-&gt;tp_name</span><br><span class="line">        );</span><br><span class="line">        Py_RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    PyTupleObject* tp = (PyTupleObject*)tuple;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handle index below zero</span></span><br><span class="line">    <span class="keyword">if</span> (idx &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        idx += PyTuple_GET_SIZE(tp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check index range</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">size_t</span>)idx &gt;= (<span class="keyword">size_t</span>)Py_SIZE(tp))</span><br><span class="line">    &#123;</span><br><span class="line">        PyErr_SetString(</span><br><span class="line">            PyExc_IndexError,</span><br><span class="line">            <span class="string">"tuple index out of range"</span></span><br><span class="line">        );</span><br><span class="line">        Py_RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set value by index</span></span><br><span class="line">    Py_INCREF(value);</span><br><span class="line">    Py_SETREF(tp-&gt;ob_item[idx], value);</span><br><span class="line">    Py_RETURN_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyMethodDef cplayground_methods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"tuple_setitem"</span>,</span><br><span class="line">        (PyCFunction)tuple_setitem,</span><br><span class="line">        METH_VARARGS,</span><br><span class="line">        <span class="string">"a hack method to set value in tuple"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyModuleDef cplayground_module = &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">"cplayground"</span>,  <span class="comment">// module name</span></span><br><span class="line">    <span class="string">"a c-python extension for testing"</span>,  <span class="comment">// module desc</span></span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    cplayground_methods</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line">PyInit_cplayground()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;cplayground_module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在模块的cpp实现中，顶头必须要<code>#include &lt;Python.h&gt;</code>，之后我们可以把自己需要暴露出去的函数给实现了（这里可以看到模块的主cpp文件能够起到胶水层的作用，如果此时有其它头文件里定义了一系列接口，就可以在这个文件里把这些接口适配为python可识别的函数模式）。实现完成之后，通过<code>method def</code>跟<code>module def</code>定义接口列表跟模块，然后再在下面定义模块启动函数，一个python的C扩展就诞生了。</p>
<p>那么怎么实现<code>tuple_setitem</code>的逻辑呢？我们需要预想下python端如何调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cplayground</span><br><span class="line"></span><br><span class="line">tp = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">cplayground.tuple_setitem(tp, <span class="number">0</span>, <span class="string">'haha'</span>)  <span class="comment"># 设置第一个元素为字符串'haha'</span></span><br></pre></td></tr></table></figure>
<p>在C层的实现上，<code>tuple_setitem</code>的签名是两个参数：<strong>module自己的引用、打包的参数集合</strong>，都是<code>PyObject*</code>。</p>
<p>首先第一步是通过<code>PyArg_ParseTuple</code>看是否能用对应的模式解包参数。关于参数的模式，可以参考<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9jLWFwaS9hcmcuaHRtbA==" title="https://docs.python.org/3/c-api/arg.html">这个文档<i class="fa fa-external-link"></i></span>。</p>
<p>之后需要对解包的参数再检查，比如检查解出来的<code>PyObject* tuple</code>是否真正是<code>tuple object</code>，以及计算索引是不是有溢出的情况。</p>
<p>最后通过<code>Py_SETREF</code>，就能把传进来的元组的内部元素重置。整个实现过程，其实是参考了<code>list object</code>的相关实现，有兴趣的同学可以深入探索一下（预告：在后面的文章里也会提到这个）。</p>
<p>整个小项目都放到了<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9weWNleHRfcGxheWdyb3VuZA==" title="https://github.com/utmhikari/pycext_playground">github<i class="fa fa-external-link"></i></span>上，是一个sln。如果要测试的话，clone之后需要注意重新走一遍环境配置的过程，确认配置无误。</p>
]]></content>
      <categories>
        <category>Python随笔</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>C++</tag>
        <tag>python扩展模块</tag>
        <tag>Visual Studio</tag>
        <tag>cplayground</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】《测试架构师修炼之道》阅读笔记</title>
    <url>/2021/10/04/testlife/test_architect_notes/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYW1hem9uLmNuL2RwL0IwMUVZOEo1QzI=" title="https://www.amazon.cn/dp/B01EY8J5C2">《测试架构师修炼之道》<i class="fa fa-external-link"></i></span>一书，笔者入行一年多的时候拜读过。虽然这本书主要偏向业务测试、质量管理的方向，而并非技术测试、测试开发的方向，但只要是测试行业从业者，笔者认为都值得一看。</p>
<p>从笔者本人角度，对于测试人员的职业发展，是极端推崇技术方向的。但工作最终总会落实到人，近年来测试被划分为偏向技术的岗位，那么技术本身就一定要搞起来，这样才能使得这类职业能够在工作框架体系里处于不屈之地。</p>
<p>但即便如此，测试本身也有很多技术/管理方法论的积淀，有很多old school的东西是值得尊重的。不论技术做成什么样，从测试工作的最终目标而言，都需要贴合传统测试遗留下来的的概念。《测试架构师修炼之道》一书，对传统测试，尤其质量管理方向相关的知识点、工作目标、工作方法都概括的非常明确，是测试行业不可多得的智慧积淀（嗯，测试行业确实缺乏沉淀！）。</p>
<p>技术方向的测试同学阅读这本书，能够更好地把握技术研发的方向；业务方向的测试同学阅读这本书，能够更全面地规划自己的发展。</p>
<p>在阅读的过程中，笔者也做了相关的读书笔记，提炼了其中的精要。本文也将把笔者的读书笔记全部分享出来：</p>
<a id="more"></a>
<h2 id="第一章：软件测试工程师的“三年之痒”"><a href="#第一章：软件测试工程师的“三年之痒”" class="headerlink" title="第一章：软件测试工程师的“三年之痒”"></a>第一章：软件测试工程师的“三年之痒”</h2><p>第三年的瓶颈：基本的技术与业务都已掌握，但不知道该如何深入，工作缺乏挑战性与成就感</p>
<p>软件测试的能力：</p>
<ul>
<li>对整个系统有整体把握</li>
<li>站在用户（玩家）角度理解需求</li>
<li>技术+产品技能</li>
</ul>
<h2 id="第二章：软件测试工程师的职业规划"><a href="#第二章：软件测试工程师的职业规划" class="headerlink" title="第二章：软件测试工程师的职业规划"></a>第二章：软件测试工程师的职业规划</h2><h3 id="职业规划路线"><a href="#职业规划路线" class="headerlink" title="职业规划路线"></a>职业规划路线</h3><p>测试工程师的两条路：</p>
<ul>
<li>管理（测试主管、PM）</li>
<li>技术（工具、平台、专项）</li>
</ul>
<h4 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h4><ul>
<li>初级（组长）：负责产品一个/多个特性（P6、P7）</li>
<li>中级（主管）：管理10~20人团队，制定、评估测试计划，评估产品质量（P7、P8）</li>
<li>高级（总监）：理解产品商业目标，团队人才管理，财务资源规划，改进产品测试效率与质量（P9+）</li>
</ul>
<h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h4><ul>
<li>产品测试专家<ul>
<li>业务需求向测试转换过程的桥梁，负责测试架构设计</li>
<li>对测试重点与难点进行攻关，提供最优方法</li>
<li>协助测试经理指定测试计划与进度</li>
<li>战略规划、业务建模、数据分析、产品生命周期质量保证</li>
<li>测试技术的涉猎（为产品服务）</li>
</ul>
</li>
<li>专项<ul>
<li>性能、可靠性、安全测试</li>
<li>技术共性的研究：测试设计、缺陷分析、探索性&amp;自动化（测试执行）、测试流程、安全性&amp;兼容性（功能性）、性能、可靠性、可移植性（可安装性）、易用性、可维护性（稳定&amp;可测试）</li>
</ul>
</li>
</ul>
<h4 id="九段秘书-amp-六段测试"><a href="#九段秘书-amp-六段测试" class="headerlink" title="九段秘书&amp;六段测试"></a>九段秘书&amp;六段测试</h4><ul>
<li>四段——深入理解产品质量，了解产品性能、可靠性、易用性等非功能属性测试，能够运用测试缺陷分析技术评估产品质量。</li>
<li>五段——推动测试技术进步，不断追求最适合产品的技术。</li>
<li>六段——缺陷预防，测试方法标准化，固化为测试工具和流程。</li>
</ul>
<h4 id="质量与测试"><a href="#质量与测试" class="headerlink" title="质量与测试"></a>质量与测试</h4><ul>
<li>质量关注大的产品流程</li>
<li>测试关注产品的小质量，除此之外，还有交付质量、经营质量等环节</li>
<li>软件测试在质量领域的发展<ul>
<li>产品流程设计</li>
<li>质量管理者（策划、控制与改进）</li>
<li>客户满意度管理</li>
</ul>
</li>
</ul>
<h2 id="第三章：软件测试架构师应该做和不该做的事情"><a href="#第三章：软件测试架构师应该做和不该做的事情" class="headerlink" title="第三章：软件测试架构师应该做和不该做的事情"></a>第三章：软件测试架构师应该做和不该做的事情</h2><p>产品测试是端到端的</p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ul>
<li>理解需求<ul>
<li>理解商业目标<ul>
<li>客户/细分客户</li>
<li>市场趋势</li>
<li>竞争对手</li>
<li>产品是否体现市场价值</li>
<li>测试策略是否和营销目标一致</li>
</ul>
</li>
<li>梳理用户使用场景<ul>
<li>产品有什么类型的用户</li>
<li>用户的业务是什么</li>
<li>竞争对手的解决方案/差异</li>
<li>产品的规范要求、行业背景、用户习惯</li>
<li>场景的输入与输出</li>
</ul>
</li>
</ul>
</li>
<li>测试策略<ul>
<li>测试范围</li>
<li>测试重点：产品价值、质量目标、代码实现、历史测试情况</li>
<li>测试目标</li>
<li>测试深度：测试方法多样性（边界值、异常值等）</li>
<li>测试广度：业务覆盖度</li>
</ul>
</li>
</ul>
<h3 id="测试分析和设计"><a href="#测试分析和设计" class="headerlink" title="测试分析和设计"></a>测试分析和设计</h3><ul>
<li>阶段测试策略<ul>
<li>V模型（需求分析-&gt;编码，单元/集成/系统/验收测试）</li>
<li>出入口准则</li>
<li>分解总体测试策略</li>
</ul>
</li>
<li>按照设计方案落实</li>
</ul>
<h3 id="测试执行"><a href="#测试执行" class="headerlink" title="测试执行"></a>测试执行</h3><ul>
<li>版本测试策略<ul>
<li>测试范围与计划的偏差</li>
<li>测试目标、用例</li>
<li>测试重点关注内容与执行顺序</li>
<li>回归&amp;自动化等测试方法</li>
</ul>
</li>
<li>跟踪测试执行<ul>
<li>跟踪用例执行情况</li>
<li>缺陷跟踪</li>
<li>调整测试策略</li>
<li>不仅仅是发现bug，而是记录与跟进</li>
</ul>
</li>
<li>建立版本质量档案<ul>
<li>质量目标：商用、demo等</li>
<li>目标分解：覆盖度/测试过程/缺陷情况</li>
<li>分类：老特性变化/新特性研发</li>
<li>优先级</li>
</ul>
</li>
</ul>
<h3 id="质量评估"><a href="#质量评估" class="headerlink" title="质量评估"></a>质量评估</h3><ul>
<li>能否进入下一阶段测试？<ul>
<li>质量目标是否达到</li>
<li>未达到的一般性质量目标如何应对</li>
<li>遗留缺陷分析</li>
</ul>
</li>
</ul>
<h3 id="测试经理、测试架构师与系统架构师"><a href="#测试经理、测试架构师与系统架构师" class="headerlink" title="测试经理、测试架构师与系统架构师"></a>测试经理、测试架构师与系统架构师</h3><ul>
<li>测试经理<ul>
<li>制定测试计划（PM）</li>
<li>通过协调调度保证测试顺利进行</li>
</ul>
</li>
<li>测试架构师<ul>
<li>制定测试策略</li>
<li>验证产品是否展现应有的价值，满足用户需求</li>
<li>理解框架，使得测试设计与执行更加有效</li>
</ul>
</li>
<li>系统架构师<ul>
<li>如何创造产品，实现产品价值</li>
<li>如何实现以满足用户需求</li>
<li>需要与测试架构师一起整理user story</li>
</ul>
</li>
</ul>
<h2 id="第四章：软件测试架构师的知识能力模型"><a href="#第四章：软件测试架构师的知识能力模型" class="headerlink" title="第四章：软件测试架构师的知识能力模型"></a>第四章：软件测试架构师的知识能力模型</h2><h3 id="软件产品质量模型"><a href="#软件产品质量模型" class="headerlink" title="软件产品质量模型"></a>软件产品质量模型</h3><p>验证是否符合需求-&gt;非功能/隐性需求？</p>
<p>质量六属性：</p>
<ul>
<li>功能性</li>
<li>可靠性</li>
<li>易用性</li>
<li>效率</li>
<li>可维护性</li>
<li>可移植性</li>
</ul>
<h4 id="功能性"><a href="#功能性" class="headerlink" title="功能性"></a>功能性</h4><p>指定条件下使用时，满足显性/隐性功能的能力</p>
<ul>
<li>适合性：满足用户基本需求</li>
<li>准确性：结果与精度正确，表达内容无误</li>
<li>互操作性：多特性能够相互配合</li>
<li>安全性</li>
<li>功能顺从性：符合功能相关标准规范</li>
</ul>
<h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><ul>
<li>成熟性：避免因故障而失效</li>
<li>容错性：发生故障/违反接口约定（异常值）情况下，维持规定的性能级别的能力</li>
<li>可恢复性：软件失效情况下，重建规定性能级别并恢复受直接数据影响的能力</li>
<li>可靠性顺从性：符合可靠性规范</li>
</ul>
<h4 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h4><p>从用户习惯的角度</p>
<ul>
<li>易理解性</li>
<li>易学性</li>
<li>易操作性</li>
<li>吸引性</li>
<li>易用性的依从性：遵循易用性相关标准与风格的程度</li>
</ul>
<h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><p>产品性能</p>
<ul>
<li>时间特性：提供适当响应和处理时间以及流量/吞吐量的能力</li>
<li>资源利用率：执行功能时，使用合适数量/类别的资源的能力</li>
<li>效率依从性：遵循相关性能指标的程度</li>
</ul>
<h4 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h4><p>可被修改的能力</p>
<ul>
<li>可分析性：诊断软件缺陷/失效原因/修改部分识别的能力</li>
<li>可修改性：软件产品能够被修改的能力</li>
<li>稳定性：软件产品不会因为修改而造成意外结果的能力（体现可修改的容易程度）</li>
<li>可测试性：软件产品已修改的部分能够被确认修复的能力</li>
<li>可维护性依从性：遵循相关标准/约定的能力</li>
</ul>
<h4 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h4><p>从一种环境迁移到另外一种环境的能力</p>
<ul>
<li>适应性：无需采用额外手段便可适应不同环境的能力（多OS兼容）</li>
<li>可安装性：在指定环境中被安装的能力（是否易安装？）</li>
<li>共存性：和环境中其它软件共存的能力（与效率/性能相关）</li>
<li>易替换性：在同样环境下替代另一个相同用途产品的能力</li>
<li>可移植性的依从性：遵循可移植的标准/约定的能力</li>
</ul>
<h3 id="测试类型"><a href="#测试类型" class="headerlink" title="测试类型"></a>测试类型</h3><ul>
<li>功能测试：产品能否满足用户特定功能要求并做出正确响应</li>
<li>安全性测试：产品是否有保护数据的能力，能在合适范围承受恶意攻击</li>
<li>兼容性测试：能够和其他相关产品/平台顺利对接（操作系统）</li>
<li>配置测试：是否能在推荐配置上流畅运行，是否会出现输入故障</li>
<li>可靠性测试：在长时间运行能否保证系统的性能水平，存在异常情况下系统是否依然可靠</li>
<li>易用性测试：产品是否易于理解、学习与操作</li>
<li>性能测试：时间/资源的使用</li>
<li>安装测试：产品是否能被安装与正确运行</li>
</ul>
<h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><p>车轮图——围绕产品质量模型的相应测试方法</p>
<h4 id="功能测试方法"><a href="#功能测试方法" class="headerlink" title="功能测试方法"></a>功能测试方法</h4><ul>
<li>单运行正常值输入法<ul>
<li>测试用户发送email，收件人地址、发件人地址、邮件内容、标题、优先级等，都是输入。测试这些的正确性，即为单运行正常值输入。</li>
<li>输入有限（邮件优先级）：遍历</li>
<li>输入无限（邮件内容）：等价类</li>
</ul>
</li>
<li>单运行边界值输入法<ul>
<li>输入边界值、超越边界的值、不合法的值与输入正常值进行对比</li>
</ul>
</li>
<li>多运行顺序执行法<ul>
<li>考虑用户习惯性的操作</li>
<li>比如用户“收到一封邮件”与“发送一封邮件”两个事件组合中，只有“用户收到一封邮件，又发送该封邮件”才是测试点，具有顺序性。而“用户收到一封邮件后发送任意一封邮件”与“用户发送一封邮件后再收到一个邮件”并非测试点，可以分开来测。</li>
</ul>
</li>
<li>多运行相互作用法<ul>
<li>考虑两种运行有业务上或者内在资源上的关联</li>
<li>“用户发邮件时，又收到一封邮件”就是相互作用的例子</li>
</ul>
</li>
</ul>
<p>单/多运行：测试人员的一次/多次操作或行为<br>从设计的角度划分功能，比如“用户和服务器建立了连接”这种叙述，并不算是运行<br>而“用户通过点击xxx” -&gt; 输出结果为和服务器建立了连接，前者算是“运行”<br>针对一个用户执行操作（多个用户，考虑可靠性测试法）</p>
<h4 id="可靠性测试方法"><a href="#可靠性测试方法" class="headerlink" title="可靠性测试方法"></a>可靠性测试方法</h4><ul>
<li>异常值输入法：采用系统不允许的输入值进行输入<ul>
<li>故障植入法：把系统放在有问题的环境中进行测试，输入仍然为正常值</li>
<li>弱网/断线重连</li>
<li>CPU、内存不足</li>
<li>软件冲突、驱动不正确</li>
<li>硬件问题</li>
</ul>
</li>
<li>稳定性测试法：在一段时间里，长时间大容量运行某种业务的一套方法<ul>
<li>低于性能测试的基准，考虑实际情况</li>
<li>增加操作数量</li>
<li>多个用户同时操作某功能</li>
<li>用户反复进行某操作</li>
<li>用户反复进行异常操作</li>
</ul>
</li>
<li>压力测试法：在一段时间里，持续使用超过系统规格的负载进行测试的方法<ul>
<li>在每个周期的某个小时段内，增大访问/操作量，持续一段时间</li>
<li>不允许业务失败</li>
</ul>
</li>
<li>恢复测试法：在持续超过负载进行一长段时间的测试后，再恢复原先的负载规格执行测试的方法<ul>
<li>持续进行超过规格的负载时，规格内的业务不是100%正确，可容忍宕机（考虑产品可靠性的要求）</li>
<li>当负载降到规格值之内后，业务必须100%正确</li>
</ul>
</li>
</ul>
<h4 id="性能测试方法"><a href="#性能测试方法" class="headerlink" title="性能测试方法"></a>性能测试方法</h4><ul>
<li>系统能够正确处理新业务的最大能力<ul>
<li>从分配资源到完成处理流程的速度</li>
<li>例子：每秒允许登录用户（开服PCU）、每秒能够主动发起多少次连接</li>
<li>考虑新业务的拆除（比如用户下线）</li>
</ul>
</li>
<li>并发：系统能够同时正确处理的最大业务的能力<ul>
<li>别的指标不能对并发指标造成影响</li>
</ul>
</li>
</ul>
<p>分析性能测试的影响因素：考虑用户发邮件，因变量为邮件大小（1bit～10MB）与邮件过滤策略（1～1000条），通过拟合曲线观察趋势。或者采用混合因变量的方法，模拟真实业务情况。</p>
<h4 id="易用性测试法"><a href="#易用性测试法" class="headerlink" title="易用性测试法"></a>易用性测试法</h4><ul>
<li>一致性：风格布局统一，操作提示是否符合设计规范等。最好有个checklist。</li>
<li>可用性：用户视角——功能是否易用？最好需要熟悉用户又熟悉测试的人（提测）<ul>
<li>完成某个业务场景配置需要的时间？</li>
<li>完成某个业务场景配置了多少步骤？</li>
<li>完成某个业务场景跳转了多少配置页面？</li>
<li>完成某个业务场景求助了几次？产品资料是否容易解决问题？</li>
</ul>
</li>
</ul>
<h3 id="测试设计技术"><a href="#测试设计技术" class="headerlink" title="测试设计技术"></a>测试设计技术</h3><h4 id="测试点与测试用例"><a href="#测试点与测试用例" class="headerlink" title="测试点与测试用例"></a>测试点与测试用例</h4><p>测试用例是测试点的加工，需要对测试点进行去重、合并、细化<br>需要保证用例的可执行性，是一份真正能够直到测试的说明书</p>
<h4 id="四步测试设计法"><a href="#四步测试设计法" class="headerlink" title="四步测试设计法"></a>四步测试设计法</h4><ul>
<li>建模<ul>
<li>流程（流程图）</li>
<li>参数（输入输出表）</li>
<li>数据（等价类分析表）</li>
<li>组合（因子表）</li>
</ul>
</li>
<li>设计基础测试用例：覆盖测试模型，确定测试条件</li>
<li>补充测试数据</li>
<li>扩展：针对容易发生缺陷的地方进一步增加用例</li>
</ul>
<h4 id="测试点的分类"><a href="#测试点的分类" class="headerlink" title="测试点的分类"></a>测试点的分类</h4><ul>
<li>流程类测试点：通过组合，形成一个完整的流程</li>
<li>参数类测试点：参数个数有限，可以遍历覆盖，系统会对不同参数有不同响应</li>
<li>数据类测试点：是一个范围，范围内的响应基本上是一样的</li>
<li>组合类测试点：流程、参数、数据的组合</li>
</ul>
<h4 id="流程类测试设计：路径分析法"><a href="#流程类测试设计：路径分析法" class="headerlink" title="流程类测试设计：路径分析法"></a>流程类测试设计：路径分析法</h4><ul>
<li>绘制业务流程图进行建模</li>
<li>对覆盖流程的各个路径进行分析，覆盖方法有：<ul>
<li>语句覆盖：所有判定和过程的最小路径集合</li>
<li>分支覆盖：覆盖系统中每个判定的所有分支所需的最小路径数</li>
<li>全覆盖：100%覆盖所有可能的路径</li>
<li>最小线性无关覆盖（常用）：每个路径片段至少被执行一次。<ul>
<li>线性无关路径（IP） = 边数 - 节点数 + 2 = 判定数 + 1 = 区域数 + 1</li>
</ul>
</li>
</ul>
</li>
<li>确定业务流程的所有子流程。对于每一个子流程，确定测试输入。</li>
</ul>
<h4 id="参数类测试设计：输入——输出表分析法"><a href="#参数类测试设计：输入——输出表分析法" class="headerlink" title="参数类测试设计：输入——输出表分析法"></a>参数类测试设计：输入——输出表分析法</h4><ul>
<li>列出相关的参数输入与输出</li>
<li>正常的输入参数/异常与正常的组合</li>
<li>排列组合后，根据业务的约束条件与控制变量法去重，得到输入——输出表</li>
<li>覆盖输入输出表，完成用例</li>
</ul>
<h4 id="数据类测试设计：等价类和边界值分析法"><a href="#数据类测试设计：等价类和边界值分析法" class="headerlink" title="数据类测试设计：等价类和边界值分析法"></a>数据类测试设计：等价类和边界值分析法</h4><ul>
<li>等价类：输入值按照测试效果划分，相同效果为一类</li>
<li>边界值：参数输入边界的取值</li>
<li>等价类分析表：在某个条件下，有效与无效输入等价类的表<ul>
<li>无效等价类一般针对单个因素</li>
<li>如果部分条件的等价类相似，可考虑合并这些条件。这样的话，某个条件下可测一部分有效/无效等价类，而另一个条件则测另一些有效/无效等价类。</li>
</ul>
</li>
</ul>
<h4 id="组合类测试设计：正交分析法"><a href="#组合类测试设计：正交分析法" class="headerlink" title="组合类测试设计：正交分析法"></a>组合类测试设计：正交分析法</h4><ul>
<li>采用因子表建模<ul>
<li>有约束关系，考虑拆表</li>
</ul>
</li>
<li>采用PICT工具生成测试用例（pairwise testing）</li>
<li>合并pairwise表，生成用例</li>
</ul>
<h4 id="控制用例粒度：测试点的组合与拆分"><a href="#控制用例粒度：测试点的组合与拆分" class="headerlink" title="控制用例粒度：测试点的组合与拆分"></a>控制用例粒度：测试点的组合与拆分</h4><ul>
<li>细粒度能够更加精确发现问题，但是用例数量会过多；粗粒度可以发现产品设计上、原型上的问题，但是可能测不到细节</li>
<li>不同阶段、不同业务功能，采取不同的粒度</li>
<li>策略覆盖：某些因子/数据类测试点在和其他测试点关系较弱的情况下，没有必要使用pairwise正交，可以考虑按比例在测试用例中进行分配</li>
<li>错误推断法：根据经验判断产品在哪些地方会出问题，针对这些问题设计测试用例</li>
</ul>
<h3 id="探索式测试"><a href="#探索式测试" class="headerlink" title="探索式测试"></a>探索式测试</h3><p>一边学习、一边设计、一边执行</p>
<h4 id="CPIE"><a href="#CPIE" class="headerlink" title="CPIE"></a>CPIE</h4><ul>
<li>收集（Collection）：收集并理解关于测试对象的信息</li>
<li>划分优先级（Prioritization）：对所有需要测试的任务进行优先级划分</li>
<li>分析调研（Investigation)：对测试任务仔细分析，预测可能输出的结果</li>
<li>实验（Experimentation）：进行测试实验，确认测试结果和预期是否符合，分析是否有必要改变测试策略与方法。若有必要则重新回到收集阶段。</li>
</ul>
<p>优点：更快测试，更快寻找到有效测试点，更高效发现缺陷<br>缺点：基本测试覆盖易不足，测试点不易复用</p>
<h4 id="选择合适的探索式测试方法"><a href="#选择合适的探索式测试方法" class="headerlink" title="选择合适的探索式测试方法"></a>选择合适的探索式测试方法</h4><ul>
<li>产品特性分区。根据不同分区，选择不同的探索测试方法<ul>
<li>历史区：老代码与特性<ul>
<li>恶邻测试法：缺陷多的代码段，需要多花时间</li>
<li>博物馆测试法：老的遗留代码与很久没有执行过的用例需要和新代码有相同的重视程度</li>
<li>上一版本测试法：检查新版本无法运行的测试用例，确保没有遗漏必须功能</li>
</ul>
</li>
<li>商业区：销售特性<ul>
<li>指南针测试法：通过阅读用户手册、场景、需求以进行测试</li>
<li>卖点测试法：对吸引用户的特性进行测试</li>
<li>地标测试法：寻找测试点，明确测试项</li>
<li>极限测试法：什么特性能使软件发挥极限？哪些输入会影响软件性能？</li>
<li>快递测试法：专注于数据从输入到输出的执行流程</li>
<li>深夜测试法：测试对象是否能自动完成任务？其中异常是否自动记录？</li>
<li>遍历测试法：选定一个测试目标，用最短路径访问目标包含的所有对象</li>
</ul>
</li>
<li>娱乐区：辅助特性<ul>
<li>配角测试法：专注于紧邻主要功能的辅助特性</li>
<li>深巷测试法：把最流行与最不流行的模块放在一起测</li>
<li>通宵测试法：测试软件长时间运行后，各模块是否正常</li>
</ul>
</li>
<li>破旧区：问题高发的特性<ul>
<li>破坏测试法：专注缺陷较多的代码段</li>
<li>反叛测试法：输入最不可能的数据</li>
<li>强迫症测试法：强迫一遍又一遍接受同样的数据</li>
</ul>
</li>
<li>旅馆区：平台或维护特性<ul>
<li>取消测试法：启动某些操作，然后停止，查看测试对象处理机制与反应</li>
<li>懒汉测试法：让程序自行处理空字段/运行默认值</li>
</ul>
</li>
<li>旅游区：噱头/一次性的特性——快速访问文件之类的各种功能<ul>
<li>收藏夹测试法：把软件可达的输出进行遍历与手机</li>
<li>长路径测试法：访问离应用程序开始点尽量远的特性，在到达目的地前尽可能在应用程序内穿行</li>
<li>超模测试法：关心表面的东西（UI显示）</li>
<li>测一送一测试法：测试同一个程序多开的情况</li>
</ul>
</li>
<li>其它区：代码变动、用户不关心但研发关心的内容<ul>
<li>内部测试法：收集这个功能哪些部分对确认测试结果、定位问题有用的测试输出，然后关心其效果</li>
<li>变动区测试法：分析版本变化，只针对变化内容测试</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="开展探索式测试"><a href="#开展探索式测试" class="headerlink" title="开展探索式测试"></a>开展探索式测试</h4><ul>
<li>确定任务——全局场景、特性漫游与局部功能点探索</li>
<li>根据任务设计探索地图<ul>
<li>现在测试什么，接下来测试什么</li>
<li>直接使用测试点测试</li>
<li>根据测试结果调整测试点</li>
<li>设定完成时间</li>
</ul>
</li>
<li>探索式测试总结<ul>
<li>哪些方法能够有效发现产品问题</li>
<li>测试过程存在什么不足</li>
</ul>
</li>
</ul>
<h3 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><h4 id="自动化的不足"><a href="#自动化的不足" class="headerlink" title="自动化的不足"></a>自动化的不足</h4><ul>
<li>成本高（维护、人力与技术）</li>
<li>脚本不一定可靠<ul>
<li>脚本难以捕获异常</li>
<li>失败的用例不一定是错误</li>
</ul>
</li>
<li>不能单靠测试解决<ul>
<li>需求、UI、命令行需要确定</li>
</ul>
</li>
</ul>
<h4 id="评估自动化的收益"><a href="#评估自动化的收益" class="headerlink" title="评估自动化的收益"></a>评估自动化的收益</h4><p>总成本 = 前期开发 + 后期维护成本</p>
<p>前期开发成本：人力、时间、金钱<br>后期维护成本：产品变更、定位/修复自动化运行环境可靠性与代码健壮性，以及其它杂项因素</p>
<p>自动化测试的收益 = 自动化测试的运行次数</p>
<p>实施成本计算方式：p = k * n / (c1 + c2)</p>
<ul>
<li>p：成本</li>
<li>k：手工执行自动化用例所花费时间成本</li>
<li>n：自动化用例执行次数</li>
<li>c1：前期成本</li>
<li>c2：后期维护成本</li>
</ul>
<h2 id="第五章：软件测试架构师的软能力修炼"><a href="#第五章：软件测试架构师的软能力修炼" class="headerlink" title="第五章：软件测试架构师的软能力修炼"></a>第五章：软件测试架构师的软能力修炼</h2><h3 id="沟通和协商"><a href="#沟通和协商" class="headerlink" title="沟通和协商"></a>沟通和协商</h3><p>基本沟通原则：尽早沟通，既要对事，也要对人——换位思考（了解项目各组成员的业务与立场）</p>
<h3 id="写好测试用例"><a href="#写好测试用例" class="headerlink" title="写好测试用例"></a>写好测试用例</h3><p>测试用例包含：</p>
<ul>
<li>用例标题（完整的句子，用条件描述）</li>
<li>前置条件</li>
<li>测试数据</li>
<li>测试步骤</li>
<li>预期结果（一种步骤，对应一种结果）</li>
</ul>
<h2 id="第六章：如何才能制定好测试策略"><a href="#第六章：如何才能制定好测试策略" class="headerlink" title="第六章：如何才能制定好测试策略"></a>第六章：如何才能制定好测试策略</h2><h3 id="测试策略"><a href="#测试策略" class="headerlink" title="测试策略"></a>测试策略</h3><ul>
<li>测试的对象和范围</li>
<li>测试的目标</li>
<li>测试的重点和难点</li>
<li>测试的深度和广度</li>
<li>如何安排各种测试活动</li>
<li>如何评价测试的效果</li>
</ul>
<p>与其它名词的不同：</p>
<ul>
<li>测试方针：产品测试通用要求、原则与底线</li>
<li>测试计划：测试策略的拆解与时间资源的分配</li>
<li>测试方案：解决在测试设计和执行方面的问题（上面6个）</li>
</ul>
<h3 id="四步测试策略制定法"><a href="#四步测试策略制定法" class="headerlink" title="四步测试策略制定法"></a>四步测试策略制定法</h3><ul>
<li>明确产品质量目标<ul>
<li>测试目标为满足质量目标</li>
<li>围绕目标进行刚刚好的测试</li>
<li>将目标——行为——评估形成闭环</li>
</ul>
</li>
<li>风险分析<ul>
<li>提前识别阻塞测试的风险，基于风险调整测试策略</li>
<li>基于风险加强和降低测试投入</li>
</ul>
</li>
<li>适配产品研发流程<ul>
<li>按照研发流程设计测试策略结构<ul>
<li>概念阶段（三方）制定总体测试策略</li>
<li>计划阶段制定阶段性测试策略</li>
</ul>
</li>
<li>根据研发流程安排测试活动</li>
</ul>
</li>
<li>测试分层<ul>
<li>将大的测试目标，分到不同层次中分阶段完成</li>
</ul>
</li>
</ul>
<h3 id="产品质量评估模型"><a href="#产品质量评估模型" class="headerlink" title="产品质量评估模型"></a>产品质量评估模型</h3><ul>
<li>多维度：覆盖质量评估各个维度</li>
<li>定量+定性：指标与分析结合</li>
<li>过程+结果：除了结果还要评估测试过程</li>
</ul>
<p>评估维度：</p>
<ul>
<li>测试覆盖度<ul>
<li>需求覆盖度评估<ul>
<li>已经验证测试的产品需求数：产品需求规格总数</li>
<li>目标为100%</li>
<li>建立需求表/用例与需求的映射关系</li>
</ul>
</li>
<li>路径覆盖度分析<ul>
<li>已经测试的语句数量：程序中可执行语句的总数</li>
<li>语句、分支、全、最小线性无关覆盖</li>
<li>确定覆盖策略，用路径分析法设计用例并跟踪执行</li>
</ul>
</li>
</ul>
</li>
<li>测试过程<ul>
<li>测试用例分析<ul>
<li>测试用例执行率<ul>
<li>已经执行的测试用例数目：测试用例总数</li>
<li>测试阻塞/未执行的测试用例，影响执行率</li>
</ul>
</li>
<li>测试用例执行通过率<ul>
<li>测试用例通过：已经执行测试用例数目</li>
</ul>
</li>
<li>测试用例和非测试用例发现缺陷比<ul>
<li>非测试用例为发散性的测试，这个比值不能过低，否则用例设计有问题</li>
</ul>
</li>
</ul>
</li>
<li>测试方法分析<ul>
<li>分析测试设计和测试方法是否符合</li>
<li>分析测试方法和测试策略是否符合</li>
<li>通过缺陷分析，反推测试方法的可行性</li>
</ul>
</li>
<li>测试投入分析<ul>
<li>测试人员安排与投入工作量</li>
</ul>
</li>
</ul>
</li>
<li>缺陷<ul>
<li>缺陷密度分析<ul>
<li>每千行代码发现的bug数</li>
<li>预测产品的缺陷数，评估当前发现的缺陷是否足够多</li>
</ul>
</li>
<li>缺陷修复情况分析<ul>
<li>缺陷修复率：已经修复缺陷：已经发现缺陷</li>
<li>在每个测试分层都要确定缺陷修复率目标</li>
<li>在每个分层结束判断是否能够进入下一阶段测试</li>
<li>如果最终缺陷修复率不能达到预期，理论上不能发布产品</li>
</ul>
</li>
<li>缺陷趋势分析<ul>
<li>判断当前系统是否能够很容易地发布缺陷</li>
<li>观察凹凸性和拐点，分析原因</li>
<li>发现缺陷与解决曲线趋势收敛：当前测试方法已经无法有效发信啊问题</li>
</ul>
</li>
<li>缺陷年龄分析<ul>
<li>定义：系统产生/引入缺陷的时间<ul>
<li>继承/历史遗留：属于历史版本、继承版本或移植代码出现的问题</li>
<li>需求阶段：需求不清、需求错误、系统整体设计的问题</li>
<li>设计阶段：功能接口/交互、边界值/流程/算法设计的问题</li>
<li>编码阶段：流程逻辑、算法、编程规范，接口规范的问题</li>
<li>新需求/变更：新需求或功能实现变更引发</li>
<li>缺陷修改：修改缺陷，引入了新的问题</li>
</ul>
</li>
<li>分析方法<ul>
<li>确定缺陷年龄（bugzilla）</li>
<li>统计各类缺陷年龄的数量，绘制缺陷年龄分析图</li>
<li>进行分析。理想情况如下：<ul>
<li>在缺陷的引入阶段就能及时发现该类缺陷，不会逃逸到下个阶段</li>
<li>在特定的分层发现该分层的问题</li>
<li>没有继承/历史遗留/新需求/缺陷修改引入的缺陷</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>缺陷触发因素分析<ul>
<li>缺陷触发因素越全面，说明测试方法越多，测试也会越深入</li>
<li>确定缺陷的确实方法和类型，统计缺陷数目，绘制缺陷触发因素柱状图分析</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="风险分析技术"><a href="#风险分析技术" class="headerlink" title="风险分析技术"></a>风险分析技术</h3><ul>
<li>分析对象：测试策略</li>
<li>分析目标：识别可能阻塞测试策略顺利进行的问题</li>
</ul>
<h4 id="风险识别"><a href="#风险识别" class="headerlink" title="风险识别"></a>风险识别</h4><ul>
<li>分析测试设计关注哪些内容，比如针对某个特性进行测试需要通过路径分析法覆盖，然后需要进行功能交互、压力测试、性能测试等测试手段</li>
<li>分析上述内容保证顺利进行，需要哪些条件，比如文档/沟通顺利、测试人员对场景有深厚理解、能够掌握测试方法等因素</li>
<li>根据缺失的因素，识别风险</li>
</ul>
<h4 id="风险评估"><a href="#风险评估" class="headerlink" title="风险评估"></a>风险评估</h4><ul>
<li>风险优先级正交表（风险影响程度 X 风险发生频率）</li>
<li>需求类风险<ul>
<li>需求质量不高，不足以支撑后续开发测试</li>
<li>开发测试都未能理解需求</li>
</ul>
</li>
<li>设计类风险<ul>
<li>设计正确性与全面性</li>
<li>测试容易发现缺陷吗？开发修复成本大吗？测试回归成本大吗？对用户影响大吗？</li>
</ul>
</li>
<li>风险应对<ul>
<li>回避、转移、减轻、改变</li>
</ul>
</li>
<li>老功能分析<ul>
<li>差异分析</li>
<li>历史测试情况分析<ul>
<li>老功能在新版本质量要求是否提升</li>
<li>老功能缺陷与测试方法分析</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="分层测试技术"><a href="#分层测试技术" class="headerlink" title="分层测试技术"></a>分层测试技术</h3><h4 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h4><p><img src="/uploads/testlife/test_architect_notes/v_model.png" alt="v模型" title="&#39;v模型&#39;"></p>
<ul>
<li>单元测试：产品实现函数单元</li>
<li>集成测试：产品模块与功能</li>
<li>系统测试：从系统角度验证功能是否正确</li>
<li>验收测试：从用户角度确认产品是否满足业务需求</li>
</ul>
<p>通信公司的分层：</p>
<ul>
<li>详细设计级<ul>
<li>模块级系统测试（MST）</li>
<li>联调（BBIT）</li>
</ul>
</li>
<li>概要设计级<ul>
<li>系统设计确认（SDV）</li>
<li>系统集成测试（SIT）</li>
<li>系统验证测试（SVT）</li>
</ul>
</li>
</ul>
<p>敏捷环境下的分层：</p>
<ul>
<li>单元测试</li>
<li>功能测试</li>
<li>非功能测试</li>
<li>探索测试</li>
</ul>
<h2 id="第七章：测试策略实战攻略"><a href="#第七章：测试策略实战攻略" class="headerlink" title="第七章：测试策略实战攻略"></a>第七章：测试策略实战攻略</h2><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>制定测试策略之前，需要进行信息收集，比如：</p>
<ul>
<li>项目的范围</li>
<li>人力投入</li>
<li>历史情况</li>
</ul>
<p>然后采用四步测试策略制定法：</p>
<ul>
<li>明确产品质量目标</li>
<li>进行风险分析</li>
<li>适配产品开发流程</li>
<li>进行测试分层</li>
</ul>
<p>产品分为4个等级：</p>
<ul>
<li>完全商用：完全满足用户需求，少量或者没有遗留问题，用户使用无限制</li>
<li>受限商用：特性无法满足用户特定场景，有普通以上的遗留问题，但有规避措施</li>
<li>测试、演示或者小范围试用：特性只满足用户部分需求，有严重以上遗留问题，无规避措施（Beta）</li>
<li>不能使用：特性无法满足用户需求，存在严重以上的遗留问题</li>
</ul>
<p>对产品每个特性，也根据四个质量等级来划分。将特性的质量目标确定后，就可以进行风险分析<br>风险分析后就能够确定测试策略的结构，可以采用总分式</p>
<ul>
<li>总体测试策略（概念与计划阶段）</li>
<li>阶段测试策略（计划与开发阶段）</li>
<li>测试执行（开发、验证、发布）</li>
</ul>
<h3 id="总体测试策略"><a href="#总体测试策略" class="headerlink" title="总体测试策略"></a>总体测试策略</h3><p>对质量目标进行分解，比如：</p>
<ul>
<li>测试覆盖度<ul>
<li>需求覆盖度</li>
<li>路径覆盖度</li>
</ul>
</li>
<li>测试过程<ul>
<li>用例执行率</li>
<li>测试用例与非测试用例发现缺陷比</li>
</ul>
</li>
<li>缺陷<ul>
<li>密度</li>
<li>修复率</li>
</ul>
</li>
</ul>
<p>并为每一个测试分层确定目标，采用老功能分析法对特性进行分类。</p>
<ul>
<li>哪些特性是新开发的</li>
<li>哪些是从老版本继承的</li>
<li>哪些特性的改动比较大</li>
<li>从老版本继承特性的历史情况</li>
</ul>
<p>新特性进行全面测试，老特性对变化的部分进行全面测试，没有变化的可以适量回归+探索</p>
<h4 id="测试深度和广度"><a href="#测试深度和广度" class="headerlink" title="测试深度和广度"></a>测试深度和广度</h4><ul>
<li>测试深度：测试过程中需要使用的测试方法</li>
<li>测试广度：测试的范围</li>
</ul>
<p>通过产品质量评估模型与老功能分析，可以初步确定测试深度：</p>
<ul>
<li>功能测试（demo只用功能测试即可）</li>
<li>性能测试</li>
<li>可靠性、易用性测试</li>
</ul>
<p>老功能分析可以用来确认测试广度：</p>
<ul>
<li>测试覆盖度、测试过程、缺陷，是否全面测试</li>
</ul>
<p>之后根据质量目标与分类，确定测试优先级与总体框架：</p>
<ul>
<li>策略层：总体、阶段、测试执行策略</li>
<li>活动层：测试分析、设计，单元、集成、系统、验收测试</li>
<li>保证层：需求、开发设计、测试设计review</li>
</ul>
<h3 id="阶段测试策略"><a href="#阶段测试策略" class="headerlink" title="阶段测试策略"></a>阶段测试策略</h3><p>采用测试分析设计表保证测试设计符合策略</p>
<ul>
<li>测试分析准备表<ul>
<li>被测对象配置在测试设计中需要考虑哪些测试方法以及功能交互</li>
<li>测试点的考虑：功能、安全、一致性、性能、易用性等</li>
<li>功能交互：安全特性、VLAN</li>
</ul>
</li>
<li>测试类型分析表<ul>
<li>对待分析的每一条需求，逐一分析各测试类型下是否有测试点</li>
</ul>
</li>
<li>功能交互分析表<ul>
<li>需要进行交互分析的功能与对应测试点的关系</li>
</ul>
</li>
</ul>
<p>之后可以对测试用例进行分级</p>
<h4 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h4><p>集成测试位于开发阶段，相当于联调。集成测试是黑盒性质的测试，包括以下几项：</p>
<ul>
<li>新合入功能是否正确</li>
<li>验证功能集成后系统功能的正确性</li>
<li>确认原来的系统功能没有被新合入的功能破坏</li>
</ul>
<p>集成测试的条件（入口准则）：</p>
<ul>
<li>计划的功能开发完成，完成了单元测试</li>
<li>功能集成完成，可测，提供用户的输入输出接口</li>
<li>测试团队做好准备<ul>
<li>测试用例已经输出，并通过评审</li>
<li>测试资源已经到位</li>
<li>测试环境已经准备好</li>
</ul>
</li>
</ul>
<p>集成测试结束条件（出口准则）：</p>
<ul>
<li>系统需要继承的功能已经全部开放，集成完成</li>
<li>计划执行的测试用例已经完成</li>
<li>缺陷分析的结果符合预期</li>
<li>达到了集成测试阶段的产品质量目标</li>
</ul>
<h4 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h4><p>系统测试主要是针对全局，而非像集成测试一样针对单个功能</p>
<ul>
<li>从系统角度验证测试功能的正确性</li>
<li>从系统角度来验证各种非功能的质量的正确性</li>
</ul>
<p>入口准则：</p>
<ul>
<li>集成测试的出口准则</li>
<li>测试团队已经做好准备</li>
</ul>
<p>系统测试会对功能、可靠性、性能、易用性等各方面进行测试，不考虑测试执行顺序容易阻塞，需要考虑以下情况：</p>
<ul>
<li>先进行稳定测试，再进行压力测试，最后进行恢复测试</li>
<li>先进行复杂的、难的测试用例，再进行简单的</li>
<li>将功能测试的测试用例和满规格的测试用例放在一起进行</li>
</ul>
<p>出口准则：</p>
<ul>
<li>计划执行的测试用例都已经完成</li>
<li>缺陷分析的结果符合预期</li>
<li>达到了系统测试阶段产品质量目标</li>
</ul>
<h4 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h4><p>产品发布前的测试，是对用户需求的确认</p>
<ul>
<li>Alpha测试<ul>
<li>由测试人员模拟用户进行的测试，应该是不太了解产品细节，但对用户非常了解的人。Alpha测试需要关注以下的内容：<ul>
<li>用户会如何学习产品？产品提供的帮助是否切实？</li>
<li>用户将产品安装在怎样的环境中？升级对用户的影响是否在容忍范围内？</li>
<li>用户环境中哪些业务时需要关注的？不需要关注的业务怎么处理？</li>
<li>etc</li>
</ul>
</li>
</ul>
</li>
<li>Beta测试<ul>
<li>由用户参加的测试，常见有如下两种：<ul>
<li>产品正式发布前将产品提前发给用户，收集反馈</li>
<li>产品开发完成后，交由用户对产品进行验收</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>验收测试的入口准则：</p>
<ul>
<li>系统测试的出口准则</li>
<li>Alpha测试人员、方案已经选好</li>
<li>Beta测试的用户已经确定</li>
</ul>
<p>出口准则：</p>
<ul>
<li>达到产品质量目标</li>
</ul>
<h2 id="第八章：版本测试策略和产品质量评估"><a href="#第八章：版本测试策略和产品质量评估" class="headerlink" title="第八章：版本测试策略和产品质量评估"></a>第八章：版本测试策略和产品质量评估</h2><p>版本测试时，应当有一份版本计划与一份测试计划，分别由开发人员和测试人员输出</p>
<ul>
<li>版本计划<ul>
<li>几个build，每个build合成什么功能</li>
</ul>
</li>
<li>测试计划<ul>
<li>集成测试、系统测试与验收测试需要测试多少个版本</li>
<li>每个版本的主要测试目标</li>
</ul>
</li>
</ul>
<p>版本测试主要工作是指定版本测试策略，然后跟进测试执行并进行评估。</p>
<h3 id="第一个版本测试策略"><a href="#第一个版本测试策略" class="headerlink" title="第一个版本测试策略"></a>第一个版本测试策略</h3><p>第一个版本策略的制定方式，也可以按照目标——风险——流程——顺序的思路来制定<br>当某一个build的提交并不完整的时候，可以根据对测试人员是否可测为基准，进行测试<br>对于测试目标，比较好的描述方式是：对某个功能（测试对象），进行哪些测试（测试方法），发现产品哪些方面的缺陷（测试结果）</p>
<p>每个版本测试策略中，需要注明哪些是重点关注的内容。首先要对提交功能进行分析，提出测试团队重点关注内容，其次要确定版本测试功能优先级表。实际开发过程中，不同功能可能分为不同的提交，因此测试功能的优先级需要实时定制更新，而后在版本策略中向测试团队说明。同时可以对测试用例进行分级，从而更加容易选择测试用例。</p>
<p>在测试执行顺序方面，可以遵循如下的原则：</p>
<ul>
<li>质量情况越好，就可以考虑将更多的测试方法组合起来执行</li>
<li>对刚提交的功能，在质量情况不明的情况下，不建议用组合测试法进行测试</li>
<li>先执行高优先级特性的测试用例，先进性复杂的、难的测试用例</li>
</ul>
<p>测试的时候会遇到一些全局因素，比如浏览器、测试工具、操作系统等运行环境，需要策略性地进行试探测试。也可在不同配置下，对相同功能进行测试。<br>“接收测试”指开发人员将版本转移给测试人员是，测试人员对这个版本进行一次测试，确认没有阻塞问题能够按照测试策略完成测试。有两种结果——通过和不通过，判断标准是是否有阻塞问题。如果不通过，但有规避阻塞地方法，可以继续进行测试。接收测试适合level1的测试用例。</p>
<h3 id="跟踪测试执行"><a href="#跟踪测试执行" class="headerlink" title="跟踪测试执行"></a>跟踪测试执行</h3><p>跟踪测试执行的目的有3个：</p>
<ul>
<li>确保测试团队按照测试策略来进行测试</li>
<li>实时关注缺陷，通过缺陷分析来确认测试策略是否合适，是否需要调整</li>
<li>关注项目中的实时风险，基于风险调整测试策略</li>
</ul>
<p>要保证测试团队按照测试策略来执行测试，需要保证以下三点：</p>
<ul>
<li>测试内容和测试策略中确定的范围、深度和广度一致<ul>
<li>测试用例和测试策略一致</li>
</ul>
</li>
<li>测试执行的顺序和测试策略一致<ul>
<li>测试团队是否按照特性优先级顺序执行测试用例</li>
<li>测试团队是否按照测试策略中的测试方法、测试顺序来执行测试用例</li>
</ul>
</li>
<li>计划测试的内容能够顺利执行<ul>
<li>原因：人力不足，时间不够，测试环境不具备，具有其它缺陷</li>
<li>缺陷跟踪<ul>
<li>缺陷趋势是否正常<ul>
<li>拐点预测：测试方法不同或测试方法不变测试对象不同，不应该出现拐点</li>
<li>判断拐点出现是否过早或者过晚</li>
</ul>
</li>
<li>是否存在因修改引入的缺陷</li>
<li>本版本中必须解决哪一些缺陷：会不会对后续测试造成阻塞，需要保证测试完整性</li>
<li>本版本中需要解决哪一些缺陷：阻塞的、改动大的、涉及需求方案设计的、致命和严重的</li>
</ul>
</li>
<li>调整测试策略<ul>
<li>被阻塞的功能较多的话，需要考虑是否提前结束测试</li>
<li>存在阻塞的功能，原计划不在本版本的用例，考虑是否可以调整到本版本中测试</li>
<li>没有阻塞的功能，原计划不在本版本的用例，考虑是否调整到本版本测试</li>
<li>拐点出现太早，说明当前测试方法不能有效发现缺陷，分析是否因测试阻塞造成</li>
<li>一直未出现拐点，说明当前测试方法能够有效发现缺陷，可以在下一阶段开始的1~2个版本中，增加一些和上一阶段测试相关的探索性测试</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="版本质量评估"><a href="#版本质量评估" class="headerlink" title="版本质量评估"></a>版本质量评估</h3><p>在进行下个版本测试之前，需要进行版本质量评估<br>质量评估的方法：</p>
<ul>
<li>记录需求和实现的偏差<ul>
<li>需求理解方的错误导致实现上的错误（开发与产品理解分歧）</li>
<li>需求没有提交完</li>
<li>记录相关的bug列表，三方讨论</li>
</ul>
</li>
<li>进行测试过程评估<ul>
<li>测试方法：总结哪些测试方法比较有效</li>
<li>测试投入</li>
<li>测试用例：是否执行完，通过率是多少（先评估质量指标是否有效），多个版本中执行结果情况如何<ul>
<li>某功能通过率不高，说明该功能质量可能不高，需要调整测试策略</li>
<li>项目初期关注首次通过率，其后关注累计通过率</li>
<li>测试用例在多版本执行结果出现反复，有可能因为新功能合入对旧功能造成影响，或者因为缺陷修改引入了新的结果</li>
</ul>
</li>
</ul>
</li>
<li>缺陷分析<ul>
<li>功能特性的缺陷密度是否正常</li>
<li>缺陷年龄分析是否正常<ul>
<li>缺陷引入阶段实时发现，不能遗留到下个阶段</li>
<li>在特定测试分层发现该层问题</li>
<li>没有继承/历史遗留/新需求变更/缺陷修改引入的缺陷</li>
</ul>
</li>
<li>缺陷触发因素分析是否正常</li>
</ul>
</li>
<li>调整测试策略：如果产生影响最终发布质量的问题，就需要采取措施</li>
<li>建立特性版本质量档案<ul>
<li>对当前测试覆盖度方面的记录，包括需求与实现的偏差</li>
<li>测试过程分析记录</li>
<li>缺陷分析</li>
</ul>
</li>
</ul>
<h3 id="后面版本测试策略"><a href="#后面版本测试策略" class="headerlink" title="后面版本测试策略"></a>后面版本测试策略</h3><ul>
<li>回归测试<ul>
<li>缺陷回归：验证缺陷是否被开发人员修复<ul>
<li>功能性缺陷：对缺陷本身与该功能相关交互验证</li>
<li>非功能性缺陷：对缺陷验证，分析缺陷修改是否对功能有影响</li>
<li>底层/中间层缺陷：控制这类缺陷在设计修改和编码上的质量</li>
</ul>
</li>
<li>功能回归：确认老功能不会因新合入功能而失效<ul>
<li>新开发功能合入版本后的回归</li>
<li>老功能回归：自动化测试</li>
</ul>
</li>
<li>阶段回归：确认产品当前质量达到该阶段的质量目标<ul>
<li>集成测试阶段：验证功能集成后正确性，满足出口条件（level 1级测试用例）</li>
<li>系统测试阶段：对重点功能进行测试</li>
<li>验收测试：对典型场景进行测试</li>
</ul>
</li>
</ul>
</li>
<li>探索式测试<ul>
<li>集成阶段中后期逐渐进行探索式测试，对新合入功能进行探索</li>
<li>系统测试阶段，对整个系统重点特性与辅助特性进行深入测试</li>
</ul>
</li>
<li>自动化测试<ul>
<li>先对需要多次执行的测试用例进行自动化，优先自动化简单的、可靠的功能</li>
</ul>
</li>
</ul>
<h3 id="阶段质量评估"><a href="#阶段质量评估" class="headerlink" title="阶段质量评估"></a>阶段质量评估</h3><p>在每个阶段完成时对整体质量进行评估，判断是否能够达到出口标准，进入下一阶段评估<br>质量评估可以按照质量评估模型进行评估，需要持续跟踪测试执行、评估版本与阶段质量。具体工作如下：</p>
<ul>
<li>确认总体策略中的质量目标是否完成<ul>
<li>对总体质量目标进行分解，为每个测试分层确定质量目标</li>
<li>如果质量红线（重要目标）没有达成，就不能进入下一阶段测试或发布</li>
<li>如果一般性目标没有达成，且没有应对措施，也不能进入下一阶段测试或发布</li>
</ul>
</li>
<li>重要的质量目标（质量红线）<ul>
<li>需求覆盖度、测试用例执行率、测试用例累计执行通过率、缺陷修复率</li>
</ul>
</li>
<li>对未达到的一般性质量目标制定应对措施<ul>
<li>非测试用例发现缺陷：寻找测试设计中的问题，改进设计，进行探索式测试<ul>
<li>产品实现/功能交互/边界值异常分支未考虑/测试场景未考虑</li>
</ul>
</li>
<li>组合缺陷分析：将缺陷分析方法进行组合<ul>
<li>缺陷密度过高，可以分析缺陷触发因素。是否采用了更多的测试方法？是否有遗留较多的缺陷？如果缺陷趋势收敛，修复率达标，可以进入下一阶段的测试。</li>
</ul>
</li>
<li>遗留缺陷：制定规避措施<ul>
<li>在版本计划发布前几个版本就开始进行，需要评估缺陷对用户影响程度、发生概率</li>
<li>致命缺陷/没有规避措施严重缺陷，不应该遗留</li>
<li>非必然重现bug，需要提单做问题记录，跟踪周期可以延长，可以适当降低问题优先级。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>质量管理</tag>
        <tag>性能测试</tag>
        <tag>业务测试</tag>
        <tag>软件测试</tag>
        <tag>测试管理</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】理解javascript/python中reduce操作的含义</title>
    <url>/2021/10/01/geekdaily/reduce_function/</url>
    <content><![CDATA[<p>在学习javascript和python的过程中，我们通常会接触到<code>map</code>、<code>filter</code>、<code>reduce</code>之类的一等公民高阶函数。理解<code>map</code>和<code>filter</code>是相对简单的事情，但理解<code>reduce</code>的话还是需要一番推敲。正值十一假期，今天这篇文章就好好讲讲<code>reduce</code>这个东西</p>
<p>我们首先以python为例，看一段<code>reduce</code>程序的操作：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stats</span>:</span></span><br><span class="line">    product: int = <span class="number">1</span></span><br><span class="line">    sum: int = <span class="number">0</span></span><br><span class="line">    num: int = <span class="number">0</span></span><br><span class="line">    avg: float = <span class="number">0.0</span></span><br><span class="line">    max: int = <span class="number">-1e9</span></span><br><span class="line">    min: int = <span class="number">1e9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reducer</span><span class="params">(cur_state, cur_element)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> isinstance(cur_state, Stats)</span><br><span class="line">    print(<span class="string">'processing element %d, current stats: %s'</span> % (cur_element, cur_state))</span><br><span class="line">    cur_state.num += <span class="number">1</span></span><br><span class="line">    cur_state.sum += cur_element</span><br><span class="line">    cur_state.product *= cur_element</span><br><span class="line">    cur_state.avg = float(cur_state.sum) / float(cur_state.num)</span><br><span class="line">    <span class="keyword">if</span> cur_element &gt; cur_state.max:</span><br><span class="line">        cur_state.max = cur_element</span><br><span class="line">    <span class="keyword">if</span> cur_element &lt; cur_state.min:</span><br><span class="line">        cur_state.min = cur_element</span><br><span class="line">    <span class="keyword">return</span> cur_state</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    ints = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    reduced_stats = reduce(reducer, ints, Stats())</span><br><span class="line">    print(reduced_stats)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>这段程序里的操作，输入是一组整数，最后输出来的是这组整数的统计数据，比如总和<code>sum</code>、积<code>product</code>、最大最小值等等。实现这个统计操作，就可以用<code>reduce</code>。在<code>functools</code>库中，我们可以看到<code>reduce</code>的定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_initial_missing = object()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce</span><span class="params">(function, sequence, initial=_initial_missing)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    reduce(function, sequence[, initial]) -&gt; value</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Apply a function of two arguments cumulatively to the items of a sequence,</span></span><br><span class="line"><span class="string">    from left to right, so as to reduce the sequence to a single value.</span></span><br><span class="line"><span class="string">    For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates</span></span><br><span class="line"><span class="string">    ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items</span></span><br><span class="line"><span class="string">    of the sequence in the calculation, and serves as a default when the</span></span><br><span class="line"><span class="string">    sequence is empty.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    it = iter(sequence)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> initial <span class="keyword">is</span> _initial_missing:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            value = next(it)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">"reduce() of empty sequence with no initial value"</span>) <span class="keyword">from</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = initial</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> it:</span><br><span class="line">        value = function(value, element)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> _functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>这段代码简单易懂，我们可以看到<code>reduce</code>函数需要一个初始值<code>initial</code>，并定义一个会变化的当前值<code>value</code>，然后会在遍历我们定义的<code>sequence</code>序列的过程中，不断用<code>function</code>（叫成<code>reducer</code>更加贴切）依据当前遍历到的元素<code>element</code>来更新当前值<code>value</code>（的内部状态），并在最后返回最终的<code>value</code>。</p>
<p>所以很显然，<code>reduce</code>这个函数，针对一个特定的<code>sequence</code>，返回值应当反映这个<code>sequence</code>的某样（些）属性。这便是<code>reduce</code>的意义所在了。</p>
<p>学过javascript的同学，会经常在网上资料看到<code>reduce</code>的翻译叫做<code>归并</code>，个人认为<code>归并</code>这个词已经翻译的非常贴切了，一时间也找不到更好的信达雅的表达。当然如果我们去检索英文百科，甚至还可以了解到更多的信息。</p>
<p><code>reduce</code>是函数式编程的一个代表。我们检索<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRnVuY3Rpb25hbF9wcm9ncmFtbWluZw==" title="https://en.wikipedia.org/wiki/Functional_programming">函数式编程的维基百科<i class="fa fa-external-link"></i></span>，里面可以跳到<code>reduce</code>的百科，我们发现其实会跳到<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRm9sZF8oaGlnaGVyLW9yZGVyX2Z1bmN0aW9u" title="https://en.wikipedia.org/wiki/Fold_(higher-order_function">另一个单词的百科<i class="fa fa-external-link"></i></span>)，叫做<code>fold</code></p>
<p>从<code>fold</code>以及衍生词汇<code>reduce</code>、<code>accumulate</code>、<code>aggregation</code>可以看到，这类操作其实用中文翻译除了叫<code>归并</code>以外，叫<code>累积</code>、<code>聚合</code>也不过分（嗯这里又可以看到我们的老朋友mongodb，<code>aggregation</code>跟<code>accumulate</code>关键词都上架了），都是代表着一种<code>遍历所有元素值，不断合并计算，得出最终结果</code>的运算操作。<code>fold</code>反过来叫做<code>unfold</code>，对应的也是<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQW5hbW9ycGhpc20=" title="https://en.wikipedia.org/wiki/Anamorphism">另一个单词的百科<i class="fa fa-external-link"></i></span>，叫做<code>Anamorphism</code>。<code>Anamorphism</code>本意是<code>岩石变性</code>、<code>渐变</code>，但在计算机领域，作为和<code>fold</code>相反的运算方式，是一个会不断根据当前值来生成下一个值，从而<code>展开</code>出来一个<code>sequence</code>的生成器<code>generator</code>（所以这种运算通俗的说，就翻译为<code>展开</code>即可，跟<code>unfold</code>也很搭）。我们熟悉的斐波那契数列，就可以用<code>unfold</code>/<code>Anamorphism</code>代表的运算方式生成。初始值为（0，1），根据（0，1）生成下一个数字1，根据（1，1）生成下一个数字2。这样不断<code>展开</code>下去，我们就可以得到特定长度的斐波那契数列了。</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>函数式编程</tag>
        <tag>reduce</tag>
        <tag>归并</tag>
        <tag>fold</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】在Vue用echarts画带不同颜色点的散点图</title>
    <url>/2021/09/16/geekdaily/echarts_scatter_color/</url>
    <content><![CDATA[<p>在vue技术栈下做图表需求，<span class="exturl" data-url="aHR0cHM6Ly9lY2hhcnRzLmFwYWNoZS5vcmcvemgvaW5kZXguaHRtbA==" title="https://echarts.apache.org/zh/index.html">echarts<i class="fa fa-external-link"></i></span>是一个非常棒的选择，提供了非常多种多样的图标示例以及非常复杂强大的API。由于笔者近期工作内容中需要分析采样点的分布情况，因此自然而然接触到了echarts的<span class="exturl" data-url="aHR0cHM6Ly9lY2hhcnRzLmFwYWNoZS5vcmcvZXhhbXBsZXMvemgvaW5kZXguaHRtbCNjaGFydC10eXBlLXNjYXR0ZXIzRA==" title="https://echarts.apache.org/examples/zh/index.html#chart-type-scatter3D">3D散点图<i class="fa fa-external-link"></i></span>。在笔者的需求中，需要对不同点进行分类，并按特定的颜色显示出来。经过一番踩坑，了解到了echarts在实现这方面的机制。</p>
<p>echarts绘图/刷新只需要通过<code>setOption</code>接口即可实现。在各种options中，<span class="exturl" data-url="aHR0cHM6Ly9lY2hhcnRzLmFwYWNoZS5vcmcvaGFuZGJvb2svemgvY29uY2VwdHMvdmlzdWFsLW1hcA==" title="https://echarts.apache.org/handbook/zh/concepts/visual-map">visualMap视觉映射组件<i class="fa fa-external-link"></i></span>能够根据数据在特定维度上的值，指定对应点的视觉属性（比如颜色、透明度、图元大小等等）。</p>
<p>要用到visualMap特性，需要import相关组件：</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; VisualMapComponent &#125; <span class="keyword">from</span> <span class="string">'echarts/components'</span></span><br><span class="line">echarts.use(VisualMapComponent)</span><br></pre></td></tr></table></figure>
<p>记得如果要用到其余的一些tooltip之类的组件，也得加上这些import声明。</p>
<p>假设我们数据每项包含X、Y、Z坐标以及一个表示颜色类别的项，我们需要首先设定visualMap如下（也可以参考官方的诸多例子）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">  visualMap: [</span><br><span class="line">    &#123;</span><br><span class="line">      min: <span class="number">0</span>,</span><br><span class="line">      max: <span class="number">1000</span>,</span><br><span class="line">      dimension: <span class="number">4</span>,</span><br><span class="line">      inRange: &#123;</span><br><span class="line">        color: [<span class="string">'#000000'</span>, <span class="string">'#aabbcc'</span>, <span class="string">'#ffffff'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    ...</span></span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这表示上色的时候，会读取数据第5个维度（index/dimension = 4）的值，然后根据值寻找对应的颜色。值的范围是0~1000，也就是说我们数据里第5个维度值为0的话，就是<code>#000000</code>，取1000就是<code>#ffffff</code>，然后取中间500的话就是<code>#aabbcc</code>了</p>
<p>因此我们可以转换下数据，添加颜色对应的整数值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> colorTagToIntMap = &#123;</span><br><span class="line">    COLOR_A: <span class="number">0</span>,</span><br><span class="line">    COLOR_B: <span class="number">500</span>,</span><br><span class="line">    COLOR_C: <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newData = data.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> colorInt = colorTagToIntMap[item.colorTag]</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        item.X,</span><br><span class="line">        item.Y,</span><br><span class="line">        item.Z,</span><br><span class="line">        item.colorTag,</span><br><span class="line">        colorTagToInt</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后在对应<span class="exturl" data-url="aHR0cHM6Ly9lY2hhcnRzLmFwYWNoZS5vcmcvaGFuZGJvb2svemgvY29uY2VwdHMvZGF0YXNldA==" title="https://echarts.apache.org/handbook/zh/concepts/dataset">dataset<i class="fa fa-external-link"></i></span>中，设置dimension为表头，设置data为上述的newData，就ok了。</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>echarts</tag>
        <tag>散点图</tag>
        <tag>scatter3D</tag>
        <tag>visualMap</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】2021新版本VSCode设置git-bash为终端的方法</title>
    <url>/2021/09/11/geekdaily/vscode_git-bash/</url>
    <content><![CDATA[<p>截至2021.9，不知道哪天更新了vscode，发现默认的终端从以前的git-bash变成了powershell，笔者用的windows电脑，于是乎要解决这个问题，把powershell变回git-bash。</p>
<p>打开settings，发现以前的<code>terminal.integrated.shell.windows</code>设置已经失效，不能再用。在settings的图形界面查看shell设置，默认的选项变成了<code>PowerShell</code>、<code>Command Prompt</code>和<code>Javascript Debug Terminal</code>，不能直接指定git-bash路径。</p>
<p>经过一番查找，发现<span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20vZG9jcy9lZGl0b3IvaW50ZWdyYXRlZC10ZXJtaW5hbA==" title="https://code.visualstudio.com/docs/editor/integrated-terminal">官方文档<i class="fa fa-external-link"></i></span>已经说明可以通过设置<code>terminal.integrated.profiles.windows</code>的方法，增加一个shell选项，从而达到目的。于是我们可以在<code>settings</code>里添加一个<code>git-bash</code>选项：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"terminal.integrated.profiles.windows": &#123;</span><br><span class="line">    "git-bash": &#123;</span><br><span class="line">        "path": "X:\\GIT_ROOT\\bin\\bash.exe"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在shell选项里就能选择git-bash了。试试看吧~</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>shell</tag>
        <tag>VSCode</tag>
        <tag>VSCode设置</tag>
        <tag>git-bash</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏开发】UE4下判断一个点是否在特定长方体内的计算方法</title>
    <url>/2021/09/01/gamedev/ue4_point_in_cuboid/</url>
    <content><![CDATA[<p>近期在研究寻路功能的测试工作，需要对玩家寻路过程中的行进轨迹进行采样，判断采样点是否在特定的寻路区域内。UE4自带了<code>NavModifierVolume</code>的actor，可以放置到场景里标识某个区域的寻路成本（不了解寻路相关背景的话可以参考<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjEvMDgvMDcvZ2FtZWRldi9yZWNhc3RkZW1vLw==" title="https://utmhikari.top/2021/08/07/gamedev/recastdemo/">先前的文章<i class="fa fa-external-link"></i></span>），因此我们做采样的时候，也需要判断某个点是否在特定的<code>NavModifierVolume</code>里。由于自己所负责的游戏是网游，<code>NavModifierVolume</code>最后导出给服务器用了，实际游戏里获取不到这些actor的数据，因此实际测试时，一方面需要下载服务器上的<code>NavModifierVolume</code>数据，另一方面还要手写相关的计算方法，来达到我们的工作目的。</p>
<p><code>NavModifierVolume</code>是一个空的长方体，可以旋转成任意形式。因此判断玩家寻路采样点是否在特定寻路区域内，也就必须解决这个数学问题——3D空间下判断一个点是否在特定长方体内。</p>
<p>通常而言，这个问题有以下的解法：</p>
<a id="more"></a>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hpdDE1MjQ0NjgvYXJ0aWNsZS9kZXRhaWxzLzc5ODU3NjY1" title="https://blog.csdn.net/hit1524468/article/details/79857665">判断是否在3组平行平面同一侧<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HYW1lcy9UZWNobmlxdWVzLzNEX2NvbGxpc2lvbl9kZXRlY3Rpb24=" title="https://developer.mozilla.org/zh-CN/docs/Games/Techniques/3D_collision_detection">判断坐标是否在XYZ范围内，如果是AABB（对齐坐标轴）<i class="fa fa-external-link"></i></span></li>
</ul>
<p>针对UE4环境，一个长方体会包含transform以及单位大小的信息：</p>
<ul>
<li>位置Location：中心点</li>
<li>旋转Rotation：Pitch、Yaw、Roll</li>
<li>大小比例Scale</li>
</ul>
<p>因此这个问题可以用这样的步骤解决（应该是对的吧，数学不好= =）：</p>
<ul>
<li>获取中心点到目标点A的向量，其中目标点A是我们需要判断是否在长方体内的点</li>
<li>对这个向量进行基于Rotation的逆运算，这样目标点的位置会变化，得到新的目标点B</li>
<li>判断目标点B，是否在一个以Location为中心点，Scale*单位长度大小的AABB中</li>
</ul>
<p>这里面最需要解决的，是如何求旋转。我们可以通过UE内部的源码来寻找思路。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UnrealMath.cpp</span></span><br><span class="line"></span><br><span class="line">FVector FRotator::UnrotateVector(<span class="keyword">const</span> FVector&amp; V) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> FRotationMatrix(*<span class="keyword">this</span>).GetTransposed().TransformVector( V );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FVector FRotator::RotateVector(<span class="keyword">const</span> FVector&amp; V) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> FRotationMatrix(*<span class="keyword">this</span>).TransformVector( V );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由一个旋转<code>FRotator</code>（带Pitch、Yaw、Roll属性），以及一个向量，可以直接求得旋转后/逆旋转后的向量。旋转一个向量需要构建特定的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWhhbnMvJUU2JTk3JThCJUU4JUJEJUFDJUU3JTlGJUE5JUU5JTk4JUI1" title="https://zh.wikipedia.org/zh-hans/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5">旋转矩阵<i class="fa fa-external-link"></i></span>，通过矩阵乘法得到新向量分量的值。逆旋转的矩阵则是旋转矩阵的转置，而转换原向量的计算方式也是相同的。</p>
<p>针对不同的坐标系规则，旋转矩阵的计算方法有很多种，而实测UE4用的旋转矩阵也是独特的一种（试过网上的一些旋转矩阵老是有分量正负号不对= =）。在<code>FRotationMatrix</code>、<code>FRotationTranslationMatrix</code>的定义中，我们可以看到旋转矩阵的构造方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RotationTranslationMatrix.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Origin should be (0.0, 0.0, 0.0) if not defined</span></span><br><span class="line">FORCEINLINE FRotationTranslationMatrix::FRotationTranslationMatrix(<span class="keyword">const</span> FRotator&amp; Rot, <span class="keyword">const</span> FVector&amp; Origin)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">float</span> SP, SY, SR;</span><br><span class="line">    <span class="keyword">float</span> CP, CY, CR;</span><br><span class="line">    FMath::SinCos(&amp;SP, &amp;CP, FMath::DegreesToRadians(Rot.Pitch));</span><br><span class="line">    FMath::SinCos(&amp;SY, &amp;CY, FMath::DegreesToRadians(Rot.Yaw));</span><br><span class="line">    FMath::SinCos(&amp;SR, &amp;CR, FMath::DegreesToRadians(Rot.Roll));</span><br><span class="line"></span><br><span class="line">    M[<span class="number">0</span>][<span class="number">0</span>] = CP * CY;</span><br><span class="line">    M[<span class="number">0</span>][<span class="number">1</span>] = CP * SY;</span><br><span class="line">    M[<span class="number">0</span>][<span class="number">2</span>] = SP;</span><br><span class="line">    M[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0.f</span>;</span><br><span class="line"></span><br><span class="line">    M[<span class="number">1</span>][<span class="number">0</span>] = SR * SP * CY - CR * SY;</span><br><span class="line">    M[<span class="number">1</span>][<span class="number">1</span>] = SR * SP * SY + CR * CY;</span><br><span class="line">    M[<span class="number">1</span>][<span class="number">2</span>] = - SR * CP;</span><br><span class="line">    M[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">0.f</span>;</span><br><span class="line"></span><br><span class="line">    M[<span class="number">2</span>][<span class="number">0</span>] = -( CR * SP * CY + SR * SY );</span><br><span class="line">    M[<span class="number">2</span>][<span class="number">1</span>] = CY * SR - CR * SP * SY;</span><br><span class="line">    M[<span class="number">2</span>][<span class="number">2</span>] = CR * CP;</span><br><span class="line">    M[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">0.f</span>;</span><br><span class="line"></span><br><span class="line">    M[<span class="number">3</span>][<span class="number">0</span>] = Origin.X;</span><br><span class="line">    M[<span class="number">3</span>][<span class="number">1</span>] = Origin.Y;</span><br><span class="line">    M[<span class="number">3</span>][<span class="number">2</span>] = Origin.Z;</span><br><span class="line">    M[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1.f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到旋转矩阵是一个4x4的结构（因为可能有设定原点坐标）。而之后，<code>TransformVector</code>是这样计算的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Matrix.inl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Transform vector</span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Transform a direction vector - will not take into account translation part of the FMatrix. </span></span><br><span class="line"><span class="comment"> * If you want to transform a surface normal (or plane) and correctly account for non-uniform scaling you should use TransformByUsingAdjointT.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FORCEINLINE FVector4 FMatrix::TransformVector(<span class="keyword">const</span> FVector&amp; V) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> TransformFVector4(FVector4(V.X,V.Y,V.Z,<span class="number">0.0f</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Homogeneous transform.</span></span><br><span class="line"></span><br><span class="line">FORCEINLINE FVector4 FMatrix::TransformFVector4(<span class="keyword">const</span> FVector4 &amp;P) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    FVector4 Result;</span><br><span class="line">    VectorRegister VecP = VectorLoadAligned(&amp;P);</span><br><span class="line">    VectorRegister VecR = VectorTransformVector(VecP, <span class="keyword">this</span>);</span><br><span class="line">    VectorStoreAligned(VecR, &amp;Result);</span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnrealMathSSE.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calculate Homogeneous transform.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param VecP VectorRegister </span></span><br><span class="line"><span class="comment"> * @param MatrixM FMatrix pointer to the Matrix to apply transform</span></span><br><span class="line"><span class="comment"> * @return VectorRegister = VecP*MatrixM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">FORCEINLINE VectorRegister <span class="title">VectorTransformVector</span><span class="params">(<span class="keyword">const</span> VectorRegister&amp;  VecP,  <span class="keyword">const</span> <span class="keyword">void</span>* MatrixM )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> VectorRegister *M = (<span class="keyword">const</span> VectorRegister *) MatrixM;</span><br><span class="line">    VectorRegister VTempX, VTempY, VTempZ, VTempW;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Splat x,y,z and w</span></span><br><span class="line">    VTempX = VectorReplicate(VecP, <span class="number">0</span>);</span><br><span class="line">    VTempY = VectorReplicate(VecP, <span class="number">1</span>);</span><br><span class="line">    VTempZ = VectorReplicate(VecP, <span class="number">2</span>);</span><br><span class="line">    VTempW = VectorReplicate(VecP, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// Mul by the matrix</span></span><br><span class="line">    VTempX = VectorMultiply(VTempX, M[<span class="number">0</span>]);</span><br><span class="line">    VTempY = VectorMultiply(VTempY, M[<span class="number">1</span>]);</span><br><span class="line">    VTempZ = VectorMultiply(VTempZ, M[<span class="number">2</span>]);</span><br><span class="line">    VTempW = VectorMultiply(VTempW, M[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// Add them all together</span></span><br><span class="line">    VTempX = VectorAdd(VTempX, VTempY);</span><br><span class="line">    VTempZ = VectorAdd(VTempZ, VTempW);</span><br><span class="line">    VTempX = VectorAdd(VTempX, VTempZ);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> VTempX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终其实就是原向量<code>[[x, y, z, 0]]（1x4）</code>乘以<code>转置矩阵（4x4）</code>，得到新的<code>1x4</code>的向量，也就是我们需要的旋转后的向量。UE4内部对计算过程做了优化，此处暂不多做分析。</p>
<p>得到了计算向量旋转的方法，我们也可以通过其转置矩阵，进行向量的某个旋转的逆运算，这样目标点相对于中心点的位置有所改变，但对应的长方体就是对齐坐标轴的了。这时就可以直接通过判断点的三个分量是不是在长方体X、Y、Z范围内，就能得出答案。</p>
]]></content>
      <categories>
        <category>游戏开发</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>UE4</tag>
        <tag>数学</tag>
        <tag>NavModifierVolume</tag>
        <tag>旋转矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏开发】UE4用C++编写行为树的Task、Service、Decorator节点</title>
    <url>/2021/08/21/gamedev/ue4_cpp_btree_nodes/</url>
    <content><![CDATA[<p>在游戏领域，行为树是常用的AI解决方案，用行为树可以快速明了地描述AI的行为模型，而UE4提也供了非常完善的行为树解决方案，不仅有用户友好的界面，而且也有多样化的底层支持。在官网的<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vNC4yNy96aC1DTi9JbnRlcmFjdGl2ZUV4cGVyaWVuY2VzL0FydGlmaWNpYWxJbnRlbGxpZ2VuY2UvQmVoYXZpb3JUcmVlcy9CZWhhdmlvclRyZWVRdWlja1N0YXJ0Lw==" title="https://docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/ArtificialIntelligence/BehaviorTrees/BehaviorTreeQuickStart/">行为树快速入门指南<i class="fa fa-external-link"></i></span>中，我们可以了解到UE4行为树编辑器的使用以及用蓝图创造行为树节点的方式，而在一些特定的需求当中，蓝图相对于C++并不会非常灵活。因此，笔者稍微研究了下行为树C++层次中的内容，简单分享下行为树里各种节点的C++写法</p>
<p>首先上一张行为树完整图，是基于<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vNC4yNy96aC1DTi9JbnRlcmFjdGl2ZUV4cGVyaWVuY2VzL0FydGlmaWNpYWxJbnRlbGxpZ2VuY2UvRVFTL0VRU1F1aWNrU3RhcnQv" title="https://docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/ArtificialIntelligence/EQS/EQSQuickStart/">场景查询系统（EQS）快速入门<i class="fa fa-external-link"></i></span>制作的：</p>
<a id="more"></a>
<p><img src="/uploads/gamedev/ue4_cpp_btree_nodes/btree.png" alt="btree" title="&#39;btree&#39;"></p>
<p>在<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vNC4yNy96aC1DTi9JbnRlcmFjdGl2ZUV4cGVyaWVuY2VzL0FydGlmaWNpYWxJbnRlbGxpZ2VuY2UvRVFTL0VRU1F1aWNrU3RhcnQv" title="https://docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/ArtificialIntelligence/EQS/EQSQuickStart/">官网EQS入门<i class="fa fa-external-link"></i></span>的例子中，AI大致遵循这样的逻辑：</p>
<ul>
<li>没看到玩家，特定范围随机某个点巡逻</li>
<li>视觉感知到玩家，会转向看着玩家</li>
<li>玩家离开视线，调用EQS找到当前时刻最好的能看到玩家的位置，走过去</li>
<li>看不到玩家，再回到随机巡逻</li>
</ul>
<p>而在笔者的行为树完整图中，添加了以下的节点：</p>
<ul>
<li>任务节点（Task）：JumpForNTimes -&gt; 跳N次</li>
<li>服务节点（Service）：TraceDistance -&gt; 监控AI到某个点的距离</li>
<li>装饰器节点（Decorator）：CheckActorDistance -&gt; 检查AI到某个Actor的距离</li>
</ul>
<p>最终想要达到的AI目的：</p>
<ul>
<li>没看到玩家，特定范围随机某个点巡逻</li>
<li>视觉感知到玩家，会转向看着玩家，然后跳N次（JumpForNTimes），并且会在屏幕实时打印AI跟玩家的距离（TraceDistance）</li>
<li>玩家离开视线，调用EQS找到当前时刻最好的能看到玩家的位置，走过去</li>
<li>看不到玩家，再回到随机巡逻。但如果玩家再次接近到一定距离，AI会“警觉”（CheckActorDistance），执行跳N次的操作</li>
</ul>
<p>下面就一起来看下这三个节点具体的写法。在写这些行为树节点具体逻辑之前，首先需要在<code>Build.cs</code>的<code>PublicDependencyModuleNames</code>加上<code>AIModule</code>跟<code>GameplayTasks</code>，保证三种节点所需要的方法都能支持</p>
<h2 id="Task节点：JumpForNTimes"><a href="#Task节点：JumpForNTimes" class="headerlink" title="Task节点：JumpForNTimes"></a>Task节点：JumpForNTimes</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vNC4yNy96aC1DTi9JbnRlcmFjdGl2ZUV4cGVyaWVuY2VzL0FydGlmaWNpYWxJbnRlbGxpZ2VuY2UvQmVoYXZpb3JUcmVlcy9CZWhhdmlvclRyZWVOb2RlUmVmZXJlbmNlL0JlaGF2aW9yVHJlZU5vZGVSZWZlcmVuY2VUYXNrcy8=" title="https://docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/ArtificialIntelligence/BehaviorTrees/BehaviorTreeNodeReference/BehaviorTreeNodeReferenceTasks/">task节点<i class="fa fa-external-link"></i></span>表示AI实际的一种操作，我们在UE4源码的<code>Runtime/AIModule/Classes/BehaviorTree/Tasks</code>中能够看到预设的许多task节点的定义。<code>JumpForNTimes</code>这类操作并不是瞬时的，需要跳完N次后才会执行后面的动作，因此在写法上，可以参考<code>BTTask_Wait</code>的实现。</p>
<p>首先创建<code>BTTask_JumpForNTimes</code>类，继承<code>UBTTaskNode</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BTTask_JumpForNTimes.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FBTJumpForNTimesTaskMemory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    int32 JumpTimesInternal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jump for n times btree task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">UCLASS()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TESTEQS_API</span> <span class="title">UBTTask_JumpForNTimes</span> :</span> <span class="keyword">public</span> UBTTaskNode</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_UCLASS_BODY()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** jump times */</span></span><br><span class="line">    UPROPERTY(Category = Jump, EditAnywhere)</span><br><span class="line">    int32 JumpTimes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> EBTNodeResult::<span class="function">Type <span class="title">ExecuteTask</span><span class="params">(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory)</span> override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> uint16 <span class="title">GetInstanceMemorySize</span><span class="params">()</span> <span class="keyword">const</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> WITH_EDITOR</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> FName <span class="title">GetNodeIconName</span><span class="params">()</span> <span class="keyword">const</span> override</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// WITH_EDITOR</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TickTask</span><span class="params">(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory, <span class="keyword">float</span> DeltaSeconds)</span> override</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>UBTTask_JumpForNTimes：JumpForNTimes任务节点定义<ul>
<li>JumpTimes：跳跃次数，是需要我们在编辑器里设置的内容，因此需要标注<code>UPROPERTY</code>+<code>EditAnywhere</code></li>
<li>ExecuteTask：任务执行时的逻辑。<ul>
<li><code>EBTNodeResult</code>是task节点执行的结果表示</li>
<li>对于非瞬时完成的任务（比如Wait），可以在<code>ExecuteTask</code>接口中返回<code>EBTNodeResult::InProgress</code>（任务进行中），并在后面的<code>TickTask</code>中判断完成条件，执行<code>FinishLatentTask(OwnerComp, EBTNodeResult)</code>来通知任务的完成结果</li>
</ul>
</li>
<li>TickTask：每个tick中该任务执行的逻辑</li>
<li>GetInstanceMemorySize：获取节点实例自己的内存空间大小，用于预分配内存</li>
<li>GetNodeIconName：编辑器里节点icon</li>
</ul>
</li>
<li>FBTJumpForNTimesTaskMemory：我们任务节点自带的内存空间，放着节点私有的变量<ul>
<li>JumpTimesInternal：实际用来记录跳跃次数的计数器</li>
<li>在GetInstanceMemorySize返回sizeof结构体，这样引擎会预分配相应大小的内存块</li>
<li>在ExecuteTask、TickTask可以通过转换uint8* NodeMemory获得内存块对应结构体的实例</li>
</ul>
</li>
</ul>
<p>在cpp逻辑里，<code>JumpForNTimes</code>可以这样实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BTTask_JumpForNTimes.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数，启用tick -&gt; bNotifyTick = true</span></span><br><span class="line">UBTTask_JumpForNTimes::UBTTask_JumpForNTimes(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">    NodeName = <span class="string">"JumpForNTimes"</span>;</span><br><span class="line">    JumpTimes = <span class="number">3</span>;</span><br><span class="line">    bNotifyTick = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始执行任务，先重置JumpTimesInternal，返回InProgress</span></span><br><span class="line">EBTNodeResult::Type UBTTask_JumpForNTimes::ExecuteTask(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (JumpTimes &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> EBTNodeResult::Failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FBTJumpForNTimesTaskMemory* MyMemory = (FBTJumpForNTimesTaskMemory*)NodeMemory;</span><br><span class="line">    MyMemory-&gt;JumpTimesInternal = JumpTimes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> AController* Controller = Cast&lt;AController&gt;(OwnerComp.GetOwner());</span><br><span class="line">    ACharacter* Character = Controller ? Controller-&gt;GetCharacter() : <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Character)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> EBTNodeResult::Failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EBTNodeResult::InProgress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在tick中，检查玩家是否在跳跃过程</span></span><br><span class="line"><span class="comment">// 如果没有的话，看下计数是否到0，到0了就不跳，还没有就继续跳</span></span><br><span class="line"><span class="keyword">void</span> UBTTask_JumpForNTimes::TickTask(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory, <span class="keyword">float</span> DeltaSeconds)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> AController* Controller = Cast&lt;AController&gt;(OwnerComp.GetOwner());</span><br><span class="line">    ACharacter* Character = Controller ? Controller-&gt;GetCharacter() : <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Character) &#123;</span><br><span class="line">        FinishLatentTask(OwnerComp, EBTNodeResult::Failed);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!Character-&gt;GetMovementComponent()-&gt;IsFalling())</span><br><span class="line">    &#123;</span><br><span class="line">        FBTJumpForNTimesTaskMemory* MyMemory = (FBTJumpForNTimesTaskMemory*)NodeMemory;</span><br><span class="line">        <span class="keyword">if</span> (MyMemory-&gt;JumpTimesInternal &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            FinishLatentTask(OwnerComp, EBTNodeResult::Succeeded);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!Character-&gt;bPressedJump)</span><br><span class="line">        &#123;</span><br><span class="line">            Character-&gt;Jump();</span><br><span class="line">            MyMemory-&gt;JumpTimesInternal--;</span><br><span class="line">            UE_LOG(LogTemp, Log, TEXT(<span class="string">"[BTTask_JumpForNTimes] JumpTimes--"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回结构体大小</span></span><br><span class="line">uint16 UBTTask_JumpForNTimes::GetInstanceMemorySize() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(FBTJumpForNTimesTaskMemory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> WITH_EDITOR</span></span><br><span class="line"><span class="comment">// 随便返回个icon名字就好了</span></span><br><span class="line">FName UBTTask_JumpForNTimes::GetNodeIconName() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// use MakeNoise icon for jump~</span></span><br><span class="line">    <span class="keyword">return</span> FName(<span class="string">"BTEditor.Graph.BTNode.Task.MakeNoise.Icon"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="Service节点：TraceDistance"><a href="#Service节点：TraceDistance" class="headerlink" title="Service节点：TraceDistance"></a>Service节点：TraceDistance</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vNC4yNy96aC1DTi9JbnRlcmFjdGl2ZUV4cGVyaWVuY2VzL0FydGlmaWNpYWxJbnRlbGxpZ2VuY2UvQmVoYXZpb3JUcmVlcy9CZWhhdmlvclRyZWVOb2RlUmVmZXJlbmNlL0JlaGF2aW9yVHJlZU5vZGVSZWZlcmVuY2VTZXJ2aWNlcy8=" title="https://docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/ArtificialIntelligence/BehaviorTrees/BehaviorTreeNodeReference/BehaviorTreeNodeReferenceServices/">Service节点<i class="fa fa-external-link"></i></span>通常用于在某个行为节点/分支执行过程中，执行响应的检查逻辑更新黑板，亦或是作为sidecar式的逻辑监控节点/分支的运行情况。</p>
<p>TraceDistance只用于实时监控AI到某个点的距离，并且在屏幕上打印数据。在实现上可以参考已有的<code>BTService_DefaultFocus</code>跟<code>BTService_RunEQS</code>来写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BTService_TraceDistance.h</span></span><br><span class="line"></span><br><span class="line">UCLASS()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TESTEQS_API</span> <span class="title">UBTService_TraceDistance</span> :</span> <span class="keyword">public</span> UBTService_BlackboardBase</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    UBTService_TraceDistance(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer = FObjectInitializer::Get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TickNode</span><span class="params">(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory, <span class="keyword">float</span> DeltaSeconds)</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnCeaseRelevant</span><span class="params">(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory)</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> WITH_EDITOR</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> FName <span class="title">GetNodeIconName</span><span class="params">()</span> <span class="keyword">const</span> override</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// WITH_EDITOR</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> int32 LogKey = <span class="number">9527</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在头文件里定义<code>UBTService_TraceDistance</code>，继承<code>UBTService_BlackboardBase</code>。<code>UBTService_BlackboardBase</code>默认提供了一个可选黑板Key的属性，在编辑器里可以看到这个选项的。其他属性如下：</p>
<ul>
<li><code>TickNode</code>是这个Service生命周期里的一个hook函数，表示每Tick的行为</li>
<li><code>OnCeaseRelevant</code>也是这个Service生命周期里的hook函数，表示当行为树运行到和这个Service不相关（Service结束服务）时候的逻辑操作</li>
<li>当然除了这两者还有一个<code>OnBecomeRelevant</code>钩子表示当运行到和Service相关的节点/分支时候的逻辑操作。</li>
</ul>
<p>我们打算在每个tick时候在特定的<code>LogKey</code>打印AI与玩家的距离，而在玩家没法再看到（TargetActor被清空）时候打印“追踪距离结束”的字样。因此cpp里可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BTService_TraceDistance.cpp</span></span><br><span class="line"></span><br><span class="line">UBTService_TraceDistance::UBTService_TraceDistance(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer)</span><br><span class="line">    : Super(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">    NodeName = <span class="string">"Trace Distance"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用tick跟CeaseRelevant，不启用BecomeRelevant</span></span><br><span class="line">    bNotifyTick = <span class="literal">true</span>;</span><br><span class="line">    bTickIntervals = <span class="literal">true</span>;</span><br><span class="line">    bNotifyBecomeRelevant = <span class="literal">false</span>;</span><br><span class="line">    bNotifyCeaseRelevant = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// accept only actors and vectors，限制只能选某个特定位置，或者actor</span></span><br><span class="line">    BlackboardKey.AddObjectFilter(<span class="keyword">this</span>, GET_MEMBER_NAME_CHECKED(UBTService_TraceDistance, BlackboardKey), AActor::StaticClass());</span><br><span class="line">    BlackboardKey.AddVectorFilter(<span class="keyword">this</span>, GET_MEMBER_NAME_CHECKED(UBTService_TraceDistance, BlackboardKey));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> UBTService_TraceDistance::TickNode(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory, <span class="keyword">float</span> DeltaSeconds)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!GEngine)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get controlled pawn location</span></span><br><span class="line">    <span class="keyword">const</span> AController* Controller = Cast&lt;AController&gt;(OwnerComp.GetOwner());</span><br><span class="line">    APawn* Pawn = Controller ? Controller-&gt;GetPawn() : <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Pawn)</span><br><span class="line">    &#123;</span><br><span class="line">        GEngine-&gt;AddOnScreenDebugMessage(LogKey, <span class="number">5.0f</span>, FColor::Red, TEXT(<span class="string">"cannot get controlled pawn"</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FVector PawnLoc = Pawn-&gt;GetActorLocation();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get target location</span></span><br><span class="line">    UBlackboardComponent* Blackboard = OwnerComp.GetBlackboardComponent();</span><br><span class="line">    <span class="keyword">if</span> (!Blackboard)</span><br><span class="line">    &#123;</span><br><span class="line">        GEngine-&gt;AddOnScreenDebugMessage(LogKey, <span class="number">5.0f</span>, FColor::Red, TEXT(<span class="string">"cannot get blackboard"</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span> Distance = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">if</span> (BlackboardKey.SelectedKeyType == UBlackboardKeyType_Object::StaticClass())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// object</span></span><br><span class="line">        UObject* KeyValue = Blackboard-&gt;GetValue&lt;UBlackboardKeyType_Object&gt;(BlackboardKey.GetSelectedKeyID());</span><br><span class="line">        AActor* TargetActor = Cast&lt;AActor&gt;(KeyValue);</span><br><span class="line">        <span class="keyword">if</span> (TargetActor)</span><br><span class="line">        &#123;</span><br><span class="line">            Distance = FVector::Distance(PawnLoc, TargetActor-&gt;GetActorLocation());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// vector</span></span><br><span class="line">        FVector DestLoc = Blackboard-&gt;GetValue&lt;UBlackboardKeyType_Vector&gt;(BlackboardKey.GetSelectedKeyID());</span><br><span class="line">        Distance = FVector::Distance(PawnLoc, DestLoc);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// print log</span></span><br><span class="line">    FString Msg = FString::Printf(TEXT(<span class="string">"distance to destination: %.2f"</span>), Distance);</span><br><span class="line">    GEngine-&gt;AddOnScreenDebugMessage(LogKey, <span class="number">5.0f</span>, FColor::Yellow, Msg);</span><br><span class="line"></span><br><span class="line">    Super::TickNode(OwnerComp, NodeMemory, DeltaSeconds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> UBTService_TraceDistance::OnCeaseRelevant(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (GEngine)</span><br><span class="line">    &#123;</span><br><span class="line">        GEngine-&gt;AddOnScreenDebugMessage(LogKey, <span class="number">5.0f</span>, FColor::Yellow, TEXT(<span class="string">"trace distance finished"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Decorator节点：CheckActorDistance"><a href="#Decorator节点：CheckActorDistance" class="headerlink" title="Decorator节点：CheckActorDistance"></a>Decorator节点：CheckActorDistance</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vNC4yNy96aC1DTi9JbnRlcmFjdGl2ZUV4cGVyaWVuY2VzL0FydGlmaWNpYWxJbnRlbGxpZ2VuY2UvQmVoYXZpb3JUcmVlcy9CZWhhdmlvclRyZWVOb2RlUmVmZXJlbmNlL0JlaGF2aW9yVHJlZU5vZGVSZWZlcmVuY2VEZWNvcmF0b3JzLw==" title="https://docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/ArtificialIntelligence/BehaviorTrees/BehaviorTreeNodeReference/BehaviorTreeNodeReferenceDecorators/">Decorator装饰器节点<i class="fa fa-external-link"></i></span>通常用来表示某种条件判断。条件判断成立后，AI的某些行为是否执行，或者执行优先级，都会有所变化。</p>
<p>在CheckActorDistance装饰器里，我们希望实现判断AI跟某个Actor距离在某个范围内，就优先执行装饰器装饰到的节点/分支的行为。我们可以参照其它预设装饰器的实现，来编写CheckActorDistance的逻辑</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BTDecorator_CheckActorDistance.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check Actor Distance</span></span><br><span class="line"><span class="comment"> * activated if distance to specific actor is in specific radius</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">UCLASS()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TESTEQS_API</span> <span class="title">UBTDecorator_CheckActorDistance</span> :</span> <span class="keyword">public</span> UBTDecorator_BlackboardBase</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    UPROPERTY(EditAnywhere, Category = CheckActorDistance)</span><br><span class="line">        <span class="keyword">float</span> DistanceRadius;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">CalculateRawConditionValue</span><span class="params">(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory)</span> <span class="keyword">const</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    UBTDecorator_CheckActorDistance(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer = FObjectInitializer::Get());</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>DistanceRadius：编辑器里需要设置的半径范围</li>
<li>CalculateRawConditionValue：用来计算装饰器条件是否成立的接口</li>
</ul>
<p>我们只需要在<code>CalculateRawConditionValue</code>里判断距离是否在给定范围内就好。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BTDecorator_CheckActorDistance.cpp</span></span><br><span class="line"></span><br><span class="line">BTDecorator_CheckActorDistance::UBTDecorator_CheckActorDistance(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">    NodeName = <span class="string">"Check Actor Distance"</span>;</span><br><span class="line"></span><br><span class="line">    BlackboardKey.AddObjectFilter(<span class="keyword">this</span>, GET_MEMBER_NAME_CHECKED(UBTDecorator_CheckActorDistance, BlackboardKey), AActor::StaticClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Default to using Self Actor</span></span><br><span class="line">    BlackboardKey.SelectedKeyName = FBlackboard::KeySelf;</span><br><span class="line">    DistanceRadius = <span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断黑板的某个actor跟ai控制的pawn是不是在给定DistanceRadius内</span></span><br><span class="line"><span class="keyword">bool</span> UBTDecorator_CheckActorDistance::CalculateRawConditionValue(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (UKismetMathLibrary::LessEqual_FloatFloat(DistanceRadius, <span class="number">0.0f</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> UBlackboardComponent* BlackboardComp = OwnerComp.GetBlackboardComponent();</span><br><span class="line">    <span class="keyword">if</span> (!BlackboardComp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AActor* TargetActor = Cast&lt;AActor&gt;(BlackboardComp-&gt;GetValue&lt;UBlackboardKeyType_Object&gt;(BlackboardKey.GetSelectedKeyID()));</span><br><span class="line">    <span class="keyword">if</span> (!TargetActor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> AController* Controller = Cast&lt;AController&gt;(OwnerComp.GetOwner());</span><br><span class="line">    APawn* Pawn = Controller ? Controller-&gt;GetPawn() : <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Pawn)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> Distance = FVector::Dist(TargetActor-&gt;GetActorLocation(), Pawn-&gt;GetActorLocation());</span><br><span class="line">    <span class="keyword">return</span> UKismetMathLibrary::LessEqual_FloatFloat(Distance, DistanceRadius);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，在黑板里最好加个<code>LastTargetActor</code>表示上一个看到的<code>TargetActor</code>，然后在AIController里丢失视线的逻辑中，在清空<code>TargetActor</code>之前，把<code>LastTargetActor</code>设置为当前的<code>TargetActor</code>，这样上一个<code>TargetActor</code>在丢失视线后回来到一定范围，AI就会有“预警”效果了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>UE的AIModule非常的大，行为树只是冰山一角，还有很多需要细细研究。</p>
]]></content>
      <categories>
        <category>游戏开发</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>UE4</tag>
        <tag>C++</tag>
        <tag>行为树</tag>
        <tag>行为树节点</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏开发】初识寻路&amp;navmesh，探索RecastDemo</title>
    <url>/2021/08/07/gamedev/recastdemo/</url>
    <content><![CDATA[<p>在手游时代，尤其对于大世界游戏而言，寻路的实现基本在专门的寻路服务器上进行。在众多寻路的解决方案中，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JlY2FzdG5hdmlnYXRpb24vcmVjYXN0bmF2aWdhdGlvbg==" title="https://github.com/recastnavigation/recastnavigation">recastnavigation<i class="fa fa-external-link"></i></span>是最为经典实用的一个，很多游戏甚至游戏引擎都采用类似的实现。recastnavigation项目自带了RecastDemo，用图形化的界面帮助用户认识寻路网格（navmesh）的生成以及寻路的过程。因此，作为初学者的笔者，也决定通过RecastDemo去初步认识寻路的机理奥秘。</p>
<h2 id="构建RecastDemo"><a href="#构建RecastDemo" class="headerlink" title="构建RecastDemo"></a>构建RecastDemo</h2><p>首先克隆recastnavigation项目，从文档中可以看到RecastDemo的构建支持Windows、Linux、MacOS三端。从实际测试的效果来看，MacOS可能存在字体无法加载的问题，建议是用Windows跟Linux跑着玩。以Windows为例，首先需要下载<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ByZW1ha2UvcHJlbWFrZS1jb3JlL3JlbGVhc2Vz" title="https://github.com/premake/premake-core/releases">premake5<i class="fa fa-external-link"></i></span>以及<span class="exturl" data-url="aHR0cHM6Ly93d3cubGlic2RsLm9yZy9kb3dubG9hZC0yLjAucGhw" title="https://www.libsdl.org/download-2.0.php">SDL开发库VC<i class="fa fa-external-link"></i></span>。premake5需要放到<code>PATH</code>下，而SDL开发库VC解压后需要按照文档描述，放到recastnavigation项目目录的<code>RecastDemo/Contrib</code>目录下，更名为<code>SDL</code>。</p>
<p>之后，在<code>RecastDemo</code>目录下执行<code>premake5 vs2019</code>，可以在<code>RecastDemo/Build/vs2019</code>中看到<code>recastnavigation.sln</code>项目文件。用VS2019打开，构建RecastDemo，就会生成exe在<code>RecastDemo/Bin</code>目录下。进入这个目录执行<code>RecastDemo.exe</code>，就能打开工具界面了。</p>
<h2 id="基础寻路操作"><a href="#基础寻路操作" class="headerlink" title="基础寻路操作"></a>基础寻路操作</h2><a id="more"></a>
<p>打开软件，在右侧<code>Properties</code>选中<code>Sample</code>为<code>Solo Mesh</code>，<code>Input Mesh</code>为<code>nav_test.obj</code>，下拉点击<code>Build</code>，就能看到生成navmesh的结果</p>
<p><img src="/uploads/gamedev/recastdemo/main_panel.png" alt="main_panel" title="&#39;main_panel&#39;"></p>
<p>在左侧的<code>Tools</code>栏下，点击<code>Test NavMesh</code>，然后在地表上用右键（shift+左键）以及左键分别标定起始位置和结束位置，就能够直接看到寻路路径生成的结果</p>
<p><img src="/uploads/gamedev/recastdemo/nav_result.png" alt="nav_result" title="&#39;nav_result&#39;"></p>
<p>左侧的<code>Tools</code>栏里面，点选<code>Pathfind Straight</code>，可以看到寻路路径的点位连接，点选<code>Pathfind Sliced</code>，可以看到寻路查找的整个过程。</p>
<h2 id="寻路参数调整"><a href="#寻路参数调整" class="headerlink" title="寻路参数调整"></a>寻路参数调整</h2><p>从先前的navmesh生成结果可以看到，在楼梯处没有生成寻路网格，所以如果用这么一个结果放到游戏里的话，玩家是不可能自动上楼的。</p>
<p>解决这个问题的方法，第一种是在<code>Properties</code>中，增加<code>Agent</code>的<code>Max Climb</code>，使得楼梯高度能够符合navmesh生成的标准。第二种是调整<code>Sample</code>为<code>Tile Mesh</code>，使得navmesh能够以一个地块tile为单位生成，地块与相邻地块之间也会计算连通性，从而使得寻路网格变成一个整体。在这个基础上，navmesh就会覆盖到每个台阶。之后，再使用跳点off-mesh连接每个台阶，使得台阶之间能够成为通路。</p>
<p>我们调整<code>Sample</code>为<code>Tile Mesh</code>，调小<code>Cell Size</code>和<code>Tile Size</code>，点击<code>Build</code>生成，再点选<code>NavMesh Portals</code>，就可以看到现在navmesh覆盖的范围以及不同tile之间的交界。</p>
<p><img src="/uploads/gamedev/recastdemo/tile_mesh.png" alt="tile_mesh" title="&#39;tile_mesh&#39;"></p>
<p>在台阶之间加上off-mesh，可以在左边<code>Tools</code>选择<code>Create Off-Mesh Links</code>去加双向的link。加完之后测试寻路，就能看到上楼的路径了。</p>
<p><img src="/uploads/gamedev/recastdemo/off_mesh.png" alt="off_mesh" title="&#39;off_mesh&#39;"></p>
<p>此外，还有一种常见的需要调整的参数，是地块的寻路成本，通常与地形的类型有关，比如在水里面，寻路的成本就高，在大路上，寻路的成本就低，并且有些时候，策划就希望玩家自动寻路能够优先去找有大路的路径。这个时候，可以通过<code>Convex Volumes</code>包裹/标识一些路面，在寻路的时候，这些路面相对于一般的路面，会有不同的成本计算规则。</p>
<p>在左侧的<code>Create Convex Volumes</code>选项中，我们可以创建一些包围盒，将特定的路面包裹住，标识这些路面的“地形”。比如下图的例子，我们在中间的小路标识了“Water”水体，最终寻路的结果，会从陆地绕道过去。</p>
<p><img src="/uploads/gamedev/recastdemo/convex_volume.png" alt="convex_volume" title="&#39;convex_volume&#39;"></p>
<p>在demo的<code>NavMeshTesterTool.cpp</code>中，我们可以看到不同“地形”对应的寻路成本定义。实际游戏开发时，寻路成本也有自定义的必要。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> NavMeshTesterTool::init(Sample* sample)</span><br><span class="line">&#123;</span><br><span class="line">    m_sample = sample;</span><br><span class="line">    m_navMesh = sample-&gt;getNavMesh();</span><br><span class="line">    m_navQuery = sample-&gt;getNavMeshQuery();</span><br><span class="line">    recalc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_navQuery)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Change costs.</span></span><br><span class="line">        m_filter.setAreaCost(SAMPLE_POLYAREA_GROUND, <span class="number">1.0f</span>);</span><br><span class="line">        m_filter.setAreaCost(SAMPLE_POLYAREA_WATER, <span class="number">10.0f</span>);</span><br><span class="line">        m_filter.setAreaCost(SAMPLE_POLYAREA_ROAD, <span class="number">1.0f</span>);</span><br><span class="line">        m_filter.setAreaCost(SAMPLE_POLYAREA_DOOR, <span class="number">1.0f</span>);</span><br><span class="line">        m_filter.setAreaCost(SAMPLE_POLYAREA_GRASS, <span class="number">2.0f</span>);</span><br><span class="line">        m_filter.setAreaCost(SAMPLE_POLYAREA_JUMP, <span class="number">1.5f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    m_neighbourhoodRadius = sample-&gt;getAgentRadius() * <span class="number">20.0f</span>;</span><br><span class="line">    m_randomRadius = sample-&gt;getAgentRadius() * <span class="number">30.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>初识RecastDemo，可以看到寻路网格生成和寻路逻辑是一个非常复杂的过程，并且也是一个需要逐渐优化的过程。寻路网格生成，不代表最终游戏里玩家自动寻路可以成功，不仅可能受到崎岖地形的困扰，动态阻挡、优先级体验等方面也是需要着重探索寻路问题的地方。</p>
<p>recast寻路相关的参考资料非常多，可以一一关注：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC83NDUzNzIzNg==" title="https://zhuanlan.zhihu.com/p/74537236">Recast基础<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC83ODg3MzM3OQ==" title="https://zhuanlan.zhihu.com/p/78873379">Detour寻路<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lubm1ubS9hcnRpY2xlL2RldGFpbHMvNDQ4MzMwMDc=" title="https://blog.csdn.net/ynnmnm/article/details/44833007">Nav导航网格寻路<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2RpZ2VzdGluZ2R1Y2suYmxvZ3Nwb3QuY29tLw==" title="http://digestingduck.blogspot.com/">recastnavigation开发者博客<i class="fa fa-external-link"></i></span></li>
<li>etc</li>
</ul>
]]></content>
      <categories>
        <category>游戏开发</category>
      </categories>
      <tags>
        <tag>寻路</tag>
        <tag>recast</tag>
        <tag>RecastDemo</tag>
        <tag>navmesh</tag>
        <tag>recastnavigation</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】python的excel库——openpyxl的用法</title>
    <url>/2021/07/11/testlife/openpyxl/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在测试工具的开发过程中，可能会遇到需要生成excel文件的需求。笔者在自研excel-diff工具的过程中，也同样接到了需要生成excel文件来展示每个sheet的diff数据。每个包含diff的sheet需要生成1个excel文件，每个文件分成3个sheet，2个sheet用于展示sheet原先的数据与修改后的数据，1个sheet用于描述性统计和超链接每个diff的情况。要生成这样的excel文件，不用专门的excel库是不行的。基于python的技术栈，经过一番调研，笔者采用openpyxl作为生成excel的库，并且顺利完成了需求。</p>
<p>学习openpyxl可以直接从<span class="exturl" data-url="aHR0cHM6Ly9vcGVucHl4bC5yZWFkdGhlZG9jcy5pby9lbi9zdGFibGUv" title="https://openpyxl.readthedocs.io/en/stable/">官方文档<i class="fa fa-external-link"></i></span>入手。一些基本操作如下：</p>
<a id="more"></a>
<h2 id="基础workbook与sheet操作"><a href="#基础workbook与sheet操作" class="headerlink" title="基础workbook与sheet操作"></a>基础workbook与sheet操作</h2><p>启动一个excel实例，直接构造<code>Workbook</code>实例即可：<code>wb = Workbook</code></p>
<p><code>Workbook</code>实例默认会带一个sheet，名称即为Sheet，可以直接通过<code>ws = wb.worksheets[0]</code>获取到这个默认的sheet。如果要改标题，可以直接用<code>ws.title = &#39;xxx&#39;</code>来执行。</p>
<p>为sheet添加数据有多种方法：</p>
<ul>
<li><code>ws.append(list_data)</code>，添加一行数据</li>
<li><code>ws.cell(row, col, value)</code>，为某行某列（都从1开始算）的单元格赋一个值</li>
</ul>
<p>创建sheet，通过<code>wb.create_sheet(title=&#39;xxx&#39;)</code>接口即可实现；通过<code>ws = wb.active</code>，可以设置某个sheet为默认打开展示的。</p>
<p>获取某行、某列以及单元格数据，可以通过<code>ws.iter_rows(row_idx, row_idx)</code>、<code>ws.iter_cols(col_idx, col_idx)</code>、<code>ws.cell(row_idx, col_idx)</code>获取，其中行、列索引均从1开始算。但如果只是要获取行、列实例，比如要调行列样式的话，需要通过<code>ws.row_dimensions[row_idx]</code>、<code>ws.col_dimensions[get_column_letter(col_idx)]</code>获取，其中<code>get_column_letter</code>是<code>openpyxl.util</code>中，通过列索引获得对应字母（A~Z，AA~AZ之类）的方法</p>
<p>通过<code>load_workbook</code>、<code>save_workbook</code>接口，可以读取或存储为excel文件。需要注意的是，这两个操作在大数据量表的情况下会有时间开销。</p>
<h2 id="样式设置"><a href="#样式设置" class="headerlink" title="样式设置"></a>样式设置</h2><p>调整excel表格样式，建议用<code>NamedStyle</code>定义各个不同的样式。一个<code>NamedStyle</code>可以应用单个单元格可支持的所有样式，包括：</p>
<ul>
<li>font：字体</li>
<li>fill：背景颜色</li>
<li>border：边框</li>
<li>alignment：排版（水平垂直居中之类）</li>
<li>etc</li>
</ul>
<p>单元格样式需要遍历每个单元格设置，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ns = NamedStyle(name=<span class="string">'test_style'</span>)</span><br><span class="line">ns.font = Font(bold=<span class="literal">True</span>)  <span class="comment"># 粗体</span></span><br><span class="line">ns.alignment = Alignment(wrapText=<span class="literal">True</span>)  <span class="comment"># 自动换行</span></span><br><span class="line">wb.add_named_style(ns)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row_idx <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">6</span>):</span><br><span class="line">    <span class="keyword">for</span> col_idx <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">7</span>):</span><br><span class="line">        ws.cell(row_idx, col_idx).style = <span class="string">'test_style'</span></span><br></pre></td></tr></table></figure>
<p>行、列样式，通过上述从<code>row_dimensions</code>、<code>col_dimensions</code>获取的实例，可以直接赋予<code>width</code>、<code>height</code>之类的行列样式属性</p>
<p>如果要冻结行列，需要通过设置<code>ws.freeze_panes</code>为特定值，这个值是这样规定的。比如<code>ws.freeze_panes = &#39;D5&#39;</code>，则表示冻结D列之前的A~C列，同时冻结5行之前的1~4行。以此类推，如果<code>ws.freeze_panes = &#39;A1&#39;</code>，那就是没有冻结的行列了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>openpyxl内部涵盖的功能非常丰富，笔者所讲述的只是冰山一角。有兴趣的同学可以尽情探索openpyxl的官方文档以及源代码，有问题也可直接google查阅~</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>测试开发</tag>
        <tag>openpyxl</tag>
        <tag>excel</tag>
        <tag>测试工具</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python随笔】python进程池ProcessPoolExecutor的用法与实现分析</title>
    <url>/2021/06/08/pythonnotes/python_processpoolexecutor/</url>
    <content><![CDATA[<p>在python开发期间，由于GIL的原因，不能直接采用并行的方式处理代码逻辑。在multiprocessing库的支持下，python程序能够启动子进程执行特定的任务，但子进程的管理也成为了问题。为了简化用户开发成本，python在concurrent.futures下内置了ProcessPoolExecutor这一数据结构，实现了简单的进程管理及任务调度。如果没有特别的需求，开发者只需要用ProcessPoolExecutor即可实现并行执行任务。因此，本文简单对ProcessPoolExecutor的实现进行分析，帮助大家更加了解python开发中进程/任务调度的一种方式。</p>
<p>首先来看ProcessPoolExecutor的用法，可以参考<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9saWJyYXJ5L2NvbmN1cnJlbnQuZnV0dXJlcy5odG1s" title="https://docs.python.org/3/library/concurrent.futures.html">官方文档<i class="fa fa-external-link"></i></span></p>
<ul>
<li>constructor：构造器<ul>
<li>max_workers：最大worker数量</li>
<li>context：进程启动方式，比如spawn、fork等。可以参考<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDM4MTg1MTkvd2hhdC1pcy10aGUtbWVhbmluZy1vZi1jb250ZXh0LWFyZ3VtZW50LWluLW11bHRpcHJvY2Vzc2luZy1wb29sLXBvb2wvNDM4MTg4Mjk=" title="https://stackoverflow.com/questions/43818519/what-is-the-meaning-of-context-argument-in-multiprocessing-pool-pool/43818829">这篇文章<i class="fa fa-external-link"></i></span></li>
<li>initializer：初始化环境用的回调/钩子，会在传进去的任务执行之前调用（比如要import什么库，读取什么配置之类）</li>
<li>initargs：初始化回调的参数</li>
</ul>
</li>
<li>submit：提交特定任务，返回一个future实例（类似于js的promise）</li>
<li>map：批量submit</li>
<li>shutdown：关闭进程池并销毁资源</li>
</ul>
<p>可以看到用法非常简单，用户一侧只需要这样操作即可得到任务执行结果：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(sleep_sec=<span class="number">10</span>, tag=<span class="string">'test'</span>)</span>:</span></span><br><span class="line">    print(<span class="string">'[%s] start sleep'</span> % tag)</span><br><span class="line">    time.sleep(sleep_sec)</span><br><span class="line">    print(<span class="string">'[%s] finish sleep'</span> % tag)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    process_pool = ProcessPoolExecutor(max_workers=<span class="number">3</span>)</span><br><span class="line">    future = process_pool.submit(task, <span class="number">3</span>, tag=<span class="string">'TEST'</span>)</span><br><span class="line">    ret = future.result()</span><br><span class="line">    print(<span class="string">'result is %s'</span> % str(ret))</span><br><span class="line">    process_pool.shutdown()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>然后就可以打印出以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[TEST] start sleep</span><br><span class="line">[TEST] finish sleep </span><br><span class="line">result is 100</span><br></pre></td></tr></table></figure>
<p>其中，finish sleep在start sleep打印的3秒后才打印出来</p>
<p>简单的入口后面肯定存在精巧的逻辑。在ProcessExecutorPool源码中，有很清晰的注释去阐述这一数据结构的实现，有兴趣的读者可以直接翻越源码，debug源码来探索其中的逻辑</p>
<p>ProcessPoolExecutor的基础结构如下：</p>
<p><img src="/uploads/geekdaily/python_processpoolexecutor/ProcessPoolExecutor.png" alt="python_processpoolexecutor"></p>
<p>其中，Queue Management Thread（队列管理线程）是整个ProcessPoolExecutor的核心，不仅控制任务的收发，而且调度任务在不同进程中的执行，并且处理因为各种原因带来的进程池的异常。</p>
<p>以上面代码为例，ProcessPoolExecutorl整个执行流程，可以如下所示：</p>
<ul>
<li>用户初始化ProcessPoolExecutor<ul>
<li>检查worker数量合法性，设置进程启动方式context</li>
<li>初始化WorkID队列、WorkID-&gt;WorkItem的缓存map、调用队列Call Queue、结果队列Result Queue</li>
<li>初始化用来激活队列管理线程的pipe<ul>
<li>队列管理线程会对一系列fd/pipe进行管理。pipe包括激活队列管理线程的以及结果队列的；fd则是进程池每个进程的</li>
<li>队列管理线程会select这些fd/pipe，根据对应事件作出行为</li>
</ul>
</li>
</ul>
</li>
<li>用户submit任务（函数+参数）到ProcessPoolExecutor实例<ul>
<li>自增WorkID，将任务所需的函数&amp;参数放到WorkItem，然后把这些信息缓存到到WorkID-&gt;WorkItem的map里</li>
<li>若是未启动进程池，先启动进程池。然后启动队列管理线程</li>
<li>唤醒队列管理线程工作<ul>
<li>唤醒的方式：给主线程连到激活队列管理线程的pipe发二进制空字符串，会被select到</li>
</ul>
</li>
<li>切到队列管理线程，线程内主循环先拿到WorkID&amp;WorkItem，同时侦测到被唤醒的signal，于是开始执行正常任务<ul>
<li>把WorkID跟WorkItem结合为CallItem放到Call Queue里</li>
<li>进程池每个进程会从Call Queue提取任务执行，将结果ResultItem放到Result Queue。如果进程异常，会直接把pid放到Result Queue</li>
<li>队列管理线程有个is_broken变量控制是否整个进程池/队列坏了，如果坏了就不能正常执行任务，整个executor都得被销毁</li>
</ul>
</li>
<li>队列管理线程select到Result Queue并读取其中内容。提取出运行结果后，和缓存的WorkID&amp;WorkItem对上。这样用户侧用future.result()就可以得到结果</li>
</ul>
</li>
<li>用户销毁ProcessPoolExecutor<ul>
<li>将关闭队列管理线程的flag置为true</li>
<li>队列管理线程在主循环中发现flag置为true，默认会等待所有WorkItem执行完后执行销毁操作</li>
<li>发送None给到进程池所有进程，这些进程收到None会返回pid，队列管理线程发现pid会自动除掉相应进程索引记录，并等待进程join</li>
<li>关闭Call Queue，赋值Result Queue为None</li>
<li>进程与Call Queue全部关闭后，队列管理线程跳出主循环，主线程等待队列管理线程join</li>
<li>关闭激活队列管理线程的pipe</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Python随笔</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>并发</tag>
        <tag>multiprocessing</tag>
        <tag>进程池</tag>
        <tag>ProcessPoolExecutor</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】Go语言string、int、float、rune、byte等数据类型的转换方法</title>
    <url>/2021/06/06/geekdaily/go_basic_data_types/</url>
    <content><![CDATA[<p>golang的数据类型转换是困惑新gopher的一大问题之一。相对于python，golang的数据类型转换可要麻烦的多，而且还不走寻常路地诞生了些新的方法跟名词。因此本文讲解golang常见数据类型string、int、rune等数据类型相互之间的转换方法，给大伙儿避坑。</p>
<p>在讲述方法之前，首先非常有必要讲下go源码对这些数据类型的表述：</p>
<a id="more"></a>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string is the set of all strings of 8-bit bytes, conventionally but not</span></span><br><span class="line"><span class="comment">// necessarily representing UTF-8-encoded text. A string may be empty, but</span></span><br><span class="line"><span class="comment">// not nil. Values of string type are immutable.</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">string</span> <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int is a signed integer type that is at least 32 bits in size. It is a</span></span><br><span class="line"><span class="comment">// distinct type, however, and not an alias for, say, int32.</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">int</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int32 is the set of all signed 32-bit integers.</span></span><br><span class="line"><span class="comment">// Range: -2147483648 through 2147483647.</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">int32</span> <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// uint64 is the set of all unsigned 64-bit integers.</span></span><br><span class="line"><span class="comment">// Range: 0 through 18446744073709551615.</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">uint64</span> <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// float32 is the set of all IEEE-754 32-bit floating-point numbers.</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">float32</span> <span class="keyword">float32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// float64 is the set of all IEEE-754 64-bit floating-point numbers.</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">float64</span> <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is</span></span><br><span class="line"><span class="comment">// used, by convention, to distinguish byte values from 8-bit unsigned</span></span><br><span class="line"><span class="comment">// integer values.</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rune is an alias for int32 and is equivalent to int32 in all ways. It is</span></span><br><span class="line"><span class="comment">// used, by convention, to distinguish character values from integer values.</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br></pre></td></tr></table></figure>
<p>从上面的描述我们可以获得以下信息：</p>
<ul>
<li><code>int</code>有符号，至少32位，但并不是<code>int32</code>的别称。如果把大于2147483647的数赋值<code>int</code>，<code>int</code>打出来也是正常的，没有损失精度</li>
<li><code>rune</code>就是<code>int32</code>，实际一般用来表示字符<code>char</code>的值。和一般的<code>char</code>不一样的是rune的精度比较高= =，并且golang也没有<code>char</code>这个内置关键字</li>
<li><code>byte</code>就是<code>uint8</code>，实际一般用来表示二进制数据中比特的值</li>
</ul>
<p>因此对于<code>rune</code>、<code>byte</code>这边，就可以当作uint8跟int32相关的转换了，这块的理解就容易得多</p>
<p>首先看字符串<code>string</code>到<code>int</code>、<code>float</code>等数值的转换：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testStringToDigit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"=============== test string to digit =================="</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">"1234567"</span></span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> i32 <span class="keyword">int32</span></span><br><span class="line">    <span class="keyword">var</span> ui64 <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    i, _ = strconv.Atoi(s)</span><br><span class="line">    i64, _ := strconv.ParseInt(s, <span class="number">10</span>, <span class="number">32</span>)</span><br><span class="line">    i32 = <span class="keyword">int32</span>(i64)</span><br><span class="line">    ui64, _ = strconv.ParseUint(s, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"string: %s, int: %d, int32:%d, uint64: %d\n"</span>,</span><br><span class="line">        s, i, i32, ui64)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sf <span class="keyword">string</span> = <span class="string">"1234512345.12345678901234"</span></span><br><span class="line">    <span class="keyword">var</span> f32 <span class="keyword">float32</span></span><br><span class="line">    <span class="keyword">var</span> f64 <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line">    f64, _ = strconv.ParseFloat(sf, <span class="number">64</span>)</span><br><span class="line">    f32In64, _ := strconv.ParseFloat(sf, <span class="number">32</span>)</span><br><span class="line">    f32 = <span class="keyword">float32</span>(f32In64)</span><br><span class="line">    fmt.Printf(<span class="string">"string: %s, float32: %f, float64: %f\n"</span>,</span><br><span class="line">        sf, f32, f64)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"===================================================="</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>string</code>到<code>int</code>用<code>strconv.Atoi</code>方法，而对于其它有bitSize限制的数据，则用<code>strconv.ParseInt</code>或者<code>strconv.ParseFloat</code>先转换成64位再调精度即可。</p>
<p>然后看数值到<code>string</code>的转换：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testDigitToString</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"=============== test digit to string =================="</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">12345</span></span><br><span class="line">    <span class="keyword">var</span> i32 <span class="keyword">int32</span> = <span class="number">-678</span></span><br><span class="line">    <span class="keyword">var</span> ui64 <span class="keyword">uint64</span> = <span class="number">901234567890</span></span><br><span class="line">    <span class="keyword">var</span> strInt <span class="keyword">string</span> = fmt.Sprintf(<span class="string">"%d"</span>, i)</span><br><span class="line">    <span class="keyword">var</span> strInt32 <span class="keyword">string</span> = strconv.FormatInt(<span class="keyword">int64</span>(i32), <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">var</span> strUInt64 <span class="keyword">string</span> = strconv.FormatUint(ui64, <span class="number">10</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"strInt: %s, strInt32: %s, strUInt64: %s\n"</span>,</span><br><span class="line">        strInt, strInt32, strUInt64)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> f32 <span class="keyword">float32</span> = <span class="number">3.1415926</span></span><br><span class="line">    <span class="keyword">var</span> f64 <span class="keyword">float64</span> = <span class="number">-3.1415926535897</span></span><br><span class="line">    <span class="keyword">var</span> strFloat32 <span class="keyword">string</span> = fmt.Sprintf(<span class="string">"%.5f"</span>, f32)</span><br><span class="line">    <span class="keyword">var</span> strFloat64 <span class="keyword">string</span> = strconv.FormatFloat(f64, <span class="string">'f'</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"strFloat32: %s, strFloat64: %s\n"</span>, strFloat32, strFloat64)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"===================================================="</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数值到<code>string</code>，最简单粗暴的方法是<code>fmt.Sprintf</code>格式化字符串。如果需要精调，则得用<code>strconv.ParseInt</code>、<code>strconv.ParseFloat</code>等方式。值得一提的是<code>strconv.ParseFloat</code>注释了多种格式可供选择，有兴趣的同学可以看源码。</p>
<p><code>string</code>和<code>rune</code>、<code>byte</code>之类数据的转换，可以如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testStringAndRuneAndByte</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"=============== test string &amp; rune &amp; byte =================="</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">"helloworld"</span></span><br><span class="line">    <span class="keyword">var</span> runes []<span class="keyword">rune</span> = []<span class="keyword">rune</span>(s)</span><br><span class="line">    <span class="keyword">var</span> bytes []<span class="keyword">byte</span> = []<span class="keyword">byte</span>(s)</span><br><span class="line">    fmt.Printf(<span class="string">"string: %s, runes: %v, bytes: %v\n"</span>, s, runes, bytes)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, char := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"type of index: %T\n"</span>, i) <span class="comment">// int</span></span><br><span class="line">            fmt.Printf(<span class="string">"type of char: %T\n"</span>, char)  <span class="comment">// int32</span></span><br><span class="line">            fmt.Printf(<span class="string">"digit value of char: %d\n"</span>, char) <span class="comment">// 104</span></span><br><span class="line">            fmt.Printf(<span class="string">"output char: %c\n"</span>, char) <span class="comment">// h</span></span><br><span class="line">            fmt.Printf(<span class="string">"is equal with rune value: %v\n"</span>, <span class="string">'h'</span> == <span class="keyword">rune</span>(char)) <span class="comment">// true</span></span><br><span class="line">            fmt.Printf(<span class="string">"is equal with byte value: %v\n"</span>, <span class="string">'h'</span> == <span class="keyword">byte</span>(char)) <span class="comment">// true</span></span><br><span class="line">            <span class="comment">// invalid expression -&gt; rune: int32, byte: uint8</span></span><br><span class="line">            <span class="comment">// fmt.Printf("is rune &amp; byte equals: %v\n", rune(char) == byte(char))</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"===================================================="</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>[]rune</code>、<code>[]byte</code>可直接将<code>string</code>变为<code>charArray</code>。值得一提的是，遍历<code>string</code>时每个<code>char</code>字符的类型为<code>int32</code>，可用<code>rune</code>表示；字符表达式<code>&#39;h&#39;</code>可以直接和<code>rune</code>、<code>byte</code>类型数字用<code>==</code>比较。</p>
<p>然后，由于<code>rune</code>、<code>byte</code>本身就是<code>int</code>系，所以这两个和<code>int</code>系类型间的转换会非常简单</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testIntAndRuneAndByte</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"=============== test int &amp; rune &amp; byte =================="</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> r <span class="keyword">rune</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">var</span> ui8 <span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line">    i, r = <span class="number">123456</span>, <span class="number">123456</span></span><br><span class="line">    fmt.Printf(<span class="string">"int is equal with rune int: %v\n"</span>, <span class="keyword">int32</span>(i) == r) <span class="comment">// true</span></span><br><span class="line">    b, ui8 = <span class="string">'a'</span>, <span class="string">'a'</span></span><br><span class="line">    fmt.Printf(<span class="string">"byte char is equal with uint8 char: %v\n"</span>, b == ui8) <span class="comment">// true</span></span><br><span class="line">    i = <span class="keyword">int</span>(<span class="string">'a'</span>)</span><br><span class="line">    r, b, ui8 = <span class="keyword">rune</span>(i), <span class="keyword">byte</span>(i), <span class="keyword">uint8</span>(i)</span><br><span class="line">    fmt.Printf(<span class="string">"int: %c, rune: %c, byte: %c, uint8: %c\n"</span>, i, r, b, ui8) <span class="comment">// 4 * 'a'</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"===================================================="</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个tips是通用数据类型<code>interface{}</code>转特定数据格式的方法，可以这样操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testInterfaceToInt</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"=============== test interface to digit =================="</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> itf <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    itf = <span class="number">1234567890123456789</span></span><br><span class="line">    i := itf.(<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cannot convert to int32/int64/float32/float64</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"interface: %v, int: %d\n"</span>, itf, i)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"===================================================="</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意<code>interface{}</code>赋值了个<code>int</code>，如果直接带后缀<code>.(int32)</code>这样指定其它数据类型，会直接报错</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>strconv</tag>
        <tag>数据类型转换</tag>
        <tag>go语法</tag>
        <tag>rune</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】游戏策划表格测试工具的技术实现</title>
    <url>/2021/06/01/testlife/table_test_tool/</url>
    <content><![CDATA[<p>在先前的<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjEvMDMvMDYvdGVzdGxpZmUvdGFibGVfY2hlY2sv" title="https://utmhikari.top/2021/03/06/testlife/table_check/">《游戏策划表格检查工具的一种设计》<i class="fa fa-external-link"></i></span>一文中，笔者分享了在一般游戏测试业务背景下设计策划表格检查工具的一种方式。本文基于先前文章的内容，将原先的表格检查工具升级为表格测试工具，涵盖更多的内容，并对其中部分技术实现进行分享。</p>
<h2 id="测试工具架构设计"><a href="#测试工具架构设计" class="headerlink" title="测试工具架构设计"></a>测试工具架构设计</h2><p>整个测试工具分为两个部分：</p>
<ul>
<li>仓库管理服务：负责管理多个策划表格的svn/git仓库，并涵盖导入表格数据的功能</li>
<li>表格测试服务：负责接收用户的测试请求，向仓库管理服务请求特定版本的数据，执行表格测试任务</li>
</ul>
<p>测试工具的整体架构如下图：</p>
<a id="more"></a>
<p><img src="/uploads/testlife/table_test_tool/table_test_tool.png" alt="表格测试工具" title="&#39;表格测试工具&#39;"></p>
<p>仓库管理服务需要挂载一个大空间的硬盘，硬盘里存储多个策划表格仓库，而管理服务则缓存仓库信息在redis中。同时用户可以在仓库管理服务的目录下自定义导入数据到redis的脚本，仓库管理服务运行时动态执行脚本代码，将表格数据以及其元数据导入到redis</p>
<p>策划表格测试服务连接redis，但约定上只有读的权限，没有增删的权限，且只能读取redis中缓存的表格数据及元数据。表格测试服务将测试相关的配置以及结果则都存储在mongodb中，提供服务接口给到web前端</p>
<p>设计仓库管理服务，如果用python的话，可以用<code>ProcessPoolExecutor</code>先开一组worker，每个worker在接收到任务时，再在其中开另外的<code>ProcessPoolExecutor</code>执行任务（像表格对比就需要同时更新并上传两个表的数据，因此得另外开pool去submit任务），在任务执行完后销毁每个worker里的pool。这样能够有效解决内存泄露的问题</p>
<h2 id="表格检查"><a href="#表格检查" class="headerlink" title="表格检查"></a>表格检查</h2><p>在先前的文章当中，提到表格检查的本质其实是数据导出，可以用mongodb聚合的方式去实现数据导出。</p>
<p>mongodb的聚合是由一系列的stages组合而成的，每个stage有固定的语法描述数据处理的方式。而放到表格数据导出这个需求里，我们可以拟定一套数据处理流水线：</p>
<ul>
<li>数据容器：从redis中读取某个版本的表格数据，转化成一个数据容器<code>DataContainer</code>的结构</li>
<li>初始数据：从数据容器中，筛选需要的数据作为初始数据，合并为一个<code>List[Dict[str, Any]]</code>形式的数据</li>
<li>数据处理步骤集：通过一系列数据处理步骤，将初始数据转化成包含最终需要的数据的集合<ul>
<li>每个数据处理步骤的接口定义是<code>process(data: List[Dict[str, Any]], container: DataContainer, tracer: PipelineStageTracer) -&gt; List[Dict[str, Any]]</code>，其中<code>data</code>是上一个处理步骤下来的数据，<code>container</code>是数据容器源头，<code>tracer</code>则用于跟踪当前处理步骤的信息</li>
</ul>
</li>
<li>数据提取规则：根据最终处理的数据，再次提取需要的数据出来，标注每个字段的含义。这一步主要用于人性化展示数据导出结果</li>
</ul>
<p>数据处理步骤需要实现json配置-&gt;处理步骤数据结构的转化。根据mongodb的定义，首先需要拆解这些步骤包含的元素：</p>
<p>一些基础的表达式包括：</p>
<ul>
<li>定位符<code>Locator</code>：xx.yy.zz，用来标识数据在某个object的位置</li>
<li>计算符<code>Calculator</code>：用于执行数学计算，参考<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9tZXRhL2FnZ3JlZ2F0aW9uLXF1aWNrLXJlZmVyZW5jZS8jYWdncmVnYXRpb24tZXhwcmVzc2lvbnM=" title="https://docs.mongodb.com/manual/meta/aggregation-quick-reference/#aggregation-expressions">aggregation expressions<i class="fa fa-external-link"></i></span>中的<code>arithemtic expr operators</code>部分</li>
<li>累积符<code>Accumulator</code>：用于提取某个列表数据的属性，参考<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvYWdncmVnYXRpb24vZ3JvdXAv" title="https://docs.mongodb.com/manual/reference/operator/aggregation/group/">mongodb group<i class="fa fa-external-link"></i></span>的内容</li>
</ul>
<p>一些基础的处理步骤包括：</p>
<ul>
<li>过滤<code>FilterStage</code>： 可以参照mongodb的<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvcXVlcnkv" title="https://docs.mongodb.com/manual/reference/operator/query/">查询实现<i class="fa fa-external-link"></i></span><ul>
<li>需要的基本数据包括：定位符<code>Locator</code>、运算符<code>Operator</code>、计算值<code>Value</code>。根据不同的<code>Operator</code>去解析不同的<code>Value</code>。比如如果需要进行逻辑运算，可以让<code>Value</code>变成内嵌<code>FilterStage</code>的列表</li>
</ul>
</li>
<li>联表<code>LookupStage</code>：可以参照mongodb的<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvYWdncmVnYXRpb24vbG9va3VwLw==" title="https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/">lookup实现<i class="fa fa-external-link"></i></span><ul>
<li>需要的基本数据包括：另一条流水线的定义<code>Pipeline</code>、自己流水线和另外流水线的<code>Locator</code>以及运算符<code>Operator</code>、流水线联入到的字段<code>Alias</code></li>
<li>可以根据lookup的实现自由添加stage的属性，比如保留不匹配的结果：<code>PreserveNullResults</code></li>
</ul>
</li>
<li>列表展开<code>FlattenStage</code>：展开特定定位符下的列表值，每一行包含列表的一个元素（1-&gt;n）的转换<ul>
<li>主要用于最终人性化地在表格中展示数据</li>
</ul>
</li>
<li>字段遴选<code>PickStage</code>：只保留特定的字段值到下一轮，通常用于内存优化</li>
</ul>
<p>每个stage都需要实现前面说的数据接口<code>process</code>。如果有特殊的数据检查需求，可以根据这些基础stage的定义方式去自创一些，实测用python创建一个新的stage，可能不需要100行。</p>
<p>有了这些基础，就能够以配置化的方式去实现数据检查规则。</p>
<h2 id="表格对比"><a href="#表格对比" class="headerlink" title="表格对比"></a>表格对比</h2><p>在<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjAvMDEvMjMvdGVzdGxpZmUvZXhjZWxfZGlmZi8=" title="https://utmhikari.top/2020/01/23/testlife/excel_diff/">《为游戏策划与QA量身定制的excel表diff算法》<i class="fa fa-external-link"></i></span>一文中已详尽叙述excel-diff的算法，本文在此基础上，提出一些tips：</p>
<ul>
<li>导入数据需要对excel做二次处理。建议去掉空表头的数据，否则会冗余较多内容</li>
<li>excel-diff算法方面，对行进行相似度比较是较为关键的一步，能够显著减少diff的时间。通常来讲，每行的前5列数据相对较为重要，从人类角度而言也通常通过前几列数据去区分哪些行做了改动。因此在相似度计算方面，前5列需要赋予高权重，如果匹配就加权重，不匹配则反减权重；而其他列则匹配加权重，不匹配不加权重。</li>
<li>前端如果用vue做的话，有些坑可以参考<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjEvMDUvMDEvZ2Vla2RhaWx5L2V4Y2VsX2RpZmZfdnhlLXRhYmxlLw==" title="https://utmhikari.top/2021/05/01/geekdaily/excel_diff_vxe-table/">《用vxe-table展示excel-diff的结果》<i class="fa fa-external-link"></i></span>一文</li>
</ul>
<h2 id="查询功能"><a href="#查询功能" class="headerlink" title="查询功能"></a>查询功能</h2><p>基于上面所提到的<code>DataContainer</code>，我们可以根据这个数据结构的特性设计一系列查询接口。这些都是比较简单方便实现的内容</p>
<ul>
<li>通过某个名字，搜对应的ID</li>
<li>输入一系列ID，输出一系列名字</li>
<li>输入一个宝箱ID，输出宝箱抽取的Mindmap</li>
<li>etc</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在数据管理+服务的架构设计基础上，可以实现多种多样的测试需求。并且从通用性角度来讲，每个项目都可以遵循以这个技术规范去扩展表格测试工具的实现，初期的话只需要修改数据导入redis的脚本就能够开始用上工具。接入上理应不会有太多障碍，同时也能把这个技术思路及产出给沉淀下来。</p>
<p>美中不足的地方，当前的工具实现还未考虑git/svn hook及时获取表格变更的diff，以及用git/svn的API获取更多仓库的信息。这些都是有挖掘价值的内容。</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>系统设计</tag>
        <tag>工具开发</tag>
        <tag>表格检查</tag>
        <tag>游戏测试</tag>
        <tag>测试开发</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏开发】UE4联机渲染swarm agent配置</title>
    <url>/2021/05/23/gamedev/ue4_swarm_build/</url>
    <content><![CDATA[<p>UE4在构建场景光照时，会启动<code>swarm agent</code>进行构建，但如果只用一台电脑会出现构建速度较慢的情况。为了加快编译的效率，需要配置联机渲染。</p>
<p>首先需要注意的是，在UE4中自动打开<code>swarm agent</code>和手动打开<code>swarm agent</code>会用到不同的配置。因此，建议的方法是手动打开<code>swarm agent</code>进行配置（对于所有机器），然后再开UE4。每个<code>swarm agent</code>以及调度器<code>swarm coordinator</code>的可执行文件位置，都在引擎的<code>Engine\Binaries\DotNET</code>下</p>
<p>在官方文档中，有<code>Unreal Swarm</code>配置的<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vZW4tVVMvUmVuZGVyaW5nQW5kR3JhcGhpY3MvTGlnaHRtYXNzL1VucmVhbFN3YXJtT3ZlcnZpZXcvaW5kZXguaHRtbA==" title="https://docs.unrealengine.com/en-US/RenderingAndGraphics/Lightmass/UnrealSwarmOverview/index.html">例子<i class="fa fa-external-link"></i></span>可以参考。假设你有一台性能强劲的机子，和一台你日常工作但性能一般般的机子。这样可以如下配置：</p>
<a id="more"></a>
<p>1、两台机子都必须装UE4（最好同一版本），都会自带<code>swarm agent</code>。两台机子局域网互通（Windows的话，开启网络共享），用主机名就可以访问对方。</p>
<p>2、<strong>将性能强劲的机子作为主机</strong>。在性能强劲的机子上，打开调度器<code>swarm coordinator</code>以及<code>swarm agent</code>，然后在<code>Settings -&gt; Distribution Settings</code>如下配置：</p>
<p><img src="/uploads/gamedev/ue4_swarm_agent/master_agent.png" alt="主机Agent" title="&#39;主机Agent&#39;"></p>
<p>配置项意义如下：</p>
<ul>
<li><code>AgentGroupName</code>：agent所属的组</li>
<li><code>AllowedRemoteAgentGroup</code>：哪些组的agent可以接收自己下发的任务</li>
<li><code>AllowedRemoteAgentNames</code>：哪些匹配名字的agent可以接收自己下发的任务</li>
<li><code>AvoidLocalExecution</code>：避免本地执行，优先分发任务到其它Agent。如果任务里某些步骤只能只能本地执行，实测选择<code>true</code>不会跑满核，而选择<code>false</code>会跑满。</li>
<li><code>CoordinatorRemotingHost</code>：调度器Host（主机名/域名/IP）</li>
<li><code>EnableStandaloneMode</code>：启用独立模式（不下发/接收构建任务）</li>
</ul>
<p>对于主机而言，<code>AgentGroupName</code>和<code>AllowedRemoteAgentGroup</code>可以设置成一样的值<code>UE4Render</code>，表示主机属于<code>UE4Render</code>组，并且从主机下发任务到自己；<code>AllowedRemoteAgentNames</code>填写通配符<code>*</code>表示允许所有机子；<code>AvoidLocalExecution</code>填写默认<code>false</code>即可；<code>CoordinatorRemotingHost</code>填写主机自己在局域网上的名字（保证稳定连上自己即可）；<code>EnableStandaloneMode</code>填写<code>false</code></p>
<p>填写完成之后，在主机的<code>swarm agent</code>上点击<code>Network -&gt; Ping Coordinator</code>，可以在调度器上看到主机的<code>swarm agent</code></p>
<p>之后需要设置主机<code>swarm agent</code>的性能参数。在<code>Settings -&gt; Developer Settings</code>下，将<code>ShowDevelopMenu</code>选择为<code>true</code>，就能看到<code>DeveloperSettings</code>页签。选中该页签，在<code>Local Performance Settings</code>下，设置<code>LocalJobsDefaultProcessPriority</code>和<code>RemoteJobsDefaultProcessPriority</code>为<code>AboveNormal</code>（最高优先级），然后将<code>LocalJobsDefaultProcessorCount</code>和<code>RemoteJobsDefaultProcessorCount</code>设置为<code>&lt;=主机逻辑处理器数-2</code>的值（不然可能用主机的人会卡死）。这样就能保证局域网内其他机子发起任务，主机可以出力了。</p>
<p>然后设置工作机的<code>swarm agent</code>，配置样例如下：</p>
<p><img src="/uploads/gamedev/ue4_swarm_agent/worker_agent.png" alt="工作机Agent" title="&#39;工作机Agent&#39;"></p>
<p>工作机和主机的<code>swarm agent</code>配置基本相同。工作机上，<code>AgentGroupName</code>和<code>AllowedRemoteAgentGroup</code>设置成为跟主机一样的值<code>UE4Render</code>；<code>AllowedRemoteAgentNames</code>填写通配符，允许任务下发到所有机子；<code>AvoidLocalExecution</code>可填写<code>true</code>，如果机子非常差的话，否则感觉工作机可以出力的话，就填写<code>false</code>，然后打开<code>DeveloperSettings</code>，将<code>LocalJobsDefaultProcessorCount</code>和<code>RemoteJobsDefaultProcessorCount</code>设置为<code>&lt;=工作机逻辑处理器数-2</code>的值，保证工作机在跑满一定核数的情况下，机子不会负载太高（这也是自己现在的设置）；<code>CoordinatorRemotingHost</code>填写局域网里主机的名称（最好不要填写IP，如果是自动分发的话）；<code>EnableStandaloneMode</code>填写<code>false</code>。工作机的<code>DeveloperSettings</code>下，和执行优先级相关的配置项可以保持和默认一样。</p>
<p>这样整个小集群就搭建完成了，可以在两台机子的<code>swarm agent</code>里，通过<code>Network</code>选项下的<code>Ping Coordinator</code>和<code>Ping Remote Agents</code>检查agent和调度器以及其它agent的连通性，相关信息会在<code>Log</code>日志页签显示。配置完<code>swarm agent</code>，工作机打开UE4，点击<code>Build</code>构建光照，就能够看到分布式构建的效果了。</p>
]]></content>
      <categories>
        <category>游戏开发</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>游戏开发</tag>
        <tag>swarm agent</tag>
        <tag>联机渲染</tag>
        <tag>分布式构建</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】副本自动化测试</title>
    <url>/2021/05/20/testlife/dungeon_autotest/</url>
    <content><![CDATA[<p>许多游戏，尤其是MMO，会包含“副本”这个概念，玩家通过打副本从而获得物品奖励及属性收益。通常来讲，单个游戏所涉及的副本数量/品种较多，因此在游戏测试过程当中，很难一次性全部遍历完所有副本的流程与玩法。为了解决这个问题，可以通过自动化测试的方式去冒烟副本玩法流程、检查奖励。为了让自动化测试用例执行更加稳定且易于维护，需要一套通用的逻辑模版去实现副本玩法自动化。自动化测试流程涉及多个部分，包括玩家账号的准备、副本的进入、副本流程、奖励检查，而本文主要考虑“副本流程”的实现。</p>
<p>副本玩法的机制可以如下描述：玩家在进入副本后，服务器会为玩家创建一个分线并让玩家执行切线操作切入副本内，而后下发副本信息，客户端则缓存信息，为玩家创建场景及指引，而后玩家根据指引游玩副本内的内容。每当玩家执行了特定的行为，比如走到指引的位置/干掉指引的怪物，就会触发这些指引绑定的触发器，触发器生效后，服务器就会同步触发出来的下一阶段的信息给到客户端，客户端便展示出下一阶段的指引，直到副本结束或者发生错误、意外退出为止。从副本机制可以看到，副本玩法的每一个步骤，在客户端中都有缓存相关的信息，在自动化的实现上，只需要每一个轮次读取副本信息，执行相关的行为即可（任务也是如此）。因此，我们可以设计如下的行为来自动跑副本：</p>
<a id="more"></a>
<p>首先需要定义副本信息状态<code>State</code>，每当状态发生变更，就说明自动化执行的行为取到了一定进展。针对状态是否变更，需要定义两类行为：<code>OnStateChanged</code>和<code>OnIdle</code>，分别对应状态变化与状态未变化（闲置）的情况。<code>OnStateChanged</code>里可以实现一些副本玩法常见的操作，而<code>OnIdle</code>方法可以集合某些副本里特殊的操作，这样可以保证副本行为的通用性。副本行为用一个循环表示，每个循环会更新当前副本信息状态，执行<code>OnStateChanged</code>或<code>OnIdle</code>。当<code>OnStateChanged</code>或<code>OnIdle</code>报错，或者<code>OnIdle</code>执行到一定的次数时，判定副本执行失败；当执行完一轮对应的后还需判断副本玩法是否已不可玩，如果还可玩的话就要继续循环，不可玩即检查副本是否已经成功完成。</p>
<p>整个流程设计可以如下图所示：</p>
<p><img src="/uploads/testlife/dungeon_autotest/dungeon_autotest.png" alt="副本自动化" title="&#39;副本自动化&#39;"></p>
<p>针对不同的副本玩法，可以在这个模板基础上进行不同的行为实现。如果副本流程更为复杂，可以在流程的各个节点增加钩子函数，并由子类实现钩子函数，从而应付一些特别的需求。如果有行为树等UI框架支持的话，描述副本行为将会变得容易很多，可以开个好头，但从中的细节，各个行为具体的实现，还需要根据实际情况仔细调试，这里也是耗费工作量最大的地方。</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>游戏自动化</tag>
        <tag>自动化测试</tag>
        <tag>游戏测试</tag>
        <tag>测试</tag>
        <tag>副本自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】用vxe-table展示excel-diff的结果</title>
    <url>/2021/05/01/geekdaily/excel_diff_vxe-table/</url>
    <content><![CDATA[<p>excel-differ是游戏测试常用的测试工具。在有些业务场景下，excel-diff的结果可能需要通过web展示。Vue技术栈下的<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20veHVsaWFuZ3poYW5fYWRtaW4vdnhlLXRhYmxl" title="https://gitee.com/xuliangzhan_admin/vxe-table">vxe-table<i class="fa fa-external-link"></i></span>表格组件能够支持大量数据的展示，因此可以用vxe-table展示excel-diff的结果。</p>
<p>excel-diff的算法本身，<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMjAvMDEvMjMvdGVzdGxpZmUvZXhjZWxfZGlmZi8=" title="https://utmhikari.top/2020/01/23/testlife/excel_diff/">先前的文章<i class="fa fa-external-link"></i></span>已有讲解，在结果展示上会按file-&gt;sheet来分。为了让结果展示更加人性化，需要对表格的样式进行区分。在<span class="exturl" data-url="aHR0cHM6Ly94dWxpYW5nemhhbl9hZG1pbi5naXRlZS5pby92eGUtdGFibGUvdjQvdGFibGUvYXBp" title="https://xuliangzhan_admin.gitee.io/vxe-table/v4/table/api">vxe-table的api列表<i class="fa fa-external-link"></i></span>中，我们可以通过<code>cell-class-name</code>的回调函数指定每个单元格的样式。针对excel-diff的结果可以这样设计样式：</p>
<a id="more"></a>
<ul>
<li>新增行/列：背景浅绿色</li>
<li>删除行/列：背景浅红色</li>
<li>重复行/列：背景浅灰色</li>
<li>移动行/列：背景浅橙色</li>
<li>修改单元格：背景浅黄色，字体红色</li>
</ul>
<p>用户在实际查看excel-diff结果时，通常需要自动滚动到对应的位置。vxe-table提供了如下api支持滚动：</p>
<ul>
<li><code>scrollToRow(row, fieldOrColumn)</code>：滚动到对应的行或列（注意field不是展示出来的表头）</li>
<li><code>scrollToColumn(fieldOrColumn)</code>：滚动到对应的列</li>
</ul>
<p>获取行、列的实例，可以用这些方法：</p>
<ul>
<li><code>getRowById(rowid)</code>：根据行的唯一主键（string）获取行</li>
<li><code>getColumns()</code>：获取columns列表</li>
<li><code>getColumnById(colid)</code>：根据列的唯一主键（string）获取列</li>
<li><code>getColumnByField(field)</code>：根据列的字段名获取列</li>
</ul>
<p>需要注意的是，滚动后，默认滚动到的行会置顶，列会放到最左边，观感不是很好。因此可以做以下的优化：</p>
<ul>
<li>当处在较为靠左的列，直接滚动到最左边</li>
<li>当处在较为靠右的列，直接滚动到最右边</li>
<li>其他情况下，滚动到前面隔2个的列</li>
<li>滚动到的行也可做类似处理，这样大部分选中数据都会显示在上面靠左的位置，基本满足观感需求</li>
</ul>
<p>针对大的表，可能会出现性能问题。性能的优化tips有以下几个：</p>
<ul>
<li>针对excel数据本身，过滤空表头、空行等无效数据，保证只有有效数据参与diff计算</li>
<li>表格需要设定<code>scroll-x</code>与<code>scroll-y</code>虚拟滚动设置，尽量一次性不渲染太多内容</li>
<li>用Object.freeze冻结excel数据、diff结果相关的object，因为这些object本身就应当是immutable的，用Object.freeze可<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ29sb3ZpbmcvcC8xMzk2OTY4NS5odG1s" title="https://www.cnblogs.com/goloving/p/13969685.html">避免vue做底层各属性的getter/setter绑定<i class="fa fa-external-link"></i></span></li>
<li>对于每个单元格取<code>cell-class-name</code>，也需要预先computed + Object.freeze一个缓存data，使得回调函数判断class-name直接可以在其中取字段来判断，这样逻辑复杂度会小</li>
<li>数据预处理中，如果要用到循环逻辑，可考虑普通的for循环代替forEach</li>
</ul>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>游戏测试</tag>
        <tag>测试开发</tag>
        <tag>前端开发</tag>
        <tag>vue</tag>
        <tag>vxe-table</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】UE4游戏枪械自动化测试的一些设计</title>
    <url>/2021/04/17/testlife/ue4_weapon_autotest/</url>
    <content><![CDATA[<p>在射击类游戏中，不可避免地需要对各种枪械武器进行测试。大多数情况下，枪械种类繁多，人工遍历测试会花非常多的时间，因此引入自动化测试替代人力执行部分冒烟用例，能够增加严重问题提早发现的可能性。枪械测试包括基础行为、伤害、弹道、后坐力等方面，从功能冒烟的角度考虑，基础行为和伤害是需要优先覆盖的部分。因此，本文以UE4引擎下的枪械测试为例，讲解基础行为跟伤害测试的一些设计。</p>
<a id="more"></a>
<p>对于枪械的基础行为测试，我们可以分为以下几种测试场景：</p>
<ul>
<li>装备武器<ul>
<li>切换到特定ID的武器，能正常卸下原来的，装备上新的</li>
</ul>
</li>
<li>射击行为<ul>
<li>正常开镜射击&amp;关镜</li>
<li>根据枪械类型的不同，能够正常执行单发/三发点射/全自动射击</li>
<li>蹲下、移动、跳跃射击正常</li>
<li>子弹正常消耗</li>
</ul>
</li>
<li>装填弹药<ul>
<li>手动装填，子弹数量正常</li>
<li>打完弹夹的子弹自动装填，子弹数量正常</li>
</ul>
</li>
<li>补充弹药<ul>
<li>利用道具或者走到特定的区域，触发弹药补充效果，补充数量正常</li>
</ul>
</li>
</ul>
<p>针对射击、开镜、移动、装填弹药等行为，因为在游戏中理应会有特定的快捷键绑定，所以在UE4引擎中可以直接调用对应的input逻辑来触发这些行为。</p>
<p>针对子弹数量是否正常的校验，需要了解的是不同的武器需要共同抽象出一些数据model逻辑（这块可以称之为”虚拟武器实例“），子弹数量的计算肯定也会放在内，因此可以通过获取这里面的数据来检查执行行为的前后，弹夹内以及备弹数量是否正常消耗或增加。</p>
<p>类似补充弹药等可能和其它功能模块耦合的行为，实现上就需要结合其他系统的内容，自己抽象一套逻辑了</p>
<p>针对伤害测试，主要的测试场景如下：</p>
<ul>
<li>伤害类型<ul>
<li>普通伤害</li>
<li>暴击伤害</li>
</ul>
</li>
<li>伤害效果<ul>
<li>血量正常减少，与飘字相符</li>
<li>特定的伤害，会产生特定的buff</li>
</ul>
</li>
</ul>
<p>针对伤害类型，主要看的是普通伤害和暴击伤害，暴击伤害的值需要比普通伤害的高。暴击的实现，假设是爆头的话，可以尝试获取射击对象的SkeletalMesh组件，然后头部socket的当前位置，然后通过rotate的接口使得角色能够朝向并瞄准到射击对象的头部。</p>
<p>针对伤害效果，需要注意的是如果是网游的话，客户端和服务器可能会分开独立计算伤害。客户端伤害数值的表现是飘字，可以通过hook飘字的接口来获取特定设计对象的伤害数据；服务端伤害数值的表现则是射击前后HP的减少。最后需要检测的就是，客户端飘字和服务器里HP减少的量相符。</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>游戏自动化</tag>
        <tag>UE4</tag>
        <tag>自动化测试</tag>
        <tag>游戏测试</tag>
        <tag>枪械自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>【代码艺廊】Protobuf+GRPC应用范例：protobuf-grpc-starter</title>
    <url>/2021/04/02/codegallery/protobuf_grpc_starter/</url>
    <content><![CDATA[<p>后端的服务间通常采用固定的协议&amp;rpc框架通信，当前主流的方案是以<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9wcm90b2J1Zg==" title="https://github.com/golang/protobuf">protobuf<i class="fa fa-external-link"></i></span>协议为基础，采用<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ3JwYy5pby8=" title="https://www.grpc.io/">grpc<i class="fa fa-external-link"></i></span>进行通信，这种方式在Golang的开发中尤其突出。因此，笔者决定做一个小的golang应用来踩坑protobuf+grpc编码模式，上传到github分享——这便是<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9wcm90b2J1Zi1ncnBjLXN0YXJ0ZXI=" title="https://github.com/utmhikari/protobuf-grpc-starter">protobuf-grpc-starter<i class="fa fa-external-link"></i></span>。</p>
<p>protobuf-grpc-starter主要受到了<span class="exturl" data-url="aHR0cHM6Ly9wYXN0ZWJpbi5jb20v" title="https://pastebin.com/">PasteBin<i class="fa fa-external-link"></i></span>的启发，用户post一段代码到服务器，得到一个短链接（shortLink），其它用户可以通过这个短链接取查看这个用户所发送的代码，实现代码文本分享。当存储文本量较大、且用户访问量较多时，数据库不一定能够承载的了查询的压力，这样就需要缓存来分担查询的任务。因此在protobuf-grpc-starter中，笔者编写了两个小server：WebSvr和CacheSvr，其中WebSvr用于处理用户的查询以及post文本请求，post的文本存储在单独的文件中；CacheSvr则在内部实现了一个驻留内存的LRU缓存，用来缓存短链接查询的结果（短链接only，保证强一致）。WebSvr和CacheSvr间基于protobuf协议采用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy1nbw==" title="https://github.com/grpc/grpc-go">grpc-go<i class="fa fa-external-link"></i></span>框架通信，处理获取/设定查询缓存的操作。为了保证新接触protobuf+grpc的同学能够专注于此，这个项目的prerequisities里也不会引入类似redis的中间件，而只有go、grpc、protobuf等相关的内容，包括：</p>
<ul>
<li>golang v1.16：有最新的库和特性</li>
<li>protoc：用来编译protobuf协议文件，需要在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL2Rvd25sb2Fkcw==" title="https://developers.google.com/protocol-buffers/docs/downloads">protoc下载地址<i class="fa fa-external-link"></i></span>下载较新的版本（protobuf3）</li>
<li>protoc-gen-go：用来生成golang的协议定义文件，可以在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL2dvdHV0b3JpYWw=" title="https://developers.google.com/protocol-buffers/docs/gotutorial">protobuf-go教程<i class="fa fa-external-link"></i></span>了解如何下载及生成文件</li>
<li>protoc-gen-go-grpc：用来生成golang的协议grpc定义的文件，可以在<span class="exturl" data-url="aHR0cHM6Ly9ncnBjLmlvL2RvY3MvbGFuZ3VhZ2VzL2dvL3F1aWNrc3RhcnQv" title="https://grpc.io/docs/languages/go/quickstart/">grpc-go教程<i class="fa fa-external-link"></i></span>了解如何下载及生成文件</li>
<li>make：项目里用了Makefile，因此需要支持make。Makefile里包含了文件生成（proto）以及服务器二进制文件生成（server）的指令</li>
</ul>
<p>整个项目的结构如下：</p>
<a id="more"></a>
<p><img src="/uploads/codegallery/protobuf_grpc_starter/structure.png" alt="protobuf_grpc_starter"></p>
<p>要体验项目，安装相关prerequisities之后，执行make编译生成协议go文件，并生成websvr与cachesvr的二进制文件。先执行cachesvr，再执行websvr，而后用户可以通过http client向websvr发送请求来观察两个服务的日志及状态。websvr的http服务器采用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpbi1nb25pYy9naW4=" title="https://github.com/gin-gonic/gin">gin<i class="fa fa-external-link"></i></span>框架，通过<code>main.go</code>源码可以直接查阅每个路由对应的handler以及内部逻辑。在这个项目里，针对用户角度的用例如下：</p>
<ul>
<li>post文本（document）：websvr会直接尝试将文本存储到DB（追加到文件）中，如果成功则返回一个短链接shortLink</li>
<li>查询document(s)：分两种情况<ul>
<li>不包含shortLink：取出DB文件所有内容，遍历查询所有符合query的document，返回一个document列表</li>
<li>包含shortLink<ul>
<li>调用CacheSvr的GetDocument函数尝试获取缓存的document。如果成功，直接返回这个document</li>
<li>如果不成功，则取出DB文件所有内容，遍历查询，直到有包含该shortLink的document为止</li>
<li>如果找到了，调用CacheSvr的SetDocument将这个document设置到缓存里，然后返回这个document。如果找不到，就返回错误</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>WebSvr和CacheSvr之间的grpc连接，参照了grpc-go中的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy1nby9ibG9iL21hc3Rlci9leGFtcGxlcy9mZWF0dXJlcy9rZWVwYWxpdmU=" title="https://github.com/grpc/grpc-go/blob/master/examples/features/keepalive">范例<i class="fa fa-external-link"></i></span>保持了长连接状态。调用CacheSvr函数的过程，也便是protobuf+grpc通信的过程。更多的信息，可以在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9wcm90b2J1Zi1ncnBjLXN0YXJ0ZXI=" title="https://github.com/utmhikari/protobuf-grpc-starter">protobuf-grpc-starter的github<i class="fa fa-external-link"></i></span>深入挖掘。</p>
<p>第一次踩坑这块的内容，纯属抛砖引玉，有疏漏之处，还需见谅~</p>
]]></content>
      <categories>
        <category>代码艺廊</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>后端开发</tag>
        <tag>gin</tag>
        <tag>protobuf</tag>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】游戏策划表格检查工具的一种解决方案</title>
    <url>/2021/03/06/testlife/table_check/</url>
    <content><![CDATA[<p>策划表格数据检查是游戏测试工作的刚性需求。在游戏开发期中，有大量bug的起因是策划同学在配置上不够规范到位。因此作为测试角度而言，需要更加便捷、更加精准的方法去定位到策划表格配置的问题。除了依靠业务人员自身对业务的熟悉程度之外，也更加依赖于一个强大有力的工具，辅助表格数据检查。</p>
<p>表格数据检查的目的有以下一些：给定某个数值策划案，检查实际配置与策划案是否有出入；给定某个配置规则，检查实际配置是否有不符合规则，造成风险的地方（除去程序导表检查的那一部分）。针对这些需求，简单粗暴的方法就是强行coding的方式，将读取表格（Excel）数据出来（或者将表格数据转化为程序文件），然后用编码的方式联表，继而通过coding逻辑，去导出不符合规则的数据。这一种方式虽然灵活，但对于业务侧同学，还存在壁垒以及需要突破的地方：</p>
<ul>
<li>壁垒：业务侧同学的技术能力，通常难以hold住coding的技巧。从技术人员角度而言，涵盖大量代码的臃肿的表格检查规则，可读性很差且难以维护。</li>
<li>突破：相较于人肉检查表格数据而言，时间的消耗主要在“联表”这一操作上面。游戏内部逻辑相对复杂，策划表之间的数据也是紧密耦合，比如一个宝箱抽取，就有可能涉及4~5个表的相互关系。如果不能够解决联表耗时的问题，表格数据检查的效率会大打折扣。</li>
</ul>
<p>因此总体来看，除了采用coding这一备选方案之外，另外一个较好的方法是采用声明式、配置化的方式描述表格检查规则，通过一系列数据处理规则的串联，导出来一份最终数据。这样一来相对减少了学习成本，从业务侧角度而言，从“学习coding”变成了“理解配置”；二来解决了联表效率的问题，业务侧只需要描述一个联表的数据处理规则，后台就可以自动按照规则描述的方式对数据处理，最终呈现到业务的，直截了当，就是最终的结果；三来解决了根本目的，不论是策划案比对（通常是另外的文档，不能按版本diff）还是检索不合规的数据，本质上都是数据导出，因此用数据处理规则的串联，就能解决大部分的需求。</p>
<a id="more"></a>
<p>了解mongodb的同学，多多少少都会听说到<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9jb3JlL2FnZ3JlZ2F0aW9uLXBpcGVsaW5lLw==" title="https://docs.mongodb.com/manual/core/aggregation-pipeline/">mongodb聚合<i class="fa fa-external-link"></i></span>，亦即数据处理流水线。在mongodb中，如果需要实现复杂的数据查询需求，就需要用到聚合的方式，定义多个流水线规则，比如过滤查询、排序、group、lookup、字段值转化、字段值计算等，去呈现最终的数据形式。这种数据查询的实现方式，与表格检查的需求不谋而合，因此笔者在实践中，也果断借鉴mongodb的思路，实现了导表、联表、转化字段、列表展开等多种数据处理规则，并且研发了Web前端界面方便实现简单的配置。这样一来，业务测试同学也只需要按照给定的规则配置方法，配置流水线规则，就能获得最终想要的数据。</p>
<p>现在剩下的问题是，原生的表格数据从何而来？如何管理？针对这点还是需要从用户的角度出发。用户侧所关心的内容无非只有这么几个：我用什么样的导表规则，需要在什么版本的策划表，导出什么样的数据。因此，当用户提交到表规则与策划表版本的之后，程序后台就需要自动执行相应的行为：更新表格到对应的版本-&gt;通过脚本去Archive表格数据为特定的数据结构-&gt;通过一系列数据处理规则加工数据-&gt;将数据转化为用户友好的形式呈现。在笔者的方案中，做了这么几件事情去解决这些问题：</p>
<ul>
<li>实现一套策划数据仓库管理系统，管理同时存在的多个策划表仓库，具体形式和笔者实现的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9yZXBvbWFzdGVy" title="https://github.com/utmhikari/repomaster">repomaster<i class="fa fa-external-link"></i></span>类似，仓库的元数据存在内存/缓存中，并且支持加载自定义导出数据脚本的方式导出策划配置数据。数据仓库管理模块需要与数据处理模块分离，尤其是仓库过大，每次更新仓库会占用较多资源，不分离的话会影响数据处理的进程。数据仓库管理与数据处理模块，通过共享代码/协议的方式，减少代码管理的成本。</li>
<li>在策划数据处理和数据仓库管理系统中，分别实现一套简易的事务管理系统。针对每一个用户的导表请求，数据处理模块生成一个后台事务单独处理。如果需要更新数据，就发送请求数据仓库管理模块更新数据，数据仓库管理模块也相应地生成一个后台事务，随机选择一个仓库更新/导出数据，并通知数据处理侧拿取导出的数据来处理。这一过程中，就算出现单点故障/数据未成功获取等意外情况，也是可以接受的。从经验上看，大量的时间瓶颈主要集中在更新仓库这一过程上。</li>
</ul>
<p>实现了这些，基本上一个表格检查工具就成型了。当然，表格检查除了这些需求之外，还有类似不同版本表格diff、gitlog追踪一类的需求。因此这一块的业务，待挖掘的空间是非常丰富的。</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>工具开发</tag>
        <tag>表格检查</tag>
        <tag>游戏测试</tag>
        <tag>测试开发</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏开发】用UE4的Subsystem来管理DataTable表格数据</title>
    <url>/2021/02/16/gamedev/ue4_datatable_subsystem/</url>
    <content><![CDATA[<p>在UE4游戏开发中，官方文档推荐了2套功能：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vZW4tVVMvSW50ZXJhY3RpdmVFeHBlcmllbmNlcy9EYXRhRHJpdmVuL2luZGV4Lmh0bWw=" title="https://docs.unrealengine.com/en-US/InteractiveExperiences/DataDriven/index.html">Data Driven Gameplay Elements<i class="fa fa-external-link"></i></span>以及<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vZW4tVVMvUHJvZ3JhbW1pbmdBbmRTY3JpcHRpbmcvU3Vic3lzdGVtcy9pbmRleC5odG1s" title="https://docs.unrealengine.com/en-US/ProgrammingAndScripting/Subsystems/index.html">Programming Subsystems<i class="fa fa-external-link"></i></span>。我们可以结合这两者的功效，实现一个简单的表格配置数据管理模块。</p>
<p>Data Driven Gameplay Elements讲述了一套通过DataTable数据表的asset驱动gameplay的方式。在C++代码中，我们可以预先定义好表结构所对应的USTRUCT，然后通过导入CSV文件的方式，去创建以该USTRUCT为结构基础的DataTable。这样在游戏里，如果需要读取配置数据的话，就可以直接在蓝图中添加获取DataTable以及获取行数据的节点，填写对应的asset路径与rowname（表格主键，以<code>---</code>为标题的列），就能够获得对应行的数据了。注意这种方式如果在需要热更的手游中是不适用的，需要用其他的方式（比如将表格配置转化为lua）</p>
<p>Programming Subsystems讲述了UE的Subsystem编程模式。Subsystem重点解决了单例Manager在游戏中生命周期的问题，并且能够直接导出方法到蓝图中，供蓝图侧调用。因此，Subsystem一个很棒的用途，就是分担BlueprintFunctionLibrary的工作。</p>
<p>以下，我们观察一个利用Subsystem模式在C++侧创建一个DataTable Manager的功能实例：</p>
<a id="more"></a>
<p>我们首先定义一个TableSubsystem，依附于GameInstance的生命周期，并作出如下约定：</p>
<ul>
<li>在游戏开始时，加载所有表格的数据</li>
<li>表格数据统一存储在<code>Content/Table</code>下，由UTF8-BOM的csv导入为DataTable，命名格式为<code>TB_表名</code></li>
</ul>
<p>因此可以简单写一个类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TableSubsystem.h</span></span><br><span class="line">UCLASS()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FOUNDERBOY_API</span> <span class="title">UTableSubsystem</span> :</span> <span class="keyword">public</span> UGameInstanceSubsystem</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TArray&lt;FString&gt; TableNames;</span><br><span class="line">    TMap&lt;FString, UDataTable*&gt; DB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(FSubsystemCollectionBase&amp; Collection)</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Deinitialize</span><span class="params">()</span> override</span>;</span><br><span class="line"></span><br><span class="line">    UFUNCTION(BlueprintCallable)</span><br><span class="line">        <span class="function">UDataTable* <span class="title">GetDataTable</span><span class="params">(<span class="keyword">const</span> FString&amp; TableName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">FORCEINLINE FString <span class="title">GetTableAssetPath</span><span class="params">(<span class="keyword">const</span> FString&amp; TableName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FString::Printf(TEXT(<span class="string">"DataTable'/Game/Table/TB_%s.TB_%s'"</span>), *TableName, *TableName);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function">UDataTable* <span class="title">LoadDataTableObj</span><span class="params">(<span class="keyword">const</span> FString&amp; TableName)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TableSubsystem.cpp</span></span><br><span class="line"><span class="keyword">void</span> UTableSubsystem::Initialize(FSubsystemCollectionBase&amp; Collection)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// init table data</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> load table data by cfg, not in hardcode stype</span></span><br><span class="line">    TableNames.Add(TEXT(<span class="string">"Monster"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> TableName : TableNames)</span><br><span class="line">    &#123;</span><br><span class="line">        UDataTable* DT = LoadDataTableObj(TableName);</span><br><span class="line">        <span class="keyword">if</span> (DT != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DB.Add(TableName, DT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> UTableSubsystem::Deinitialize()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UDataTable* UTableSubsystem::GetDataTable(<span class="keyword">const</span> FString&amp; TableName)</span><br><span class="line">&#123;</span><br><span class="line">    UDataTable** DT = DB.Find(TableName);</span><br><span class="line">    <span class="keyword">if</span> (DT == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *DT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UDataTable* UTableSubsystem::LoadDataTableObj(<span class="keyword">const</span> FString&amp; TableName)</span><br><span class="line">&#123;</span><br><span class="line">    FString AssetPath = GetTableAssetPath(TableName);</span><br><span class="line">    <span class="keyword">return</span> LoadObject&lt;UDataTable&gt;(<span class="literal">nullptr</span>, *AssetPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个类中，我们需要假设已经导入了一个Monster表，并且定义了对应的USTRUCT。编译完成之后，就可以在蓝图中使用<code>GetDataTable</code>节点获取已经加载的表格数据了：</p>
<p><img src="/uploads/gamedev/ue4_datatable_subsystem/bp.png" alt="获取表格数据" title="&#39;获取表格数据&#39;"></p>
<p>开发的时候，所有系统的表格数据检索接口都可以写在TableSubsystem里。在蓝图中如果需要检索各个表格的数据，就可以统一调用TableSubsystem的接口了。</p>
]]></content>
      <categories>
        <category>游戏开发</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>C++</tag>
        <tag>DataTable</tag>
        <tag>Subsystem</tag>
        <tag>游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title>【代码艺廊】start-fastapi升级，对FastAPI应用开发的全新理解</title>
    <url>/2021/01/24/codegallery/start_fastapi/</url>
    <content><![CDATA[<p>2021，新的开始，曾经精心制作的轻量级web后端框架<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9zdGFydC1mYXN0YXBp" title="https://github.com/utmhikari/start-fastapi">start-fastapi<i class="fa fa-external-link"></i></span>也经历了一次升级。这次升级，是基于这一年来使用start-fastapi开发以及应用与业务工作的经验，对已有框架进行的结构性的优化。</p>
<p>start-fastapi，甚至是<span class="exturl" data-url="aHR0cHM6Ly9mYXN0YXBpLnRpYW5nb2xvLmNvbS8=" title="https://fastapi.tiangolo.com/">FastAPI<i class="fa fa-external-link"></i></span>本身，其专注的方面都是在快速实现轻量级应用当中。在升级后2021版的结构中，针对如何更加效率地组成FastAPI应用，下了很多手笔。我们可以一探究竟：</p>
<a id="more"></a>
<p>升级版start-fastapi第一层只保留了4个目录：app、cfg、core、misc。app目录和core目录，都包含controller/handler、model和service，但区别在于，用户需要把项目专有的逻辑放到app目录下，而在core中编写底层逻辑，这样如果要用start-fastapi编写另外一个项目，那么python代码方面，core整个都可以copy过去，减少了项目迁移的成本。<br>cfg为配置目录，其二层目录名称代表着不同的运行环境，每个运行环境下包含一组相同文件名的配置集，这样能够易于管理各个环境的配置。所有部署、文档、开发资源等内容，统一放到misc目录下，通过这种方式，可以让开发者更加专注于业务逻辑的编写上。</p>
<p>除了目录方面的改动之外，也增加了如下内容，让用户更加方便地组成各类逻辑：</p>
<ul>
<li>增加response的基类、内部通用返回值的类型定义（success, message, data）。实现某些通用接口的时候，这些数据结构就能派上用场</li>
<li>抽象与框架相关的，和一些经常用到的工具函数，统一放到core的lib中，这样编写业务逻辑，就没有必要import一堆东西了</li>
<li>增加一个事务服务的模板（trans service），用来管理/监控各类需要通过fastapi的background task运行的任务。</li>
<li>增加一个生成handler、model、service代码模板的脚本，实现快速编程</li>
<li>etc</li>
</ul>
<p>更多的细节，clone/fork源码，细细挖掘吧~</p>
]]></content>
      <categories>
        <category>代码艺廊</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>python</tag>
        <tag>工具开发</tag>
        <tag>fastapi</tag>
        <tag>start-fastapi</tag>
      </tags>
  </entry>
  <entry>
    <title>【代码艺廊】代码仓库管理小工具repomaster</title>
    <url>/2021/01/01/codegallery/repomaster/</url>
    <content><![CDATA[<p>呼吸不停，coding不止。代码艺廊新系列，将要用来陈列自己的大小作品；极客日常系列，则专门用于分享新的技术心得。开年第一作，介绍一个自制用于管理代码仓库的小工具<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9yZXBvbWFzdGVy" title="https://github.com/utmhikari/repomaster">repomaster<i class="fa fa-external-link"></i></span>。</p>
<p>代码仓库管理在许多场景能够用到，比如用作构建集群的文件缓存、构建配置的代码仓库服务、配置导出与检查等等，其中最后一种需求在游戏QA的工作场景（导表检查）会是一个比较重要的需求，而repomaster的设计方式也会更加贴合管理大量同一个repo不同checkout副本的情况。作为一个纯靠内存作为缓存，无需持久化数据的应用，repomaster在技术选型上，Golang一定是最合适的语言（共享内存+方便的并发控制）。只需要少量的代码，就能够搭起来架子。</p>
<p>当前的repomaster已经具备如下的功能：</p>
<a id="more"></a>
<ul>
<li>代码仓库缓存与刷新：用<span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcub3JnL3NyYy9zeW5jL21hcC5nbw==" title="https://golang.org/src/sync/map.go">sync.Map<i class="fa fa-external-link"></i></span>就能够简单处理。每一个仓库都clone到特定数字文件夹当中，以文件夹名的数字作为key来存储每一个repo信息</li>
<li>代码仓库的拉取、更新、容错处理：当前支持git，以<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvLWdpdC9nby1naXQ=" title="https://github.com/go-git/go-git">go-git<i class="fa fa-external-link"></i></span>作为主要类库实现。由于go-git的内部接口较复杂，建议二次开发增加采用执行shell cmd的方式兜底。</li>
<li>代码仓库文件信息导出</li>
<li>采用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpbi1nb25pYy9naW4=" title="https://github.com/gin-gonic/gin">gin<i class="fa fa-external-link"></i></span>作为网络框架，稳定对外提供HTTP服务</li>
</ul>
<p>当前repomaster已经实现了缓存管理及git的支持，如果有需要适配特定业务的需求，可以直接在repomaster的service与handler模块上进行扩展。当前的实现也有很多优化扩展的空间，未来的维护计划，也希望把更多的Golang特性应用到repomaster当中。</p>
]]></content>
      <categories>
        <category>代码艺廊</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>工具开发</tag>
        <tag>git</tag>
        <tag>gin</tag>
        <tag>go-git</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】在UE4插件中启用Automation自动化测试功能</title>
    <url>/2020/12/20/testlife/ue4_automation/</url>
    <content><![CDATA[<p>UE4本身支持在前端会话中执行自动化测试功能。有了它，我们可以用C++编写对应的自动化脚本，在编辑器的生命周期中随时随地运行，测试整个研发系统的子功能。</p>
<p><img src="/uploads/testlife/ue4_automation/session_frontend.png" alt="会话前端" title="&#39;会话前端&#39;"></p>
<p>要深入了解UE4自带的自动化测试功能，可以参考<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vemgtQ04vVGVzdGluZ0FuZE9wdGltaXphdGlvbi9BdXRvbWF0aW9uL2luZGV4Lmh0bWw=" title="https://docs.unrealengine.com/zh-CN/TestingAndOptimization/Automation/index.html">自动化系统概述<i class="fa fa-external-link"></i></span>文章系列。而本文则介绍最简单的接入UE4自带Automation自动化测试的方法，以<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9VbnJlYWxBdXRvbWF0b3I=" title="https://github.com/utmhikari/UnrealAutomator">UnrealAutomator<i class="fa fa-external-link"></i></span>插件为例，提供一个最小的插件+Automation的范例</p>
<a id="more"></a>
<p>按照约定，每个插件需要在<code>Private/Tests</code>文件夹下，建立<code>插件名RunTests.cpp</code>，作为自动化测试的入口。</p>
<p>然后，通过宏注册自动化测试的类，并实现其<code>RunTest</code>函数，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">IMPLEMENT_SIMPLE_AUTOMATION_TEST(FUnrealAutomatorWidgetTest, <span class="string">"UnrealAutomator.Widget"</span>, EAutomationTestFlags::EditorContext | EAutomationTestFlags::EngineFilter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> FUnrealAutomatorWidgetTest::RunTest(<span class="keyword">const</span> FString&amp; Parameters)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 查看当前是否存在UWidget</span></span><br><span class="line">    UE_LOG(LogUnrealAutomator, Log, TEXT(<span class="string">"Start UA Widget Test..."</span>));</span><br><span class="line">    <span class="keyword">auto</span> WidgetJson = FUIService::GetWidgetTreeJson();</span><br><span class="line">    <span class="keyword">auto</span> WidgetJsonString = FCommonUtil::JsonStringify(WidgetJson);</span><br><span class="line">    UE_LOG(LogUnrealAutomator, Log, TEXT(<span class="string">"Current widget: %s"</span>), *WidgetJsonString);</span><br><span class="line">    TSharedPtr&lt;FJsonObject&gt; DefaultJsonObj = MakeShareable(<span class="keyword">new</span> FJsonObject());</span><br><span class="line">    <span class="keyword">return</span> !WidgetJsonString.IsEmpty() &amp;&amp;</span><br><span class="line">        !WidgetJsonString.Equals(FCommonUtil::JsonStringify(DefaultJsonObj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译，重启编辑器，打开会话前端的自动化测试页签，就能够看到该测试用例了：<code>UnrealAutomator.Widget</code>。</p>
<p>在编辑器中打开游戏，执行该测试用例，就能够判断当前是否存在UWidget了。</p>
<p>这是最简单的一种自动化测试，更为复杂的逻辑与测试机制可以参考<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vemgtQ04vVGVzdGluZ0FuZE9wdGltaXphdGlvbi9BdXRvbWF0aW9uL1RlY2huaWNhbEd1aWRlL2luZGV4Lmh0bWw=" title="https://docs.unrealengine.com/zh-CN/TestingAndOptimization/Automation/TechnicalGuide/index.html">自动化技术指南<i class="fa fa-external-link"></i></span>以及周边文章。后续的测试方式，还要慢慢研究~</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>游戏自动化</tag>
        <tag>UE4</tag>
        <tag>游戏测试</tag>
        <tag>UE4插件</tag>
        <tag>UE4 Automation</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python随笔】python轻量级消息队列库celery的应用</title>
    <url>/2020/11/29/pythonnotes/celery/</url>
    <content><![CDATA[<p>python语言，一般适用于快速实现业务需求的用途，在大型架构方面其应用范围并没有Java、Golang以及C++那么丰富，因此相对来讲还没有形成非常统一的技术体系。在某些需求中可能需要开发多个服务，服务之间需要实现异步通信，甚至是调用对方的函数。<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNlbGVyeXByb2plY3Qub3JnL2VuL3N0YWJsZS8=" title="https://docs.celeryproject.org/en/stable/">celery<i class="fa fa-external-link"></i></span>就是一个典型的例子，它提供了以将python函数注册到消息队列的方式暴露服务的方法，并且支持RabbitMQ、Redis等多种Broker中间代理形式。</p>
<p>celery同时也支持多个python的web框架，在其<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNlbGVyeXByb2plY3Qub3JnL2VuL3N0YWJsZS9nZXR0aW5nLXN0YXJ0ZWQvaW50cm9kdWN0aW9uLmh0bWw=" title="https://docs.celeryproject.org/en/stable/getting-started/introduction.html">介绍页<i class="fa fa-external-link"></i></span>中，也明确说明了Tornado、Django、web2py等框架都有自己的celery实现方法，当然要知道其他框架的实践，可以上github上探查一番。</p>
<p>celery简便易用，本文笔者以自己整理的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9zdGFydC1mYXN0YXBp" title="https://github.com/utmhikari/start-fastapi">start-fastapi<i class="fa fa-external-link"></i></span>为例，讲述接入celery的方法。</p>
<a id="more"></a>
<p>首先克隆start-fastapi，是笔者稍微加料的一个fastapi版本，主要在fastapi原本基础上对配置以及目录进行了整理，形成了一个开箱即用的Web后端框架。以Redis作为broker为例，我们首先需要<code>pip install celery[redis]</code>，然后可以在<code>service.celery</code>中新建一个<code>app.py</code>文件，作为celery的app实例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">celery_app = Celery(<span class="string">'celery_tester'</span>,</span><br><span class="line">                    broker=<span class="string">'redis://:helloword@localhost:6379/0'</span>,</span><br><span class="line">                    backend=<span class="string">'redis://:helloword@localhost:6379/1'</span>)</span><br><span class="line"></span><br><span class="line">celery_app.conf.update(task_track_started=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>对于整个消息队列，broker代理的信息缓存在DB0中，而backend存储每一个消息trace info，缓存在DB1中。</p>
<p>之后在<code>service.celery</code>新建<code>worker.py</code>文件，里面import app后，注册待暴露的函数。这里的例子是通过item_id延迟3s获取item的price，<code>get_item</code>方法获取了item basemodel的实例，通过这个实例可以拿到price</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .app <span class="keyword">import</span> celery_app</span><br><span class="line"><span class="keyword">from</span> service <span class="keyword">import</span> item <span class="keyword">as</span> item_service</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@celery_app.task(acks_late=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_item_price</span><span class="params">(item_id: int)</span> -&gt; float:</span></span><br><span class="line">    item = item_service.get_item(item_id)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> item:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span></span><br><span class="line">    <span class="keyword">return</span> item.price</span><br></pre></td></tr></table></figure>
<p>为了让这个函数能暴露出去，我们需要应用这个worker文件的内容。进入到项目根目录，如果用venv的话，先<code>source ./venv/bin/activate</code>，然后执行<code>celery -A service.celery.worker worker -l info</code>，就能够启动celery的worker，并且可以看到tasks中有了<code>service.celery.worker.get_item_price</code></p>
<p>通过<code>ps -ef | grep python</code>，我们看到如下信息，可以看到fastapi应用跟celery worker处在不同的进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root         786       1  0 20:01 ?        00:00:00 /usr/bin/python3 /usr/bin/networkd-dispatcher --run-startup-triggers</span><br><span class="line">root         874       1  0 20:01 ?        00:00:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal</span><br><span class="line">hikari      3934    3067  1 20:28 pts/0    00:00:00 /home/hikari/PycharmProjects/celery_test/venv/bin/python /home/hikari/PycharmProjects/celery_test/venv/bin/celery -A service.celery.worker worker -l info</span><br><span class="line">hikari      3936    3934  0 20:28 pts/0    00:00:00 /home/hikari/PycharmProjects/celery_test/venv/bin/python /home/hikari/PycharmProjects/celery_test/venv/bin/celery -A service.celery.worker worker -l info</span><br><span class="line">hikari      3937    3934  0 20:28 pts/0    00:00:00 /home/hikari/PycharmProjects/celery_test/venv/bin/python /home/hikari/PycharmProjects/celery_test/venv/bin/celery -A service.celery.worker worker -l info</span><br><span class="line">hikari      3938    3934  0 20:28 pts/0    00:00:00 /home/hikari/PycharmProjects/celery_test/venv/bin/python /home/hikari/PycharmProjects/celery_test/venv/bin/celery -A service.celery.worker worker -l info</span><br><span class="line">hikari      3939    3934  0 20:28 pts/0    00:00:00 /home/hikari/PycharmProjects/celery_test/venv/bin/python /home/hikari/PycharmProjects/celery_test/venv/bin/celery -A service.celery.worker worker -l info</span><br><span class="line">hikari      3940    3934  0 20:28 pts/0    00:00:00 /home/hikari/PycharmProjects/celery_test/venv/bin/python /home/hikari/PycharmProjects/celery_test/venv/bin/celery -A service.celery.worker worker -l info</span><br><span class="line">hikari      3941    3934  0 20:28 pts/0    00:00:00 /home/hikari/PycharmProjects/celery_test/venv/bin/python /home/hikari/PycharmProjects/celery_test/venv/bin/celery -A service.celery.worker worker -l info</span><br><span class="line">hikari      3954    2728 12 20:28 ?        00:00:00 /home/hikari/PycharmProjects/celery_test/venv/bin/python /home/hikari/PycharmProjects/celery_test/main.py</span><br><span class="line">hikari      3955    3954  0 20:28 ?        00:00:00 /home/hikari/PycharmProjects/celery_test/venv/bin/python -c from multiprocessing.resource_tracker import main;main(4)</span><br><span class="line">hikari      3956    3954  4 20:28 ?        00:00:00 /home/hikari/PycharmProjects/celery_test/venv/bin/python -c from multiprocessing.spawn import spawn_main; spawn_main(tracker_fd=5, pipe_handle=7) --multiprocessing-fork</span><br><span class="line">hikari      3968    3086  0 20:28 pts/1    00:00:00 grep --color=auto python</span><br></pre></td></tr></table></figure>
<p>于是乎，我们增加一个controller，用来测试celery worker是否生效。controller也引用<code>service.celery.app</code>，通过<code>send_task</code>执行<code>service.celery.worker.get_item_price</code>任务，传参为1，然后再打印返回值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@router.get('/v1/test/celery')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_celery</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    test celery example</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    task = celery_app.send_task(<span class="string">'service.celery.worker.get_item_price'</span>, args=[<span class="number">1</span>])</span><br><span class="line">    LOGGER.info(<span class="string">'triggered celery task: %s'</span> % task)</span><br><span class="line">    print(task.get())</span><br><span class="line">    <span class="comment"># background_tasks.add_task(on_celery_message, task)</span></span><br><span class="line">    <span class="keyword">return</span> success(msg=<span class="string">'triggered celery test!'</span>)</span><br></pre></td></tr></table></figure>
<p>我们通过<code>curl http://127.0.0.1:8000/v1/test/celery</code>来测试这个接口。结果也很显然，约3s之后，fastapi端打印了返回值到stdout中，然后curl接口返回了success。</p>
<p>例子已经上传到<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9mYXN0YXBpLWNlbGVyeS10ZXN0" title="https://github.com/utmhikari/fastapi-celery-test">fastapi-celery-test<i class="fa fa-external-link"></i></span>上，基本操作就系介样，后面再慢慢探索把~</p>
]]></content>
      <categories>
        <category>Python随笔</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>start-fastapi</tag>
        <tag>web开发</tag>
        <tag>celery</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python随笔】python的os.walk方法源码分析</title>
    <url>/2020/11/15/pythonnotes/python_os_walk/</url>
    <content><![CDATA[<p>在日常python编程中，有很多遍历文件夹内文件的需求，而os.walk方法就是一个满足该需求的例子。不熟悉这个方法的同学，刚开始用os.walk的时候难免踩坑。因此本文采用源码分析的方式，讲述os.walk的机理，让大家对于这个方法有更加深入的理解。</p>
<p>以python3为例，os.walk方法的源码如下：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(top, topdown=True, onerror=None, followlinks=False)</span>:</span></span><br><span class="line">    <span class="string">"""Directory tree generator.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    For each directory in the directory tree rooted at top (including top</span></span><br><span class="line"><span class="string">    itself, but excluding '.' and '..'), yields a 3-tuple</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        dirpath, dirnames, filenames</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    dirpath is a string, the path to the directory.  dirnames is a list of</span></span><br><span class="line"><span class="string">    the names of the subdirectories in dirpath (excluding '.' and '..').</span></span><br><span class="line"><span class="string">    filenames is a list of the names of the non-directory files in dirpath.</span></span><br><span class="line"><span class="string">    Note that the names in the lists are just names, with no path components.</span></span><br><span class="line"><span class="string">    To get a full path (which begins with top) to a file or directory in</span></span><br><span class="line"><span class="string">    dirpath, do os.path.join(dirpath, name).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If optional arg 'topdown' is true or not specified, the triple for a</span></span><br><span class="line"><span class="string">    directory is generated before the triples for any of its subdirectories</span></span><br><span class="line"><span class="string">    (directories are generated top down).  If topdown is false, the triple</span></span><br><span class="line"><span class="string">    for a directory is generated after the triples for all of its</span></span><br><span class="line"><span class="string">    subdirectories (directories are generated bottom up).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    When topdown is true, the caller can modify the dirnames list in-place</span></span><br><span class="line"><span class="string">    (e.g., via del or slice assignment), and walk will only recurse into the</span></span><br><span class="line"><span class="string">    subdirectories whose names remain in dirnames; this can be used to prune the</span></span><br><span class="line"><span class="string">    search, or to impose a specific order of visiting.  Modifying dirnames when</span></span><br><span class="line"><span class="string">    topdown is false has no effect on the behavior of os.walk(), since the</span></span><br><span class="line"><span class="string">    directories in dirnames have already been generated by the time dirnames</span></span><br><span class="line"><span class="string">    itself is generated. No matter the value of topdown, the list of</span></span><br><span class="line"><span class="string">    subdirectories is retrieved before the tuples for the directory and its</span></span><br><span class="line"><span class="string">    subdirectories are generated.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    By default errors from the os.scandir() call are ignored.  If</span></span><br><span class="line"><span class="string">    optional arg 'onerror' is specified, it should be a function; it</span></span><br><span class="line"><span class="string">    will be called with one argument, an OSError instance.  It can</span></span><br><span class="line"><span class="string">    report the error to continue with the walk, or raise the exception</span></span><br><span class="line"><span class="string">    to abort the walk.  Note that the filename is available as the</span></span><br><span class="line"><span class="string">    filename attribute of the exception object.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    By default, os.walk does not follow symbolic links to subdirectories on</span></span><br><span class="line"><span class="string">    systems that support them.  In order to get this functionality, set the</span></span><br><span class="line"><span class="string">    optional argument 'followlinks' to true.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Caution:  if you pass a relative pathname for top, don't change the</span></span><br><span class="line"><span class="string">    current working directory between resumptions of walk.  walk never</span></span><br><span class="line"><span class="string">    changes the current directory, and assumes that the client doesn't</span></span><br><span class="line"><span class="string">    either.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Example:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    import os</span></span><br><span class="line"><span class="string">    from os.path import join, getsize</span></span><br><span class="line"><span class="string">    for root, dirs, files in os.walk('python/Lib/email'):</span></span><br><span class="line"><span class="string">        print(root, "consumes", end="")</span></span><br><span class="line"><span class="string">        print(sum(getsize(join(root, name)) for name in files), end="")</span></span><br><span class="line"><span class="string">        print("bytes in", len(files), "non-directory files")</span></span><br><span class="line"><span class="string">        if 'CVS' in dirs:</span></span><br><span class="line"><span class="string">            dirs.remove('CVS')  # don't visit CVS directories</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    top = fspath(top)</span><br><span class="line">    dirs = []</span><br><span class="line">    nondirs = []</span><br><span class="line">    walk_dirs = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># We may not have read permission for top, in which case we can't</span></span><br><span class="line">    <span class="comment"># get a list of the files the directory contains.  os.walk</span></span><br><span class="line">    <span class="comment"># always suppressed the exception then, rather than blow up for a</span></span><br><span class="line">    <span class="comment"># minor reason when (say) a thousand readable directories are still</span></span><br><span class="line">    <span class="comment"># left to visit.  That logic is copied here.</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Note that scandir is global in this module due</span></span><br><span class="line">        <span class="comment"># to earlier import-*.</span></span><br><span class="line">        scandir_it = scandir(top)</span><br><span class="line">    <span class="keyword">except</span> OSError <span class="keyword">as</span> error:</span><br><span class="line">        <span class="keyword">if</span> onerror <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            onerror(error)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> scandir_it:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    entry = next(scandir_it)</span><br><span class="line">                <span class="keyword">except</span> StopIteration:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> OSError <span class="keyword">as</span> error:</span><br><span class="line">                <span class="keyword">if</span> onerror <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    onerror(error)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                is_dir = entry.is_dir()</span><br><span class="line">            <span class="keyword">except</span> OSError:</span><br><span class="line">                <span class="comment"># If is_dir() raises an OSError, consider that the entry is not</span></span><br><span class="line">                <span class="comment"># a directory, same behaviour than os.path.isdir().</span></span><br><span class="line">                is_dir = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> is_dir:</span><br><span class="line">                dirs.append(entry.name)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nondirs.append(entry.name)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> topdown <span class="keyword">and</span> is_dir:</span><br><span class="line">                <span class="comment"># Bottom-up: recurse into sub-directory, but exclude symlinks to</span></span><br><span class="line">                <span class="comment"># directories if followlinks is False</span></span><br><span class="line">                <span class="keyword">if</span> followlinks:</span><br><span class="line">                    walk_into = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        is_symlink = entry.is_symlink()</span><br><span class="line">                    <span class="keyword">except</span> OSError:</span><br><span class="line">                        <span class="comment"># If is_symlink() raises an OSError, consider that the</span></span><br><span class="line">                        <span class="comment"># entry is not a symbolic link, same behaviour than</span></span><br><span class="line">                        <span class="comment"># os.path.islink().</span></span><br><span class="line">                        is_symlink = <span class="literal">False</span></span><br><span class="line">                    walk_into = <span class="keyword">not</span> is_symlink</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> walk_into:</span><br><span class="line">                    walk_dirs.append(entry.path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Yield before recursion if going top down</span></span><br><span class="line">    <span class="keyword">if</span> topdown:</span><br><span class="line">        <span class="keyword">yield</span> top, dirs, nondirs</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Recurse into sub-directories</span></span><br><span class="line">        islink, join = path.islink, path.join</span><br><span class="line">        <span class="keyword">for</span> dirname <span class="keyword">in</span> dirs:</span><br><span class="line">            new_path = join(top, dirname)</span><br><span class="line">            <span class="comment"># Issue #23605: os.path.islink() is used instead of caching</span></span><br><span class="line">            <span class="comment"># entry.is_symlink() result during the loop on os.scandir() because</span></span><br><span class="line">            <span class="comment"># the caller can replace the directory entry during the "yield"</span></span><br><span class="line">            <span class="comment"># above.</span></span><br><span class="line">            <span class="keyword">if</span> followlinks <span class="keyword">or</span> <span class="keyword">not</span> islink(new_path):</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">from</span> walk(new_path, topdown, onerror, followlinks)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Recurse into sub-directories</span></span><br><span class="line">        <span class="keyword">for</span> new_path <span class="keyword">in</span> walk_dirs:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> walk(new_path, topdown, onerror, followlinks)</span><br><span class="line">        <span class="comment"># Yield after recursion if going bottom up</span></span><br><span class="line">        <span class="keyword">yield</span> top, dirs, nondirs</span><br></pre></td></tr></table></figure>
<p>os.walk包含了4个参数：top、topdown、onerror以及followlinks。top指代需要遍历的根目录；topdown指代是否自顶向下进行遍历；onerror为过程中抛异常的回调；followlinks指代是否需要跟踪符号链接。</p>
<p>从源码和注释中可以看到，os.walk本身返回的是一个生成器generator。生成器会根据上一次的状态，不断地生产下一个值，因此生成器生成的值可能会是无穷无尽的，但因为只保留少量的状态信息，所以不太耗费资源。想象一下，如果遍历一个包含大量文件的文件夹，不用生成器直接把遍历所有的结果整合起来给到调用者，那势必需要花费相当多的资源去存储所有结果的信息。每当遍历到一个文件夹时，os.walk会采取如下操作：</p>
<ul>
<li>尝试获得os.scandir的iterator迭代器。scandir方法，返回的也是generator，和listdir不同。</li>
<li>在scandir_iterator作用域里，不断调用next获取文件夹下剩余的entry</li>
<li>判断entry是文件夹还是文件，分别放到dirs与nondirs列表中</li>
<li>如果不是topdown自顶向下，而是bottomup自底向上，需要将搜到的子文件夹/符号链接的文件夹放到walk_dirs中，后续先遍历它们</li>
<li>确定dirs跟nondirs列表后，根据是否自顶向下遍历来执行行为<ul>
<li>如果设置了自顶向下遍历，就yield <code>(当前目录, 子一层的文件夹列表, 子一层的非文件夹列表)</code>。值得一提的是，我们可以修改子一层文件夹列表里面的值，来实现比如剪枝的需求</li>
<li>如果设置自底向上，就先yield from walk_dirs里的各个文件夹及子一层文件夹/非文件夹列表，然后再yield当前目录/子一层信息</li>
</ul>
</li>
</ul>
<p>os.walk的原理大致如此。与此同时，os.walk方法也是一个非常典型的使用generator的例子，值得我们在应用python的时候学习与回顾</p>
]]></content>
      <categories>
        <category>Python随笔</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>python</tag>
        <tag>遍历文件</tag>
        <tag>os.walk</tag>
        <tag>generator</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】UE4插件通过C++导出LLM数据的方法</title>
    <url>/2020/11/08/geekdaily/ue4_llm_dump_cpp/</url>
    <content><![CDATA[<p>近期为了丰富UE4插件<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9VbnJlYWxBdXRvbWF0b3I=" title="https://github.com/utmhikari/UnrealAutomator">UnrealAutomator<i class="fa fa-external-link"></i></span>的基础功能，在ProfileService中增加了<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vZW4tVVMvUHJvZ3JhbW1pbmcvRGV2ZWxvcG1lbnQvVG9vbHMvTG93TGV2ZWxNZW1vcnlUcmFja2VyL2luZGV4Lmh0bWw=" title="https://docs.unrealengine.com/en-US/Programming/Development/Tools/LowLevelMemoryTracker/index.html">LLM<i class="fa fa-external-link"></i></span>数据获取的方法。LLM拥有抓取UE4底层模块内存使用情况的功能，各种Modules按照LLM的规范实现相应宏即可将内存使用数据实时更新到LLM系统中。如果从产品外部，是难以直接访问这些信息的。</p>
<p>以UE4.24为例，用C++在UE4插件实现LLM数据获取的方式如下：</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * See HAL/LowLevelMemTracker.h</span></span><br><span class="line"><span class="comment"> * If detailed info is needed, a proper solution is to make vars/functions explicitly in LLM.h/.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TSharedPtr&lt;FJsonObject&gt; FProfileService::GetLLMStats()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE_LOW_LEVEL_MEM_TRACKER &amp;&amp; STATS</span></span><br><span class="line">    FLowLevelMemTracker&amp; LLM = FLowLevelMemTracker::Get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get all tags</span></span><br><span class="line">    TArray&lt;<span class="keyword">const</span> TCHAR*&gt; LLMTagNames;</span><br><span class="line">    TArray&lt;ELLMTag&gt; LLMTags;</span><br><span class="line">    TArray&lt;FName&gt; LLMTagStatNames;</span><br><span class="line">    TArray&lt;FName&gt; LLMTagStatGroupNames;</span><br><span class="line">    <span class="keyword">for</span> (uint64 i = <span class="number">0</span>; i &lt; (int32)ELLMTag::GenericTagCount; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> TCHAR* TagName = LLM.FindTagName(i);</span><br><span class="line">        <span class="keyword">if</span> (TagName != <span class="literal">nullptr</span> &amp;&amp; !FString(TagName).Equals(TEXT(<span class="string">"?"</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            ELLMTag Tag = <span class="keyword">static_cast</span>&lt;ELLMTag&gt;(i);</span><br><span class="line">            LLMTags.Push(Tag);</span><br><span class="line">            LLMTagNames.Push(TagName);</span><br><span class="line">            <span class="comment">/*LLMTagStatNames.Push(LLMGetTagStat(Tag));</span></span><br><span class="line"><span class="comment">            LLMTagStatGroupNames.Push(LLMGetTagStatGroup(Tag));*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (uint64 i = LLM_CUSTOM_TAG_START; i &lt;= LLM_CUSTOM_TAG_END; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> TCHAR* TagName = LLM.FindTagName(i);</span><br><span class="line">        <span class="keyword">if</span> (TagName != <span class="literal">nullptr</span> &amp;&amp; !FString(TagName).Equals(TEXT(<span class="string">"?"</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            ELLMTag Tag = <span class="keyword">static_cast</span>&lt;ELLMTag&gt;(i);</span><br><span class="line">            LLMTags.Push(Tag);</span><br><span class="line">            LLMTagNames.Push(TagName);</span><br><span class="line">            <span class="comment">/*LLMTagStatNames.Push(LLMGetTagStat(Tag));</span></span><br><span class="line"><span class="comment">            LLMTagStatGroupNames.Push(LLMGetTagStatGroup(Tag));*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int32 NumTags = LLMTags.Num();</span><br><span class="line">    UE_LOG(LogUnrealAutomator, Log, TEXT(<span class="string">"Found %d LLM Tags!"</span>), NumTags);</span><br><span class="line">    <span class="keyword">if</span> (NumTags == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update stats</span></span><br><span class="line">    LLM.UpdateStatsPerFrame();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gather amount</span></span><br><span class="line">    TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; LLMStatsArray;</span><br><span class="line">    <span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; LLMTags.Num(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        TSharedPtr&lt;FJsonObject&gt; TagAmountJson = MakeShareable(<span class="keyword">new</span> FJsonObject());</span><br><span class="line">        TagAmountJson-&gt;SetNumberField(TEXT(<span class="string">"Amount"</span>), LLM.GetTagAmountForTracker(ELLMTracker::Default, LLMTags[i]));</span><br><span class="line">        TagAmountJson-&gt;SetStringField(TEXT(<span class="string">"TagName"</span>), LLMTagNames[i]);</span><br><span class="line">        TagAmountJson-&gt;SetNumberField(TEXT(<span class="string">"TagNum"</span>), <span class="keyword">static_cast</span>&lt;uint64&gt;(LLMTags[i]));</span><br><span class="line">        <span class="comment">/*TagAmountJson-&gt;SetStringField(TEXT("StatName"), LLMTagStatNames[i].ToString());</span></span><br><span class="line"><span class="comment">        TagAmountJson-&gt;SetStringField(TEXT("StatGroupName"), LLMTagStatGroupNames[i].ToString());*/</span></span><br><span class="line">        LLMStatsArray.Push(MakeShareable(<span class="keyword">new</span> FJsonValueObject(TagAmountJson)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make json</span></span><br><span class="line">    TSharedPtr&lt;FJsonObject&gt; LLMStats = MakeShareable(<span class="keyword">new</span> FJsonObject());</span><br><span class="line">    LLMStats-&gt;SetArrayField(TEXT(<span class="string">"Data"</span>), LLMStatsArray);</span><br><span class="line">    LLMStats-&gt;SetNumberField(TEXT(<span class="string">"Count"</span>), LLMStatsArray.Num());</span><br><span class="line">    <span class="keyword">return</span> LLMStats;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    UE_LOG(LogUnrealAutomator, WARNING, TEXT(<span class="string">"Cannot get LLM stats! STATS or ENABLE_LOW_LEVEL_MEM_TRACKER macro not enabled!"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LLM追踪内存，默认给了70多个tag，如果用户需要把自己的模块加进去可以加到custom tag里。用这个实现基本能导出这些tag的实时占用数据。</p>
<p>值得一提的是，在引擎默认LLM的实现当中（<code>Core/HAL/Public/LowLevelMemTracker.h</code>与<code>Core/HAL/Private/LowLevelMemTracker.cpp</code>），默认屏蔽了内部的一些类以及extern函数的实现，使得用户无法通过<code>MODULE_API</code>的方式直接访问相应的数据结构及功能。如果实在有深入挖掘的需求，比如说区分<code>stat LLMFULL</code>与<code>LLM summary</code>，需要考虑更改引擎的代码，公开一部分模块内容，修改<code>LLMGetTagStat</code>与<code>LLMGetTagStatGroup</code>实现去支持custom tag，从而更加方便实现需求。</p>
<p>再提一嘴，除了LLM之外，如果要获得其它的stat数据，可以采用<span class="exturl" data-url="aHR0cHM6Ly9hbnN3ZXJzLnVucmVhbGVuZ2luZS5jb20vcXVlc3Rpb25zLzU1MDI3MS9zYXZpbmctc3RhdHMtdG8tZmlsZS5odG1sP3NvcnQ9b2xkZXN0" title="https://answers.unrealengine.com/questions/550271/saving-stats-to-file.html?sort=oldest">Hook Stats<i class="fa fa-external-link"></i></span>的方式进行。这块以后有空再慢慢研究~</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>C++</tag>
        <tag>UE4插件</tag>
        <tag>LLM</tag>
        <tag>UnrealAutomator</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】UE4游戏自动化测试插件——UnrealAutomator</title>
    <url>/2020/10/24/testlife/unreal_automator/</url>
    <content><![CDATA[<p>UE4游戏/手游自动化测试有很多方案可以执行，不论是传统的UI测试方法还是具备前瞻性质的以图像识别+机器学习技术为主的方法，都能够满足不同的需求。适逢1024节日，受到<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RlbmNlbnQvR0F1dG9tYXRvcg==" title="https://github.com/Tencent/GAutomator">GAutomator<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FpcnRlc3RQcm9qZWN0L1BvY28tU0RL" title="https://github.com/AirtestProject/Poco-SDK">PocoSDK<i class="fa fa-external-link"></i></span>的启发，笔者近期决定开始UE4专属自动化测试插件<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9VbnJlYWxBdXRvbWF0b3I=" title="https://github.com/utmhikari/UnrealAutomator">UnrealAutomator<i class="fa fa-external-link"></i></span>的研发。当前已经集成并扩展了GAutomator的UI信息检索功能，已经能够满足UI测试服务端的基本需求。</p>
<p>UnrealAutomator的核心愿景，是希望集成游戏QA同学日常测试需求相关的功能到统一的插件当中，并在稳定的通信协议基础上设计易于扩展/二次开发的SDK，让各个UE4手游测试组能够比较容易地根据自己的需求去进行定制。相比较原有在UE4上的解决方案，PocoSDK的UE4插件并不能够像GA一样，通过AndroidWindow获得安卓手游的控件的精确位置；而GAutomator的UE4仅仅是集成了UI检索的功能，剩余的功能都需要GAutomator Python Client Module实现，且由于GA Client Module直接在代码实现中耦合了UIAutomator跟WeTest的相关功能，二次开发极其不方便。因此，UnrealAutomator将采取如下的方案解决这些问题：</p>
<a id="more"></a>
<ul>
<li>采用HTTP协议，以<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9VbnJlYWxIdHRwU2VydmVy" title="https://github.com/utmhikari/UnrealHttpServer">UnrealHttpServer<i class="fa fa-external-link"></i></span>为基础扩展插件。其带来的收益是提供了稳定的通信协议，并且能有扩展到很多集成平台的机会，并且从代码review的角度上来考虑的话，采用Handler/Service/Model的机制，各个功能模块发挥的作用也会非常清晰，代码也比较容易读懂。</li>
<li>丰富检索功能与返回的检索信息，并增加了invoke event的功能，使得某些控件的事件（比如Button的OnClick）能够直接执行，减少一些操作上的不便。</li>
<li>丰富API的功能与实现，尽量使得外部的Client Module不需要考虑底层的基础，只需要考虑业务上的模块：<ul>
<li>UnrealHttpServer的API Client，只负责与插件的对接</li>
<li>移动端操作模块：adb client，UIAutomator</li>
<li>第三方平台的agent</li>
<li>自动化业务层逻辑抽象，比如登录、背包、组队等等游戏系统模块，抽象相关操作为http request</li>
<li>自动化流程逻辑</li>
</ul>
</li>
</ul>
<p>UnrealAutomator除了UI相关功能之外，在现在的计划（脑补）当中，也希望集成更多的功能，使得能从游戏的底层挖掘更多深层次的信息，利于测试工作的验收与检查。</p>
<ul>
<li>脚本语言框架支持，如Unlua、slua-unreal等</li>
<li>蓝图（物件模板）与游戏场景相关的功能挖掘</li>
<li>地图/Gameplay基本信息的支持</li>
<li>Profiling相关的数据导出</li>
<li>抽象inputs、axis与行为树相关功能，实现角色操作与托管</li>
<li>etc</li>
</ul>
<p>先前不是C++/UE4程序员，借着UnrealAutomator这个机会，也希望锤炼一下这块的技术。一方面希望能够对手游技术栈有更加深入的理解，从而利于测试工作；另一方面也希望抛砖引玉，为手游QA工作输出一点微薄的贡献；再一方面也希望自己在业务百忙之中，能够坚持下来作品的创造，得到更为长足的成长~</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>游戏自动化</tag>
        <tag>UE4</tag>
        <tag>游戏测试</tag>
        <tag>UE4插件</tag>
        <tag>UnrealAutomator</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】解决UE4中FJsonObject转USTRUCT的坑</title>
    <url>/2020/10/18/geekdaily/fjsonobject_to_ustruct/</url>
    <content><![CDATA[<p>前些天在写<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9VbnJlYWxBdXRvbWF0b3I=" title="https://github.com/utmhikari/UnrealAutomator">UnrealAutomator<i class="fa fa-external-link"></i></span>的Web解析模块的时候，遇到了一些USTRUCT方面的问题，由于笔者以前并非UE4程序员，因此踩了一些坑，果断分享一下踩坑历程。</p>
<p>首先聊一下USTRUCT的生成。USTRUCT是UE4的特性之一，从非C++/UE4程序员的角度来讲，USTRUCT、UPROPERTY、GENERATED_BODY之类的概念类似于注释和装饰器的作用，可以在编译等时期将代码标识的内涵纳入自己的Runtime。举一个例子，UnrealAutomator中的UIModel.h：</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CoreMinimal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Components/Widget.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须要有这个，include之后通过UE4刷新项目生成相关代码，用于支持USTRUCT等宏的识别</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"UIModel.generated.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Query template for ui widget</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">USTRUCT()</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FUIWidgetQuery</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    GENERATED_BODY()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UPROPERTY()</span><br><span class="line">        int32 ID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">        FString Name = TEXT(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">        FString Text = TEXT(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// properties below are relatively no need to be modified</span></span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">        FString ClassName = TEXT(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">        <span class="keyword">bool</span> bIsNameAsKeyword = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">        <span class="keyword">bool</span> bIsTextAsKeyword = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    FUIWidgetQuery()</span><br><span class="line">        : ID(<span class="number">0</span>)</span><br><span class="line">        , Name(TEXT(<span class="string">""</span>))</span><br><span class="line">        , Text(TEXT(<span class="string">""</span>))</span><br><span class="line">        , ClassName(TEXT(<span class="string">""</span>))</span><br><span class="line">        , bIsNameAsKeyword(<span class="literal">false</span>)</span><br><span class="line">        , bIsTextAsKeyword(<span class="literal">false</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    FUIWidgetQuery(int32 InID,</span><br><span class="line">        FString InName,</span><br><span class="line">        FString InText,</span><br><span class="line">        FString InClassName,</span><br><span class="line">        <span class="keyword">bool</span> bInIsNameAsKeyword,</span><br><span class="line">        <span class="keyword">bool</span> bInIsTextAsKeyword)</span><br><span class="line">        : ID(InID)</span><br><span class="line">        , Name(InName)</span><br><span class="line">        , Text(InText)</span><br><span class="line">        , ClassName(InClassName)</span><br><span class="line">        , bIsNameAsKeyword(bInIsNameAsKeyword)</span><br><span class="line">        , bIsTextAsKeyword(bInIsTextAsKeyword)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记得要有cpp文件实现它，当然不管有没有这个函数，都得加一个cpp文件</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsMatch</span><span class="params">(UWidget* Widget,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">bool</span> bIsDisabledIncluded = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">bool</span> bIsInvisibleIncluded = <span class="literal">false</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在有一个需求，就是把一个以json字符串为body的http request解析成这个USTRUCT，自然而然会需要FJsonObject相关的功能。http request的body原生为<code>TArray&lt;uint8&gt;</code>的格式，得先转为<code>FString</code>，然后转为<code>FJsonObject</code>，之后再转为<code>USTRUCT</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TArray&lt;uint8&gt; to FString</span></span><br><span class="line">FString FWebUtil::GetRequestStringBody(<span class="keyword">const</span> FHttpServerRequest&amp; Request)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Body to utf8 string, should be called after CheckRequestContent(Request, bIsCheckUTF8 = true)</span></span><br><span class="line">    TArray&lt;uint8&gt; RequestBodyBytes = Request.Body;</span><br><span class="line">    FString RequestBodyString = FString(UTF8_TO_TCHAR(RequestBodyBytes.GetData()));</span><br><span class="line">    UE_LOG(UALog, Log, TEXT(<span class="string">"Request string body: %s"</span>), *RequestBodyString);</span><br><span class="line">    <span class="keyword">return</span> RequestBodyString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FString to TSharedPtr&lt;FJsonObject&gt;</span></span><br><span class="line">TSharedPtr&lt;FJsonObject&gt; FCommonUtil::JsonParse(FString Str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// string to json</span></span><br><span class="line">    TSharedRef&lt;TJsonReader&lt;&gt;&gt; JsonReader = TJsonReaderFactory&lt;&gt;::Create(Str);</span><br><span class="line">    TSharedPtr&lt;FJsonObject&gt; JsonObject;</span><br><span class="line">    <span class="keyword">bool</span> bSuccess = FJsonSerializer::Deserialize(JsonReader, JsonObject);</span><br><span class="line">    <span class="keyword">if</span> (!bSuccess)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JsonObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TSharedPtr&lt;FJsonObject&gt; to USTRUCT</span></span><br><span class="line"><span class="comment">// 就算用FJsonObjectConverter::JsonObjectStringToUStruct，也需要经历先转到Json再转到USTRUCT的过程</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> UStructType&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">GetRequestUStructBody</span><span class="params">(<span class="keyword">const</span> FHttpServerRequest&amp; Request, UStructType* StructBody)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    verifyf(StructBody != <span class="literal">nullptr</span>, TEXT(<span class="string">"USTRUCT to be converted should not be null~"</span>));</span><br><span class="line"></span><br><span class="line">    TSharedPtr&lt;FJsonObject&gt; JsonBody = GetRequestJsonBody(Request);</span><br><span class="line">    <span class="keyword">if</span> (JsonBody == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// extend/update struct with json values</span></span><br><span class="line">    <span class="comment">// 如果原来struct有预设值，在json convert中，会覆盖原来的值</span></span><br><span class="line">    <span class="keyword">if</span> (!FJsonObjectConverter::JsonObjectToUStruct&lt;UStructType&gt;(JsonBody.ToSharedRef(), StructBody, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        UE_LOG(UALog, Warning, TEXT(<span class="string">"failed to parse json body to ustruct!"</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StructBody == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        UE_LOG(UALog, Warning, TEXT(<span class="string">"cast to USTRUCT failed! struct ptr is still null!"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UE_LOG(UALog, Log, TEXT(<span class="string">"convert to USTRUCT successfully!"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，json转USTRUCT的过程中，不能通过传空指针USTRUCT的方式企图希望<code>FJsonObjectConverter::JsonObjectToUStruct</code>能够对USTRUCT进行重赋值。一方面是C++左右值的特性引起的，另一方面在转属性的过程中，也需要读取原来USTRUCT的属性值相关信息，如果传进去的是空指针就会crash。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板json转ustruct函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OutStructType&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">JsonObjectToUStruct</span><span class="params">(<span class="keyword">const</span> TSharedRef&lt;FJsonObject&gt;&amp; JsonObject, OutStructType* OutStruct, int64 CheckFlags = <span class="number">0</span>, int64 SkipFlags = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> JsonObjectToUStruct(JsonObject, OutStructType::StaticStruct(), OutStruct, CheckFlags, SkipFlags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳到JsonAttributesToUStruct</span></span><br><span class="line"><span class="keyword">bool</span> FJsonObjectConverter::JsonObjectToUStruct(<span class="keyword">const</span> TSharedRef&lt;FJsonObject&gt;&amp; JsonObject, <span class="keyword">const</span> UStruct* StructDefinition, <span class="keyword">void</span>* OutStruct, int64 CheckFlags, int64 SkipFlags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> JsonAttributesToUStruct(JsonObject-&gt;Values, StructDefinition, OutStruct, CheckFlags, SkipFlags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳到JsonAttributesToUStructWithContainer</span></span><br><span class="line"><span class="keyword">bool</span> FJsonObjectConverter::JsonAttributesToUStruct(<span class="keyword">const</span> TMap&lt; FString, TSharedPtr&lt;FJsonValue&gt; &gt;&amp; JsonAttributes, <span class="keyword">const</span> UStruct* StructDefinition, <span class="keyword">void</span>* OutStruct, int64 CheckFlags, int64 SkipFlags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> JsonAttributesToUStructWithContainer(JsonAttributes, StructDefinition, OutStruct, StructDefinition, OutStruct, CheckFlags, SkipFlags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">JsonAttributesToUStructWithContainer</span><span class="params">(<span class="keyword">const</span> TMap&lt; FString, TSharedPtr&lt;FJsonValue&gt; &gt;&amp; JsonAttributes, <span class="keyword">const</span> UStruct* StructDefinition, <span class="keyword">void</span>* OutStruct, <span class="keyword">const</span> UStruct* ContainerStruct, <span class="keyword">void</span>* Container, int64 CheckFlags, int64 SkipFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果是FJsonObjectWrapper，可以直接转换</span></span><br><span class="line">    <span class="keyword">if</span> (StructDefinition == FJsonObjectWrapper::StaticStruct())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Just copy it into the object</span></span><br><span class="line">        FJsonObjectWrapper* ProxyObject = (FJsonObjectWrapper *)OutStruct;</span><br><span class="line">        ProxyObject-&gt;JsonObject = MakeShared&lt;FJsonObject&gt;();</span><br><span class="line">        ProxyObject-&gt;JsonObject-&gt;Values = JsonAttributes;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果未声明properties，直接返回</span></span><br><span class="line">    int32 NumUnclaimedProperties = JsonAttributes.Num();</span><br><span class="line">    <span class="keyword">if</span> (NumUnclaimedProperties &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iterate over the struct properties</span></span><br><span class="line">    <span class="keyword">for</span> (TFieldIterator&lt;UProperty&gt; PropIt(StructDefinition); PropIt; ++PropIt)</span><br><span class="line">    &#123;</span><br><span class="line">        UProperty* Property = *PropIt;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check to see if we should ignore this property</span></span><br><span class="line">        <span class="keyword">if</span> (CheckFlags != <span class="number">0</span> &amp;&amp; !Property-&gt;HasAnyPropertyFlags(CheckFlags))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Property-&gt;HasAnyPropertyFlags(SkipFlags))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find a json value matching this property name</span></span><br><span class="line">        <span class="keyword">const</span> TSharedPtr&lt;FJsonValue&gt;* JsonValue = JsonAttributes.Find(Property-&gt;GetName());</span><br><span class="line">        <span class="keyword">if</span> (!JsonValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// we allow values to not be found since this mirrors the typical UObject mantra that all the fields are optional when deserializing</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (JsonValue-&gt;IsValid() &amp;&amp; !(*JsonValue)-&gt;IsNull())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里就需要取到OutStruct的属性的Value值了，如果是OutStruct是空指针，就会crash掉</span></span><br><span class="line">            <span class="keyword">void</span>* Value = Property-&gt;ContainerPtrToValuePtr&lt;uint8&gt;(OutStruct);</span><br><span class="line">            <span class="keyword">if</span> (!JsonValueToUPropertyWithContainer(*JsonValue, Property, Value, ContainerStruct, Container, CheckFlags, SkipFlags))</span><br><span class="line">            &#123;</span><br><span class="line">                UE_LOG(LogJson, Error, TEXT(<span class="string">"JsonObjectToUStruct - Unable to parse %s.%s from JSON"</span>), *StructDefinition-&gt;GetName(), *Property-&gt;GetName());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (--NumUnclaimedProperties &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// If we found all properties that were in the JsonAttributes map, there is no reason to keep looking for more.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>规避了这些坑，FJsonObject转USTRUCT就顺利了</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>UE4</tag>
        <tag>C++</tag>
        <tag>FJsonObject</tag>
        <tag>USTRUCT</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】Win10更改IDEA（Jetbrains全家桶）的插件和配置路径</title>
    <url>/2020/10/06/geekdaily/idea_change_config_path/</url>
    <content><![CDATA[<p>Jetbrains家的IDE，默认安装之后，配置和插件都存储在系统特定的文件夹中，如果是Windows系统的话，就会在用户文件夹存储。这样就滋生了一个问题：随着插件等安装的越来越多，系统盘也会占掉一些空间，这个时候就有了转移默认插件与配置路径的需求。今天就以IDEA为例讲述一下如何操作。</p>
<a id="more"></a>
<p>首先了解下默认存储的位置。Win10的话，IDEA可能在这里：<code>C:\Users\用户名\AppData\Roaming\JetBrains</code>。如果是AndroidStudio，则可能在这里：<code>C:\Users\用户名\.AndroidStudio4.0</code>。在这个目录里面深度浏览，应该能够看到有一个文件夹下存储了<code>config</code>以及<code>system</code>文件夹，这里便存储了插件、IDE配置等内容。</p>
<p>而后退出idea，先在某个地方新建文件夹，将<code>config</code>与<code>system</code>目录剪切进去（本文新建<code>D:\.IDEA</code>文件夹为例）。然后进入IDEA的安装目录，在其<code>bin</code>目录下有一个<code>idea.properties</code>文件，用记事本、notepad++之类的软件打开，修改其中内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#---------------------------------------------------------------------</span><br><span class="line"># Uncomment this option if you want to customize path to IDE config folder. Make sure you&apos;re using forward slashes.</span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line"># 默认下面这行是会注释掉的，现在取消注释，配置为新的config目录。注意路径分隔符是正斜杠，不是反斜杠</span><br><span class="line">idea.config.path=D:/.IDEA/config</span><br><span class="line"></span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line"># Uncomment this option if you want to customize path to IDE system folder. Make sure you&apos;re using forward slashes.</span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line"># 同样，取消下面一行的注释，配置为新的system目录</span><br><span class="line">idea.system.path=D:/.IDEA/system</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 下面两个插件、日志的配置不用去掉注释，是跟随config和system配置走的</span><br><span class="line"></span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line"># Uncomment this option if you want to customize path to user installed plugins folder. Make sure you&apos;re using forward slashes.</span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line"># idea.plugins.path=$&#123;idea.config.path&#125;/plugins</span><br><span class="line"></span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line"># Uncomment this option if you want to customize path to IDE logs folder. Make sure you&apos;re using forward slashes.</span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line"># idea.log.path=$&#123;idea.system.path&#125;/log</span><br></pre></td></tr></table></figure>
<p>之后再重新打开IDEA，应该新的配置都生效了。可以装一个插件试试看？应该不会在系统盘里装了。这个方法，理论上J家桶的IDE都可以用上，试试看吧~</p>
<p>如果IDEA有大版本更新，注意在更新的时候，不要选择replace掉原来的<code>idea.properties</code>文件，而是ignore。不然又要重新来一遍了。</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>Win10</tag>
        <tag>Intellij IDEA</tag>
        <tag>Jetbrains</tag>
        <tag>IDE</tag>
        <tag>idea.properties</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】我心目中的测试</title>
    <url>/2020/09/06/testlife/be_a_tester/</url>
    <content><![CDATA[<p>很久以前写过一篇文章：<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMTkvMTIvMjIvdGVzdGxpZmUvYXJlX3Rlc3RlcnNfY29udHJvbGxpbmdfcXVhbGl0eS8=" title="https://utmhikari.top/2019/12/22/testlife/are_testers_controlling_quality/">《测试、策划与开发，谁来把控游戏的质量》<i class="fa fa-external-link"></i></span>，聊了一下测试、策划和开发三者的关系。时至今日回头来看，大方向还是差不多的。在某些地方，测试地位低，被策划跟开发冷眼相看，所以让他们开心就好；在某些地方，测试、策划和开发也可以在同一层次上讨论需求与研发过程的好坏。说白了，把控游戏质量，是三个部门一起的责任，而且测试并不是必须要为策划和程序收烂摊子。</p>
<a id="more"></a>
<p>言归正传。写今天这篇文章，来源于回忆到毕业工作的前两年很多负面的事情。一来是想到当时在项目组里做测试被其他部门以冷眼相待的事实；另一来是想到由于自己工作年限较低（说白了就是官僚权力斗争）的原因，自己坚持的技术理念没有得到认同，导致被所谓的高级技术砖家排挤的事实。作为热爱技术的人，我心目中的测试，特指自己想成为的技术向的测试，不仅需要有过硬的编码能力，而且还需要有项目规划、人员管理以及架构设计的能力，就如同张艺兴一样（着实牛逼= =），编曲、舞技、唱歌样样全能。测试的目的是完成各种质（黑）量（科）保（技）障需求，技术选型来讲相对更加多元化，因此更加需要一个开放包容的环境鼓励技术创新与业务交流。一个被策划开发冷眼相待，技术上不允许百花齐放的工作环境，对于测试技术的发展来说就是噩梦。因此我当时也决意离开毕业之后的第一家公司，远走高飞，不再沾染对技术毫无尊重的“阿里味”。</p>
<p>在先前的<span class="exturl" data-url="aHR0cHM6Ly91dG1oaWthcmkudG9wLzIwMTkvMDcvMTMvdGVzdGxpZmUvYW5kcm9pZF9mcHMv" title="https://utmhikari.top/2019/07/13/testlife/android_fps/">《安卓FPS测试详解》<i class="fa fa-external-link"></i></span>一文中，有聊到自己是因为做fps专项测试而对测试岗位产生了兴趣。这并不是开始，其实早在初中的时候，自己就对反病毒相关的知识感兴趣了，但碍于没有形成自我的认知，这份兴趣没能够坚持并深入下去，着实是一件遗憾的事情。这也是我心目中测试的特点之一，不拘泥于一点，善于创造变化。在我以前呆过的地方，提倡拥抱变化，而技术测试的工作之一，也是从已有的、内在的工作流程中，发现、定位优化点并加以改善，创造变化，让大家一起拥抱。这一点，和开发对于已有的代码进行重构优化是一个意思——追求极致，追求100分。</p>
<p>技术是无穷无尽的，人一辈子也不能熟练掌握所有的技术，而且技术精通的再多，做的东西没人用的上，也无济于事。在测试工作期间，自己也了解到作为一个技术测试，最重要的一点就是精准打击：选合适的技术，造合适的轮子。作为测试，往技术的底层需要有钻研精神，往测试工作宏观层面也要有缜密的思考。不能局限自己，要勇于突破，细心且大胆。</p>
<p>至于自己，最近打算开始学习UE4游戏开发，制作一款单机小游戏。就像上面说的，作为测试，尤其是一个游戏测试，不能局限自己，得多了解下游戏开发技术，否则就没有办法去突破游戏测试的界限。工作之余，该想做的东西，该想学的技术，还是得干。独木难以改变环境，但可以改变自己，给自己增值，去获得更多的选择权。</p>
<p>作为一个有自我逻辑体系的人，在新生思想和事物的接受上极其慢热保守，但经过消化后便能成精，加以沉淀。感谢这两年的经历，让我形成了自己独特的观点，并对此更加坚持。今天晚了，该睡了，所以就先写到这里，后面再说。</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>游戏测试</tag>
        <tag>质量管理</tag>
        <tag>测试</tag>
        <tag>功能测试</tag>
        <tag>技术测试</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】游戏自动化该怎么做？</title>
    <url>/2020/09/06/testlife/game_autotest/</url>
    <content><![CDATA[<p>游戏自动化该怎么做？这是一个值得探讨的问题。在中国，用手游自动化来描述，可能更为贴切。游戏自动化技术并不难以上手，有许多现成的工具提供使用。但是，要想做好游戏自动化，让其真正服务于游戏研发/运营期业务，并不是一件容易的事情。</p>
<a id="more"></a>
<p>自动化测试技术上的实质是通过代码模拟玩家的行为，本意是用来补足真人测试工作。游戏测试通常分为功能测试与专项测试，游戏自动化同样也需要适应这两种场景。专项测试分很多种，普遍来讲客户端性能测试、后台压力测试等等。后台压力测试可以采用机器人的方式连接后台专用的测试接口，可以直接调用后台的逻辑执行已经预定义的GM；客户端性能测试一般采用直接操作游戏客户端的方式，比如利用Airtest的UI自动化，或者是以GAutomator（Unity）为代表的接口自动化方法。如果是业务专项，比如数值测试、PVP平衡性、异常图像检测方面，可以采用AI自动化的方法。而自动化作为功能测试的用途，则一般采用UI自动化、接口自动化的方法，较为方便，能够控制逻辑。</p>
<p>游戏自动化测试执行的有效时间（除去用例的不稳定与环境因素），决定了其质量的下限。比如用于功能测试的场景，游戏自动化不可能代替黑盒测试人员去将所有的用例覆盖一边，但能够作为冒烟的作用去跑黑盒测试人员没有空余时间去遍历的场景，从而确保尽可能更多的功能是正常的。功能自动化很难跑出缺陷，但一旦跑出来的缺陷基本性质都较为严重，因此如果不充分覆盖更多的功能玩法，不在更多的机器上运行，功能自动化是没有意义的。同理，业务/性能专项也是如此，没有在更多的机器上去运行，那还不如增加人力去覆盖相应的场景。</p>
<p>纯粹的UI自动化不适合做大规模的游戏自动化，因为UI自动化本质上是将游戏控件viewport坐标映射到手机上的绝对坐标去执行的，一定会存在适配的问题，而且很多游戏内部的判断逻辑，用UI自动化是无法实现的。因此，UI自动化必须有接口自动化或者AI训练输入的方式，使得测试用例更加稳定。接口自动化相对于AI训练输入，逻辑上会更加稳定一些，理论上也会适用于更多的场景（尤其是跑流程的类型），但会对代码有一定的侵入，因此接口自动化对代码设计模式有一定的要求。从笔者的经验上来看，接口自动化需要做如下几个事情：</p>
<ul>
<li>确保主机（客户端）与手游（服务端）之间的通信</li>
<li>游戏代码侵入：定义自动化关心的接口，模块不与业务代码耦合</li>
<li>在客户端上，抽象一层自动化关心的接口</li>
<li>对于每个自动化用例，尽可能用抽象出来的一层自动化关心的接口实现</li>
</ul>
<p>其中，定义自动化关心的接口是很重要的一环，它不仅决定了自动化用例是否能够方便地实现以及维护，而且决定了者一套框架能否方便复用到其它游戏项目中。这是从自动化业务本身特性出发，所必须的一个环节。</p>
<p>AI自动化相对于接口自动化，侵入的程度会更加少，但需要更为优厚的基础条件（不论是游戏原本的代码实现支持，还是用于训练AI的基础设施）。行为树是最基础的AI，但支撑行为树的内部逻辑仍然属于接口自动化的范畴，因此这里的AI自动化偏向于“模拟玩家输入”的AI。这一块笔者了解不深，但从AI本身的特性（向一个数学目标逼近）上来讲，最适用于竞技型以及图像识别相关的场景。这些都是光靠接口自动化难以做到的东西。</p>
<p>当然，不论是AI、UI还是靠接口，除了跑自动化用例之外，都需要对日志、截图、录屏等信息进行收集，形成对用例流程的闭环，保留更为丰富的信息用于后续定位问题。</p>
<p>如何支持自动化大规模的使用，是除自动化实现本身之外的另外一个问题，也就是在做一个云真机平台的基础上，赋予自动化测试所特殊需求的功能。云真机平台的实现网上有很多类似的说明，此处不再赘述，但要支持多样自动化用例的运行，还需要一定的规范。最理想、标准的方案是<code>docker image + configmap</code>的形式，母镜像是用户的自动化用例框架，<code>configmap</code>映射用户在这个框架之下的用例配置。这样除去游戏本身的约束之外，在主机（客户端）层面，就能够让用户采用自己的方案去实现了。</p>
<p>总而言之，游戏自动化做到60分很容易，要往100分冲刺，还需要一番精心的设计。</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>游戏自动化</tag>
        <tag>游戏测试</tag>
        <tag>手游自动化</tag>
        <tag>UI自动化</tag>
        <tag>接口自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏开发】用Lua编写UE4游戏逻辑——UnLua上手</title>
    <url>/2020/08/02/gamedev/unlua_try/</url>
    <content><![CDATA[<p>大型的游戏项目包含许多错综复杂的业务逻辑，针对UE4游戏而言，如果纯粹采用C++编写的话，一方面会增加大量的劳动成本，影响效率，另一方面难以解决游戏热更的问题。lua作为胶水语言，能够与C/C++/C#等语言互通，简化业务逻辑编写，并且支持热更。针对UE4的游戏开发，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RlbmNlbnQvVW5MdWE=" title="https://github.com/Tencent/UnLua">UnLua<i class="fa fa-external-link"></i></span>以及<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RlbmNlbnQvc2x1YXVucmVhbA==" title="https://github.com/Tencent/sluaunreal">sluaunreal<i class="fa fa-external-link"></i></span>都是采用lua编写逻辑的解决方案。</p>
<p>作为一个没有怎么接触过游戏开发技术栈的小白，本文主要上手UnLua的使用。</p>
<a id="more"></a>
<p>从github上，我们可以clone下来示例的project，编译后即可运行。整个demo的逻辑是在一个空间中自动生成AI敌人，玩家需要射击AI以保全自身，如果碰到AI即游戏失败。整个游戏的逻辑基本在<code>Content/Script</code>下的lua文件中，对于开发者而言，只需要<code>创建蓝图——导出Lua脚本——编写逻辑</code>，就能够完成需求。</p>
<p>编辑器采用VSCode + Emmylua + C/C++的搭配即可，如果有debug需求可以VS搭配Code。要导出UnLua解析的UE4的lua接口，在<code>UnLuaIntelliSense.Build.cs</code>中修改至<code>ENABLE_INTELLISENSE=1</code>，然后重新构建，即可导出lua定义到<code>Plugins/UnLua/Intermediate/IntelliSense</code>，之后调整workspace的配置即可：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"emmylua.source.roots"</span>: [<span class="string">"./Plugins/UnLua/Intermediate/IntelliSense"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以对示例教程中的子弹进行改装。我们可以增加一个<code>CustomProjectile</code>，其蓝图实例为<code>BP_CustomProjectile</code>，并实现UnLua的接口。我们可以自定义其Static Mesh的形状以及材质。之后，通过蓝图窗口的<code>lua template</code>可以在项目中导出蓝图接口<code>BP_CustomProjectile_C.lua</code>，而不需要自己编写蓝图逻辑。然后在蓝图的<code>Interfaces</code>中选中<code>Get Module Name</code>，返回<code>BP_CustomProjectile_C</code>所在位置即可。</p>
<p>首先对于CustomProjectile，可以自定义一个<code>ProjectileInitializer.lua</code>：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span> <span class="string">"UnLua"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">_G</span>.ProjectileInitializer = ProjectileInitializer <span class="keyword">or</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProjectileInitializer:GetRandomColor</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> R = UE4.UKismetMathLibrary.RandomFloat()</span><br><span class="line">    <span class="keyword">local</span> G = UE4.UKismetMathLibrary.RandomFloat()</span><br><span class="line">    <span class="keyword">local</span> B = UE4.UKismetMathLibrary.RandomFloat()</span><br><span class="line">    <span class="keyword">return</span> UE4.FLinearColor(R, G, B, <span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProjectileInitializer:GetInitializer</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> color = self:GetRandomColor()</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        Color = color,</span><br><span class="line">        Ratio = (color.R + color.G + color.B) / <span class="number">3</span>,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ProjectileInitializer</span><br></pre></td></tr></table></figure>
<p>之后可以编写<code>BP_CustomProjectile_C</code>的代码，和<code>BP_DefaultProjectile_C</code>基本相同：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span> <span class="string">"UnLua"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> BP_CustomProjectile_C = Class(<span class="string">"Weapon.BP_ProjectileBase_C"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BP_CustomProjectile_C:Initialize</span><span class="params">(Initializer)</span></span></span><br><span class="line">    self.BaseColor = Initializer.Color</span><br><span class="line">    self.DamageRatio = Initializer.Ratio <span class="keyword">or</span> <span class="number">0.1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BP_CustomProjectile_C:UserConstructionScript</span><span class="params">()</span></span></span><br><span class="line">    self.Super.UserConstructionScript(self)</span><br><span class="line">    self.Damage = self.Damage * self.DamageRatio</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Projectile Damage: "</span> .. <span class="built_in">tostring</span>(self.Damage));</span><br><span class="line">    self.DamageType = UE4.UClass.Load(<span class="string">"/Game/Core/Blueprints/BP_DamageType.BP_DamageType_C"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BP_CustomProjectile_C:ReceiveBeginPlay</span><span class="params">()</span></span></span><br><span class="line">    self.Super.ReceiveBeginPlay(self)</span><br><span class="line">    <span class="keyword">local</span> MID = self.StaticMesh:CreateDynamicMaterialInstance(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> MID <span class="keyword">then</span></span><br><span class="line">        MID:SetVectorParameterValue(<span class="string">"BaseColor"</span>, self.BaseColor)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> BP_CustomProjectile_C</span><br></pre></td></tr></table></figure>
<p>这样即可根据颜色深度来判断projectile的伤害，实现伤害随机的效果。</p>
<p>对于UMG而言，也可以在UMG蓝图中先设置各个控件为变量，然后调用各个变量的反射接口以设置控件属性。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span> <span class="string">"UnLua"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> UMG_Main_C = Class()</span><br><span class="line"></span><br><span class="line">UMG_Main_C.ExitBtnText = <span class="string">"Hello World"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UMG_Main_C:Construct</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.ExitButtonTextBlock <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"exit button text is nil!"</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"bind exit button text..."</span>)</span><br><span class="line">        self.ExitButtonTextBlock:SetText(UMG_Main_C.ExitBtnText)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    self.ExitButton.OnClicked:Add(self, UMG_Main_C.OnClicked_ExitButton)	</span><br><span class="line">    <span class="comment">--self.ExitButton.OnClicked:Add(self, function(Widget) UE4.UKismetSystemLibrary.ExecuteConsoleCommand(Widget, "exit") end )</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UMG_Main_C:OnClicked_ExitButton</span><span class="params">()</span></span></span><br><span class="line">    UE4.UKismetSystemLibrary.ExecuteConsoleCommand(self, <span class="string">"exit"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> UMG_Main_C</span><br></pre></td></tr></table></figure>
<p>从一个UE4初学者角度而言，UnLua的熟悉会有一定壁垒，需要建立在对UE4的C++变成较为熟悉的基础上，才能熟练应用。UnLua/sluaunreal相对于蓝图解决了一个最大的问题是逻辑的可维护性以及可热更的能力，以便支持业务逻辑的快速迭代。lua本身是没有强制静态类型的，虽然最近已有了<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlYWwtbGFuZ3VhZ2UvdGw=" title="https://github.com/teal-language/tl">teal<i class="fa fa-external-link"></i></span>的产生，但整个生态还没有完全兴起。因此如果使用lua作为胶水语言，不在lua层先做一两层业务抽象再写逻辑的话，还不如直接写C++来的稳定。因此，针对初学者或者是独立开发者，用C++加上蓝图是更加妥当的选择。</p>
<p>That’s it，游戏开发是一门很独特的技术栈，还有许多值得探索的东西。自己虽然没有从事游戏开发工作，但说不定有一天，能够自己写一个自己的游戏呢。</p>
]]></content>
      <categories>
        <category>游戏开发</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>C++</tag>
        <tag>游戏开发</tag>
        <tag>UnLua</tag>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】安卓游戏投屏/录屏利器——scrcpy</title>
    <url>/2020/07/18/testlife/scrcpy/</url>
    <content><![CDATA[<p>手机投屏/录屏在测试领域的用途有很多，比如：</p>
<ul>
<li>作为（自动化）测试报告的一部分，记录测试的实时场景</li>
<li>投屏到电脑，用于UI自动化测试</li>
<li>作为日常测试工作使用</li>
</ul>
<p>当前手机投屏/录屏的解决方案有两个：STF的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29wZW5zdGYvbWluaWNhcA==" title="https://github.com/openstf/minicap">minicap<i class="fa fa-external-link"></i></span>以及Genymobile的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0dlbnltb2JpbGUvc2NyY3B5" title="https://github.com/Genymobile/scrcpy">scrcpy<i class="fa fa-external-link"></i></span>。今天则稍微介绍一下scrcpy，能够兼容各类安卓手机，并且在投屏方面，低延迟与高清晰度兼具。</p>
<a id="more"></a>
<p>scrcpy，又名screen copy，分为<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0dlbnltb2JpbGUvc2NyY3B5L3RyZWUvbWFzdGVyL3NlcnZlcg==" title="https://github.com/Genymobile/scrcpy/tree/master/server">scrcpy-server<i class="fa fa-external-link"></i></span>以及scrcpy-client，server调用安卓内部的接口的获取屏幕信息，然后发送给client，client解码屏幕信息，完成录制/投屏等功能。同时，client也可以接收输入、点击、拖拽信息，通过swipe、input等操作传达给手机，或是发送给scrcpy-server让server进行操作。因此对于手机手残党来说，采用scrcpy投屏日常玩手机是一个不错的选择。</p>
<p>scrcpy的client实现因人而异，主要用于解码视频以及解析用户操作。当前也有许多出色的解决方案，比如：</p>
<ul>
<li>默认<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0dlbnltb2JpbGUvc2NyY3B5L3RyZWUvbWFzdGVyL2FwcA==" title="https://github.com/Genymobile/scrcpy/tree/master/app">client<i class="fa fa-external-link"></i></span>，采用<span class="exturl" data-url="aHR0cHM6Ly93d3cubGlic2RsLm9yZy9pbmRleC5waHA=" title="https://www.libsdl.org/index.php">SDL2<i class="fa fa-external-link"></i></span>制作</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JhcnJ5LXJhbi9RdFNjcmNweQ==" title="https://github.com/barry-ran/QtScrcpy">QtScrcpy<i class="fa fa-external-link"></i></span>，采用<span class="exturl" data-url="aHR0cHM6Ly93d3cucXQuaW8vY24=" title="https://www.qt.io/cn">Qt<i class="fa fa-external-link"></i></span>制作</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NyZXZpbnNhanUvZ3Vpc2NyY3B5" title="https://github.com/srevinsaju/guiscrcpy">guiscrcpy<i class="fa fa-external-link"></i></span>，采用<span class="exturl" data-url="aHR0cHM6Ly9weXBpLm9yZy9wcm9qZWN0L1B5UXQ1Lw==" title="https://pypi.org/project/PyQt5/">PyQt5<i class="fa fa-external-link"></i></span>制作</li>
</ul>
<p>其中实现相对比较完善的方案是QtScrcpy，除了投屏、手机操作周边比较完善之外，还提供自定义屏幕按键/拖拽配置。如果有日常使用后者是自动化用例录制的需求，对QtScrcpy进行二次开发是很好的选择。</p>
<p>在原理方面，scrcpy调用了<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvbWVkaWEvTWVkaWFDb2RlYy5odG1s" title="https://developer.android.com/reference/android/media/MediaCodec.html">MediaCodec<i class="fa fa-external-link"></i></span>接口。编码器会不断从<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9TdXJmYWNl" title="https://developer.android.com/reference/android/view/Surface">Input Surface<i class="fa fa-external-link"></i></span>中获取屏幕数据，然后进行编码通过socket发送到client中。从官方文档也可以获知，<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9TdXJmYWNl" title="https://developer.android.com/reference/android/view/Surface">Surface<i class="fa fa-external-link"></i></span>存储了屏幕数据，采用Surface为编码器传递数据会是更加适宜的选择。scrcpy编码屏幕数据的相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalStreamScreen</span><span class="params">(Device device, FileDescriptor fd)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    MediaFormat format = createFormat(bitRate, maxFps, codecOptions);</span><br><span class="line">    device.setRotationListener(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">boolean</span> alive;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            MediaCodec codec = createCodec();</span><br><span class="line">            IBinder display = createDisplay();</span><br><span class="line">            ScreenInfo screenInfo = device.getScreenInfo();</span><br><span class="line">            Rect contentRect = screenInfo.getContentRect();</span><br><span class="line">            <span class="comment">// include the locked video orientation</span></span><br><span class="line">            Rect videoRect = screenInfo.getVideoSize().toRect();</span><br><span class="line">            <span class="comment">// does not include the locked video orientation</span></span><br><span class="line">            Rect unlockedVideoRect = screenInfo.getUnlockedVideoSize().toRect();</span><br><span class="line">            <span class="keyword">int</span> videoRotation = screenInfo.getVideoRotation();</span><br><span class="line">            <span class="keyword">int</span> layerStack = device.getLayerStack();</span><br><span class="line"></span><br><span class="line">            setSize(format, videoRect.width(), videoRect.height());</span><br><span class="line">            configure(codec, format);</span><br><span class="line">            Surface surface = codec.createInputSurface();</span><br><span class="line">            setDisplaySurface(display, surface, videoRotation, contentRect, unlockedVideoRect, layerStack);</span><br><span class="line">            codec.start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                alive = encode(codec, fd);</span><br><span class="line">                <span class="comment">// do not call stop() on exception, it would trigger an IllegalStateException</span></span><br><span class="line">                codec.stop();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                destroyDisplay(display);</span><br><span class="line">                codec.release();</span><br><span class="line">                surface.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (alive);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        device.setRotationListener(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">encode</span><span class="params">(MediaCodec codec, FileDescriptor fd)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> eof = <span class="keyword">false</span>;</span><br><span class="line">    MediaCodec.BufferInfo bufferInfo = <span class="keyword">new</span> MediaCodec.BufferInfo();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!consumeRotationChange() &amp;&amp; !eof) &#123;</span><br><span class="line">        <span class="keyword">int</span> outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -<span class="number">1</span>);</span><br><span class="line">        eof = (bufferInfo.flags &amp; MediaCodec.BUFFER_FLAG_END_OF_STREAM) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (consumeRotationChange()) &#123;</span><br><span class="line">                <span class="comment">// must restart encoding with new size</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (outputBufferId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ByteBuffer codecBuffer = codec.getOutputBuffer(outputBufferId);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sendFrameMeta) &#123;</span><br><span class="line">                    <span class="comment">// 将编码数据+长度写到socket，发给scrcpy的client</span></span><br><span class="line">                    writeFrameMeta(fd, bufferInfo, codecBuffer.remaining());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                IO.writeFully(fd, codecBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (outputBufferId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                codec.releaseOutputBuffer(outputBufferId, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !eof;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只需要单纯实现录屏，采用原生scrcpy-client的no display选项就能够实现。如果用程序控制scrcpy的录屏，建议选择mkv格式录制，并通过<code>adb shell pkill app_process</code>杀死scrcpy-server来达到终止录屏的效果。否则可能造成视频损坏。如果采用系统的screenrecord方案，部分手机可能会不支持，因此可以考虑两者相辅相成。</p>
<p>总之，scrcpy有很多用途值得挖掘，尤其在移动/游戏测试领域，scrcpy未来上应有和minicap相提并论的空间。</p>
<p>最近忙碌，难以抽时间深入研究技术，再加上安卓底层/视频技术方面也是第一次接触，便纯当抛砖引玉。有叙述不妥之处，欢迎指正！</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>游戏测试</tag>
        <tag>Android</tag>
        <tag>scrcpy</tag>
        <tag>手机投屏</tag>
        <tag>游戏录屏</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】代码覆盖率测试之代码染色优化——以lua代码覆盖为例</title>
    <url>/2020/06/13/testlife/coverage_beautify/</url>
    <content><![CDATA[<p>在研发代码覆盖率测试工具的时候，通常除了代码覆盖数据收集模块之外，一般还要研发前端展示的部分以展现代码覆盖分析报告，通常会为每一个文件增加行染色，类似于<span class="exturl" data-url="aHR0cHM6Ly93d3cuamFjb2NvLm9yZy9qYWNvY28vdHJ1bmsvY292ZXJhZ2Uvb3JnLmphY29jby5jb3JlL29yZy5qYWNvY28uY29yZS5pbnRlcm5hbC5hbmFseXNpcy5maWx0ZXIvVHJ5V2l0aFJlc291cmNlc0phdmFjRmlsdGVyLmphdmEuaHRtbCNMMTg0" title="https://www.jacoco.org/jacoco/trunk/coverage/org.jacoco.core/org.jacoco.core.internal.analysis.filter/TryWithResourcesJavacFilter.java.html#L184">jacoco<i class="fa fa-external-link"></i></span>这种形式。</p>
<p>然而代码覆盖报告实际出来的行染色，会出现许多正常代码行没有着色的情况。这是因为编程语言认为的“行”和本身我们在文本编辑器打出的”行“是不一样的。编译出来的“行”实际上是一段操作，比如我们定义一个函数的时候，编译器认为我们执行的操作有包括function xxx那一行，于是就有一种情况——我们实际没有运行过这个函数，但由于定义被覆盖，因此出现function xxx染绿，而函数体染红的现象。从用户的角度而言，用户如果对代码编译这块并不熟悉的话，就会造成理解上的偏差。</p>
<p>因此考虑工作成本，如果有必要的话，需要对代码覆盖数据进行修改，从而展现更好的代码行染色效果。以lua为例，可以采用这样的方法：</p>
<a id="more"></a>
<p>lua代码收集已经在<span class="exturl" data-url="aHR0cDovL3V0bWhpa2FyaS50b3AvMjAxOS8wMy8xMC9sdWF0YWxrL2x1YWNvdi8=" title="http://utmhikari.top/2019/03/10/luatalk/luacov/">luacov源码分析<i class="fa fa-external-link"></i></span>有相关解读，这块不赘述。在代码编译的语法分析方面有一个经典的方法叫做<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMTI3MTg3OQ==" title="https://zhuanlan.zhihu.com/p/31271879">递归下降法<i class="fa fa-external-link"></i></span>，如果需要测定覆盖率的语言是像lua这样简单的话，就可以直接应用。我们可以从lua文件原始的覆盖数据，推断近乎真实的覆盖数据。首先把一个文件所有的代码分为不同的chunk：</p>
<ul>
<li>main chunk</li>
<li>loop end chunk</li>
<li>do end chunk</li>
<li>(local) function end chunk</li>
<li>if elseif else end chunk</li>
</ul>
<p>而后自顶向下递归下降遍历代码行。我们起始就已经在main chunk，因此理论上来说，main chunk中所有不是其它子chunk的代码都能被覆盖到（当然也包括do end）。而后针对loop、if/elseif/else、function，则采用如下的判断机制：</p>
<ul>
<li>loop内及loop语句本身的代码行覆盖多少次算多少次</li>
<li>function内如果一行都没有覆盖，那么function与end声明也算没有覆盖。就算是return function() end也一样，因为用户比较关心这个function实际是否有运行</li>
<li>if方面，统计每个if、elseif、else块的代码覆盖，分为三种状态：全部覆盖、部分未覆盖、全部未覆盖。</li>
</ul>
<p>lua本身是不支持检测if事件的，但实际通过语法分析，可以检测到if代码块，这样我们就可以像jacoco一样，为if代码行染一个不同的颜色。至于代码染色如何标记，其实可以用int32的高几位来标记对应行的颜色就好了，这种方法在做增量覆盖的情况下也适用。</p>
<p>如果出现xxx end在同一行的情况，那就更好办了，该覆盖几次是几次。</p>
<p>假定程序员写代码写的比较规范的话，用这种方法进行行染色展现代码覆盖报告，效果可是真的杠杠的。</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>lua</tag>
        <tag>代码覆盖率</tag>
        <tag>代码染色</tag>
        <tag>语法分析</tag>
        <tag>递归下降法</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】在UE4插件中编写一个HTTP Web Server</title>
    <url>/2020/05/23/geekdaily/ue4_http_server/</url>
    <content><![CDATA[<p>在某些游戏研发or测试的需求中，需要在Unreal增加一个插件或者模块，里面启动一个服务器作为SDK，然后外部通过直连或者adb forward可以连接到客户端中，获取客户端实时的场景、actor信息等等。UE4本身除了socket server支持之外，也支持简单的HTTP Web Server。由于网上没有比较好的范例，因此这里给出一个例子。</p>
<p>本文以Unreal 4.24为例。搭建HTTP Server，需要在<code>.Build.cs</code>中引入如下模块：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">PrivateDependencyModuleNames.AddRange(</span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">string</span>[]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"CoreUObject"</span>,</span><br><span class="line">        <span class="string">"Engine"</span>,</span><br><span class="line">        <span class="string">"Slate"</span>,</span><br><span class="line">        <span class="string">"SlateCore"</span>,</span><br><span class="line">        <span class="comment">// ... add private dependencies that you statically link with here ...</span></span><br><span class="line">        <span class="string">"HTTP"</span>,</span><br><span class="line">        <span class="string">"HttpServer"</span>,</span><br><span class="line">        <span class="string">"JsonUtilities"</span>,</span><br><span class="line">        <span class="string">"Json"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>通过<code>FHttpServerModule::Get()</code>方法，可以获得内置的HTTP Server模块的一个单例，该instance负责管理内置private的socket listeners。我们可以通过该单例获取<code>HTTPRouter</code>，然后绑定路由跟handler，然后调用<code>StartAllListeners</code>，就能够启动Web服务器。具体代码如下：</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Runtime/Online/HTTPServer/Public/HttpServerModule.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Runtime/Online/HTTPServer/Public/HttpPath.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果插件module type为runtime之类，只要包括编辑器的，就加这个判断，这样编辑器里不会直接启动server，而standalone时候可以启动</span></span><br><span class="line">    <span class="comment">// 如果编辑器里直接启动了，那么改代码重新编译会卡住</span></span><br><span class="line">    <span class="keyword">if</span> (!GIsEditor)</span><br><span class="line">    &#123;</span><br><span class="line">        StartServer(Port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StartServer</span><span class="params">(uint32 Port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> HttpServerModule = &amp;FHttpServerModule::Get();</span><br><span class="line">    TSharedPtr&lt;IHttpRouter&gt; HttpRouter = HttpServerModule-&gt;GetHttpRouter(Port);</span><br><span class="line">    <span class="comment">// 这里注意一个点，就是底层不支持相同http path配置不同的request method</span></span><br><span class="line">    HttpRouter-&gt;BindRoute(FHttpPath(TEXT(<span class="string">"/health"</span>)), EHttpServerRequestVerbs::VERB_GET, HEALTH_CHECK_HANDLER);</span><br><span class="line">    HttpServerModule-&gt;StartAllListeners();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，HEALTH_CHECK_HANDLER需要传进来一个TFunction，可以通过相关代码查阅到。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Runtime\Online\HTTPServer\Private\HttpRouter.cpp</span></span><br><span class="line"></span><br><span class="line">FHttpRouteHandle FHttpRouter::BindRoute(<span class="keyword">const</span> FHttpPath&amp; HttpPath,  <span class="keyword">const</span> EHttpServerRequestVerbs&amp; HttpVerbs,  <span class="keyword">const</span> FHttpRequestHandler&amp; Handler)</span><br><span class="line">&#123;</span><br><span class="line">    check(HttpPath.IsValidPath());</span><br><span class="line">    check(EHttpServerRequestVerbs::VERB_NONE != HttpVerbs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (RequestHandlerRegistrar-&gt;Contains(HttpPath.GetPath()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> RouteHandle = MakeShared&lt;FHttpRouteHandleInternal&gt;(HttpPath.GetPath(), HttpVerbs, Handler);</span><br><span class="line">    RequestHandlerRegistrar-&gt;Add(HttpPath.GetPath(), RouteHandle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RouteHandle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runtime\Online\HTTPServer\Public\HttpRequestHandler.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FHttpRequestHandler</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  NOTE - Returning true implies that the delegate will eventually invoke OnComplete</span></span><br><span class="line"><span class="comment"> *  NOTE - Returning false implies that the delegate will never invoke OnComplete</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param Request The incoming http request to be handled</span></span><br><span class="line"><span class="comment"> * @param OnComplete The callback to invoke to write an http response</span></span><br><span class="line"><span class="comment"> * @return True if the request has been handled, false otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> TFunction&lt;<span class="keyword">bool</span>(<span class="keyword">const</span> FHttpServerRequest&amp; Request, <span class="keyword">const</span> FHttpResultCallback&amp; OnComplete)&gt; FHttpRequestHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runtime\Online\HTTPServer\Public\HttpResultCallback.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* FHttpResultCallback</span></span><br><span class="line"><span class="comment">* This callback is intended to be invoked exclusively by FHttpRequestHandler delegates</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* @param Response The response to write</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> TFunction&lt;<span class="keyword">void</span>(TUniquePtr&lt;FHttpServerResponse&gt;&amp;&amp; Response)&gt; FHttpResultCallback;</span><br></pre></td></tr></table></figure>
<p>在FHttpRequestHandler函数内部中，如果调用了<code>OnComplete(Response)</code>但<code>return false</code>的话，会<code>CHECK</code>不过造成程序crash。因此，可以封装一个生成<code>FHttpRequestHandler</code>的函数，使得实际只需要根据Request返回一个Response就可以。我们把这种函数自定义为<code>FHttpResponser</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> TFunction&lt;TUniquePtr&lt;FHttpServerResponse&gt;(<span class="keyword">const</span> FHttpServerRequest&amp; Request)&gt; FHttpResponser;</span><br><span class="line"></span><br><span class="line"><span class="function">FHttpRequestHandler <span class="title">CreateHandler</span><span class="params">(<span class="keyword">const</span> FHttpResponser&amp; HttpResponser)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [HttpResponser](<span class="keyword">const</span> FHttpServerRequest&amp; Request, <span class="keyword">const</span> FHttpResultCallback&amp; OnComplete)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> Response = HttpResponser(Request);</span><br><span class="line">        <span class="keyword">if</span> (Response == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        OnComplete(MoveTemp(Response));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们实际只需要编写<code>FHttpResponser</code>就可以了。比如上面的HEALTH_CHECK_HANDLER例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TUniquePtr&lt;FHttpServerResponse&gt; HealthCheck(<span class="keyword">const</span> FHttpServerRequest&amp; Request)</span><br><span class="line">&#123;</span><br><span class="line">    UE_LOG(UALog, Log, TEXT(<span class="string">"Health Check"</span>));</span><br><span class="line">    <span class="keyword">if</span> (GEngine != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GEngine-&gt;AddOnScreenDebugMessage(<span class="number">-1</span>, <span class="number">10.0f</span>, FColor::Green, TEXT(<span class="string">"Health Check Successfully!"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SuccessResponse(<span class="string">"Health Check Successfully!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HttpRouter-&gt;BindRoute(</span></span><br><span class="line"><span class="comment">//     FHttpPath(TEXT("/health")),</span></span><br><span class="line"><span class="comment">//     EHttpServerRequestVerbs::VERB_GET,</span></span><br><span class="line"><span class="comment">//     CreateHandler(&amp;FBaseHandler::HealthCheck));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TUniquePtr&lt;FHttpServerResponse&gt; SuccessResponse(TSharedPtr&lt;FJsonObject&gt; Data, FString Message)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(Data, Message, <span class="literal">true</span>, SUCCESS_CODE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TUniquePtr&lt;FHttpServerResponse&gt; JsonResponse(TSharedPtr&lt;FJsonObject&gt; Data, FString Message, <span class="keyword">bool</span> Success, int32 Code)</span><br><span class="line">&#123;</span><br><span class="line">    TSharedPtr&lt;FJsonObject&gt; JsonObject = MakeShareable(<span class="keyword">new</span> FJsonObject());</span><br><span class="line">    JsonObject-&gt;SetObjectField(TEXT(<span class="string">"data"</span>), Data);</span><br><span class="line">    JsonObject-&gt;SetStringField(TEXT(<span class="string">"message"</span>), Message);</span><br><span class="line">    JsonObject-&gt;SetBoolField(TEXT(<span class="string">"success"</span>), Success);</span><br><span class="line">    JsonObject-&gt;SetNumberField(TEXT(<span class="string">"code"</span>), (<span class="keyword">double</span>)Code);</span><br><span class="line">    FString JsonString;</span><br><span class="line">    TSharedRef&lt;TJsonWriter&lt;&gt;&gt; Writer = TJsonWriterFactory&lt;&gt;::Create(&amp;JsonString);</span><br><span class="line">    FJsonSerializer::Serialize(JsonObject.ToSharedRef(), Writer);</span><br><span class="line">    <span class="keyword">return</span> FHttpServerResponse::Create(JsonString, TEXT(<span class="string">"application/json"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于一般HTTP返回的body是json，因此可以像上述一样另外封装作为模板response body的函数。对于request body，要转换为json，可以另外加函数去获取<code>TSharedPtr&lt;FJsonObject&gt;</code>的request json body实例。首先检查header是否为json格式，然后转化为json。采用<code>UTF8_TO_TCHAR</code>方法可以支持转换中文。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TSharedPtr&lt;FJsonObject&gt; GetRequestJsonBody(<span class="keyword">const</span> FHttpServerRequest&amp; Request)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// check if content type is application/json</span></span><br><span class="line">    <span class="keyword">bool</span> IsUTF8JsonContent = IsUTF8JsonRequestContent(Request);</span><br><span class="line">    <span class="keyword">if</span> (!IsUTF8JsonContent)</span><br><span class="line">    &#123;</span><br><span class="line">        UE_LOG(UALog, Warning, TEXT(<span class="string">"caught request not in utf-8 application/json body content!"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// body to utf8 string</span></span><br><span class="line">    TArray&lt;uint8&gt; RequestBodyBytes = Request.Body;</span><br><span class="line">    FString RequestBodyString = FString(UTF8_TO_TCHAR(RequestBodyBytes.GetData()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string to json</span></span><br><span class="line">    TSharedRef&lt;TJsonReader&lt;&gt;&gt; JsonReader = TJsonReaderFactory&lt;&gt;::Create(RequestBodyString);</span><br><span class="line">    TSharedPtr&lt;FJsonObject&gt; RequestBody;</span><br><span class="line">    <span class="keyword">if</span> (!FJsonSerializer::Deserialize(JsonReader, RequestBody))</span><br><span class="line">    &#123;</span><br><span class="line">        UE_LOG(UALog, Warning, TEXT(<span class="string">"failed to parse request string to json: %s"</span>), *RequestBodyString);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RequestBody;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsUTF8JsonRequestContent</span><span class="params">(<span class="keyword">const</span> FHttpServerRequest&amp; Request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> bIsUTF8JsonContent = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; HeaderElem : Request.Headers)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (HeaderElem.Key == TEXT(<span class="string">"Content-type"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Value : HeaderElem.Value)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> LowerValue = Value.ToLower();</span><br><span class="line">                <span class="keyword">if</span> (LowerValue.StartsWith(TEXT(<span class="string">"charset="</span>)) &amp;&amp; LowerValue != TEXT(<span class="string">"charset=utf-8"</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (LowerValue == TEXT(<span class="string">"application/json"</span>) || LowerValue == TEXT(<span class="string">"text/json"</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    bIsUTF8JsonContent = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bIsUTF8JsonContent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，UE4的一个基本的C++ HTTP Web Server就成型了。笔者因之做了一个简单的模板，传送门在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9VbnJlYWxIdHRwU2VydmVy" title="https://github.com/utmhikari/UnrealHttpServer">UnrealHttpAutomator<i class="fa fa-external-link"></i></span>~</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>C++</tag>
        <tag>web开发</tag>
        <tag>HTTP Server</tag>
        <tag>UE4插件</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】游戏自动化测试工具GAutomator上手</title>
    <url>/2020/05/05/testlife/try_gautomator/</url>
    <content><![CDATA[<p>最近开始研究一些游戏自动化测试方面的内容。游戏自动化测试是游戏测试研究领域的难点之一，当前主流的方案有两种，一种是采用纯粹的UI识别方法进行，典型的例子是<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FpcnRlc3RQcm9qZWN0L0FpcnRlc3Q=" title="https://github.com/AirtestProject/Airtest">Airtest<i class="fa fa-external-link"></i></span>，另一种是直接嵌入到游戏引擎中获取节点树等元素从而对实体进行操作，典型的例子是<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RlbmNlbnQvR0F1dG9tYXRvcg==" title="https://github.com/Tencent/GAutomator">GAutomator<i class="fa fa-external-link"></i></span>。由于笔者先前略微接触过Airtest方面的内容，因此本次决定上手GAutomator尝试游戏自动化。</p>
<p>本次上手过程具体则用GAutomator对Unreal4.24示例mobile项目中的元素进行操作，利用安卓手机进行调试。基本原理上，GAutomator会作为插件嵌入到Unreal项目中，自己包含一些获取World中信息的功能，而后listen一个端口，从而外部请求该插件可以获取World中的信息。通过adb进行搭桥，在外部，用户可以基于<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RlbmNlbnQvR0F1dG9tYXRvci90cmVlL21hc3Rlci9HQXV0b21hdG9yQW5kcm9pZA==" title="https://github.com/Tencent/GAutomator/tree/master/GAutomatorAndroid">GAutomatorAndroid<i class="fa fa-external-link"></i></span>编写，从而不仅可以与GAutomator的Unreal插件打通，而且也可以通过预先集成的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW9jb25nL3VpYXV0b21hdG9y" title="https://github.com/xiaocong/uiautomator">UIAutomator<i class="fa fa-external-link"></i></span>这样的工具直接模拟屏幕操作。</p>
<a id="more"></a>
<p>由于GAutomator原先对于Unity的支持较好，但笔者暂时没踩Unity的坑，因此仅针对Unreal而言，从第一次上手的体验来看，GAutomator还有许多优化点，比如：</p>
<ul>
<li>GAutomator的设定更类似客户端中的一个内嵌的GM指令服务端，但当前的“客户端”是纯粹的Python库，因此需要因GAutomator插件实现的功能而进行维护更新。理想的方式是采用GUI+蓝图的用户体验实现，通过提交任务的方式交付给GAutomator Unreal插件，在插件内部执行对应的自动化任务。</li>
<li>针对游戏用例的多样性，需要更多对世界实例进行操作的底层功能支持。业务用例的维护不能对这些底层功能造成影响，已经写好的底层功能仅因引擎实现以及实体操作需求的改变而改变。</li>
<li>大批量、多次游戏用例需要考虑前置条件生成/状态保存等需求，这些需求可能需要在自动化指令的基础上去结合预配置的GM指令。因此如何解耦这些不同的业务模块，也是需要考量的问题。</li>
</ul>
<p>总的来看这块还有很多有待挖掘的地方。如果有机会实战的话，再看看吧~</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>自动化测试</tag>
        <tag>游戏测试</tag>
        <tag>手游自动化</tag>
        <tag>GAutomator</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】在hugo博客中利用shortcode嵌入bilibili视频</title>
    <url>/2020/04/21/geekdaily/bilibili_in_hugo/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9nb2h1Z28uaW8v" title="https://gohugo.io/">hugo<i class="fa fa-external-link"></i></span>是当前热门的个人博客框架之一，和hexo同样是markdown文件跟博客帖子一一对应。有些同学想利用hugo制作个人视频博客，但发现在hugo博客中不支持直接在markdown里输入iframe标签，从而没有办法将其它网站的视频（比如b站）嵌进来。这种情况下，我们可以采用hugo内置的<span class="exturl" data-url="aHR0cHM6Ly9nb2h1Z28uaW8vY29udGVudC1tYW5hZ2VtZW50L3Nob3J0Y29kZXMv" title="https://gohugo.io/content-management/shortcodes/">shortcode<i class="fa fa-external-link"></i></span>机制完成这个需求。</p>
<p>我们参考的文章是<span class="exturl" data-url="aHR0cHM6Ly9nb2h1Z28uaW8vdGVtcGxhdGVzL3Nob3J0Y29kZS10ZW1wbGF0ZXMv" title="https://gohugo.io/templates/shortcode-templates/">create your own shortcodes<i class="fa fa-external-link"></i></span>，在这个文档中介绍了自定义shortcode从而快速渲染网页的方法，并且举了youtube以及vimeo的例子。照葫芦画瓢，我们也可以定义b站的shortcode。</p>
<p>我们首先在<code>layouts/shortcodes</code>目录下创建<code>bilibili.html</code>，然后填充内容如下：</p>
<a id="more"></a>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">"//player.bilibili.com/player.html?bvid=&#123;&#123;.Get 0 &#125;&#125;&amp;page=&#123;&#123; if .Get 1 &#125;&#125;&#123;&#123;.Get 1&#125;&#125;&#123;&#123; else &#125;&#125;1&#123;&#123;end&#125;&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">scrolling</span>=<span class="string">"no"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">height</span>=<span class="string">"768px"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">width</span>=<span class="string">"1024px"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">frameborder</span>=<span class="string">"no"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">framespacing</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">allowfullscreen</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>整个iframe是基于b站分享链接模板的。对于用户而言，主要关心bv号跟page（一个bv可能是个视频列表，有好几part）。在<code>bilibili.html</code>中，定义了唯一的bv号作为query，而后page默认为1，用户可以自行指定。</p>
<p>写好了<code>bilibili.html</code>中，在markdown里嵌入视频的话，用以下形式写就ok了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&lt; bilibili BV1RE411b71v &gt;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要指定part，比如要看大逃脱第一季第3回，这样写就ok了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&lt; bilibili BV18t41187Bx 3 &gt;&#125;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>hugo</tag>
        <tag>bilibili</tag>
        <tag>shortcode</tag>
        <tag>iframe</tag>
      </tags>
  </entry>
  <entry>
    <title>【GitHub探索】Eclipse Theia &amp; Gitpod——云端IDE尝鲜</title>
    <url>/2020/04/13/githubdiscovery/theia_and_gitpod/</url>
    <content><![CDATA[<p>本月，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VjbGlwc2UtdGhlaWEvdGhlaWE=" title="https://github.com/eclipse-theia/theia">eclipse theia<i class="fa fa-external-link"></i></span>发布了1.0版本。作为一个云端/桌面IDE框架，并且顶着eclipse foundation的名声，theia在github上受到万众瞩目。因此笔者决定上手eclipse theia，提前品尝一下云端IDE的滋味。</p>
<p>笔者选择了<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0cG9kLmlvLw==" title="https://www.gitpod.io/">gitpod<i class="fa fa-external-link"></i></span>而非本地docker作为theia的实验对象，这是因为gitpod本身就是theia的扩展版，并且支持github/gitlab上的项目导入，相当于云端github/gitlab项目的IDE，这样就可以实现在theia中启动一个theia项目，一探其中究竟。</p>
<p>登录gitpod，选择theia项目。项目的预设中会自动构建并在容器的3000端口启动theia。点击右侧的preview，就可以在gitpod的theia中打开原生的theia网页。当然也可以利用gitpod的open in browser方法，在自己浏览器的新标签页中打开原生的theia。</p>
<a id="more"></a>
<p><img src="/uploads/githubdiscovery/theia_and_gitpod/gitpod.png" alt="Gitpod中打开theia"></p>
<p>theia是以vscode为基础制作的。我们可以看到原生的theia是不包含插件安装等功能的，而在gitpod中，又基于theia，支持了vsix插件的安装、项目网站构建preview以及支持用户主机与容器交互等一系列的额外功能。插件安装是IDE的核心功能之一，一定程度上决定了整个产品的生态。以之为例，安装流程能够跑通，且插件可以持久化（针对单用户），但也有兼容性问题，比如括号染色插件，bracket pair colorizer安装不能生效，而rainbow brackets可以生效。可以说这一part还需要继续观望。</p>
<p><img src="/uploads/githubdiscovery/theia_and_gitpod/rainbow_brackets.png" alt="rainbow_brackets"></p>
<p>如果想临时将自己的github项目进行更改，可以将之放在gitpod上进行。具体的方法是，在chrome中安装<span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvZ2l0cG9kLW9ubGluZS1pZGUvZG9kbW1vb2Vva2xhZWpvYmdsZWlvZWxsYWRhY2Jla2k=" title="https://chrome.google.com/webstore/detail/gitpod-online-ide/dodmmooeoklaejobgleioelladacbeki">gitpod插件<i class="fa fa-external-link"></i></span>，这样在github网页里，就会额外多出来一个gitpod按钮了。</p>
<p><img src="/uploads/githubdiscovery/theia_and_gitpod/gitpod_button.png" alt="gitpod_button"></p>
<p>登录gitpod后，点击github项目里的gitpod按钮，gitpod就会生成一个包含该github项目的容器，并启动theia将该项目放到workspace中。用户修改了项目代码后可以直接git push（第一次push时会提示需要授权），从而对github项目进行更新。</p>
<p>由于gitpod作为一项服务，存在收费内容，并且没有容器规格申请的功能业务，IDE周边支持暂不完善，因此仍然不能取代基于本地主机IDE的开发流程。但是cloud IDE终究还是直接提供了环境与部署流程，让开发者专注于业务代码的编写，这块对于开发效率的收益还是非常可观的，因此拭目以待。另外，对于theia，如果业务中有在网页进行编码的需求，采用theia框架扩展开发，可能是一个不错的选择。</p>
]]></content>
      <categories>
        <category>GitHub探索</category>
      </categories>
      <tags>
        <tag>研发效能</tag>
        <tag>eclipse theia</tag>
        <tag>gitpod</tag>
        <tag>cloud IDE</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】记一次导表检查流程中导致JVM的OOM问题</title>
    <url>/2020/03/14/testlife/table_check_oom/</url>
    <content><![CDATA[<p>最近在项目组测试有开发一个导表检查的需求，大致是在策划提交表更新到svn之后，svn发送post-commit到策划表数据服务，而后策划表数据服务下载excel文件，更新数据之后，将导表检查下游服务所需的检查数据进行整合，然后post到导表检查服务。在这个过程中，由于做的仓促没有考虑设计，最后策划表数据服务的JVM发生了OOM问题。经过一番排查改进了设计，解决了这个问题。</p>
<p>JVM的内存结构跟GC流程是老生常谈的话题。Java8去掉了永久区的设定，更改为了Metaspace存储类的元信息、常量等内容，而剩下来依然是新区eden和老区old。当eden区空间满的时候触发young gc，将eden区根节点不可达的对象清除，存活的对象转到survivor区。survivor区的对象如果经历了某一个数（可配置，最高15）的young gc后仍然存活，就会转到old区。如果短时间内创建大量对象，且eden区放不下，young gc没有清除过多数据的情况下，多余的数据会转到old区。如果old区也放不下，就出现OOM（Out Of Memory）。一般业务层面导致OOM的原因基本上是一次产生大量对象，或者是内存泄露，没有及时清除不需要的数据引用。</p>
<p>策划表数据的业务逻辑上是下载数据-&gt;更新数据-&gt;进行导表检查的一个流程，其中下载、更新数据这一环节会产生大量的对象，而同样进行导表检查时为了发导表检查所需的数据，也会产生大对象——需要将数据序列化为json字符串。在这个流程里自己犯了几个错误导致OOM的问题，具体如下：</p>
<a id="more"></a>
<ul>
<li>导表检查的设计直接采用request数据然后在response里获取导表检查结果的方式，并没有增加回调接口，使得如果导表检查方出现逻辑问题不能及时返回结果的话，发送的导表数据json以及序列化后的结果将不能被gc，导致内存泄漏。因此增加了一个回调接口供导表检查下游调用，使得httpclient对象能够释放，从而request的json数据可以被young gc给消除掉。</li>
<li>request接口采用第三方的库，传参是json string，但是在实际post时候会调用getBytes，无形中增加了内存开销。因此直接把第三方库代码扣下来，并且直接序列化json为bytes，减少内存开销。</li>
<li>导表检查前会导入数据，导入数据会不断下载excel文件并提取其中内容，这个步骤有触发young gc的可能。如果某次导入数据之后需要导表检查，就手动申请一次gc()，避免潜在的问题。</li>
<li>导表检查所在的容器规格升级为8G内存，并在jvm启动选项中设定eden区跟老区各一半，survivor区最大总共占1/4的eden区。</li>
</ul>
<p>最终暂时解决了这个问题，如果后续有其它的优化策略，还要继续补充。</p>
<hr>
<p>更新：后续找到了内存泄露的原因，是导表过程中缓存大量数据所致，最终修复了这个缺陷。至于JVM方面，一般情况下，基本上也不需要调参的啦~</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>gc</tag>
        <tag>导表检查</tag>
        <tag>java</tag>
        <tag>JVM</tag>
        <tag>OOM</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】再度上手start-fastapi</title>
    <url>/2020/02/26/geekdaily/start_fastapi_reborn/</url>
    <content><![CDATA[<p>近期项目组准备做一个新的工具，因此自个儿做的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9zdGFydC1mYXN0YXBp" title="https://github.com/utmhikari/start-fastapi">start-fastapi<i class="fa fa-external-link"></i></span>框架正好能派上用场试试水。在起草需求搭建最初框架的时候也逐步发现原先的start-fastapi有一些不足的地方，因此做了一些针对性的优化。</p>
<p>首先必须重新介绍一下start-fastapi，其本身是轻量级web框架<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RpYW5nb2xvL2Zhc3RhcGk=" title="https://github.com/tiangolo/fastapi">fastapi<i class="fa fa-external-link"></i></span>的延伸，但是由于fastapi给的例子过于简单，因此就基于此做了一个简单的web后端脚手架，借鉴了<span class="exturl" data-url="aHR0cHM6Ly9lZ2dqcy5vcmcvemgtY24vaW50cm8vcXVpY2tzdGFydC5odG1s" title="https://eggjs.org/zh-cn/intro/quickstart.html">eggjs<i class="fa fa-external-link"></i></span>的目录组织模型，使得整个框架更加易于投产。如果稍微看过start-fastapi其中的代码的话就能够发现它并不是一个OOP的框架，这是因为一方面python本身不是向java一般与OO设计理念强耦合，且其module隔离与动态加载机制已经足够区分每一个功能模块了；另一方面轻量的HTTP Web Server本身作为无状态的服务，各个功能模块应该是静态式、单例式的存在。在start-fastapi上也可以继续扩展底层。从起草工具的效果来看，多人协同开发时，每个人负责的模块应当也不会有太大冲突的概率。</p>
<p>接下来是近期优化的一些点，首先是application目录下的优化。原先application分为了service、middleware、config等多个模块，但现在直接缩减为controller、logger跟router，这是因为service跟middleware里全局性的功能模块一般都是用户自定义的，而controller的response可以约定，logger factory也可以统一提供。而router作为后端app的固有功能，这块就必不可少了。</p>
<a id="more"></a>
<p>然后是controller的优化，在参考了官网的<span class="exturl" data-url="aHR0cHM6Ly9mYXN0YXBpLnRpYW5nb2xvLmNvbS90dXRvcmlhbC9iaWdnZXItYXBwbGljYXRpb25zLw==" title="https://fastapi.tiangolo.com/tutorial/bigger-applications/">Bigger Applications<i class="fa fa-external-link"></i></span>文档之后，果断把controller写成了经典的装饰器模式。装饰器模式对于业务而言是很大的利好，如果一个新成员协同研发的话就不必在router与controllers之间切来切去。</p>
<p>最后是启动的优化。在start-fastapi的入口中采用uvicorn去启动app程序，但这里疏忽了一个点是uvicorn相当于重新loadfile去载入这个文件里面的python内容，因此如果不把fastapi app的初始化逻辑分离出去相当于加载了两次。分离到根目录<code>app.py</code>之后，这个问题就迎刃而解了。</p>
<p>关于uvicorn、starlette、asgi相关的东西，还有许多坑暂时没时间踩，要有空再慢慢瞧瞧了。</p>
<hr>
<p>更新：另外解决了一个分离config配置的问题，现在uvicorn application的配置被分离到<code>config/app</code>中，而<code>config/dev.cfg</code>与<code>config/prod.cfg</code>则是用户定义的配置，采用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZXNrdW1hci9weXRob24tZG90ZW52" title="https://github.com/theskumar/python-dotenv">python-dotenv<i class="fa fa-external-link"></i></span>的格式。非常方便，用<code>os.getenv</code>就能获取到。</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>python</tag>
        <tag>fastapi</tag>
        <tag>start-fastapi</tag>
        <tag>装饰器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】写一个基于vuetify的v-autocomplete的自定义组件</title>
    <url>/2020/02/16/geekdaily/v_autocomplete/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly92dWV0aWZ5anMuY29tL3poLUhhbnMv" title="https://vuetifyjs.com/zh-Hans/">Vuetify<i class="fa fa-external-link"></i></span>是Vue的一套前端组件框架，基于Material Design设计，界面较为整洁。最近由于项目需要开始入手，但在写自定义<code>v-autocomplete</code>组件的时候却踩了许多坑。因此本文果断记录一下踩坑的过程。</p>
<p>首先新上手vue的话肯定耳边都会萦绕着“双向绑定”一词，用的最多的属性就是<code>v-model</code>了。但是我们参考<span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcvdjIvZ3VpZGUvZm9ybXMuaHRtbA==" title="https://cn.vuejs.org/v2/guide/forms.html">官方文档<i class="fa fa-external-link"></i></span>可以发现<code>v-model</code>只是语法糖，除了绑定默认组件的值（比如<code>select</code>元素是<code>value</code>，而<code>checkbox</code>元素是<code>checked</code>）之外，还会绑定监听用户输入事件（比如<code>text</code>元素是<code>input</code>，而<code>radio</code>元素是<code>change</code>）。因此要用<code>v-model</code>的话需要关注相应的元素是否本身就支持语法糖。我们在<span class="exturl" data-url="aHR0cHM6Ly92dWV0aWZ5anMuY29tL3poLUhhbnMvY29tcG9uZW50cy9hdXRvY29tcGxldGVz" title="https://vuetifyjs.com/zh-Hans/components/autocompletes">v-autocomplete官方文档<i class="fa fa-external-link"></i></span>中可以发现，其扩展了<code>v-select</code>组件，因此如果用自定义组件包一层的话，一般主要关心的是怎样传递最终选择的value，就可以了。</p>
<p>比如要做一个异步检索items的<code>v-autocomplete</code>组件，我们可以用如下的方式自定义：</p>
<p>其中template如下：</p>
<a id="more"></a>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">v-autocomplete</span>&gt;</span></span><br><span class="line">        :v-model="select"</span><br><span class="line">        :items="items"</span><br><span class="line">        :loading="loading"</span><br><span class="line">        :search-input.sync="search"</span><br><span class="line">        item-text="text"</span><br><span class="line">        item-value="value"</span><br><span class="line">    <span class="tag">&lt;/<span class="name">v-autocomplete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后script如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// 略过其它属性</span></span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            items: [],</span><br><span class="line">            loading: <span class="literal">false</span>,</span><br><span class="line">            currentSearchValue: <span class="string">''</span>,</span><br><span class="line">            search: <span class="literal">null</span>,</span><br><span class="line">            select: <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        select(val) &#123;</span><br><span class="line">            <span class="comment">// 触发changeVal事件，更改select到的item的value</span></span><br><span class="line">            <span class="keyword">this</span>.$emit(<span class="string">'changeVal'</span>, val)</span><br><span class="line">        &#125;,</span><br><span class="line">        search(val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.currentValue = val</span><br><span class="line">            <span class="comment">// 注意保持缓存的items，不要加清空items的逻辑，否则先前传出去的item的value（select）也没了</span></span><br><span class="line">            <span class="keyword">this</span>.handleSearch(val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        handleSearch(v) &#123;</span><br><span class="line">            <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!_this.currentValue === v) &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                _this.loading = <span class="literal">true</span></span><br><span class="line">                <span class="comment">// 下面是自定义的检索items的逻辑</span></span><br><span class="line">                asyncSearch().then(<span class="function">(<span class="params">resp</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (resp.code === <span class="number">200</span> &amp;&amp; _this.currentValue === v) &#123;</span><br><span class="line">                        _this.items = resp.data.map(<span class="function"><span class="params">d</span> =&gt;</span> (&#123;</span><br><span class="line">                            ...d,</span><br><span class="line">                            text: d.textPart,  <span class="comment">// 显示的文本</span></span><br><span class="line">                            value: d.valuePart,  <span class="comment">// 真正要传出去的值</span></span><br><span class="line">                        &#125;))</span><br><span class="line">                    &#125;</span><br><span class="line">                    _this.loading = <span class="literal">false</span></span><br><span class="line">                &#125;).catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    _this.loading = <span class="literal">false</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;, <span class="number">200</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在接受组件值的那一端，假设我们自定义组件叫<code>CustomVAutoComplete</code>的话。只需要写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CustomVAutoComplete</span> @<span class="attr">changeVal</span>=<span class="string">"handleValChange"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// 略过其它属性</span></span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            autoCompleteVal: <span class="string">''</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        handleValChange(v) &#123;</span><br><span class="line">            <span class="keyword">this</span>.autoCompleteVal = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就可以了</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
        <tag>vuetify</tag>
        <tag>v-autocomplete</tag>
        <tag>v-model</tag>
      </tags>
  </entry>
  <entry>
    <title>【GitHub探索】FastAPI——新一代实用python轻量级Web后端框架</title>
    <url>/2020/02/01/githubdiscovery/fastapi/</url>
    <content><![CDATA[<p>本月，一款名为<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RpYW5nb2xvL2Zhc3RhcGk=" title="https://github.com/tiangolo/fastapi">FastAPI<i class="fa fa-external-link"></i></span>的轻量级Web框架在trending榜上有名。本着踩坑的心态试用了fastapi，发现其坑并没有许多相同量级web框架（比如flask）来的多，上手极其容易。因此果断整理了一下fastapi的上手过程。</p>
<p>FastAPI基于<span class="exturl" data-url="aHR0cHM6Ly93d3cuc3RhcmxldHRlLmlvLw==" title="https://www.starlette.io/">Starlette<i class="fa fa-external-link"></i></span>网络框架进行封装，不仅性能优异，并且解决了许多用python开发效率工具或是轻量级应用的后端同学的痛点。比如：</p>
<ul>
<li>结合<span class="exturl" data-url="aHR0cHM6Ly9weWRhbnRpYy1kb2NzLmhlbHBtYW51YWwuaW8v" title="https://pydantic-docs.helpmanual.io/">pydantic<i class="fa fa-external-link"></i></span>，实现param与body的静态类型检查</li>
<li>用妥当的方式接收/返回json body</li>
<li>结合Starlette，从而自带restful api以及middleware的支持</li>
<li>自带调试router，基本顶替postman的工作</li>
<li>etc</li>
</ul>
<p>安装fastapi需要python3.6以上，预先<code>pip3 install fastapi uvicorn</code>。我们来看一下FastAPI的例子：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example.py</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    name: str</span><br><span class="line">    price: float</span><br><span class="line">    is_offer: bool = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_root</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"Hello"</span>: <span class="string">"World"</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get("/items/&#123;item_id&#125;")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_item</span><span class="params">(item_id: int, q: str = None)</span>:</span>  <span class="comment"># 此处q为query的字段</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"item_id"</span>: item_id, <span class="string">"q"</span>: q&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put("/items/&#123;item_id&#125;")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_item</span><span class="params">(item_id: int, item: Item)</span>:</span>  <span class="comment"># 此处Item为body的schema</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"item_name"</span>: item.name, <span class="string">"item_id"</span>: item_id&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    uvicorn.run(<span class="string">'example:app'</span>)</span><br></pre></td></tr></table></figure>
<p>采用<span class="exturl" data-url="aHR0cHM6Ly93d3cudXZpY29ybi5vcmcv" title="https://www.uvicorn.org/">Uvicorn<i class="fa fa-external-link"></i></span>打开<code>app</code>，我们的后端便能够起起来。进入<code>http://localhost:8000/docs</code>，就能够进入路由的描述与调试界面。<br>在调试界面中我们可以自己输入params/query/body，如果输入值的类型不对或者是缺少相应的body字段，response会自动带错误码以及detail信息。比如在<code>put /items/{item_id}</code>中，我们输入body为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"named"</span>: <span class="string">"string"</span>,</span><br><span class="line">  <span class="attr">"price"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"is_offer"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据Item model定义缺少了name字段，故返回422错误码以及json body：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"detail"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"loc"</span>: [</span><br><span class="line">        <span class="string">"body"</span>,</span><br><span class="line">        <span class="string">"item"</span>,</span><br><span class="line">        <span class="string">"name"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"msg"</span>: <span class="string">"field required"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"value_error.missing"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以说对于开发人员而言是非常方便了。</p>
<p>实际采用fastapi + uvicorn开发时会遇到部分customization的问题，比如<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9BY2Nlc3NfY29udHJvbF9DT1JT" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">跨域cors<i class="fa fa-external-link"></i></span>的header处理以及logger配置之类。针对这些，笔者把fastapi可能用到的一些基本的后端配置与目录结构进行了整理，放到了<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9zdGFydC1mYXN0YXBp" title="https://github.com/utmhikari/start-fastapi">start-fastapi<i class="fa fa-external-link"></i></span>项目中，相当于一个模板。针对上述的例子，跨域处理一般放到middleware中，可以添加Starlette所带的CORSMiddleware进行处理；而用uvicorn启动的话，logging日志模块会被uvicorn重写，因此若要自定义日志，需要参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VuY29kZS91dmljb3JuL2Jsb2IvbWFzdGVyL3V2aWNvcm4vY29uZmlnLnB5" title="https://github.com/encode/uvicorn/blob/master/uvicorn/config.py">uvicorn config<i class="fa fa-external-link"></i></span>中的<code>LOGGING_CONFIG</code>来自己重写，加载到uvicorn的<code>log_config</code>配置中。如果还有额外的自定义需求，可参考<span class="exturl" data-url="aHR0cHM6Ly9mYXN0YXBpLnRpYW5nb2xvLmNvbS9wcm9qZWN0LWdlbmVyYXRpb24v" title="https://fastapi.tiangolo.com/project-generation/">fastapi项目生成模板<i class="fa fa-external-link"></i></span>以及该官网中其它的文档自行定制。</p>
<p>FastAPI的生产环境暂时没有踩坑。但从FastAPI的定位以及研发环境提供的功能与API来看，已经能够极大提升研发效能。后续有空再封装下生产环境部署流程，以后要开发后端小工具就基本上用这个跟start-fastapi上了。</p>
]]></content>
      <categories>
        <category>GitHub探索</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>python</tag>
        <tag>fastapi</tag>
        <tag>效率工具</tag>
        <tag>web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】为游戏策划与QA量身定制的excel表diff算法</title>
    <url>/2020/01/23/testlife/excel_diff/</url>
    <content><![CDATA[<p>国内的游戏研发团队里许多策划同学都习惯采用excel作为配表工具。因此对策划同学校对与QA同学验收工作来说，需要相应的diff工具去检测excel文件的变更，从而能够尽早发现配表的问题。为此，在笔者启动的游戏效率工具集<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9nYW1lZmYtdG9vbHNldA==" title="https://github.com/utmhikari/gameff-toolset">gameff-toolset<i class="fa fa-external-link"></i></span>小项目中，首个小脚本便做了excel diff。</p>
<p>diff的算法有非常多，但是如何体现策划表与策划工作的特性，这才是最需要注意的。许多项目的策划表都通过SVN进行存储，因此从SVN的commit信息中就可以知道哪些策划表发生了变更/增加，因此，我们只需关心每个excel文件如何进行diff运算就可以了。</p>
<p>策划的excel配表有如下的特点：</p>
<a id="more"></a>
<ul>
<li>每个sheet有表头header，一般为行表头header</li>
<li>header一般定下后不会再变化</li>
<li>不同的sheet，表结构基本不同</li>
<li>row不一定有主键，甚至同sheet有重复的id</li>
<li>每次变更时，变更的行数相对不变的行数较少</li>
<li>可能存在将某些行移动到其它位置的情况</li>
<li>策划同学在excel某些空白区域可能会加上注释</li>
</ul>
<p>因此，我们从sheet的粒度来看，diff模块可以这样设计：</p>
<ul>
<li>定义表头行index，数据起始行index，数据起始列index</li>
<li>统计增加与去除的表头。如果单纯表头名称改了，下面的数据改动基本没有，也算整个列都改了。这样，列的长度就变得一样了。</li>
<li>对于共有的表头，统计下面的行数据，去除不合法的行。如果行中起始列上没有数据，就算不合法。</li>
<li>通过求行的hash，来获得变更前excel与变更后excel中行的映射，从而知道哪些行没有变动，哪些行变动了。</li>
<li>针对没有变动的行，求变更后excel中这些行的索引的<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9uZ2VzdF9pbmNyZWFzaW5nX3N1YnNlcXVlbmNl" title="https://en.wikipedia.org/wiki/Longest_increasing_subsequence">LIS<i class="fa fa-external-link"></i></span>。具体的求法可以参考<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzk5MjY5Ny9sb25nZXN0LWluY3JlYXNpbmctc3Vic2VxdWVuY2U=" title="https://stackoverflow.com/questions/3992697/longest-increasing-subsequence">stackoverflow<i class="fa fa-external-link"></i></span>上的一个帖子，主要思想是用两个数组分别维护长为x的lis的最后一个数的最小索引以及某索引的数作为lis最后一个数时前一个数的索引，然后通过回溯后一个数组，从而获得lis串。通过lis串，我们可以知道哪些行只是单纯地被移动位置，而其中内容并没有被改动过。</li>
<li>针对“变动”的行，也分三种情况：增加行，删减行与修改行。由于每次变更所涉及的行一般不多，因此可以采用o(n方)复杂度的方法每行逐格比较。通过逐格比较，可以求出行间相似度，因此我们可以定义一个相似度阈值来判断两行是否相似。如果某个行跟原来的行的相似度大于阈值，就说明这两行相对应，是一个“修改行”的行为，故我们只需记录其中单元格的变化；如果从变更前的某行找不到相似的变更后的某行，就是一个“删减行”的行为；如果有些变更后的行没有变更前的行对应，就是一个“增加行”的行为。</li>
</ul>
<p>这个模块详细的代码已经写在了<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9nYW1lZmYtdG9vbHNldC9ibG9iL21hc3Rlci9saWIvZXhjZWxfZGlmZmVyLnB5" title="https://github.com/utmhikari/gameff-toolset/blob/master/lib/excel_differ.py">excel_differ.py<i class="fa fa-external-link"></i></span>中，虽然没有过于细致的整理，可能有许多优化空间，但模块已经拆分的足够明确，并且性能表现也足够OK了。如果拿两个文件夹下的excel文件作为对比的话，可以输出一个类似于<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9nYW1lZmYtdG9vbHNldC9ibG9iL21hc3Rlci90ZXN0L2V4Y2VsX2RpZmZlci9yZXBvcnQuanNvbg==" title="https://github.com/utmhikari/gameff-toolset/blob/master/test/excel_differ/report.json">这样<i class="fa fa-external-link"></i></span>的json报告。因此若要投产，不论是单纯copypaste脚本，还是接到web server，都绰绰有余了。</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>游戏测试</tag>
        <tag>游戏策划</tag>
        <tag>excel-diff</tag>
        <tag>diff算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】解决使用mongodb时同时update多条数据的问题</title>
    <url>/2020/01/12/geekdaily/mongo_multi_updatemany/</url>
    <content><![CDATA[<p>在实际使用mongodb的场景中，我们经常遇到多个请求同时在某个collection里update多条document的需求。这个需求看似有许多种解法，但是具体哪种好也说不准。现在便让我们一探究竟吧~</p>
<p>首先我们利用pymongo添加1000000条数据，name字段为hello：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"></span><br><span class="line">client = MongoClient()</span><br><span class="line">db = client[<span class="string">'test'</span>]</span><br><span class="line">coll = db[<span class="string">'concurrency'</span>]</span><br><span class="line"></span><br><span class="line">coll.insert_many([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"hello"</span>,</span><br><span class="line">        <span class="string">"num"</span>: i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>然后，我们另外加一个进程，启动任务为将num字段为偶数的documents的name字段给update成aa，而主线程则update所有documents的name字段为bb。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool, Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client = MongoClient()</span><br><span class="line">db = client[<span class="string">'test'</span>]</span><br><span class="line">coll = db[<span class="string">'concurrency'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name, m)</span>:</span></span><br><span class="line">    coll.update_many(</span><br><span class="line">        &#123;<span class="string">"num"</span>: &#123;<span class="string">"$mod"</span>: [m, <span class="number">0</span>]&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"$set"</span>: &#123;<span class="string">"name"</span>: str(name)&#125;&#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Process(target=f, args=(<span class="string">'aa'</span>, <span class="number">2</span>))</span><br><span class="line">    p.start()</span><br><span class="line">    coll.update_many(&#123;&#125;, &#123;<span class="string">"$set"</span>: &#123;<span class="string">"name"</span>: <span class="string">'bb'</span>&#125;&#125;)</span><br><span class="line">    p.join()</span><br><span class="line">    docs = coll.find()</span><br><span class="line">    d = dict()</span><br><span class="line">    <span class="keyword">for</span> doc <span class="keyword">in</span> docs:</span><br><span class="line">        n = doc[<span class="string">'name'</span>]</span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> d.keys():s</span><br><span class="line">            d[n] = <span class="number">0</span></span><br><span class="line">        d[n] += <span class="number">1</span></span><br><span class="line">    pprint.pprint(d)</span><br></pre></td></tr></table></figure>
<p>最后结果是：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&apos;aa&apos;: 9809, &apos;bb&apos;: 990191&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，两个conn提交的update_many请求，在mongo内部并不是原子的任务。进程比主线程后起，因此进程在update时，主线程已经执行了部分update任务了。但是由于进程update的documents数量较少，因此很快就追上了主线程的进度，从而只有约10000个record最后是被进程给update的。</p>
<p>在mongo官方的<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9jb3JlL3dyaXRlLW9wZXJhdGlvbnMtYXRvbWljaXR5Lw==" title="https://docs.mongodb.com/manual/core/write-operations-atomicity/">写操作原子性<i class="fa fa-external-link"></i></span>文档中提到，mongodb对于单个document的写操作是原子的。也就是说，在updateMany里，对每一个符合filter的document的修改操作是原子的，但是整个updateMany，不会阻塞其它client的update操作。</p>
<p>如果要多个updateMany任务不发生并发，最简便的第一种方法是在业务逻辑中加锁，或者用一个任务队列进行管理。这种方法不仅适合updateMany场景，同样也适合在update的时候，需要修改表结构的场景（document全量update，可能需要先delete后insert）。</p>
<p>第二种方法是利用mongodb提供的<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9jb3JlL3RyYW5zYWN0aW9ucy8=" title="https://docs.mongodb.com/manual/core/transactions/">事务<i class="fa fa-external-link"></i></span>功能，使得在单个session上这些updateMany操作能够有序进行。事务功能启用需要mongo为副本集模式，版本至少4.0，若有分布式事务的需求需要至少4.2的版本。</p>
<p>第三种方法则是在每一个documents中加入version字段，在update的filter中去另外对比version版本号，从而保证最新版本的documents能够存入数据库。在这个思路下，也可以另外再加一个meta表存储最新version的信息（每一个doc里还是要version字段）。只有成功更新了meta表的version，才能updateMany数据表中的documents，否则阻止这个意向。</p>
<p>第三种方法相对前两种方法可控性较低，因此实际场景中，暂推荐第一种以及第二种方法。（如果有其它更有效的方法，欢迎指正orz）</p>
<hr>
<p>在第一种方法的基础上延伸，可以设置一定量的lock，而后将请求信息hash掉，mod进特定idx的lock。这样只需要控制lock的量，就能控制多个updateMany的需求了。</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>mongodb</tag>
        <tag>pymongo</tag>
        <tag>事务</tag>
        <tag>原子性</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】测试、策划与开发，谁来把控游戏的质量？</title>
    <url>/2019/12/22/testlife/are_testers_controlling_quality/</url>
    <content><![CDATA[<p>近期进入了另外一个项目组，工作沟通的时候遇到了一些碰撞。在和项目组其它伙伴交换意见的同时，自己也开始思考这个问题：测试、策划与开发，这三个主导游戏研发的部门，谁才是真正把控着游戏的质量？</p>
<p>从自己的职业立场与岗位的配置上来看，测试理所应当真正管控游戏的质量，但是实际上又不尽然。从策划和开发的立场上来看，一个关心游戏呈现的效果，一个关心游戏的稳定性，都是广义上的“质量管理”。但实际情况下，许多研发与策划同学会希望测试能专注于提bug，这方面没有什么问题，而希望测试同学只提出经过自己确认后的所谓的bug，这种观点倒是有点不靠谱。</p>
<a id="more"></a>
<p>然而现实并非如此理想，造成这种情况有很多原因：</p>
<ul>
<li>策划与开发等其它岗位的同学，并非质量管理职业，对测试与质量管理缺乏了解。</li>
<li>测试的字眼以及点点点的泛滥，会招致部分技术专精者先入为主的偏见。</li>
<li>策划与开发相对于游戏产品，是一线产出者，有捍卫自己成果的权利。</li>
<li>etc</li>
</ul>
<p>即便如此，策划与开发并没有管控缺陷流程的权利，因此禁止测试人员“随意”提出缺陷，是一种越界行为。在整个研发流程中定义缺陷的人，应当是测试（质量管理）人员，而不是其它岗位的同行。如果一致认为某些缺陷定义不当，那么只能将其定义为“不予修复的缺陷”，而不是将其否认不是一个缺陷。</p>
<p>缺陷的产生，究其本因，可能是缺陷没有对产品的整体效果造成实质影响，也有可能是文档没有及时维护导致用例滞后，还有可能是测试人员自身没有做好对产品的把控造成误报。但不论怎样，在缺陷产生之后，都需要充分沟通与交换信息，才能够完整解决每一个缺陷问题。因此，每一个缺陷记录，不仅仅是对bug的反映，更是记载了研发流程中每一个问题的解决过程，是有实际意义的。</p>
<p>在大项目里，我们需要以产品利益为考量，择其重者而行之。团队的稳定会比个人的理想优先级高，因此很多情况下，各岗位的小伙伴在不够熟悉地基础上，需要不断磨合妥协，寻找微妙的关系，才能达到稳定共赢。但与此同时，我也希望游戏行业质量管理工作在实践上更加完善和规范，在业务能力上更加精进。这样，才能拥有资本去争取更多原本属于这个岗位的权利。</p>
<p>希望n年之后，回顾这篇文章，有更加全面的解读。let’s see</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>游戏开发</tag>
        <tag>游戏测试</tag>
        <tag>质量管理</tag>
        <tag>测试</tag>
        <tag>游戏策划</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】小谈游戏测试用例与代码间的联系</title>
    <url>/2019/12/06/testlife/game_testcase_with_code/</url>
    <content><![CDATA[<p>近几周一直在某SLG项目内负责功能模块测试与周边工具推进的工作，渐渐感悟到了些用例设计与业务代码的联系。</p>
<p>游戏的业务逻辑是比一般应用复杂的。而且对于自己项目这种强玩法的游戏而言，甚至还会出现以下的现象——<strong>QA驱动策划，策划驱动开发</strong>。</p>
<p>策划案能够大概阐述游戏的界面、逻辑与数值，但是如果有复杂的特例，还需要QA在实际测试中去挖掘。游戏测试用例的设计过程，不仅可以看成是策划案的延伸，而且也可以看作是一份业务代码的参考文档。如果了解游戏服务端与客户端机制，跟进过代码的话，甚至可以根据它们设计一些极端的用例。</p>
<p>好比说，某一个建筑，占地是5x5，但是它横跨国界，一部分在A国，一部分在B国。那么这个建筑，是属于A国，还是B国呢？</p>
<a id="more"></a>
<p>如果你是开发的话，会考虑一个简单的设计：这一个建筑中心点在哪里，就属于哪个国家。</p>
<p>解决所属国家很简单，但是业务是多变的，策划的大脑是被二柱子捅得很深的。如果游戏机制允许玩家占领了该建筑，并利用这个建筑的地块做一些操作，那么根据中心点判断所属国家的逻辑，并足以满足业务，还需要加上地块的判定。</p>
<p>因此测试点就来了：</p>
<ul>
<li>建筑在国界，中心点在A国 ——&gt; 显示所属A国</li>
<li>建筑在国界，所属A国，但也拥有B国的地 ——&gt; 能利用B国地块，做xxx操作</li>
</ul>
<p>至于真实能不能用B国的地块做xxx操作，这就需要与策划沟通了。但重要的是，这一类地方，往往是容易出现缺陷的地方。</p>
<p>又比如说，你本来有一个5x5的建筑，但是等你换了阵营之后，建筑缩水成3x3的了，但“进入”建筑后的游戏功能基本没有变化。这个时候，不仅需要回归建筑相关功能，而且也需要关注建筑体积变化带来的影响。比如说，我为这个建筑添加了一个标记，那么点击原来5x5的范围，是不是还能激活这个标记？</p>
<p>如果没有配表支持的话，可能在开发过程中，原先就会写死建筑的大小。这样，点击3x3外围的空地，就有可能激活标记，导致bug。</p>
<p>总之，QA是最了解产品（游戏）的人。设计测试用例的时候，也要想到如果是自己写这个业务逻辑，会怎样设计代码，这样反推过来，就形成了一种代码排查方案。作为QA，你永远不知道研发会在什么样的地方犯错，但是常code review，养成跟进代码并思考的习惯，就能够对游戏代码设计增加一份了解，从而更容易发现游戏设计中不容易被人注意，却又容易引发缺陷的细节。</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>游戏测试</tag>
        <tag>测试</tag>
        <tag>功能测试</tag>
        <tag>code review</tag>
        <tag>测试用例</tag>
      </tags>
  </entry>
  <entry>
    <title>【从零单排Golang】第五话：用自带net包写一个简单的负载均衡</title>
    <url>/2019/11/24/gofromzero/05_load_balancer/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9nb2Zyb216ZXJv" title="https://github.com/utmhikari/gofromzero">Github传送门<i class="fa fa-external-link"></i></span></p>
<p>golang在工业中用途最多的方面就是编写中间件以及上游设施，因此切入golang的话，了解其网络库是很有必要的。因此，笔者上手了自带的net包，花了一天左右的时间写了个简单的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUI0JTlGJUU4JUJEJUJEJUU1JTlEJTg3JUU4JUExJUEx" title="https://zh.wikipedia.org/wiki/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">负载均衡（Load Balancer）<i class="fa fa-external-link"></i></span>，也算是能用啦= =</p>
<h2 id="用net包写负载均衡"><a href="#用net包写负载均衡" class="headerlink" title="用net包写负载均衡"></a>用net包写负载均衡</h2><p>我们在浏览网页时，通常会遇到服务方故障的情况，提示我们nginx、apache之类的字眼。这些，便都是负载均衡的工作了。</p>
<p>一个负载均衡可能会包含以下的功能：</p>
<ul>
<li>负载调节<ul>
<li>上游连接分配（策略：轮流（roundrobin）、最少连接等）</li>
<li>权重管理</li>
</ul>
</li>
<li>健康检查（业务是否OK）</li>
<li>协议支持<ul>
<li>tcp、udp</li>
<li>http、https</li>
<li>路由代理</li>
<li>数据缓存与压缩</li>
</ul>
</li>
<li>安全<ul>
<li>限流，DDOS防护</li>
<li>备用负载均衡</li>
</ul>
</li>
</ul>
<p>为了实践一下（培养手感），笔者用net包弄了一个基于tcp的简易负载均衡，实现了上述最基础的负载调节与健康检查功能。</p>
<p>首先设计一个struct：</p>
<a id="more"></a>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> loadBalancer <span class="keyword">struct</span> &#123;</span><br><span class="line">    Port <span class="keyword">uint</span></span><br><span class="line">    Listener net.Listener</span><br><span class="line">    ServerMap <span class="keyword">map</span>[<span class="keyword">uint</span>]*Server</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了用于listen的端口与listener实例之外，用一个map储存每一个服务的信息与状态。虽然粒度有点大，但凑合能用。</p>
<p>每一个服务包含了地址、权重、是否活跃等信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID <span class="keyword">uint</span></span><br><span class="line">    Active <span class="keyword">bool</span></span><br><span class="line">    Host <span class="keyword">string</span> <span class="string">`json:"host"`</span></span><br><span class="line">    Port <span class="keyword">uint</span> <span class="string">`json:"port"`</span></span><br><span class="line">    Weight <span class="keyword">float64</span> <span class="string">`json:"weight"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过一个配置文件，可以生成一个不accept但listen的负载均衡实例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化负载均衡实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLoadBalancerOnConfig</span><span class="params">(configPath <span class="keyword">string</span>)</span> <span class="params">(*loadBalancer, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// load config</span></span><br><span class="line">    lb, err := initLoadBalancer(configPath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// listen but not accept</span></span><br><span class="line">    addr := fmt.Sprintf(<span class="string">"0.0.0.0:%d"</span>, lb.Port)</span><br><span class="line">    server, err := net.Listen(network, addr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lb, err</span><br><span class="line">    &#125;</span><br><span class="line">    lb.Listener = server</span><br><span class="line">    log.Printf(<span class="string">"Load balancer is ready at %s...\n"</span>, addr)</span><br><span class="line">    <span class="keyword">go</span> lb.healthCheck()</span><br><span class="line">    <span class="keyword">return</span> lb, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中注意到，启动实例后，会直接开启健康检查任务，这样就能实现上游服务信息的初始化，让我们一开始就能够了解哪些上游服务可用（active）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 健康检查——轮询每个服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lb *loadBalancer)</span> <span class="title">healthCheck</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">        wg.Add(<span class="built_in">len</span>(lb.ServerMap))</span><br><span class="line">        <span class="keyword">for</span> id, server := <span class="keyword">range</span> lb.ServerMap &#123;</span><br><span class="line">            tmpID := id</span><br><span class="line">            tmpServer := server</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">defer</span> wg.Done()</span><br><span class="line">                addr := tmpServer.GetAddr()</span><br><span class="line">                conn, err := net.DialTimeout(network, addr, dialTimeout)</span><br><span class="line">                mtx.Lock()</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    log.Printf(<span class="string">"Health check failed at server %d (%s): %s\n"</span>,</span><br><span class="line">                        tmpID, addr, err.Error())</span><br><span class="line">                    lb.setInactive(tmpID)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.Printf(<span class="string">"Health check success at server %d (%s)!"</span>,</span><br><span class="line">                        tmpID, addr)</span><br><span class="line">                    lb.setActive(tmpID)</span><br><span class="line">                    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                        _ = conn.Close()</span><br><span class="line">                    &#125;()</span><br><span class="line">                &#125;</span><br><span class="line">                mtx.Unlock()</span><br><span class="line">            &#125;()</span><br><span class="line">        &#125;</span><br><span class="line">        wg.Wait()</span><br><span class="line">        time.Sleep(healthCheckInterval)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后，用户需要调用<code>Run()</code>，才能真正接受外界连接。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启动负载均衡服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lb *loadBalancer)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := lb.Listener.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">"Error while closing load balancer! %s\n"</span>, err.Error())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    log.Printf(<span class="string">"Load balancer will be launched after 3 seconds..."</span>)</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">var</span> clientID <span class="keyword">uint</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := lb.Listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">"Error while accepting connection! %s\n"</span>, err.Error())</span><br><span class="line">        &#125;</span><br><span class="line">        clientID++</span><br><span class="line">        <span class="keyword">go</span> handler(conn, clientID, lb)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在每一个连接的handler中，会新增一个转发器forwarder，采取最少连接数策略连接上游服务，在程序中是选中权重最低的，尽可能active的那一个。由于“连接”是一个阻塞操作，因此我们乐观地认为所有连接都趋向于成功，在连接之前增加权重：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理客户端连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(conn net.Conn, clientID <span class="keyword">uint</span>, lb *loadBalancer)</span></span> &#123;</span><br><span class="line">    addrString := getAddrString(conn)</span><br><span class="line">    <span class="comment">// allocate a server for forwarding data</span></span><br><span class="line">    <span class="keyword">var</span> forwarder net.Conn</span><br><span class="line">    mtx.Lock()</span><br><span class="line">    serverID := lb.SelectServerID()</span><br><span class="line">    serverAddr := lb.ServerMap[serverID].GetAddr()</span><br><span class="line">    lb.weighConnect(serverID)</span><br><span class="line">    mtx.Unlock()</span><br><span class="line">    <span class="comment">// 以下略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果连接成功则保持，连接失败则减去权重。成功后，通过forward方法，把用户连接的数据转发给相应的服务，并且也会把服务器write的数据转发给用户：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转发客户端数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forward</span><span class="params">(conn net.Conn, forwarder net.Conn, clientID <span class="keyword">uint</span>, serverID <span class="keyword">uint</span>, lb *loadBalancer)</span></span> &#123;</span><br><span class="line">    clientAddr := getAddrString(conn)</span><br><span class="line">    serverAddr := lb.ServerMap[serverID].GetAddr()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log.Printf(<span class="string">"[%d] %s disconnected from %s\n"</span>,</span><br><span class="line">            clientID, clientAddr, serverAddr)</span><br><span class="line">        mtx.Lock()</span><br><span class="line">        lb.weighDisconnect(serverID)</span><br><span class="line">        mtx.Unlock()</span><br><span class="line">        lb.PrintServers()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> errCode <span class="keyword">int32</span> = <span class="number">0</span></span><br><span class="line">    callback := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        _ = conn.Close()</span><br><span class="line">        _ = forwarder.Close()</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="comment">// request</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> callback()</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">make</span>([]<span class="keyword">byte</span>, bufferSize)</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            n, readErr := conn.Read(b)</span><br><span class="line">            <span class="keyword">if</span> readErr != <span class="literal">nil</span> &#123;</span><br><span class="line">                atomic.CompareAndSwapInt32(&amp;errCode, <span class="number">0</span>, ReadC2FError)</span><br><span class="line">                log.Printf(<span class="string">"[%d] Read c2f error from %s: %s"</span>,</span><br><span class="line">                    clientID, clientAddr, readErr.Error())</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            _, writeErr := forwarder.Write(b[:n])</span><br><span class="line">            <span class="keyword">if</span> writeErr != <span class="literal">nil</span> &#123;</span><br><span class="line">                atomic.CompareAndSwapInt32(&amp;errCode, <span class="number">0</span>, WriteF2SError)</span><br><span class="line">                log.Printf(<span class="string">"[%d] Write f2s error to %s: %s"</span>,</span><br><span class="line">                    clientID, serverAddr, writeErr.Error())</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// response</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> callback()</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">make</span>([]<span class="keyword">byte</span>, bufferSize)</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            n, readErr := forwarder.Read(b)</span><br><span class="line">            <span class="keyword">if</span> readErr != <span class="literal">nil</span> &#123;</span><br><span class="line">                atomic.CompareAndSwapInt32(&amp;errCode, <span class="number">0</span>, ReadS2FError)</span><br><span class="line">                log.Printf(<span class="string">"[%d] Read s2f error from %s: %s"</span>,</span><br><span class="line">                    clientID, serverAddr, readErr.Error())</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            _, writeErr := conn.Write(b[:n])</span><br><span class="line">            <span class="keyword">if</span> writeErr != <span class="literal">nil</span> &#123;</span><br><span class="line">                atomic.CompareAndSwapInt32(&amp;errCode, <span class="number">0</span>, WriteF2CError)</span><br><span class="line">                log.Printf(<span class="string">"[%d] Write f2c error to %s: %s"</span>,</span><br><span class="line">                    clientID, clientAddr, writeErr.Error())</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Printf(<span class="string">"[%d] Closed on signal: %d\n"</span>, clientID, errCode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，一个简易的负载均衡就完成了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述的负载均衡还存在许多问题，从语言上来讲，比如：</p>
<ul>
<li>并行/并发锁粒度太大</li>
<li>可以用一些相对封装较好的实例，如net.Dialer</li>
<li>可以利用golang自带channel、context等机制</li>
</ul>
<p>而从业务上来讲，模块耦合较多，扩展性会差一点。并且真正完备的负载均衡设施，还需要考虑很复杂的功能，这些都需要一个个模块好好设计来实现的。</p>
<p>不论是语言层面还是业务层面都有很多的提升空间。加油吧~</p>
]]></content>
      <categories>
        <category>从零单排Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>net包</tag>
        <tag>tcp</tag>
        <tag>负载均衡</tag>
        <tag>数据转发</tag>
      </tags>
  </entry>
  <entry>
    <title>【GitHub探索】v语言上手，用vlang写一个聊天应用</title>
    <url>/2019/11/16/githubdiscovery/vlang/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>vlang（v语言）自从6月份突然炒热起来，不知不觉到了11月，正式版就要出来了，在11月的GitHub Trending榜中依然排在前10。这着实令人好奇，因此笔者决定试用一下vlang，写一个小应用，体验一下感受。</p>
<h2 id="v语言上手"><a href="#v语言上手" class="headerlink" title="v语言上手"></a>v语言上手</h2><p>v语言可以在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ZsYW5nL3Y=" title="https://github.com/vlang/v">GitHub传送门<i class="fa fa-external-link"></i></span>中clone下载，支持多操作系统，有以下的特性：</p>
<ul>
<li>快速编译</li>
<li>快速转译</li>
<li>热更</li>
</ul>
<p>其余的，还有自带的GUI库、结合Go与Rust的语言特性之类，也可以算作所谓的卖点。</p>
<p>安装v语言也很简单，比如在windows上，首先需要安装Visual Studio提供的MSVC环境，然后只需要：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/vlang/v.git</span><br></pre></td></tr></table></figure>
<p>然后执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./make.bat</span><br></pre></td></tr></table></figure>
<p>再设置环境变量到PATH，就能够随时随地执行vlang了。</p>
<a id="more"></a>
<p>如果要更新vlang，则只需要：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">v up</span><br></pre></td></tr></table></figure>
<p>就可以自动更新并编译了。</p>
<h2 id="写一个聊天应用"><a href="#写一个聊天应用" class="headerlink" title="写一个聊天应用"></a>写一个聊天应用</h2><p>为了试用vlang，笔者简单写了个聊天应用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9zaGluZ2VraW5vdg==" title="https://github.com/utmhikari/shingekinov">shingekinov<i class="fa fa-external-link"></i></span>，设计上暂时用了全局锁而非消息队列，然后也顺带把vlang的自带网络库熟悉了一下。</p>
<p>vlang并没有全局变量的说法，因此需要通过在main函数里保管指针启动实例。对于一个简单的聊天服务器实例可以如下设计：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Server</span></span> &#123;</span><br><span class="line">    instance net.Socket</span><br><span class="line"><span class="keyword">mut</span>:</span><br><span class="line">    clients map[string]net.Socket</span><br><span class="line">    pairs map[string]string</span><br><span class="line">    mtx sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>clients</code>存储客户端socket，而<code>pairs</code>存储聊天的一对。每一个客户端连接都采用<code>go</code>关键字（orz）创建一个单独的线程进行handle。要注册客户或者处理消息时，则上全局锁。全局锁lock方法会自动等待，所以暂时不会造成死锁。handle方法如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">handle</span></span>(s net.Socket, server <span class="keyword">mut</span> Server) &#123;</span><br><span class="line">    fdint := s.sockfd</span><br><span class="line">    fd := fdint.<span class="built_in">str</span>()</span><br><span class="line">    logger.info('$fd connected!!!')</span><br><span class="line">    s.write('$fd: Welcome to ShinGeKiNoV Chat Platform~')</span><br><span class="line">    server.mtx.lock()</span><br><span class="line">    server.register(fd, s)</span><br><span class="line">    server.mtx.unlock()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        msg := s.read_line().replace('\r\n', '').replace(<span class="string">'\n'</span>, '')</span><br><span class="line">        <span class="keyword">if</span> msg.len &gt; <span class="number">0</span> &#123;</span><br><span class="line">            logger.info(<span class="symbol">'Received</span> message size $&#123;msg.len&#125; from $fd: $msg')</span><br><span class="line">        &#125;</span><br><span class="line">        server.mtx.lock()</span><br><span class="line">        <span class="keyword">if</span> server.is_chatting(fd) &#123;</span><br><span class="line">            <span class="keyword">match</span> msg &#123;</span><br><span class="line">                '' &#123;</span><br><span class="line">                    logger.warn('$fd itself disconnected...')</span><br><span class="line">                    server.leave_chat(fd)</span><br><span class="line">                    server.unregister(fd)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="symbol">'exit</span>' &#123;</span><br><span class="line">                    logger.warn('$fd is going to leave chat...')</span><br><span class="line">                    server.leave_chat(fd)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    server.handle_chat(fd, msg)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> msg &#123;</span><br><span class="line">                '' &#123;</span><br><span class="line">                    logger.warn('$fd itself disconnected...')</span><br><span class="line">                    server.leave_chat(fd)</span><br><span class="line">                    server.unregister(fd)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="symbol">'exit</span>' &#123;</span><br><span class="line">                    logger.warn('$fd is requesting to disconnect...')</span><br><span class="line">                    s.write(<span class="symbol">'Disconnecting</span>...')</span><br><span class="line">                    server.leave_chat(fd)</span><br><span class="line">                    server.unregister(fd)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="symbol">'help</span>' &#123;</span><br><span class="line">                    s.write(server.help())</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="symbol">'list</span>' &#123;</span><br><span class="line">                    s.write(server.list())</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="symbol">'chat</span>' &#123;</span><br><span class="line">                    server.join_chat(fd)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    s.write(<span class="symbol">'Invalid</span> command: $msg! Type <span class="string">"help"</span> <span class="keyword">for</span> options~')</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        server.mtx.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，在做这个简单聊天服务器的同时，笔者也发现vlang当前的版本虽然看似功能非常多，但是每一个功能都还是非常稚嫩，可以说是挖了一个很大的坑。比如当前版本的map采用普通二叉树存储key（orz），并且在insert与delete上都是有bug的；再比如socket客户端断开时，没有EOF的支持…v语言，也成为了笔者码代码以来第一个需要改标准库源码才能运行成功的编程语言（orz）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>v语言，首先是库的支持，还是太笼统了，离真正可用还差一段距离，并且没有完善GC的支持，在线上环境这一part是很致命的。</p>
<p>按v语言的特性来看，算是一种“翻译语言”，可以翻译为C语言，似乎也能翻译成javascript，因此挺适合做热更的需求，对于游戏开发似乎很有用喔。</p>
<p>总的来讲，这些细节还是得慢慢磨，期待后续吧~</p>
]]></content>
      <categories>
        <category>GitHub探索</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>v语言</tag>
        <tag>聊天服务器</tag>
        <tag>翻译语言</tag>
        <tag>shingekinov</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】游戏业务用例测试体验感悟</title>
    <url>/2019/11/03/testlife/start_game_test/</url>
    <content><![CDATA[<p>近期稍微停歇了下开发的任务，转为进入游戏项目组去探究真正的游戏测试业务是如何进行。在此前做测试工具与平台时会常常遇到业务需求不能准确击中的瓶颈，因此真实投入体验，调研项目组的测试痛点，能够对后续的技术支持工作大有裨益。</p>
<p>游戏，尤其是网游，是一类非常特殊的软件产品，可能会有以下的特点：</p>
<ul>
<li>服务端与客户端强耦合</li>
<li>各个系统模块间存在复杂的联系，业务复杂度相对于一般的产品高</li>
<li>单体状态的变化，可能影响到多个实体的状态及属性</li>
<li>策划配表数值变动多，迭代频率高</li>
<li>游戏的新功能特性研发，需要牵扯到很多原有的设定</li>
<li>etc…</li>
</ul>
<p>简而言之，游戏是一个高内聚、体量较大、变化需求多的软件系统，因此游戏业务测试本身就是不小的挑战。</p>
<p>项目组现处于刚上线的阶段，主要业务是外网缺陷修复的验收以及新功能的测试及回归。其中，新功能的回归测试在笔者认为是更为艰巨的任务。我们首先可以看一下一个基本的测试用例是怎样的:</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用例 = 前置条件（在X条件下） + 操作（执行Y） + 预期结果（每个关联实体的状态变化）</span><br></pre></td></tr></table></figure>
<p>在回归测试里，不说关联实体的数量，单说前置条件，一方面由于新功能关联的旧模块可能较多，这样就导致前置条件的可能性也会很多，排列组合后呈指数级增长；另一方面在实际游戏体验中，达成前置条件所需要的步骤也较繁琐。针对这两个问题，最稳妥的的解决方案是：</p>
<ul>
<li>测试方式：最稳妥的是黑盒测试。黑盒测试能够直接观察客户端与服务端的表现，并且当下也只有人类能够判断哪些表现属于缺陷（某些细节要考虑到策划的设定）。AI跑游戏即使可能实现，但也不能直接与测试业务交互；UI自动化能够保证操作的成功，但难以观测操作所产生的对其它实体的影响是否正确。</li>
<li>用例设计：先设计出所有可能的用例单元，再在实际游戏中进行覆盖。一次正常的游戏流程中，尽可能过滤掉那些现实游戏运行中难以发生的状态变化，并且尽可能覆盖不同分支的用例单元，从而真实提升</li>
<li>GM指令：通常是客户端发给服务端的快速达成某些条件的指令，比如一键99级、改系统时间那种。熟悉GM指令与游戏设计，能够显著提升测试效率。</li>
</ul>
<p>因此脑海中衍生了以下的技术支撑思路：</p>
<ul>
<li>上游&amp;资源管理：在实际测试中最怕遇到协议对不上、配表对不上之类的外在问题，因此需要一套稳定的上游&amp;资源管理机制，提供稳定的测试环境，并监控资源与代码的变更。</li>
<li>用例工具：通常业务测试中用例设计会分模块，采用思维导图软件划分支。但这是有局限性的，如果有一个巨大的图能够表现整个游戏系统，能够对功能用例的设计组合起到更好的指导作用。因此针对游戏的用例设计&amp;管理工具，也是长线调研的方向。</li>
</ul>
<p>诸多想法都也只是萌芽，希望后面继续深入的话，能发掘更多的东西吧~</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>游戏测试</tag>
        <tag>测试</tag>
        <tag>业务测试</tag>
        <tag>用例设计</tag>
        <tag>回归测试</tag>
      </tags>
  </entry>
  <entry>
    <title>【DIY小记】解决技嘉Z390 AORUS PRO不识别SSD/机械硬盘的问题</title>
    <url>/2019/10/29/diymemo/gigabyte_z390/</url>
    <content><![CDATA[<p>笔者近期用技嘉（GIGABYTE）Z390装机时遇到了装上一个SSD跟一个机械硬盘后，机械硬盘无法被主板/操作系统识别的问题，经过一番研究后发现了解决方案，特地分享：</p>
<p>首先本经验理论上应当适用于不同厂家的Z390主板上（比如华硕之类）</p>
<p>SSD或机械硬盘无法识别可能是主板芯片共享频宽的问题。以技嘉为例，我们首先需要知道SSD或机械硬盘插在了哪里，以及硬盘有哪些接口。在技嘉Z390上，有以下的硬盘接口：</p>
<ul>
<li>M.2（M2A/M2M）</li>
<li>SATA</li>
</ul>
<p>在说明书中应当会有这些插口所插到的位置图示。</p>
<p>如果不了解硬盘原来插到了哪个接口，可以开机进入BIOS，BIOS中也会显示这些接口插了哪些硬盘。如果插过的硬盘没显示，那就是没识别到了。</p>
<p>接下来也得翻说明书找硬盘接口相关的内容，以技嘉Z390为例，在说明书的<code>插座及跳线介绍——M.2及SATA插座安装注意事项</code>中，会有<strong>表格及文字</strong>显示M.2的哪个接口安装了哪种SSD，会与哪个SATA接口共享频宽，从而不兼容。借助这个表格找到兼容的接口，把原先插在SATA的硬盘换一个兼容号码的插座，就好了。技嘉的话，SATA插到3、4号（中间两个），是没问题的。</p>
]]></content>
      <categories>
        <category>DIY小记</category>
      </categories>
      <tags>
        <tag>主板</tag>
        <tag>Z390</tag>
        <tag>技嘉</tag>
        <tag>装机</tag>
        <tag>BIOS</tag>
      </tags>
  </entry>
  <entry>
    <title>【Lua杂谈】服务端架构skynet简易入门项目——create-skynet</title>
    <url>/2019/10/26/luatalk/create_skynet/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="https://utmhikari.github.io/2019/10/20/luatalk/skynet/">skynet通信原理与源码分析</a>一文中，我们已经详尽地弄清楚了<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3Vkd3Uvc2t5bmV0" title="https://github.com/cloudwu/skynet">skynet<i class="fa fa-external-link"></i></span>地通信架构，为我们上手skynet提供了极大的帮助。因此本篇文章接续上文，正式上手使用skynet。</p>
<h2 id="skynet入门项目：create-skynet"><a href="#skynet入门项目：create-skynet" class="headerlink" title="skynet入门项目：create-skynet"></a>skynet入门项目：create-skynet</h2><p>要做一个基于skynet的项目，首先需要一个好的模板。skynet的最佳实践并非将服务卸载skynet模块中，而是将skynet当作一个单独的库/SDK看待，自己独立在另外的目录写业务逻辑。因此，笔者在数月前简单地整合了一下skynet的boilerplate项目——<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9jcmVhdGUtc2t5bmV0" title="https://github.com/utmhikari/create-skynet">create-skynet<i class="fa fa-external-link"></i></span>，采用这个项目搭建skynet服务端结构会较为清晰。</p>
<h3 id="服务-amp-库的约定"><a href="#服务-amp-库的约定" class="headerlink" title="服务&amp;库的约定"></a>服务&amp;库的约定</h3><p>在create-skynet的配置中，每个服务的lua文件入口以config中<code>luaservice</code>项为准：</p>
<ul>
<li>service/服务名.lua</li>
<li>service/服务名/main.lua</li>
<li>skynet/service/服务名.lua（默认的服务）</li>
</ul>
<p>skynet启动时会根据服务名注册相应服务，因此自己在service下定义的服务名最好不要与skynet原有服务重名。</p>
<p>skynet在为每一个服务读取lua库的时候，会根据运行skynet脚本的工作目录以及config里的设置去读取，这是由config的<code>lua_path</code>与<code>lua_cpath</code>为准的。在create-skynet里，lualib的位置有：</p>
<a id="more"></a>
<ul>
<li>service/服务名/?.lua</li>
<li>lualib/?.lua</li>
<li>luaclib/?.so</li>
<li>skynet/lualib/?.lua（默认）</li>
<li>skynet/luaclib/?.so（默认）</li>
</ul>
<p>因此后续在服务逻辑中require时，需要注意lualib文件所在的位置。</p>
<p>skynet更多具体的config设置，可参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3Vkd3Uvc2t5bmV0L3dpa2kvQ29uZmln" title="https://github.com/cloudwu/skynet/wiki/Config">官方wiki<i class="fa fa-external-link"></i></span></p>
<h3 id="启动skynet服务"><a href="#启动skynet服务" class="headerlink" title="启动skynet服务"></a>启动skynet服务</h3><p>create-skynet实现了skynet最简单的sproto服务的例子。如果您对sproto不了解，可以参阅笔者的<a href="https://utmhikari.github.io/2019/09/12/luatalk/sproto/">lua专用rpc协议sproto</a>一文。</p>
<p>在create-skynet里，config的start项指定了初始的服务入口——<code>main</code>，因此我们只需在<code>service/main.lua</code>里写内容，skynet就会自动读到。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- service/main.lua</span></span><br><span class="line"><span class="keyword">local</span> skynet = <span class="built_in">require</span> <span class="string">"skynet"</span></span><br><span class="line"></span><br><span class="line">skynet.start(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    skynet.<span class="built_in">error</span>(<span class="string">"create-skynet start server~"</span>)</span><br><span class="line">    skynet.uniqueservice(<span class="string">"proto"</span>)</span><br><span class="line">    <span class="keyword">local</span> debug_console_port = skynet.<span class="built_in">getenv</span>(<span class="string">"debug_console_port"</span>)</span><br><span class="line">    <span class="keyword">if</span> debug_console_port <span class="keyword">then</span></span><br><span class="line">        skynet.newservice(<span class="string">"debug_console"</span>, debug_console_port)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    skynet.newservice(<span class="string">"db"</span>)</span><br><span class="line">    <span class="keyword">local</span> watchdog = skynet.newservice(<span class="string">"watchdog"</span>)</span><br><span class="line">    <span class="keyword">local</span> watchdog_port = skynet.<span class="built_in">getenv</span>(<span class="string">"watchdog_port"</span>)</span><br><span class="line">    skynet.call(watchdog, <span class="string">"lua"</span>, <span class="string">"start"</span>, &#123;</span><br><span class="line">        port = watchdog_port,</span><br><span class="line">        nodelay = <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    skynet.<span class="built_in">error</span>(<span class="string">"Watchdog listening on"</span>, watchdog_port)</span><br><span class="line">    skynet.<span class="built_in">exit</span>()</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>在主入口<code>service/main.lua</code>中，通过<code>skynet.start(callback)</code>的形式，就可以定义该服务启动时的逻辑。首先启动了协议服务<code>proto</code>；其次通过<code>skynet.getenv</code>读取<code>debug_console_port</code>配置项，如果有则启动skynet内置<code>debug_console</code>服务；而后启动<code>db</code>服务，是一个意思意思的内存kv数据库；之后启动<code>watchdog</code>，监听配置的<code>watchdog_port</code>所对应的端口。</p>
<p>我们可以通过解构<code>watchdog</code>服务，从而了解skynet服务的基本样式。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- service/watchdog/main.lua</span></span><br><span class="line"><span class="keyword">local</span> skynet = <span class="built_in">require</span> <span class="string">"skynet"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> CMD = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> SOCKET = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> gate</span><br><span class="line"><span class="keyword">local</span> agent = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SOCKET.open</span><span class="params">(fd, addr)</span></span></span><br><span class="line">    skynet.<span class="built_in">error</span>(<span class="string">"New client from : "</span> .. addr)</span><br><span class="line">    agent[fd] = skynet.newservice(<span class="string">"agent"</span>)</span><br><span class="line">    skynet.call(agent[fd], <span class="string">"lua"</span>, <span class="string">"start"</span>, &#123;</span><br><span class="line">        gate = gate, client = fd, watchdog = skynet.self()</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">close_agent</span><span class="params">(fd)</span></span></span><br><span class="line">    <span class="keyword">local</span> a = agent[fd]</span><br><span class="line">    agent[fd] = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> a <span class="keyword">then</span></span><br><span class="line">        skynet.call(gate, <span class="string">"lua"</span>, <span class="string">"kick"</span>, fd)</span><br><span class="line">        <span class="comment">-- disconnect never return</span></span><br><span class="line">        skynet.send(a, <span class="string">"lua"</span>, <span class="string">"disconnect"</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SOCKET.close</span><span class="params">(fd)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"socket close"</span>,fd)</span><br><span class="line">    close_agent(fd)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SOCKET.error</span><span class="params">(fd, msg)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"socket error"</span>,fd, msg)</span><br><span class="line">    close_agent(fd)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SOCKET.warning</span><span class="params">(fd, size)</span></span></span><br><span class="line">    <span class="comment">-- size K bytes havn't send out in fd</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"socket warning"</span>, fd, size)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SOCKET.data</span><span class="params">(fd, msg)</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CMD.start</span><span class="params">(conf)</span></span></span><br><span class="line">    skynet.call(gate, <span class="string">"lua"</span>, <span class="string">"open"</span> , conf)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CMD.close</span><span class="params">(fd)</span></span></span><br><span class="line">    close_agent(fd)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">skynet.start(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    skynet.dispatch(<span class="string">"lua"</span>, <span class="function"><span class="keyword">function</span><span class="params">(session, source, cmd, subcmd, ...)</span></span></span><br><span class="line">        <span class="keyword">if</span> cmd == <span class="string">"socket"</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> f = SOCKET[subcmd]</span><br><span class="line">            f(...)</span><br><span class="line">            <span class="comment">-- socket api don't need return</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">local</span> f = <span class="built_in">assert</span>(CMD[cmd])</span><br><span class="line">            skynet.ret(skynet.pack(f(subcmd, ...)))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">    gate = skynet.newservice(<span class="string">"gate"</span>)</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>在<code>watchdog</code>服务主入口的代码中，出现了<code>skynet.dispatch</code>，它会为某个类型的消息注册回调函数从而进行处理。如果哪个服务调用了<code>skynet.send/call(watchdog地址, &quot;lua&quot;, ...)</code>，那么<code>watchdog</code>就会拿回调函数跟后边<code>...</code>的参数凑上去，执行业务逻辑了。</p>
<p>在skynet架构中，<code>watchdog</code>与内置的网关服务<code>gate</code>是强耦合的。我们可以看到<code>watchdog</code>在刚启动时也会新增<code>gate</code>服务，然后<code>service/main.lua</code>调用<code>skynet.call(watchdog, &quot;lua&quot;, &quot;start&quot;, 配置)</code>时，<code>watchdog</code>主入口中对应的<code>CMD.start</code>就会被执行，然后在<code>gate</code>调用的<code>gateserver.lua</code>中，<code>CMD.open</code>的开启端口监听的逻辑被执行了。之后，如果有新的连接，<code>gate</code>会通知<code>watchdog</code>新连接的fd跟地址，并且而<code>watchdog</code>只需要负责新增<code>agent</code>服务，根据socket的不同情况执行相应回调管理<code>agent</code>就好了。</p>
<p>在<code>agent</code>服务里，只需要根据连接的fd，读取或发送数据就好，网关服务<code>gate</code>会帮你分包。这里<code>agent</code>主入口也采用官方例子中的代码，基本的套路也是一方面不断read这个fd出来的数据，识别sproto，然后调用<code>db</code>服务存取数据；另一方面会隔一段时间向fd写入心跳包，实现双工长连接tcp。此处便不再赘述啦~</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>skynet的基本用法便是如此，后面还有很多挖掘点，可以查看wiki等资料深入探索~</p>
]]></content>
      <categories>
        <category>Lua杂谈</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>教程</tag>
        <tag>lua</tag>
        <tag>skynet</tag>
        <tag>create-skynet</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】electron+react+antd深色主题打造桌面应用</title>
    <url>/2019/10/20/geekdaily/electron_react/</url>
    <content><![CDATA[<p>桌面应用的实现方式有很多，但谈到多操作系统平台兼容的话，就不得不提到<span class="exturl" data-url="aHR0cHM6Ly9lbGVjdHJvbmpzLm9yZy8=" title="https://electronjs.org/">electron<i class="fa fa-external-link"></i></span>。electron是前端开发的利好，做过web前端的同学只要稍微迁移下自己的项目，就能够将原本的web前端变成桌面应用。</p>
<p>因此，本文以react为例，以antd为UI库支持，讲解基于react的electron应用该如何搭建。</p>
<p>首先，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uLXJlYWN0LWJvaWxlcnBsYXRlL2VsZWN0cm9uLXJlYWN0LWJvaWxlcnBsYXRl" title="https://github.com/electron-react-boilerplate/electron-react-boilerplate">electron-react-boilerplate<i class="fa fa-external-link"></i></span>项目，就帮助我们初始化了基于react的electron应用。electron-react-boilerplate内置了flow静态类型检查机制、基于webpack的electron应用打包支持以及with redux的前端架构。故在此基础上再引入其它的lib，也不会过于困难。本文采用的electron-react-boilerplate版本为0.17.1。</p>
<p>通过<code>yarn add antd</code>，就可以安装上antd库。要在内置的例子里以antd为layout的话，首先需要在<code>app</code>文件夹下新建<code>app.global.less</code>文件，填充内容：<code>@import &#39;../node_modules/antd/dist/antd.less&#39;;</code>，然后我们可以再观察到，<code>app/containers/Root.js</code>是redux store的抽象层，wrap了路由；路由所在的文件为<code>app/Route.js</code>，是以<code>&lt;App&gt;</code>标签为根的路由集合；<code>&lt;App&gt;</code>主界面所在的文件为<code>app/containers/App.js</code>，我们通过更改其中的内容，就可以变换主界面的样式了。我们就以antd的layout为例，写一个App主界面：</p>
<a id="more"></a>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Layout, Card, Icon, Menu, Button &#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; shell &#125; <span class="keyword">from</span> <span class="string">'electron'</span>;</span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">'../constants/routes'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; Sider, Content &#125; = Layout;</span><br><span class="line"></span><br><span class="line">type Props = &#123;</span><br><span class="line">  children: React.Node</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type State = &#123;</span><br><span class="line">  menuKey: string</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> menuList = [</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="string">'note'</span>, <span class="attr">text</span>: <span class="string">'笔记'</span>, <span class="attr">icon</span>: <span class="string">'book'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="string">'setting'</span>, <span class="attr">text</span>: <span class="string">'设置'</span>, <span class="attr">icon</span>: <span class="string">'setting'</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">Props</span>, <span class="title">State</span>&gt; </span>&#123;</span><br><span class="line">  props: Props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    history: PropTypes.object.isRequired</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line">    menuKey: <span class="string">'note'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  handleMenuClick = <span class="function">(<span class="params">e: Event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">menuKey</span>: e.key &#125;);</span><br><span class="line">    <span class="keyword">const</span> &#123; history &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    history.push(routes[e.key]);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; children &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> &#123; menuKey &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Layout style=&#123;&#123; <span class="attr">minHeight</span>: <span class="string">'100vh'</span> &#125;&#125;&gt;</span><br><span class="line">        &lt;Sider collapsible=&#123;<span class="literal">false</span>&#125;&gt;</span><br><span class="line">          &lt;Menu</span><br><span class="line">            style=&#123;&#123; <span class="attr">height</span>: <span class="string">'100%'</span> &#125;&#125;</span><br><span class="line">            theme=<span class="string">"dark"</span></span><br><span class="line">            onClick=&#123;<span class="keyword">this</span>.handleMenuClick&#125;</span><br><span class="line">            selectedKeys=&#123;[menuKey]&#125;</span><br><span class="line">            mode=<span class="string">"inline"</span></span><br><span class="line">          &gt;</span><br><span class="line">            &#123;menuList.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">              &lt;Menu.Item key=&#123;item.key&#125;&gt;</span><br><span class="line">                &lt;span&gt;</span><br><span class="line">                  &lt;Icon type=&#123;item.icon&#125; /&gt;</span><br><span class="line">                  &#123;<span class="string">`\t<span class="subst">$&#123;item.text&#125;</span>`</span>&#125;</span><br><span class="line">                &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">              &lt;/</span>Menu.Item&gt;</span><br><span class="line">            ))&#125;</span><br><span class="line">          &lt;<span class="regexp">/Menu&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Sider&gt;</span><br><span class="line">        &lt;Content&gt;</span><br><span class="line">          &lt;Card</span><br><span class="line">            title=&#123;menuList.find(<span class="function"><span class="params">i</span> =&gt;</span> i.key === menuKey).text&#125;</span><br><span class="line">            style=&#123;&#123; <span class="attr">height</span>: <span class="string">'100%'</span> &#125;&#125;</span><br><span class="line">            extra=&#123;</span><br><span class="line">              &lt;Button</span><br><span class="line">                shape=<span class="string">"circle"</span></span><br><span class="line">                onClick=&#123;() =&gt;shell.openExternal(<span class="string">'https://github.com'</span>)&#125;</span><br><span class="line">                icon=<span class="string">"github"</span></span><br><span class="line">              /&gt;</span><br><span class="line">            &#125;</span><br><span class="line">          &gt;</span><br><span class="line">            &#123;children&#125;</span><br><span class="line">          &lt;<span class="regexp">/Card&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Content&gt;</span><br><span class="line">      &lt;<span class="regexp">/Layout&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default withRouter(App);</span></span><br></pre></td></tr></table></figure>
<p>写App主界面后，记得也得实时更新<code>app/Route.js</code>以及其关联的<code>app/constants/routes.json</code>数据喔~</p>
<p>在<code>app/containers</code>中其它以<code>Page</code>结尾的文件，约定俗成是各个子路由绑定redux的层次。比如在上面我们设置了笔记的menu，那么在<code>app/containers/NotePage.js</code>中，就可以定义跟redux的绑定：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> Note <span class="keyword">from</span> <span class="string">'../components/note/index'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> NoteActions <span class="keyword">from</span> <span class="string">'../actions/note'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; ...state.note &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bindActionCreators(NoteActions, dispatch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(Note);</span><br></pre></td></tr></table></figure>
<p>之后在<code>app/components/note/index.js</code>中，就可以编写笔记页面的样式了。</p>
<p>至于redux这块，由于flow增加了静态检查，因此会稍微麻烦一点。虽然在<code>app/reducers/index.js</code>中已经帮我们完成了reducer的绑定，但在<code>app/reducers/types.js</code>中，还需要初始化各个state的类型：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> type &#123; Dispatch <span class="keyword">as</span> ReduxDispatch, Store <span class="keyword">as</span> ReduxStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// action</span></span><br><span class="line"><span class="keyword">export</span> type Action = &#123;</span><br><span class="line">  +type: string</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// note state</span></span><br><span class="line"><span class="keyword">export</span> type NoteState = &#123;</span><br><span class="line">  notes: <span class="built_in">Array</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// state type</span></span><br><span class="line"><span class="keyword">export</span> type StateType = &#123;</span><br><span class="line">  note: NoteState</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type GetState = <span class="function"><span class="params">()</span> =&gt;</span> StateType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type Dispatch = ReduxDispatch&lt;Action&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type Store = ReduxStore&lt;GetState, Action&gt;;</span><br></pre></td></tr></table></figure>
<p>之后根据预定义的类型，再写action跟reducer。拿note笔记模块为例，action跟reducer如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app/actions/note.js</span></span><br><span class="line"><span class="keyword">import</span> type &#123; Dispatch &#125; <span class="keyword">from</span> <span class="string">'../reducers/types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch: Dispatch</span>) =&gt;</span> dispatch(&#123; <span class="attr">type</span>: <span class="string">'ADD_NOTE'</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">edit</span>(<span class="params">index: number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch: Dispatch</span>) =&gt;</span> dispatch(&#123; <span class="attr">type</span>: <span class="string">'EDIT_NOTE'</span>, index &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch: Dispatch</span>) =&gt;</span> dispatch(&#123; <span class="attr">type</span>: <span class="string">'REMOVE_NOTE'</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch: Dispatch</span>) =&gt;</span> dispatch(&#123; <span class="attr">type</span>: <span class="string">'CLEAR_NOTE'</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app/reducers/note.js</span></span><br><span class="line"><span class="keyword">import</span> type &#123; Action, NoteState &#125; <span class="keyword">from</span> <span class="string">'./types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultState: NoteState = &#123;</span><br><span class="line">  notes: []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addNote = <span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">  ...state,</span><br><span class="line">  notes: [...state.notes, state.notes.length + <span class="number">1</span>]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> editNote = <span class="function">(<span class="params">state, payload</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; notes &#125; = state;</span><br><span class="line">  <span class="keyword">const</span> &#123; index &#125; = payload;</span><br><span class="line">  <span class="built_in">console</span>.log(payload);</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= notes.length || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> newNotes = [...notes];</span><br><span class="line">  newNotes[index] *= <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123; ...state, <span class="attr">notes</span>: newNotes &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> removeNote = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; notes &#125; = state;</span><br><span class="line">  <span class="keyword">if</span> (notes.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> newNotes = [...notes];</span><br><span class="line">  newNotes.splice(newNotes.length - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123; ...state, <span class="attr">notes</span>: newNotes &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clearNote = <span class="function"><span class="params">state</span> =&gt;</span> (&#123; ...state, <span class="attr">notes</span>: [] &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">note</span>(<span class="params">state: NoteState = defaultState, action: Action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, ...payload &#125; = action;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD_NOTE'</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> addNote(state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'EDIT_NOTE'</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> editNote(state, payload);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'REMOVE_NOTE'</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> removeNote(state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'CLEAR_NOTE'</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> clearNote(state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样便初始化好了基本的笔记增删改查操作，整个桌面应用就有雏形了。</p>
<p>桌面软件一般会有标题与菜单栏，标题的修改是在<code>app/app.html</code>的<code>title</code>标签，而菜单的修改在<code>app/menu.js</code>中。</p>
<p>antd的深色主题在桌面应用中显示会不错，因此我们想要最终产品为深色主题。值得注意的是，由于我们刚开始引入antd新建了less文件，但electron-react-boilerplate默认不支持less，因此需要我们在开发与生产环境的webpack配置中（<code>configs/webpack.config.renderer.dev.babel.js</code>与<code>configs/webpack.config.renderer.prod.babel.js</code>）先将antd的深色主题import进来，然后自行<code>yarn add less-loader</code>，再在配置中的<code>module.rules</code>列表中，追加一段就好：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> antdTheme <span class="keyword">from</span> <span class="string">'@ant-design/dark-theme'</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'style-loader'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'css-loader'</span> <span class="comment">// translates CSS into CommonJS</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'less-loader'</span>, <span class="comment">// compiles Less to CSS</span></span><br><span class="line">      options: &#123;</span><br><span class="line">        modifyVars: antdTheme,</span><br><span class="line">        javascriptEnabled: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这样，electron+react+antd深色主题桌面应用的基础流程就打通了。</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>前端</tag>
        <tag>electron</tag>
        <tag>antd</tag>
        <tag>桌面应用</tag>
      </tags>
  </entry>
  <entry>
    <title>【Lua杂谈】基于lua的服务端架构——skynet通信原理与源码分析</title>
    <url>/2019/10/20/luatalk/skynet/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>提起中国的lua产品，就不得不想到<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3Vkd3Uvc2t5bmV0" title="https://github.com/cloudwu/skynet">skynet<i class="fa fa-external-link"></i></span>，一款针对游戏，但又不仅限于游戏的服务端架构。skynet充分利用了lua的特性，并且在此基础上易扩展HTTP、HTTPS、WebSocket等模块，因此由skynet入手理解lua原理以及服务端架构是一个非常不错的选择。</p>
<p>通过skynet，我们可以构建许多小巧而高性能、高可用的应用。废话不多说，让我们一起来探索skynet架构吧~</p>
<h2 id="skynet通信原理与源码分析"><a href="#skynet通信原理与源码分析" class="headerlink" title="skynet通信原理与源码分析"></a>skynet通信原理与源码分析</h2><p>服务端架构中，不同子服务的通信调度是核心功能。因此，我们以单点（standalone）的skynet实例为例，由外而内，逐步剖析。</p>
<p>要介绍skynet的通信原理，首先要提到lua中的一个概念——lua_State。lua_State是lua的运行时（runtime），是一个原生隔离的、高性能的运行环境，若在多核并行运行lua_State，其性能一定不会差。lua作为嵌入式语言，以C为基础，可以实现操作系统粒度级的lua_State调度，因此skynet也就如同lua_State管理器一样了。</p>
<p>每一种业务可以看作一个service，而每一个service中，都会有一个lua_State充当执行业务逻辑的环境。举个例子，在实际开发当中，比如做一个HTTP服务的话，我们需要自己预先配置好的skynet service主入口lua文件中，写上<code>skynet.uniqueservice(&quot;app&quot;)</code>启动一个独特的名为<code>app</code>的服务，而后在其中的逻辑中，根据每一个HTTP连接，解析其中的数据包。并调用<code>skynet.newservice</code>动态创建单独的上下文服务<code>ctx</code>来处理这个请求。<code>ctx</code>服务还有可能需要查询数据库中的数据，并返回结果，因此我们可能还需要通过<code>skynet.uniqueservice(&quot;db&quot;)</code>预先创建数据库服务<code>db</code>二次封装skynet内置mongo、mysql库的功能，然后再通过<code>skynet.call</code>来与<code>db</code>服务通信，获得<code>db</code>服务某个函数执行的返回结果，再在<code>ctx</code>服务的处理逻辑中写入HTTP Response，从而完成整个处理过程。在这一过程中，具体业务逻辑的处理都会在各个service所拥有的lua_State中运行，但调度通信的逻辑，则就是底层的活了。</p>
<p>因此在skynet底层中，不仅需要支持多个lua_State的运转，而且相对更有挑战性的是，如何让service之间能够相互交流。为了解决这个问题，我们可以看到，在底层中，每一个service都属于<code>snlua</code>类型。<code>snlua</code>除了包括自己的lua_State之外，还维护了一个称之为context的运行状态：</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lua-skynet.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snlua</span> &#123;</span></span><br><span class="line">    lua_State * L;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ctx</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * preload;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skynet_server.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> * instance;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skynet_module</span> * <span class="title">mod</span>;</span></span><br><span class="line">    <span class="keyword">void</span> * cb_ud;</span><br><span class="line">    skynet_cb cb; <span class="comment">// 用于处理每一个消息的回调函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">queue</span>;</span> <span class="comment">// context专属的message_queue</span></span><br><span class="line">    FILE * logfile;</span><br><span class="line">    <span class="keyword">uint64_t</span> cpu_cost; <span class="comment">// in microsec</span></span><br><span class="line">    <span class="keyword">uint64_t</span> cpu_start; <span class="comment">// in microsec</span></span><br><span class="line">    <span class="keyword">char</span> result[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> handle; <span class="comment">// 维护一个handle，可以理解为操作系统的URL</span></span><br><span class="line">    <span class="keyword">int</span> session_id;</span><br><span class="line">    <span class="keyword">int</span> ref;</span><br><span class="line">    <span class="keyword">int</span> message_count;</span><br><span class="line">    <span class="keyword">bool</span> init;</span><br><span class="line">    <span class="keyword">bool</span> endless;</span><br><span class="line">    <span class="keyword">bool</span> profile;</span><br><span class="line"></span><br><span class="line">    CHECKCALLING_DECL</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在lua业务逻辑中执行<code>skynet.newservice</code>或<code>skynet.uniqueservice</code>，skynet框架就会根据服务名称读取对应入口的代码执行。要让这个服务启动，入口文件的代码还需要添加<code>skynet.start</code>函数：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- skynet.lua</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.start</span><span class="params">(start_func)</span></span></span><br><span class="line">    c.callback(skynet.dispatch_message)</span><br><span class="line">    init_thread = skynet.timeout(<span class="number">0</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        skynet.init_service(start_func)</span><br><span class="line">        init_thread = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>可以看到在启动之时，会通过<code>c.callback</code>注册一个回调函数用于分发消息，其逻辑如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lua-skynet.c</span></span><br><span class="line"><span class="comment">// 对应c.callback</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">lcallback(lua_State *L) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">context</span> = <span class="title">lua_touserdata</span>(<span class="title">L</span>, <span class="title">lua_upvalueindex</span>(1));</span></span><br><span class="line">    <span class="keyword">int</span> forward = lua_toboolean(L, <span class="number">2</span>);</span><br><span class="line">    luaL_checktype(L,<span class="number">1</span>,LUA_TFUNCTION);</span><br><span class="line">    lua_settop(L,<span class="number">1</span>);</span><br><span class="line">    lua_rawsetp(L, LUA_REGISTRYINDEX, _cb);</span><br><span class="line">    lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_MAINTHREAD);</span><br><span class="line">    lua_State *gL = lua_tothread(L,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (forward) &#123;</span><br><span class="line">        skynet_callback(context, gL, forward_cb);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        skynet_callback(context, gL, _cb); <span class="comment">// 调用skynet_callback注册回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">forward_cb(struct skynet_context * context, <span class="keyword">void</span> * ud, <span class="keyword">int</span> type, <span class="keyword">int</span> session, <span class="keyword">uint32_t</span> source, <span class="keyword">const</span> <span class="keyword">void</span> * msg, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">    _cb(context, ud, type, session, source, msg, sz);</span><br><span class="line">    <span class="comment">// don't delete msg in forward mode.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_cb(struct skynet_context * context, <span class="keyword">void</span> * ud, <span class="keyword">int</span> type, <span class="keyword">int</span> session, <span class="keyword">uint32_t</span> source, <span class="keyword">const</span> <span class="keyword">void</span> * msg, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">    <span class="comment">// 太长略过，就是在这个snlua service的lua_State上执行逻辑啦</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skynet_server.c</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">skynet_callback(struct skynet_context * context, <span class="keyword">void</span> *ud, skynet_cb cb) &#123;</span><br><span class="line">    context-&gt;cb = cb; <span class="comment">// 注册回调函数</span></span><br><span class="line">    context-&gt;cb_ud = ud;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以我们看到，最终处理消息的逻辑，就会注册到context的cb上。context会维护这个service专属的消息队列<code>message_queue</code>，多个service的消息队列在skynet里就被存放在一个全局唯一的队列<code>global_queue</code>中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_mq.c</span></span><br><span class="line"><span class="comment">// 每个service的context的消息队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> handle; <span class="comment">// 也维护一个handle，通过这个handle，能反过来找到对应的context</span></span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">int</span> release;</span><br><span class="line">    <span class="keyword">int</span> in_global;</span><br><span class="line">    <span class="keyword">int</span> overload;</span><br><span class="line">    <span class="keyword">int</span> overload_threshold;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skynet_message</span> *<span class="title">queue</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">next</span>;</span> <span class="comment">// 全局队列里的下一个</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局队列：双端message_queue队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">global_queue</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在skynet架构启动之际，会根据用户配置创建全局消息队列以外，还会初始化定时器、日志、socket、集群等基础模块及服务。当然在这个过程中，也会创建几个worker：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_start.c</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">skynet_start(struct skynet_config * config) &#123;</span><br><span class="line">    <span class="comment">// 略过上面</span></span><br><span class="line">    skynet_mq_init();</span><br><span class="line">    <span class="comment">// 略过中间</span></span><br><span class="line">    start(config-&gt;thread); <span class="comment">// config中的thread配置项即为worker数</span></span><br><span class="line">    <span class="comment">// 略过下面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">start(<span class="keyword">int</span> thread) &#123;</span><br><span class="line">    <span class="comment">// 略过上面</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> weight[] = &#123;</span><br><span class="line">        <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">        <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, &#125;; <span class="comment">// 每个worker的负载</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">worker_parm</span> <span class="title">wp</span>[<span class="title">thread</span>];</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;thread;i++) &#123;</span><br><span class="line">        wp[i].m = m;</span><br><span class="line">        wp[i].id = i;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="keyword">sizeof</span>(weight)/<span class="keyword">sizeof</span>(weight[<span class="number">0</span>])) &#123;</span><br><span class="line">            wp[i].weight= weight[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wp[i].weight = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        create_thread(&amp;pid[i+<span class="number">3</span>], thread_worker, &amp;wp[i]); <span class="comment">// 创建worker线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 略过下面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skynet_mq.c</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">skynet_mq_init() &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">global_queue</span> *<span class="title">q</span> = <span class="title">skynet_malloc</span>(<span class="title">sizeof</span>(*<span class="title">q</span>));</span></span><br><span class="line">    <span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="keyword">sizeof</span>(*q));</span><br><span class="line">    SPIN_INIT(q);</span><br><span class="line">    Q=q; <span class="comment">// 创建全局唯一global_queue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这些worker会做什么呢？我们查看worker线程任务的函数定义即可知晓：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skynet_start.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">thread_worker(<span class="keyword">void</span> *p) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">worker_parm</span> *<span class="title">wp</span> = <span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> id = wp-&gt;id;</span><br><span class="line">    <span class="keyword">int</span> weight = wp-&gt;weight;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> *<span class="title">m</span> = <span class="title">wp</span>-&gt;<span class="title">m</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skynet_monitor</span> *<span class="title">sm</span> = <span class="title">m</span>-&gt;<span class="title">m</span>[<span class="title">id</span>];</span></span><br><span class="line">    skynet_initthread(THREAD_WORKER);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> * <span class="title">q</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (!m-&gt;quit) &#123;</span><br><span class="line">        <span class="comment">// 当worker的监控monitor未退出时，循环运行，分发消息</span></span><br><span class="line">        q = skynet_context_message_dispatch(sm, q, weight);</span><br><span class="line">        <span class="comment">// 略过下面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skynet_server.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *</span></span><br><span class="line"><span class="class"><span class="title">skynet_context_message_dispatch</span>(<span class="title">struct</span> <span class="title">skynet_monitor</span> *<span class="title">sm</span>, <span class="title">struct</span> <span class="title">message_queue</span> *<span class="title">q</span>, <span class="title">int</span> <span class="title">weight</span>) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果是一开始，或上一次预先取得消息队列为NULL</span></span><br><span class="line">        q = skynet_globalmq_pop(); <span class="comment">// 那么就尝试从全局队列中pop一个消息队列</span></span><br><span class="line">        <span class="keyword">if</span> (q==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> handle = skynet_mq_handle(q);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ctx</span> = <span class="title">skynet_handle_grab</span>(<span class="title">handle</span>);</span> <span class="comment">// 找到对应的context</span></span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drop_t</span> <span class="title">d</span> = &#123;</span> handle &#125;;</span><br><span class="line">        skynet_mq_release(q, drop_message, &amp;d);</span><br><span class="line">        <span class="keyword">return</span> skynet_globalmq_pop(); <span class="comment">// 预先取下一个消息队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i,n=<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skynet_message</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (skynet_mq_pop(q,&amp;msg)) &#123; <span class="comment">// 返回值为0表示消息队列不为空</span></span><br><span class="line">            skynet_context_release(ctx);</span><br><span class="line">            <span class="keyword">return</span> skynet_globalmq_pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">0</span> &amp;&amp; weight &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            n = skynet_mq_length(q);</span><br><span class="line">            n &gt;&gt;= weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> overload = skynet_mq_overload(q);</span><br><span class="line">        <span class="keyword">if</span> (overload) &#123;</span><br><span class="line">            skynet_error(ctx, <span class="string">"May overload, message queue length = %d"</span>, overload);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// skynet_monitor监控了每个worker，通过version标识分发消息的次数</span></span><br><span class="line">        <span class="comment">// 通过skynet_monitor_trigger，可以++version标识</span></span><br><span class="line">        <span class="comment">// worker是一直不断运行的。如果version一直没涨</span></span><br><span class="line">        <span class="comment">// 就说明某一个消息在分发处理时死循环了</span></span><br><span class="line">        skynet_monitor_trigger(sm, msg.source , handle);</span><br><span class="line">        <span class="keyword">if</span> (ctx-&gt;cb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            skynet_free(msg.data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dispatch_message(ctx, &amp;msg); <span class="comment">// 分发消息给对应的context</span></span><br><span class="line">        &#125;</span><br><span class="line">        skynet_monitor_trigger(sm, <span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(q == ctx-&gt;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">nq</span> = <span class="title">skynet_globalmq_pop</span>();</span></span><br><span class="line">    <span class="keyword">if</span> (nq) &#123;</span><br><span class="line">        <span class="comment">// If global mq is not empty , push q back, and return next queue (nq)</span></span><br><span class="line">        <span class="comment">// Else (global mq is empty or block, don't push q back, and return q again (for next dispatch)</span></span><br><span class="line">        skynet_globalmq_push(q);</span><br><span class="line">        q = nq;</span><br><span class="line">    &#125;</span><br><span class="line">    skynet_context_release(ctx);</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">dispatch_message(struct skynet_context *ctx, struct skynet_message *msg) &#123;</span><br><span class="line">    <span class="comment">// 略过前置检查逻辑</span></span><br><span class="line">    <span class="keyword">int</span> reserve_msg; <span class="comment">// 是否在内存中保留消息数据？</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;profile) &#123; <span class="comment">// 如果在性能测试，记录cpu时间</span></span><br><span class="line">        ctx-&gt;cpu_start = skynet_thread_time();</span><br><span class="line">        reserve_msg = ctx-&gt;cb(ctx, ctx-&gt;cb_ud, type, msg-&gt;session, msg-&gt;source, msg-&gt;data, sz);</span><br><span class="line">        <span class="keyword">uint64_t</span> cost_time = skynet_thread_time() - ctx-&gt;cpu_start;</span><br><span class="line">        ctx-&gt;cpu_cost += cost_time;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不管怎么样都要调用context的消息处理回调函数处理消息</span></span><br><span class="line">        reserve_msg = ctx-&gt;cb(ctx, ctx-&gt;cb_ud, type, msg-&gt;session, msg-&gt;source, msg-&gt;data, sz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!reserve_msg) &#123;</span><br><span class="line">        skynet_free(msg-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    CHECKCALLING_END(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，这些worker会不断地从全局队列中取出单个消息队列，而后让这个消息队列所对应的service通过其context上注册的回调函数cb，处理相应的消息。</p>
<p>因此到这里，消息处理这一块的逻辑已经弄清了。如果要完成通信的闭环，还需要解决两个问题：</p>
<ul>
<li>发送方service如何推送消息到目标service？（<code>skynet.send</code>，非阻塞发送消息）</li>
<li>发送方如何获得目标service处理的返回值？（<code>skynet.call</code>，阻塞等待消息处理结果）</li>
</ul>
<p>我们先来看<code>skynet.send</code>。这个函数调用了底层注册的<code>send</code>函数，对应了<code>lua-skynet.c</code>中的<code>lsend</code>函数。我们以此为起点，观察消息推送的过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lua-skynet.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    uint32 address</span></span><br><span class="line"><span class="comment">     string address</span></span><br><span class="line"><span class="comment">    integer type</span></span><br><span class="line"><span class="comment">    integer session</span></span><br><span class="line"><span class="comment">    string message</span></span><br><span class="line"><span class="comment">     lightuserdata message_ptr</span></span><br><span class="line"><span class="comment">     integer len</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">lsend(lua_State *L) &#123;</span><br><span class="line">    <span class="keyword">return</span> send_message(L, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">send_message(lua_State *L, <span class="keyword">int</span> source, <span class="keyword">int</span> idx_type) &#123;</span><br><span class="line">    <span class="comment">// 略过上面</span></span><br><span class="line">    <span class="comment">// 消息类型，一般在lua层写业务逻辑的话，都约定用string就好了</span></span><br><span class="line">    <span class="keyword">int</span> mtype = lua_type(L,idx_type+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">switch</span> (mtype) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_TSTRING: &#123;</span><br><span class="line">        <span class="keyword">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">void</span> * msg = (<span class="keyword">void</span> *)lua_tolstring(L,idx_type+<span class="number">2</span>,&amp;len);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            msg = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 我们可以指定某个服务的名称（string），或者地址（uint）</span></span><br><span class="line">        <span class="keyword">if</span> (dest_string) &#123;</span><br><span class="line">            <span class="comment">// 如果指定名称，走skynet_sendname逻辑，当然最后也会寻址，再去走skynet_send逻辑。</span></span><br><span class="line">            session = skynet_sendname(context, source, dest_string, type, session , msg, len);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            session = skynet_send(context, source, dest, type, session , msg, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 略过下面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skynet-server.c</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">skynet_send(struct skynet_context * context, <span class="keyword">uint32_t</span> source, <span class="keyword">uint32_t</span> destination , <span class="keyword">int</span> type, <span class="keyword">int</span> session, <span class="keyword">void</span> * data, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">    <span class="comment">// 略过参数检验部分</span></span><br><span class="line">    <span class="keyword">if</span> (skynet_harbor_message_isremote(destination)) &#123;</span><br><span class="line">        <span class="comment">// 暂时略过harbor（集群）的部分</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        struct skynet_message smsg;  <span class="comment">// 把消息数据打包到skynet_message结构体</span></span><br><span class="line">        smsg.source = source;</span><br><span class="line">        smsg.session = session;</span><br><span class="line">        smsg.data = data;</span><br><span class="line">        smsg.sz = sz;</span><br><span class="line">        <span class="keyword">if</span> (skynet_context_push(destination, &amp;smsg)) &#123;  <span class="comment">// 推送到目标的context</span></span><br><span class="line">            skynet_free(data);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">skynet_context_push(<span class="keyword">uint32_t</span> handle, struct skynet_message *message) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ctx</span> = <span class="title">skynet_handle_grab</span>(<span class="title">handle</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    skynet_mq_push(ctx-&gt;<span class="built_in">queue</span>, message);  <span class="comment">// 把消息推入消息队列当中</span></span><br><span class="line">    skynet_context_release(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这样的一顿操作，就可以把消息发送到指定service的消息队列里了，然后就等worker来取消息回调处理啦~</p>
<p>那么第二个，如何实现获取处理结果的需求呢？这个是在lua层实现的，通过目标服务调用<code>skynet.ret</code>逻辑，<code>skynet.call</code>就可以获取返回值。我们来观察两边的逻辑：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- skynet.lua</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">yield_call</span><span class="params">(service, session)</span></span></span><br><span class="line">    watching_session[session] = service <span class="comment">-- 监控是否有收到相应session的返回数据</span></span><br><span class="line">    session_id_coroutine[session] = running_thread</span><br><span class="line">    <span class="keyword">local</span> succ, msg, sz = coroutine_yield <span class="string">"SUSPEND"</span> <span class="comment">-- 挂起，直到该session有返回为止</span></span><br><span class="line">    watching_session[session] = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> succ <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">error</span> <span class="string">"call failed"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> msg,sz</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.call</span><span class="params">(addr, typename, ...)</span></span></span><br><span class="line">    <span class="keyword">local</span> tag = session_coroutine_tracetag[running_thread]</span><br><span class="line">    <span class="keyword">if</span> tag <span class="keyword">then</span></span><br><span class="line">        c.trace(tag, <span class="string">"call"</span>, <span class="number">2</span>)</span><br><span class="line">        c.send(addr, skynet.PTYPE_TRACE, <span class="number">0</span>, tag)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> p = proto[typename]</span><br><span class="line">    <span class="keyword">local</span> session = c.send(addr, p.id , <span class="literal">nil</span> , p.pack(...)) <span class="comment">-- 获取本次消息的session</span></span><br><span class="line">    <span class="keyword">if</span> session == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">error</span>(<span class="string">"call to invalid address "</span> .. skynet.address(addr))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> p.<span class="built_in">unpack</span>(yield_call(addr, session))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.ret</span><span class="params">(msg, sz)</span></span></span><br><span class="line">    <span class="comment">-- 在此逻辑之前，会通过dispatch_message分发消息，缓存消息的发送方、session等信息</span></span><br><span class="line">    msg = msg <span class="keyword">or</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">local</span> tag = session_coroutine_tracetag[running_thread]</span><br><span class="line">    <span class="keyword">if</span> tag <span class="keyword">then</span> c.trace(tag, <span class="string">"response"</span>) <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 获取缓存的session信息</span></span><br><span class="line">    <span class="keyword">local</span> co_session = session_coroutine_id[running_thread]</span><br><span class="line">    session_coroutine_id[running_thread] = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> co_session == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> sz ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">            c.trash(msg, sz)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">-- send don't need ret</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 获取缓存的发送方信息</span></span><br><span class="line">    <span class="keyword">local</span> co_address = session_coroutine_address[running_thread]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> co_session <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">error</span> <span class="string">"No session"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 目标服务返回数据给发送方，带上session标识，表示这是该session消息的返回</span></span><br><span class="line">    <span class="keyword">local</span> ret = c.send(co_address, skynet.PTYPE_RESPONSE, co_session, msg, sz)</span><br><span class="line">    <span class="keyword">if</span> ret <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">elseif</span> ret == <span class="literal">false</span> <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- If the package is too large, returns false. so we should report error back</span></span><br><span class="line">        c.send(co_address, skynet.PTYPE_ERROR, co_session, <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>可以看到，通过提供发送方与session标识信息，发送方就能够知道哪些消息是该session的返回值了。</p>
<p>这样一来，skynet内部的通信机制，就全部串上了！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一不小心写多了点，希望能有助于各位小伙伴加深对服务端以及skynet架构的理解。如果有叙述不当的地方，恳请指正~~~</p>
<p>那么skynet具体要怎么用呢？这一part暂时决定在后面的系列献上~</p>
]]></content>
      <categories>
        <category>Lua杂谈</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>源码分析</tag>
        <tag>lua</tag>
        <tag>skynet</tag>
        <tag>lua_State</tag>
      </tags>
  </entry>
  <entry>
    <title>【Easy Python】另类实用Python教程——Easy Python精编版上线</title>
    <url>/2019/10/08/easypython/pdf/</url>
    <content><![CDATA[<p>最近小包装了一下<a href="https://utmhikari.github.io/categories/Easy-Python/">Easy Python系列</a>，放到<span class="exturl" data-url="aHR0cHM6Ly93d3cueXVxdWUuY29tL2hpa2FyaS16eTVjMC9lYXN5LXB5dGhvbg==" title="https://www.yuque.com/hikari-zy5c0/easy-python">语雀<i class="fa fa-external-link"></i></span>上整合精编了个pdf投放，完成Easy Python系列的最后一项任务。</p>
<p>第一次编撰一个短篇技术系列，小有成就，值得鼓励。但路还有很远，慢慢来吧~</p>
<p>传送门如下：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMVJ6OTlpWXFzRGxIYkZNbWJhNlVKZkE=" title="https://pan.baidu.com/s/1Rz99iYqsDlHbFMmba6UJfA">百度网盘<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Easy Python</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>数据挖掘</tag>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】hexo+NexT博客自定义代码高亮主题配色CSS</title>
    <url>/2019/10/07/geekdaily/next_code_theme/</url>
    <content><![CDATA[<p>用hexo+NexT搭建博客的同学或许会遇到一个问题：默认的代码配色只有<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nocmlza2VtcHNvbi90b21vcnJvdy10aGVtZQ==" title="https://github.com/chriskempson/tomorrow-theme">Tomorrow Theme<i class="fa fa-external-link"></i></span>五种，如果想要自己的代码配色，应当如何自定义呢？</p>
<p>其实也是可以的。在NexT的<code>source/css/highlight/theme.styl</code>中，我们就可以看到几种主题的具体配色：</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="variable">$highlight_theme</span> = hexo-config(<span class="string">"highlight_theme"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="variable">$highlight_theme</span> == <span class="string">"normal"</span></span><br><span class="line">  <span class="variable">$highlight</span>-<span class="attribute">background</span>   = <span class="number">#f7f7f7</span></span><br><span class="line">  <span class="variable">$highlight</span>-current-line = <span class="number">#efefef</span></span><br><span class="line">  <span class="variable">$highlight</span>-selection    = <span class="number">#d6d6d6</span></span><br><span class="line">  <span class="variable">$highlight</span>-foreground   = <span class="number">#4d4d4c</span></span><br><span class="line">  <span class="variable">$highlight</span>-comment      = <span class="number">#8e908c</span></span><br><span class="line">  <span class="variable">$highlight</span>-red          = <span class="number">#c82829</span></span><br><span class="line">  <span class="variable">$highlight</span>-orange       = <span class="number">#f5871f</span></span><br><span class="line">  <span class="variable">$highlight</span>-yellow       = <span class="number">#eab700</span></span><br><span class="line">  <span class="variable">$highlight</span>-green        = <span class="number">#718c00</span></span><br><span class="line">  <span class="variable">$highlight</span>-aqua         = <span class="number">#3e999f</span></span><br><span class="line">  <span class="variable">$highlight</span>-blue         = <span class="number">#4271ae</span></span><br><span class="line">  <span class="variable">$highlight</span>-purple       = <span class="number">#8959a8</span></span><br><span class="line">  <span class="variable">$highlight</span>-gutter       = &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#869194</span>,</span><br><span class="line">    bg-<span class="attribute">color</span>: <span class="number">#eff2f3</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="variable">$highlight_theme</span> == <span class="string">"night"</span></span><br><span class="line">  <span class="variable">$highlight</span>-<span class="attribute">background</span>   = <span class="number">#1d1f21</span></span><br><span class="line">  <span class="variable">$highlight</span>-current-line = <span class="number">#282a2e</span></span><br><span class="line">  <span class="variable">$highlight</span>-selection    = <span class="number">#373b41</span></span><br><span class="line">  <span class="variable">$highlight</span>-foreground   = <span class="number">#c5c8c6</span></span><br><span class="line">  <span class="variable">$highlight</span>-comment      = <span class="number">#969896</span></span><br><span class="line">  <span class="variable">$highlight</span>-red          = <span class="number">#cc6666</span></span><br><span class="line">  <span class="variable">$highlight</span>-orange       = <span class="number">#de935f</span></span><br><span class="line">  <span class="variable">$highlight</span>-yellow       = <span class="number">#f0c674</span></span><br><span class="line">  <span class="variable">$highlight</span>-green        = <span class="number">#b5bd68</span></span><br><span class="line">  <span class="variable">$highlight</span>-aqua         = <span class="number">#8abeb7</span></span><br><span class="line">  <span class="variable">$highlight</span>-blue         = <span class="number">#81a2be</span></span><br><span class="line">  <span class="variable">$highlight</span>-purple       = <span class="number">#b294bb</span></span><br><span class="line">  <span class="variable">$highlight</span>-gutter       = &#123;</span><br><span class="line">    <span class="attribute">color</span>: lighten(<span class="variable">$highlight</span>-background, <span class="number">50%</span>),</span><br><span class="line">    bg-<span class="attribute">color</span>: darken(<span class="variable">$highlight</span>-background, <span class="number">100%</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>我们可以看到其实如果要增加一个自定义主题的话，其实加一段if跟其配色，然后在配置里配置theme的关键词就好了。那么自己配色的话应该怎样参考呢？我们可以在<code>source/css/highlight/highlight.styl</code>中找到答案：</p>
<a id="more"></a>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line">pre &#123;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.comment</span> &#123; <span class="attribute">color</span>: <span class="variable">$highlight</span>-comment; &#125;</span><br><span class="line"></span><br><span class="line">  .variable</span><br><span class="line">  .attribute</span><br><span class="line">  .constant</span><br><span class="line">  .tag</span><br><span class="line">  .name</span><br><span class="line">  .regexp</span><br><span class="line">  .ruby</span><br><span class="line">  <span class="selector-class">.xml</span> <span class="selector-class">.tag</span> .title</span><br><span class="line">  <span class="selector-class">.xml</span> .pi</span><br><span class="line">  <span class="selector-class">.xml</span> .doctype</span><br><span class="line">  <span class="selector-class">.html</span> .doctype</span><br><span class="line">  <span class="selector-class">.css</span> .id</span><br><span class="line">  <span class="selector-class">.css</span> .class</span><br><span class="line">  <span class="selector-class">.css</span> <span class="selector-class">.pseudo</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$highlight</span>-red;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .number</span><br><span class="line">  .preprocessor</span><br><span class="line">  .built_in</span><br><span class="line">  .builtin-name</span><br><span class="line">  .literal</span><br><span class="line">  .params</span><br><span class="line">  .constant</span><br><span class="line">  <span class="selector-class">.command</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$highlight</span>-orange;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.constant</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$highlight</span>-constant;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.ruby</span> <span class="selector-class">.class</span> .title</span><br><span class="line">  <span class="selector-class">.css</span> <span class="selector-class">.rules</span> .attribute</span><br><span class="line">  .string</span><br><span class="line">  .symbol</span><br><span class="line">  .value</span><br><span class="line">  .inheritance</span><br><span class="line">  .header</span><br><span class="line">  <span class="selector-class">.ruby</span> .symbol</span><br><span class="line">  <span class="selector-class">.xml</span> .cdata</span><br><span class="line">  .special</span><br><span class="line">  <span class="selector-class">.formula</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$highlight</span>-green;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .title</span><br><span class="line">  <span class="selector-class">.css</span> <span class="selector-class">.hexcolor</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$highlight</span>-aqua;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .function</span><br><span class="line">  <span class="selector-class">.python</span> .decorator</span><br><span class="line">  <span class="selector-class">.python</span> .title</span><br><span class="line">  <span class="selector-class">.ruby</span> <span class="selector-class">.function</span> .title</span><br><span class="line">  <span class="selector-class">.ruby</span> <span class="selector-class">.title</span> .keyword</span><br><span class="line">  <span class="selector-class">.perl</span> .sub</span><br><span class="line">  <span class="selector-class">.javascript</span> .title</span><br><span class="line">  <span class="selector-class">.coffeescript</span> <span class="selector-class">.title</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$highlight</span>-blue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .keyword</span><br><span class="line">  <span class="selector-class">.javascript</span> <span class="selector-class">.function</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$highlight</span>-purple;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在这段css中可以看到不同的代码块的不同配色，对照该css所示配置颜色即可。当然若有细节需求，更改上面代码块的css也是ok的。</p>
<p>比如笔者采用经典的<code>solarized light</code>配色，就可以在<code>source/css/highlight/theme.styl</code>加上一段：</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="variable">$highlight_theme</span> == <span class="string">"solarized light"</span></span><br><span class="line">  <span class="variable">$highlight</span>-<span class="attribute">background</span>   = <span class="number">#FDF6E3</span></span><br><span class="line">  <span class="variable">$highlight</span>-constant     = <span class="number">#00FF00</span></span><br><span class="line">  <span class="variable">$highlight</span>-current-line = <span class="number">#FDF6E3</span></span><br><span class="line">  <span class="variable">$highlight</span>-selection    = <span class="number">#ECE7D5</span></span><br><span class="line">  <span class="variable">$highlight</span>-foreground   = <span class="number">#657A81</span></span><br><span class="line">  <span class="variable">$highlight</span>-comment      = <span class="number">#93A1A1</span></span><br><span class="line">  <span class="variable">$highlight</span>-red          = <span class="number">#D30102</span></span><br><span class="line">  <span class="variable">$highlight</span>-orange       = <span class="number">#657A81</span></span><br><span class="line">  <span class="variable">$highlight</span>-yellow       = <span class="number">#657A81</span></span><br><span class="line">  <span class="variable">$highlight</span>-green        = <span class="number">#2AA198</span></span><br><span class="line">  <span class="variable">$highlight</span>-aqua         = <span class="number">#657A81</span></span><br><span class="line">  <span class="variable">$highlight</span>-blue         = <span class="number">#657A81</span></span><br><span class="line">  <span class="variable">$highlight</span>-purple       = <span class="number">#B58900</span></span><br><span class="line">  <span class="variable">$highlight</span>-gutter       = &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#586E75</span></span><br><span class="line">    bg-<span class="attribute">color</span>: <span class="number">#FDF6E3</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然后在NexT的<code>_config.yml</code>中应用该配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Code Highlight theme</span></span><br><span class="line"><span class="comment"># Available values: normal | night | night eighties | night blue | night bright</span></span><br><span class="line"><span class="comment"># https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line"><span class="attr">highlight_theme:</span> <span class="string">solarized</span> <span class="string">light</span></span><br></pre></td></tr></table></figure>
<p>就ok了</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>NexT</tag>
        <tag>代码高亮</tag>
        <tag>styl</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>【极客日常】解决国内go1.13的go mod无法安装依赖的问题</title>
    <url>/2019/10/07/geekdaily/go113_proxy/</url>
    <content><![CDATA[<p>在<a href="https://utmhikari.github.io/2019/07/20/gofromzero/01_first_code/">从零单排Golang第一话</a>中讲到了Golang的基础开发环境配置，其中讲到了Go的依赖管理方面，提及了以后的趋势会采用官方的go mod进行管理。关于这一块，现在有了更加简单的方法。</p>
<p>最新的Go1.13中已经将go mod列为默认的包管理方法，但国内用户go mod vendor时还是有可能会出错，这是因为在go get时会检查哈希值，需要访问官方的sumdb。由于众所周知的不可抗因素，sumdb没法直接访问，这样就会造成下载依赖失败。解决的方法也很简单，只需要一行终端命令即可：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>
<p>如果采用idea+Go插件开发的话需要注意，idea可能会托管环境变量，这个时候需要进入<code>settings, languages &amp; frameworks, go, go modules</code>里，设置proxy为<code>https://goproxy.cn,direct</code>，就ok了。</p>
]]></content>
      <categories>
        <category>极客日常</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>GOPROXY</tag>
        <tag>go mod</tag>
        <tag>GOSUMDB</tag>
        <tag>go env</tag>
      </tags>
  </entry>
  <entry>
    <title>【从零单排Golang】第四话：Win10安装minikube，用client-go部署mongodb</title>
    <url>/2019/10/03/gofromzero/04_kubernetes_mongo/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9nb2Zyb216ZXJv" title="https://github.com/utmhikari/gofromzero">Github传送门<i class="fa fa-external-link"></i></span></p>
<p>提起Golang，就不得不提起<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLw==" title="https://kubernetes.io/zh/">kubernetes<i class="fa fa-external-link"></i></span>，在崇尚上云的今天，kubernetes已成为服务端同学必需掌握之学问。在<a href="https://utmhikari.github.io/2019/09/01/gofromzero/03_docker_client/">第三话</a>中，我们介绍了docker容器，它相当于虚拟操作系统，可以提供环境供各种不同的应用运行，从而实现轻量部署。但要是业务复杂，需要部署较多应用的话，就会遇到许多运维相关的问题，比如：</p>
<ul>
<li>应用关联的资源很多都需要持久化存储，它们的存储空间需要怎样分配及调度呢？</li>
<li>不同地域的应用，如何取得相互联系？</li>
<li>在应用集群中，如果有一个子应用挂了，该怎么办？</li>
<li>。。。</li>
</ul>
<p>这些问题，单靠docker是解决不了的（也不是docker所要关心的），需要在docker的基础上做更高层次的运维平台才能解决，而kubernetes，就是方案之一。复杂的调度逻辑，都会由kubernetes负责，而运维开发人员则基本只需向kubernetes提供资源及其描述，就能满足运维需求，从而提升工作效率。</p>
<p>既然准备入坑，就需要强行踩下去，因此今天就试试“家中上云”，单机搭建kubernetes，部署一个mongodb数据库。废话不多说，咱们开始吧~</p>
<h2 id="minikube——在Win10本地搭建kubernetes"><a href="#minikube——在Win10本地搭建kubernetes" class="headerlink" title="minikube——在Win10本地搭建kubernetes"></a>minikube——在Win10本地搭建kubernetes</h2><a id="more"></a>
<p>笔者的电脑为Win10，因此搭建环境的部分，只考虑Win10的情况。</p>
<p>要在本地搭建kubernetes运维平台，首先建议安装docker，直接在官网下载<span class="exturl" data-url="aHR0cHM6Ly93d3cuZG9ja2VyLmNvbS9wcm9kdWN0cy9kb2NrZXItZGVza3RvcA==" title="https://www.docker.com/products/docker-desktop">Docker Desktop<i class="fa fa-external-link"></i></span>安装即可（提供了日常容器环境+Hyper-V虚拟机功能+kubectl客户端）。在此基础上，安装kubernetes的最好方式是采用官方提供的<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvdGFza3MvdG9vbHMvaW5zdGFsbC1taW5pa3ViZS8=" title="https://kubernetes.io/docs/tasks/tools/install-minikube/">minikube<i class="fa fa-external-link"></i></span>工具。minikube提供了一套单节点kubernetes环境（实体为虚拟机），从而使得单机用户也可以享受kubernetes的所有功能。kubernetes厂商为Google，由于众所周知的原因，下载Google资源一直是一个难题。因此，我们需要一个魔改版本——<span class="exturl" data-url="aHR0cHM6Ly95cS5hbGl5dW4uY29tL2FydGljbGVzLzIyMTY4Nw==" title="https://yq.aliyun.com/articles/221687">minikube阿里云版<i class="fa fa-external-link"></i></span>，从而避免科学上网的烦恼。下载好，保存好，记得把minikube根目录加到<code>PATH环境变量</code>，这样就能在cmd/powershell里直接运行。</p>
<p>启动minikube之前，需要在Hyper-V创建一个外部的虚拟交换机（开始——Windows管理工具——Hyper-V管理器——虚拟交换机管理器——创建外部虚拟交换机），笔者这边取名为<code>EXTERNAL_SWITCH</code>。</p>
<p>minikube启动之后，会在用户文件夹下创建kubernetes配置，而后在Hyper-V中创建一个虚拟机——一个linux系统，里边会自带一个docker+kubernetes的环境。在虚拟机内，我们可以执行docker相关的命令与容器交互，比如查看当前kubernetes相关容器/镜像的信息与状态；而在外边，也就是我们的Win10主机里，因为minikube已经创建了配置，所以我们可以知道kubernetes节点的ip，并且可以用<code>kubectl</code>与虚拟机中的kubernetes交互，获得其中状态信息。</p>
<p>启动minikube的方式，建议编写脚本执行：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># minikube-start.ps1</span></span><br><span class="line">minikube start --vm-driver hyperv --hyperv-virtual-switch=EXTERNAL_SWITCH</span><br></pre></td></tr></table></figure>
<p>把这个脚本放到minikube.exe同级目录中，就可以直接运行了。如果不能运行的话，一般是powershell执行脚本权限问题，解决方法是用管理员身份打开powershell，然后执行：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> Unrestricted</span><br></pre></td></tr></table></figure>
<p>把执行权限放宽，就好了。</p>
<p>但后面还会有一个问题，普通用户不能创建Hyper-V虚拟机，这个时候只需要在普通用户的powershell中输入<code>whoami</code>查看<code>用户组\用户名</code>，然后管理员身份打开powershell，输入：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">net localgroup <span class="string">"Hyper-V Administrators"</span> <span class="string">"用户组\用户名"</span> /add</span><br></pre></td></tr></table></figure>
<p>就可以以普通用户身份，输入<code>minikube-start</code>，启动minikube虚拟机了。</p>
<p>输入<code>minikube status</code>可以查看minikube的状态。如果状态是类似于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">host: Running</span><br><span class="line">kubelet: Running</span><br><span class="line">apiserver: Running</span><br><span class="line">kubectl: Correctly Configured: pointing to minikube-vm at 192.168.0.102</span><br></pre></td></tr></table></figure>
<p>的话，就说明启动成功了。</p>
<p>要退出minikube，最稳定的方法是<code>minikube ssh</code>进入到虚拟机中，然后<code>sudo poweroff</code>关闭虚拟机。在笔者电脑上，直接使用<code>minikube stop</code>关闭虚拟机有极大概率卡住无法关闭，因此暂不推荐这种方法。</p>
<h2 id="client-go——用Golang在kubernetes部署mongodb"><a href="#client-go——用Golang在kubernetes部署mongodb" class="headerlink" title="client-go——用Golang在kubernetes部署mongodb"></a>client-go——用Golang在kubernetes部署mongodb</h2><p>minikube搭建完毕后，接下来就要实战了——在minikube中部署mongodb。</p>
<p>首先不要急着码，而是要解决以下的问题：</p>
<ul>
<li>数据在哪里存储？（kubernetes的主机是minikube创建的虚拟机，所以在虚拟机里）</li>
<li>如何暴露数据库的连接端口？（主机可访问节点，故将mongodb端口转发至节点端口）</li>
</ul>
<p>对于数据库集群而言，通常会将其封装成一类叫做StatefulSet（副本集）的资源。StatefulSet主要包含Pod的集合，以及和各个Pod关联的PersistentVolumeClaim（PVC）集合。Pod是kubernetes调度的单位，可以理解成单个应用实例，而PVC则是这些Pod各个对应的持久化存储空间的声明。在实际场景中，管理存储空间的人员会预先在kubernetes为许多实在的持久化存储空间打下标记，统称为Storage Class，用户则只需要在StatefulSet声明怎样存储（PVC），kubernetes就在内部把各个Pod根据相应的Storage Class及PVC从而分配空间（PV），绑定起来。如果一个Pod发生故障，存储空间也不会消失，过后恢复的Pod也会跟原来一样，拥有和原来相同的标识，存储空间也和原来的PV对应。</p>
<p>而在笔者这里的例子里，创建多个数据库以及多个存储空间较为麻烦，因此也有其它的办法——在Pod的资源声明中，我们可以告诉kubernetes要在启动mongodb容器之时，挂载minikube虚拟机里面的一个目录进去存储数据库数据，这样容器宕机之后，数据依然不会消失。</p>
<p>因此，创建mongodb的StatefulSet资源代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createMongoStatefulSet</span><span class="params">(clientset *kubernetes.Clientset)</span> <span class="params">(*appsv1.StatefulSet, error)</span></span> &#123;</span><br><span class="line">    replicas := <span class="keyword">int32</span>(<span class="number">1</span>)</span><br><span class="line">    terminationGracePeriodSeconds := <span class="keyword">int64</span>(<span class="number">10</span>)</span><br><span class="line">    statefulSet := appsv1.StatefulSet&#123;</span><br><span class="line">        ObjectMeta: metav1.ObjectMeta&#123;Name: <span class="string">"mongo"</span>&#125;,</span><br><span class="line">        Spec: appsv1.StatefulSetSpec&#123;</span><br><span class="line">            ServiceName: <span class="string">"mongo"</span>,</span><br><span class="line">            Replicas:    &amp;replicas,</span><br><span class="line">            Template: v1.PodTemplateSpec&#123;</span><br><span class="line">                ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">                    Labels: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"role"</span>: <span class="string">"mongo"</span>&#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">                Spec: v1.PodSpec&#123;</span><br><span class="line">                    TerminationGracePeriodSeconds: &amp;terminationGracePeriodSeconds,</span><br><span class="line">                    Volumes: []v1.Volume&#123;</span><br><span class="line">                        &#123;</span><br><span class="line">                            Name: <span class="string">"mongo-volume"</span>,</span><br><span class="line">                            VolumeSource: v1.VolumeSource&#123;</span><br><span class="line">                                HostPath: &amp;v1.HostPathVolumeSource&#123;Path: <span class="string">"/home/docker/mongo"</span>&#125;,</span><br><span class="line">                            &#125;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    Containers: []v1.Container&#123;</span><br><span class="line">                        &#123;</span><br><span class="line">                            Name:         <span class="string">"mongo"</span>,</span><br><span class="line">                            Image:        <span class="string">"library/mongo:latest"</span>,</span><br><span class="line">                            Command:      []<span class="keyword">string</span>&#123;<span class="string">"mongod"</span>, <span class="string">"--replSet"</span>, <span class="string">"rs0"</span>, <span class="string">"--bind_ip"</span>, <span class="string">"0.0.0.0"</span>&#125;,</span><br><span class="line">                            Ports:        []v1.ContainerPort&#123;&#123;ContainerPort: <span class="number">27017</span>&#125;&#125;,</span><br><span class="line">                            VolumeMounts: []v1.VolumeMount&#123;&#123;Name: <span class="string">"mongo-volume"</span>, MountPath: <span class="string">"/data/db"</span>&#125;&#125;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            Selector: &amp;metav1.LabelSelector&#123;</span><br><span class="line">                MatchLabels: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"role"</span>: <span class="string">"mongo"</span>&#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clientset.AppsV1().StatefulSets(defaultNamespace).Create(&amp;statefulSet)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个StatefulSet里面，创建了单副本（replicas=1）的mongo数据库。在副本的Pod模板里，该副本挂载了虚拟机的<code>/home/docker/mongo</code>目录（minikube默认用户为docker，mongo目录需要预先创建）到容器里的<code>/data/db</code>目录，也就是mongodb数据存储的地方。mongo启动参数要<code>--bind_ip 0.0.0.0</code>，从而能够被外部访问。</p>
<p>另外我们也可以看到，这个StatefulSet有一个ServiceName字段，这是因为通过相应的Service，这个StatefulSet才会被集群内其它成员发现。因此，在创建StatefulSet之前，我们其实还需要创建一个相应的Service资源：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createMongoService</span><span class="params">(clientset *kubernetes.Clientset)</span> <span class="params">(*v1.Service, error)</span></span> &#123;</span><br><span class="line">    service := v1.Service&#123;</span><br><span class="line">        ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">            Name:   <span class="string">"mongo"</span>,</span><br><span class="line">            Labels: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"name"</span>: <span class="string">"mongo"</span>&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        Spec: v1.ServiceSpec&#123;</span><br><span class="line">            Type: <span class="string">"NodePort"</span>,</span><br><span class="line">            Ports: []v1.ServicePort&#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    Port:       <span class="number">27017</span>,</span><br><span class="line">                    TargetPort: intstr.IntOrString&#123;Type: <span class="number">0</span>, IntVal: <span class="number">27017</span>&#125;,</span><br><span class="line">                    NodePort:   <span class="number">32017</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            Selector: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"role"</span>: <span class="string">"mongo"</span>&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clientset.CoreV1().Services(defaultNamespace).Create(&amp;service)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过NodePort方式，Service资源可以将被服务者的端口（Port）映射到自己的端口（TargetPort），然后再绑定到节点特定的端口（NodePort）。mongodb的默认端口是27017，而通过<code>minikube ip</code>，我们也可以知道节点的ip。这样，我们就能在Win10主机里访问minikube里的mongodb了。</p>
<p>把mongodb的Service与StatefulSet资源声明交给kubernetes，它就会自动把mongodb部署起来了。试试吧~</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>kubernetes的难点主要来自于业务经验。技术与业务并行，同志仍需努力！</p>
]]></content>
      <categories>
        <category>从零单排Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>mongodb</tag>
        <tag>client-go</tag>
        <tag>kubernetes</tag>
        <tag>minikube</tag>
      </tags>
  </entry>
  <entry>
    <title>【DIY小记】CSGO究极装机优化设置指南</title>
    <url>/2019/09/21/diymemo/csgo/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上周电脑突发极其奇怪的bug，启动了不到一会儿CPU阻塞，所有程序打不开，安全模式查毒、修复系统、清存储卸软件均没有获得较好的效果。因此索性重装了Windows，所有一切推倒重来。</p>
<p>既然推倒重来，那CSGO就是不得不装的一款游戏。CSGO到现在也有10年的历史了，然而在网上能搜到的游戏优化设置要么过时，要么没有详尽的整合。因此，本文章借着装机经验，整理了自己优化CSGO的历程~</p>
<p>由于笔者为Win10+N卡，因此在Linux/Mac以及非N卡下玩CSGO的同学，部分配置还需另行google~</p>
<h2 id="Win10游戏设置"><a href="#Win10游戏设置" class="headerlink" title="Win10游戏设置"></a>Win10游戏设置</h2><p>运行在Win10的游戏需要关闭Win10自带的游戏优化与配置</p>
<p>首先关闭XBox自带的DVR（游戏内录像之类），有很多种方法，这里通过注册表方式解决：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\System\GameConfigStore]</span><br><span class="line">&quot;GameDVR_Enabled&quot;=dword:0</span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\GameDVR]</span><br><span class="line">&quot;AllowGameDVR&quot;=dword:0</span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\PolicyManager\default\ApplicationManagement\AllowGameDVR]</span><br><span class="line">&quot;value&quot;=dword:0</span><br></pre></td></tr></table></figure>
<p>新建<code>disableDVR.reg</code>将以上文本复制进去，执行即可。</p>
<p>如果对注册表不熟悉的话，可以另外百度搜直接在系统设置关闭的方法（非常多，随便挑一个就好），比如<span class="exturl" data-url="aHR0cHM6Ly93d3cucGNvbmxpbmUuY29tLmNuL3dpbjEwLzEwNzcvMTA3NzI4MDcuaHRtbA==" title="https://www.pconline.com.cn/win10/1077/10772807.html">这个<i class="fa fa-external-link"></i></span>。</p>
<p>然后就是查缺补漏了。打开<code>系统设置——游戏</code>，在<code>游戏栏</code>条目关闭<code>使用游戏栏录制剪辑、屏幕截图和广播</code>，如图：</p>
<p><img src="/uploads/diymemo/csgo/gamebar.png" alt="游戏栏"></p>
<p>而后，在<code>游戏模式</code>条目，关闭<code>游戏模式</code>，否则CSGO画面虚的一笔。</p>
<p><img src="/uploads/diymemo/csgo/gamemode.png" alt="游戏模式"></p>
<p>如果出现有条目不同的情况，可能是系统版本不同的原因（笔者为1903）~</p>
<h2 id="鼠标设置"><a href="#鼠标设置" class="headerlink" title="鼠标设置"></a>鼠标设置</h2><p>鼠标设置必须要做的一个是关闭鼠标加速：</p>
<p>打开<code>控制面板</code>，选择<code>鼠标</code>中的<code>指针选项</code>一栏，取消勾选<code>提高指针精确度</code></p>
<p><img src="/uploads/diymemo/csgo/cp_mouse.png" alt="指针精确度"></p>
<p>而后，如果你的鼠标有额外驱动程序（比如雷蛇），需要下载驱动程序去鼠标加速然后diy一个自己感到舒适的配置。如果没有，那就可以继续下面了。</p>
<h2 id="N卡设置"><a href="#N卡设置" class="headerlink" title="N卡设置"></a>N卡设置</h2><p>首先安装N卡图形驱动（可以官网搜也可以用驱动软件），如果成功的话，我们就能够找到<code>NVIDIA控制面板</code>了。</p>
<p>在<code>NVIDIA控制面板</code>下设置N卡，具体如下：</p>
<p>首先进入<code>通过预览调整图像设置</code>条目，拖动条为侧重性能：</p>
<p><img src="/uploads/diymemo/csgo/nvidia_preview.png" alt="预览"></p>
<p>而后进入<code>管理3D设置</code>条目，全局设置着重性能而非质量。当然如果你想某些其他游戏着重质量，可以不改全局设置，而修改程序设置。</p>
<p>之后进入<code>配置Surround、PhysX</code>条目，将PhysX设置为显卡而非CPU：</p>
<p><img src="/uploads/diymemo/csgo/physx.png" alt="PhysX"></p>
<p>适用于CSGO的设置如下：</p>
<p><img src="/uploads/diymemo/csgo/nvidia1.png" alt="N卡1"></p>
<p><img src="/uploads/diymemo/csgo/nvidia2.png" alt="N卡2"></p>
<p>如果部分设置条目不同，应当为NVIDIA显卡型号或驱动版本不同所致，需要另行检索~</p>
<p>再然后就看个人情况了。比如你csgo分辨率为4:3但又想全屏没黑条的话，可以在<code>调整桌面尺寸和位置</code>条目中的<code>缩放</code>选择<code>全屏</code>，并勾选<code>覆盖由游戏和程序设置的缩放模式</code>，记得把刷新率也设置到最高~</p>
<p><img src="/uploads/diymemo/csgo/fullscreen.png" alt="全屏"></p>
<h2 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h2><p>自己电脑CSGO在steam内启动参数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-novid -high -tickrate 128 -preload -refresh 120 -useforcedmparms -noforcemspd -noforcemaccel +exec autoexec.cfg</span><br></pre></td></tr></table></figure>
<p>笔者为神船刷新率120Hz显示器，因此启动参数会填写了<code>-refresh 120</code>，其他小伙伴请根据自己显示器最大刷新率填写<code>-refresh</code>参数，比如144、200多啥的。</p>
<p>最后会启动时执行<code>autoexec.cfg</code>，其内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rate &quot;128000&quot;</span><br><span class="line">cl_cmdrate &quot;128&quot;</span><br><span class="line">cl_updaterate &quot;128&quot;</span><br><span class="line">cl_interp &quot;0&quot;</span><br><span class="line">cl_interp_ratio &quot;1&quot;</span><br><span class="line">cl_lagcompensation &quot;1&quot;</span><br><span class="line">r_dynamic &quot;0&quot;</span><br><span class="line">r_drawtracers_firstperson &quot;0&quot;</span><br><span class="line">fps_max &quot;300&quot;</span><br><span class="line">cl_radar_always_centered &quot;0&quot;</span><br><span class="line">cl_radar_scale &quot;0.3&quot;</span><br><span class="line">cl_hud_radar_scale &quot;1.15&quot;</span><br><span class="line">cl_radar_icon_scale_min &quot;1&quot;</span><br><span class="line">cl_radar_rotate &quot;1&quot;</span><br><span class="line">snd_mixahead &quot;0.05&quot;</span><br></pre></td></tr></table></figure>
<p>是一个稳当但并非最牛皮游戏体验的设置。如果要追求最佳游戏体验，比如可以设置<code>fps_max &quot;999&quot;</code>之类。</p>
<p><code>autoexec.cfg</code>需要存储到<code>${Steam游戏目录}\steamapps\common\Counter-Strike Global Offensive\csgo\cfg</code>中才可以执行到。其它的cfg脚本也同样如此。</p>
<h2 id="游戏内部设置"><a href="#游戏内部设置" class="headerlink" title="游戏内部设置"></a>游戏内部设置</h2><p>接下来是游戏内部的设置，首先是<code>视频设置</code>，效果全低，着重性能即可。</p>
<p>为了方便截图，采用了窗口模式：</p>
<p><img src="/uploads/diymemo/csgo/video.png" alt="视频"></p>
<p>用本本的小伙伴需要同时设置<code>显示设置</code>为<code>电视</code>，这样会有更好的颜色效果。</p>
<p>而后是鼠标，打开<code>键盘/鼠标</code>一栏，启用原始数据输入，关闭鼠标加速</p>
<p><img src="/uploads/diymemo/csgo/mouse.png" alt="鼠标"></p>
<p>其它设置因人而异。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>音频方面的优化还没有系统的概念，而且因耳机效果而已，因此需要另行搜索啦~</p>
<p>其它地方，如果有缺，求留言补充~</p>
<p>如果配置不当，恳请指正~</p>
]]></content>
      <categories>
        <category>DIY小记</category>
      </categories>
      <tags>
        <tag>CSGO</tag>
        <tag>Win10</tag>
        <tag>NVIDIA</tag>
        <tag>游戏优化</tag>
        <tag>游戏设置</tag>
      </tags>
  </entry>
  <entry>
    <title>【Lua杂谈】lua专用rpc协议sproto——基础介绍&amp;用于协议测试的二次开发</title>
    <url>/2019/09/12/luatalk/sproto/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>rpc（远程过程调用），是不同主机间的交互的机制之一。好比说，我们想要获取服务器的某个资源，我们就可以发送一条讯息给服务器，然后服务器解析信息，再返回推送资源的信息，这样，便实现了我们客户端跟服务器的相互的“远程调用”。</p>
<p>为了让不同主机之间能够相互理解发送的讯息，我们需要约定统一的信息格式标准，使得不同的主机可以发送基于这个信息格式的讯息，也可以解析这个格式。这种标准，我们称之为协议（protocol）。</p>
<p>Lua中协议选择有许多种，protobuf、json均可。但是今天，就稍微介绍一下云风同志当年为lua量身设计的sproto协议以及其用于协议测试的二次开发。So, let the party begin~</p>
<h2 id="sproto协议描述"><a href="#sproto协议描述" class="headerlink" title="sproto协议描述"></a>sproto协议描述</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3Vkd3Uvc3Byb3Rv" title="https://github.com/cloudwu/sproto">sproto<i class="fa fa-external-link"></i></span>是专用于lua的协议框架，相对于protobuf跟json，sproto在数据的序列化/反序列化效率上有极大的优势。rpc中为了快速效率地传送协议数据，会将数据组装压缩发送，接收端再解压拆解数据识别消息，从而减小了网络传输的开销。这个数据处理过程便可称之为序列化/反序列化。</p>
<p>sproto的设计类似于<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy8/aGw9emgtQ04=" title="https://developers.google.com/protocol-buffers/?hl=zh-CN">protobuf<i class="fa fa-external-link"></i></span>，基本类型为<code>string</code>、<code>binary</code>、<code>integer</code>以及<code>boolean</code>四种。对于array序列的支持，则加上引用星号<code>*</code>即可；对于非整数的支持方面，用户可以parse string来处理实数，或者指定integer的小数位数来处理小数（decimal）。除此之外，用户也可以像编程里面strcut那样自定义类型，类型与类型之间也可以嵌套。</p>
<p>我们可以从<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3Vkd3Uvc3Byb3RvL2Jsb2IvbWFzdGVyL1JFQURNRS5tZA==" title="https://github.com/cloudwu/sproto/blob/master/README.md">readme<i class="fa fa-external-link"></i></span>中寻找各种例子。数据类型的例子如下：</p>
<a id="more"></a>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">.Person &#123; # . means a user defined type</span><br><span class="line">    name <span class="number">0</span> : <span class="built_in">string</span> # <span class="built_in">string</span> is a build-in type.</span><br><span class="line">    id <span class="number">1</span> : integer</span><br><span class="line">    email <span class="number">2</span> : <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">    .PhoneNumber &#123; # user defined type can be nest.</span><br><span class="line">        number <span class="number">0</span> : <span class="built_in">string</span></span><br><span class="line">        type <span class="number">1</span> : integer</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    phone <span class="number">3</span> : *PhoneNumber # *PhoneNumber means an array of PhoneNumber.</span><br><span class="line">    height <span class="number">4</span> : integer(<span class="number">2</span>) # (<span class="number">2</span>) means a <span class="number">1</span>/<span class="number">100</span> fixed-point number.</span><br><span class="line">    data <span class="number">5</span> : binary # Some binary data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.AddressBook &#123;</span><br><span class="line">    person <span class="number">0</span> : *Person(id) # (id) is <span class="keyword">optional</span>, means Person.id is main index.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个用户自定义的数据类型需要包含子项的名称、编号（序列化时排序）与子项数据类型。基于这些数据类型，我们可以约定各种各样的协议。比如：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">foobar <span class="number">1</span> &#123; # define a new protocol (for RPC used) with tag <span class="number">1</span></span><br><span class="line">    request Person # Associate the type Person with foobar.request</span><br><span class="line">    response &#123; # define the foobar.response type</span><br><span class="line">        ok <span class="number">0</span> : boolean</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，协议foobar（编号为1）请求与返回的协议数据格式便一目了然了。</p>
<p>至于协议的序列化设计，在云风所著<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNvZGluZ25vdy5jb20vMjAxNC8wNy9lam95cHJvdG8uaHRtbA==" title="https://blog.codingnow.com/2014/07/ejoyproto.html">《设计一种简化的 protocol buffer 协议》<i class="fa fa-external-link"></i></span>的Wire Protocol与“0 压缩”章节中已经详尽描述了，此处便不再赘述。</p>
<h2 id="sproto协议收发"><a href="#sproto协议收发" class="headerlink" title="sproto协议收发"></a>sproto协议收发</h2><p>收发协议的例子可以查看skynet网络框架的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3Vkd3Uvc2t5bmV0L3dpa2kvU3Byb3Rv" title="https://github.com/cloudwu/skynet/wiki/Sproto">Sproto<i class="fa fa-external-link"></i></span>一章。</p>
<p>sproto本身也分两层，当我们使用sproto的时候，通常调用sproto的lua嵌入层模块<code>sproto.lua</code>中的函数。真实收发sproto协议时，需要带上协议包头<code>header</code>表现协议的外在信息，比如：</p>
<ul>
<li>type 协议的类型——REQUEST或RESPONSE</li>
<li>session 协议的标识——通过这个标识对应请求与响应</li>
</ul>
<p>一开始，我们可以采用<code>sproto.parse</code>或<code>sproto.new</code>把自己储存的协议定义解析至内存里。通过<code>local host = sproto:host(包头名)</code>，我们便可指定包头。之后，通过<code>host:attach(解析的协议)</code>，我们可以创建一个回调函数，用来打包每个协议数据包，而相对地，通过<code>host:dispatch</code>，就可以解析每一个传输过来的协议数据了。具体操作在github项目上的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3Vkd3Uvc3Byb3RvL2Jsb2IvbWFzdGVyL3Nwcm90by5sdWE=" title="https://github.com/cloudwu/sproto/blob/master/sproto.lua">sproto.lua<i class="fa fa-external-link"></i></span>都能看到，例子则可以查看<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3Vkd3Uvc3Byb3RvL2Jsb2IvbWFzdGVyL3Rlc3RycGMubHVh" title="https://github.com/cloudwu/sproto/blob/master/testrpc.lua">testrpc.lua<i class="fa fa-external-link"></i></span>。</p>
<h2 id="用于协议测试的二次开发"><a href="#用于协议测试的二次开发" class="headerlink" title="用于协议测试的二次开发"></a>用于协议测试的二次开发</h2><p>要测试sproto，首先需要导出所有协议。在官方的实现中，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3Vkd3Uvc3Byb3RvL2Jsb2IvbWFzdGVyL3Nwcm90by5j" title="https://github.com/cloudwu/sproto/blob/master/sproto.c">sproto.c<i class="fa fa-external-link"></i></span>的<code>void sproto_dump(struct sproto *s)</code>函数可以把所有协议都print出来，对应的lua接口是<code>require(&quot;sproto.core&quot;).dumpproto(解析的协议.__cobj))</code>。而在笔者自己fork的项目中，就修改了<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9zcHJvdG8vYmxvYi9tYXN0ZXIvbHNwcm90by5j" title="https://github.com/utmhikari/sproto/blob/master/lsproto.c">lsproto.c（lua注册层）<i class="fa fa-external-link"></i></span>的实现，增加了totable的功能。通过totable导出之后，在协议测试过程中统计协议信息就不是什么难题了。</p>
<p>而协议测试的一个必备功能就是从工具端发送协议，（并非从真实客户端发送），因此首先我们也需要魔改<code>sproto.lua</code>来便利测试。我们可以观察<code>sproto:host</code>函数：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sproto:host</span><span class="params">( packagename )</span></span></span><br><span class="line">    packagename = packagename <span class="keyword">or</span>  <span class="string">"package"</span></span><br><span class="line">    <span class="keyword">local</span> obj = &#123;</span><br><span class="line">        __proto = self,</span><br><span class="line">        __package = <span class="built_in">assert</span>(core.querytype(self.__cobj, packagename), <span class="string">"type package not found"</span>),</span><br><span class="line">        __session = &#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setmetatable</span>(obj, host_mt)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其中的<code>__session</code>用于缓存每一个指定了session的包，这个缓存过程是在上面所述<code>host:attach</code>里打包回调函数实现的：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">host:attach</span><span class="params">(sp)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(name, args, session, ud)</span></span></span><br><span class="line">        <span class="keyword">local</span> proto = queryproto(sp, name)</span><br><span class="line">        header_tmp.<span class="built_in">type</span> = proto.tag</span><br><span class="line">        header_tmp.session = session</span><br><span class="line">        header_tmp.ud = ud</span><br><span class="line">        <span class="keyword">local</span> header = core.encode(self.__package, header_tmp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> session <span class="keyword">then</span></span><br><span class="line">            self.__session[session] = proto.response <span class="keyword">or</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> proto.request <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> content = core.encode(proto.request, args)</span><br><span class="line">            <span class="keyword">return</span> core.pack(header ..  content)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> core.pack(header)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>因此，如果要实现从工具端凭空发送协议的话，可以另外在host的obj中增加<code>__name</code>缓存每个协议名的发送信息。要凭空发一条协议时，如果<code>__name</code>中没有缓存，就再凭空生成一个session，而如果有，就根据缓存中是否包含session来判断需不需要凭空生成session。通过修改<code>host</code>与<code>attach</code>函数，就可以满足这些需求啦~</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不论是sproto，还是啥，协议测试本身实现方案众多，需求也千变万化，单靠这一篇文章，难以完全说明。</p>
<p>路漫漫其修远兮~</p>
]]></content>
      <categories>
        <category>Lua杂谈</category>
      </categories>
      <tags>
        <tag>lua</tag>
        <tag>sproto</tag>
        <tag>协议</tag>
        <tag>协议测试</tag>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>【从零单排Golang】第三话：利用docker client本地部署MySQL</title>
    <url>/2019/09/01/gofromzero/03_docker_client/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9nb2Zyb216ZXJv" title="https://github.com/utmhikari/gofromzero">Github传送门<i class="fa fa-external-link"></i></span></p>
<p>最近回忆起了在学校那会儿趣事：刚开始上数据库原理课程，一开始装Microsoft SQL Server，全班同学都在吐槽，怨声载道——这个说数据库咋启动不了，那个说数据库咋卸载不干净，个个焦头烂额，实在是好一番风景。唉，那时候就在想，要是有一个类似于软件管家的东西托管Microsoft SQL Server，让我们一键安装/卸载，可不就好了。</p>
<p>进入工业界，接触了运维方面的知识，才了解到<span class="exturl" data-url="aHR0cHM6Ly93d3cuZG9ja2VyLmNvbS8=" title="https://www.docker.com/">docker<i class="fa fa-external-link"></i></span>的存在。不同于当年常用的虚拟机软件（VMWare WorkStation），docker并未对操作系统的硬件支撑做虚拟化，只是操作系统的进程，但却模拟了一个操作系统的环境，因此相对于虚拟机而言，docker更加轻量。轻量的运行环境意味着基于docker的部署，在管理与调度上会更加容易。看，kubernetes！</p>
<p>再回到我们的学习生活，拿MySQL为例吧——有了docker，安装卸载MySQL，就会变得无比容易。首先<code>docker pull mysql</code>；而后整理一下配置——通过<code>-v</code>映射数据在本地的存储路径，通过<code>-p</code>暴露出来mysql容器的端口，通过<code>-e</code>设置MySQL密码等环境变量；之后<code>docker run</code>带上上面的设置，我们的MySQL就启动了！要彻底卸载的话，只需要三行命令：<code>docker stop ${MySQL容器ID}</code>、<code>docker rm ${MySQL容器ID}</code>与<code>docker image rm ${MySQL镜像ID}</code>，就ok了，是不是EZPZ？</p>
<p>正好，docker是基于Golang编写。因此本期从零单排，我们就用Golang来挑战一下如何与docker交互吧~</p>
<h2 id="编写Golang程序部署MySQL"><a href="#编写Golang程序部署MySQL" class="headerlink" title="编写Golang程序部署MySQL"></a>编写Golang程序部署MySQL</h2><p>首先，我们研究一下相关的技术栈：官方提供的Golang客户端库<span class="exturl" data-url="aHR0cHM6Ly9nb2RvYy5vcmcvZ2l0aHViLmNvbS9kb2NrZXIvZG9ja2VyL2NsaWVudA==" title="https://godoc.org/github.com/docker/docker/client">docker client<i class="fa fa-external-link"></i></span>为Golang与docker间搭建了桥梁，其实质是对<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL2FwaS92MS4yNC8=" title="https://docs.docker.com/engine/api/v1.24/">docker engine api<i class="fa fa-external-link"></i></span>的抽象；而docker engine api实质则是一个HTTP后端，是对docker内部镜像与容器管理功能的抽象。</p>
<p>通过docker client库，我们只需关心相关的参数输入。库中的方法会自动拼装参数，发送至docker engine api，从而实现交互。docker client的一些小例子，可以参考<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZGV2ZWxvcC9zZGsvZXhhbXBsZXMv" title="https://docs.docker.com/develop/sdk/examples/">这里<i class="fa fa-external-link"></i></span>。</p>
<p>接下来，我们必须研究一下，要部署MySQL容器，需要有哪些步骤：</p>
<a id="more"></a>
<ul>
<li>登录docker hub</li>
<li>拉取MySQL镜像</li>
<li>设置参数，启动容器</li>
<li>开启日志</li>
</ul>
<p>这四个步骤，我们可以抽象成为四个func：</p>
<ul>
<li>login</li>
<li>pullImage</li>
<li>runImage</li>
<li>logImage</li>
</ul>
<p>那么我们的主func便是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主线程的上下文</span></span><br><span class="line"><span class="keyword">var</span> ctx = context.Background()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LaunchMySQL</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Println(<span class="string">"Creating docker client..."</span>)</span><br><span class="line">    cli, err := client.NewEnvClient()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"Error while creating docker client! %s"</span>, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> closeClient(cli)</span><br><span class="line">    login(cli)</span><br><span class="line">    pullImage(cli)</span><br><span class="line">    id := runImage(cli)</span><br><span class="line">    logImage(cli, id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>四个步骤，我们分开来看：</p>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(cli *client.Client)</span></span> &#123;</span><br><span class="line">    log.Println(<span class="string">"Logging in docker registry..."</span>)</span><br><span class="line">    ok, err := cli.RegistryLogin(ctx, types.AuthConfig&#123;</span><br><span class="line">        Username: <span class="string">"用户名"</span>,</span><br><span class="line">        Password: <span class="string">"密码"</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"Error while logging in docker registry! %s"</span>, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"%s --- Token: %s\n"</span>, ok.Status, ok.IdentityToken)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用<code>RegistryLogin</code>方法，即可登录docker hub，之后就免去认证的步骤了~</p>
<h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pullImage</span><span class="params">(cli *client.Client)</span></span> &#123;</span><br><span class="line">    log.Println(<span class="string">"Pulling MySQL Image..."</span>)</span><br><span class="line">    reader, err := cli.ImagePull(</span><br><span class="line">        ctx,</span><br><span class="line">        <span class="string">"docker.io/library/mysql"</span>,</span><br><span class="line">        types.ImagePullOptions&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"Error while pulling image! %s"</span>, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    _, err = io.Copy(os.Stdout, reader)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">"Successfully pulled MySQL Image!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拉取镜像步骤，需要指定镜像的完整存储位置：<code>docker.io/library/mysql</code></p>
<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create and start image</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runImage</span><span class="params">(cli *client.Client)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    log.Println(<span class="string">"Running MySQL Image..."</span>)</span><br><span class="line">    resp, err := cli.ContainerCreate(</span><br><span class="line">        ctx,</span><br><span class="line">        &amp;container.Config&#123;</span><br><span class="line">            Image: <span class="string">"mysql:latest"</span>,</span><br><span class="line">            Env: []<span class="keyword">string</span>&#123;<span class="string">"MYSQL_ROOT_PASSWORD"</span>, <span class="string">"123456"</span>&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &amp;container.HostConfig&#123;</span><br><span class="line">            PortBindings: nat.PortMap&#123;</span><br><span class="line">                <span class="string">"3306/tcp"</span>: []nat.PortBinding&#123;</span><br><span class="line">                    &#123;</span><br><span class="line">                        HostIP: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">                        HostPort: <span class="string">"3306"</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            Mounts: []mount.Mount&#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    Type:   mount.TypeBind,</span><br><span class="line">                    Source: <span class="string">"E:\\Tools\\MySQL"</span>,</span><br><span class="line">                    Target: <span class="string">"/var/lib/mysql"</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="literal">nil</span>,</span><br><span class="line">        <span class="string">"MySQLDB"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"Error while creating image! %s"</span>, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Successfully created MySQL image: %s!\n"</span>, resp.ID)</span><br><span class="line">    err = cli.ContainerStart(ctx, resp.ID, types.ContainerStartOptions&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"Error while starting image! %s"</span>, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">"Successfully ran MySQL image!"</span>)</span><br><span class="line">    <span class="keyword">return</span> resp.ID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于镜像与配置，我们便可以启动一个容器</p>
<p>在<code>Config</code>里，设置环境变量<code>MYSQL_ROOT_PASSWORD</code>为<code>123456</code>，而后在<code>HostConfig里</code>，暴露<code>3306</code>端口（MySQL默认端口）到宿主机的<code>3306</code>端口，而后宿主机的<code>E:\Tools\MySQL</code>路径与容器里<code>/var/lib/mysql</code>路径绑定，这样mysql的数据就能在我们的本机（宿主机）持久化了</p>
<h3 id="开启日志"><a href="#开启日志" class="headerlink" title="开启日志"></a>开启日志</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logImage</span><span class="params">(cli *client.Client, containerID <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    log.Println(<span class="string">"Fetching log on MySQL container..."</span>)</span><br><span class="line">    reader, err := cli.ContainerLogs(ctx, containerID, types.ContainerLogsOptions&#123;</span><br><span class="line">        ShowStdout:<span class="literal">true</span>,</span><br><span class="line">        ShowStderr:<span class="literal">true</span>,</span><br><span class="line">        Timestamps:<span class="literal">true</span>,</span><br><span class="line">        Follow:<span class="literal">true</span>,</span><br><span class="line">        Details:<span class="literal">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"Error while logging image! %s"</span>, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    _, err = io.Copy(os.Stdout, reader)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在日志选项中，把所有bool项开启，日志数据便更加细节了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>golang与docker交互的例子繁不胜数，但总归还要业务来决定使用哪些功能。</p>
<p>另外不得不说，在9102年的今天，修习技术的同学，带的电脑必须得有个docker。</p>
]]></content>
      <categories>
        <category>从零单排Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>docker</tag>
        <tag>docker client</tag>
        <tag>MySQL</tag>
        <tag>docker API</tag>
      </tags>
  </entry>
  <entry>
    <title>【Lua杂谈】一文上手coroutine协程</title>
    <url>/2019/08/25/luatalk/coroutine/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>提到lua，就不得不提协程coroutine。coroutine是lua的一种内在机制，为lua提供了原生的异步支持。从用户层面来看，用户不需关心coroutine的内在实现，而只需要用coroutine调度function即可，因此非常方便。</p>
<p>对于一个function而言，coroutine可以将function的代码分片，使得一个function可以分阶段运行。在实现上，function的状态管理会与CPU的机制相似。如果把一个function当做一个任务来看待的话，在coroutine的封装下，这个任务会被分解成多个阶段的子任务。这样，我们就可以把多个任务的子任务相互协调调度，实现更加灵活的功能交互。</p>
<p>因此，本期Lua杂谈，就来小试一抔coroutine的使用吧。</p>
<h2 id="coroutine的基本用法"><a href="#coroutine的基本用法" class="headerlink" title="coroutine的基本用法"></a>coroutine的基本用法</h2><p>官方5.3.5版本的coroutine库，提供了如下的接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lcorolib.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> luaL_Reg co_funcs[] = &#123;</span><br><span class="line">  &#123;<span class="string">"create"</span>, luaB_cocreate&#125;,</span><br><span class="line">  &#123;<span class="string">"resume"</span>, luaB_coresume&#125;,</span><br><span class="line">  &#123;<span class="string">"running"</span>, luaB_corunning&#125;,</span><br><span class="line">  &#123;<span class="string">"status"</span>, luaB_costatus&#125;,</span><br><span class="line">  &#123;<span class="string">"wrap"</span>, luaB_cowrap&#125;,</span><br><span class="line">  &#123;<span class="string">"yield"</span>, luaB_yield&#125;,</span><br><span class="line">  &#123;<span class="string">"isyieldable"</span>, luaB_yieldable&#125;,</span><br><span class="line">  &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用户可以通过<code>coroutine.wrap</code>与<code>coroutine.create</code>两种方式封装一个function（任务）。通过<code>wrap</code>封装任务会返回一个纯粹的lua函数（type为function），而用<code>create</code>封装则返回的是一个封装好的线程。</p>
<p>在Lua中，线程thread与协程coroutine的概念内涵有较多相似之处，但我们可以认为，线程是更加宏观广泛的概念，协程则是一种特殊的线程。线程强调的不同的<code>routine</code>之间运行是否独立；而协程强调的则是不同<code>routine</code>之间具有相互<code>co</code>的协作功能。</p>
<p>基于这两种方式调度任务的代码写法大同小异。以下以<code>create</code>封装任务为例，我们一起看看会是怎样的进行——</p>
<a id="more"></a>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">output</span><span class="params">(co, ...)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Info:"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\tSTATUS:"</span>, coroutine.<span class="built_in">status</span>(co))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\tRUNNING:"</span>, coroutine.<span class="built_in">running</span>())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\tYIELDABLE:"</span>, coroutine.isyieldable())</span><br><span class="line">    <span class="keyword">if</span> ... <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Output: "</span>)</span><br><span class="line">        <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(&#123;...&#125;) <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">""</span>, <span class="built_in">tostring</span>(v))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"----------------------------------------\n"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> co</span><br><span class="line"></span><br><span class="line">co = coroutine.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">(a, b)</span></span></span><br><span class="line">    <span class="keyword">local</span> ab = a + b</span><br><span class="line">    <span class="built_in">output</span>(co)</span><br><span class="line">    <span class="keyword">local</span> c, d = coroutine.<span class="built_in">yield</span>(ab)</span><br><span class="line">    coroutine.<span class="built_in">resume</span>(coroutine.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span> <span class="params">(co_thread)</span></span> <span class="built_in">output</span>(co_thread) <span class="keyword">end</span>), co)</span><br><span class="line">    <span class="keyword">local</span> cd = c + d</span><br><span class="line">    <span class="built_in">output</span>(co)</span><br><span class="line">    <span class="keyword">local</span> e, f = coroutine.<span class="built_in">yield</span>(cd)</span><br><span class="line">    <span class="built_in">output</span>(co)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tostring</span>(e) .. <span class="built_in">tostring</span>(f)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> ok1, ret1 = coroutine.<span class="built_in">resume</span>(co, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">output</span>(co, <span class="built_in">tostring</span>(ok1) .. <span class="string">": "</span> .. <span class="built_in">tostring</span>(ret1))</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> ok2, ret2 = coroutine.<span class="built_in">resume</span>(co, <span class="number">11</span>, <span class="number">22</span>)</span><br><span class="line"><span class="built_in">output</span>(co, <span class="built_in">tostring</span>(ok2) .. <span class="string">": "</span> .. <span class="built_in">tostring</span>(ret2))</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> ok3, ret3 = coroutine.<span class="built_in">resume</span>(co, <span class="number">111</span>, <span class="number">222</span>)</span><br><span class="line"><span class="built_in">output</span>(co, <span class="built_in">tostring</span>(ok3) .. <span class="string">": "</span> .. <span class="built_in">tostring</span>(ret3))</span><br></pre></td></tr></table></figure>
<p>我们首先定义了函数<code>output</code>函数输出当前各线程的状态（普通主线程、协程均可）。在<code>coroutine</code>中封装了以下的功能查看线程信息：</p>
<ul>
<li><code>coroutine.status</code>：指定一个线程，返回该线程的状态，可以是<code>suspended（没运行，或被切出）</code>、<code>running（正在运行）</code>、<code>dead（任务完成，或遇到错误）</code>以及<code>normal（正调着另外一个协程）</code>四种之一。</li>
<li><code>coroutine.running</code>：返回当前线程以及是否为主线程的boolean。</li>
<li><code>coroutine.isyieldable</code>：返回当前线程是否具有<code>yield</code>切出功能，如果是普通主线程，或者是不支持yield的C编写的线程，就不能切出。</li>
</ul>
<p>之后定义了协程<code>co</code>，采用<code>create</code>封装一个任务。封装完之后，就试着跑一下。</p>
<p>我们先看看最后的输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Info:</span><br><span class="line">        STATUS: running</span><br><span class="line">        RUNNING:        thread: 00000000006ee6b8        false</span><br><span class="line">        YIELDABLE:      true</span><br><span class="line">----------------------------------------</span><br><span class="line"></span><br><span class="line">Info:</span><br><span class="line">        STATUS: suspended</span><br><span class="line">        RUNNING:        thread: 00000000006e5ef8        true</span><br><span class="line">        YIELDABLE:      false</span><br><span class="line">Output:</span><br><span class="line">        true: 3</span><br><span class="line">----------------------------------------</span><br><span class="line"></span><br><span class="line">Info:</span><br><span class="line">        STATUS: normal</span><br><span class="line">        RUNNING:        thread: 00000000006f2e28        false</span><br><span class="line">        YIELDABLE:      true</span><br><span class="line">----------------------------------------</span><br><span class="line"></span><br><span class="line">Info:</span><br><span class="line">        STATUS: running</span><br><span class="line">        RUNNING:        thread: 00000000006ee6b8        false</span><br><span class="line">        YIELDABLE:      true</span><br><span class="line">----------------------------------------</span><br><span class="line"></span><br><span class="line">Info:</span><br><span class="line">        STATUS: suspended</span><br><span class="line">        RUNNING:        thread: 00000000006e5ef8        true</span><br><span class="line">        YIELDABLE:      false</span><br><span class="line">Output:</span><br><span class="line">        true: 33</span><br><span class="line">----------------------------------------</span><br><span class="line"></span><br><span class="line">Info:</span><br><span class="line">        STATUS: running</span><br><span class="line">        RUNNING:        thread: 00000000006ee6b8        false</span><br><span class="line">        YIELDABLE:      true</span><br><span class="line">----------------------------------------</span><br><span class="line"></span><br><span class="line">Info:</span><br><span class="line">        STATUS: dead</span><br><span class="line">        RUNNING:        thread: 00000000006e5ef8        true</span><br><span class="line">        YIELDABLE:      false</span><br><span class="line">Output:</span><br><span class="line">        true: 111222</span><br><span class="line">----------------------------------------</span><br></pre></td></tr></table></figure>
<p>然后再分解运行过程：</p>
<ol>
<li>主线程调用<code>coroutine.resume(co, 1, 2)</code>开始这个协程，其中<code>1, 2</code>为输入参数，对应任务function里的初始参数<code>a, b</code>。</li>
<li>在协程中，把<code>1, 2</code>相加得到<code>3</code>给<code>ab</code>变量，而后<code>output</code>线程状态：<code>status(co)</code>返回了<code>running</code>表示协程<code>co</code>正在运行，而<code>running</code>与<code>isyieldable</code>则只关心哪个线程运行了它们。在协程里，<code>running</code>会返回协程地址以及<code>false</code>，代表不是主线程；而在主线程里，<code>running</code>会返回主线程地址以及<code>true</code>。同样，在协程里，<code>isyieldable</code>会返回<code>true</code>表示该线程可被<code>yield</code>，而在主线程则不行，为<code>false</code>。后面的结果也都同样。</li>
<li>调用<code>coroutine.yield(ab)</code>切出协程，切回主线程，这一阶段返回的结果为<code>ab</code>。</li>
<li>主线程视角下，<code>coroutine.resume</code>的返回结果为当前协程这一阶段是否没有异常（<code>ok</code>）以及协程<code>yield</code>出来的返回值。因此<code>ok1</code>与<code>ret1</code>则为<code>true</code>跟<code>ab</code>。主线程调用<code>output</code>函数查看各个线程状况，可以看到<code>status(co)</code>为<code>suspended</code>，协程<code>co</code>正在暂停状态，等待下一次<code>resume</code>；而由于在主线程，<code>running</code>与<code>isyieldable</code>分别为<code>true</code>跟<code>false</code>。</li>
<li>主线程调用<code>coroutine.resume(co, 11, 22)</code>继续这个协程。在协程<code>co</code>的视角下，<code>local c, d = coroutine.yield(ab)</code>中的<code>c, d</code>，即为<code>resume</code>它的线程传进来的两个参数，在这里也就是<code>11, 22</code>了。</li>
<li>协程<code>co</code>又调起另一个协程，在另一个协程调用<code>output</code>来看原来协程<code>co</code>的<code>status</code>。嘛，这一步只是为了加一个<code>status == &quot;normal&quot;</code>的例子。</li>
<li>把<code>11 + 22</code>的结果<code>33</code>给<code>cd</code>，然后<code>output</code>线程状态，结果与步骤2相似。而后，再把<code>cd</code>给<code>yield</code>切出去。</li>
<li>主线程收到返回值<code>ok2 = true</code>以及<code>ret2 = 33</code>，而后再<code>output</code>，结果也与步骤4相似。</li>
<li>主线程再次<code>resume</code>协程<code>co</code>，输入参数<code>111, 222</code>给协程中的<code>e, f</code>，协程内部<code>output</code>状态后，最终返回了字符串<code>111222</code>，协程任务结束。此时主线程中调用<code>output(co)</code>，可以看到<code>co</code>的状态已经为<code>dead</code>。由于协程<code>co</code>没有发生异常，那么<code>dead</code>就表示协程所有的子任务都结束啦~</li>
</ol>
<p>至此，整一个<code>coroutine.create</code>的例子已经完成。而对于<code>coroutine.wrap</code>，由于返回的是一个lua函数而非线程，因此需要通过<code>pcall</code>等手段捕获错误，从而不至于断掉主线程运行。有兴趣的同学，可以一探究竟~</p>
<h2 id="coroutine与后端洋葱圈模型"><a href="#coroutine与后端洋葱圈模型" class="headerlink" title="coroutine与后端洋葱圈模型"></a>coroutine与后端洋葱圈模型</h2><p><code>coroutine</code>的重点在于<code>co</code>，在官网上，也有<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVhLm9yZy9waWwvOS4zLmh0bWw=" title="https://www.lua.org/pil/9.3.html">排列组合<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVhLm9yZy9waWwvOS4yLmh0bWw=" title="https://www.lua.org/pil/9.2.html">生产者——消费者<i class="fa fa-external-link"></i></span>等表现协同任务的例子。不过本文则要搬出我们的老朋友——后端的洋葱圈模型，示意图如下：</p>
<p><img src="/uploads/luatalk/coroutine/onion.png" alt="洋葱圈模型" title="&#39;洋葱圈模型&#39;"></p>
<p>后端对于数据规范、安全性等是相当有要求的。比如一个获取数据的请求到达后端，首先都要经过重重关卡检查请求的合法性，而后后端控制器才调用服务取出数据，最后返回时，还得再一个个关卡严查，才能把该带的数据带出去。洋葱圈模型的数据处理流水线，便是如此。</p>
<p>我们以一个例子来试试吧~</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">middleware_header</span><span class="params">(ctx)</span></span></span><br><span class="line">    ctx.header[<span class="string">"user-agent"</span>] = <span class="string">"ShangQi"</span></span><br><span class="line">    ctx.header[<span class="string">"referer"</span>] = <span class="string">"America"</span></span><br><span class="line">    coroutine.<span class="built_in">yield</span>()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">middleware_body</span><span class="params">(ctx)</span></span></span><br><span class="line">    ctx.body.data = <span class="string">"Chinese Hero"</span></span><br><span class="line">    coroutine.<span class="built_in">yield</span>()</span><br><span class="line">    <span class="keyword">if</span> ctx.body.data ~= <span class="string">"Chinese Hero"</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(ctx.header[<span class="string">"user-agent"</span>] .. <span class="string">" is not a Chinese Hero!"</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">controller</span><span class="params">(ctx)</span></span></span><br><span class="line">    <span class="keyword">if</span> ctx.header[<span class="string">"referer"</span>] ~= <span class="string">"China"</span> <span class="keyword">then</span></span><br><span class="line">        ctx.body.data = <span class="string">"You are not Chinese!"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> context = &#123; header = &#123;&#125;, body = &#123;&#125; &#125;</span><br><span class="line">handle(context, middleware_header, middleware_body, controller)</span><br></pre></td></tr></table></figure>
<p>在这个场景里，我们要处理的数据叫<code>context</code>。<code>context</code>先经过两个<code>middleware</code>中间件<code>header</code>与<code>body</code>，通过两个关卡，才进入到正式的掌权端<code>controller</code>。</p>
<p>在<code>header</code>中间件中，<code>context</code>为自己的<code>header</code>加上了两个头衔：<code>user-agent</code>表示用户代理身份，这里叫做<code>ShangQi</code>；<code>referer</code>表示从哪里来，这里叫做<code>America</code>。</p>
<p>在<code>body</code>中间件中，<code>context</code>为自己的<code>body</code>加上了<code>Chinese Hero</code>的数据，然后切出不管，并且打赌，如果切回来不是<code>Chinese Hero</code>的话，就告诉全世界，这个<code>user-agent</code>身份不能代表<code>Chinese Hero</code>。</p>
<p>但在真正掌握控制大权的<code>controller</code>中，则不会为标榜<code>Chinese Hero</code>的非中国人买单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ShangQi is not a Chinese Hero!</span><br></pre></td></tr></table></figure>
<p>那么，怎样实现这一过程呢？我们看一下整一个代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">(ctx, ...)</span></span></span><br><span class="line">    <span class="keyword">local</span> handlers = &#123;&#125;</span><br><span class="line">    <span class="keyword">local</span> args = <span class="built_in">table</span>.pack(...)</span><br><span class="line">    <span class="comment">-- 检查长度</span></span><br><span class="line">    <span class="keyword">if</span> #args == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, <span class="string">"Error! Expected at least one handler (controller) for context!"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 把middleware跟controller用coroutine.create封装，插入到handlers中</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, #args <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">type</span>(args[i]) == <span class="string">"function"</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>, <span class="string">"Error! Handler "</span> .. <span class="built_in">tostring</span>(i) .. <span class="string">" is not a function!"</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(handlers, coroutine.<span class="built_in">create</span>(args[i]))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 客户端 --&gt; middleware（上半部分） --&gt; controller</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, #handlers <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> ok, err = coroutine.<span class="built_in">resume</span>(handlers[i], ctx)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> tag = <span class="string">"controller"</span></span><br><span class="line">            <span class="keyword">if</span> i ~= #handlers <span class="keyword">then</span></span><br><span class="line">                tag = <span class="string">"middleware #"</span> .. <span class="built_in">tostring</span>(i)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>, <span class="string">"Error at "</span> .. tag .. <span class="string">"! "</span> .. err</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 移除controller</span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">remove</span>(handlers)</span><br><span class="line">    <span class="comment">-- 客户端 &lt;-- middleware（下半部分） &lt;-- controller</span></span><br><span class="line">    <span class="keyword">while</span> #handlers &gt; <span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> co = <span class="built_in">table</span>.<span class="built_in">remove</span>(handlers)</span><br><span class="line">        <span class="keyword">if</span> coroutine.<span class="built_in">status</span>(co) == <span class="string">"suspended"</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> ok, err = coroutine.<span class="built_in">resume</span>(co, ctx)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>, <span class="string">"Error at middleware #"</span> .. <span class="built_in">tostring</span>(#handlers + <span class="number">1</span>) .. <span class="string">"! "</span> .. err</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">-- strict mode, call coroutine.yield() forcibly</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>, <span class="string">"Error at middleware #"</span> .. <span class="built_in">tostring</span>(#handlers + <span class="number">1</span>) .. <span class="string">"! Please cast coroutine.yield() in strict mode!"</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>我们可以把所有的中间件与控制器处理任务都封装成协程，然后入栈（<code>table.insert</code>）。最后一个处理者（handler），也就是控制器处理完毕后，开始将一个个协程pop（<code>table.remove</code>）出来，再<code>resume</code>，这样，就能够模拟洋葱圈模型的操作了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>lua的coroutine非常灵活。配合各种底层架构，可以玩出很多种不同的花样。多上手试试吧~</p>
]]></content>
      <categories>
        <category>Lua杂谈</category>
      </categories>
      <tags>
        <tag>异步</tag>
        <tag>lua</tag>
        <tag>coroutine</tag>
        <tag>协程</tag>
        <tag>洋葱圈模型</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】iOS审核&amp;静态扫描二三事</title>
    <url>/2019/08/19/testlife/ios_review/</url>
    <content><![CDATA[<p>我们的日常生活离不开手机，有些同学喜欢用国产的安卓机，而另一些同学喜欢用简约的iPhone。</p>
<p>对比安卓和iOS的软件生态，我们可以发现：安卓软件的投放渠道繁多，题材花样繁复，质量大小不一，而iOS的投放渠道则为App Store独家，相对安卓软件来讲，不仅质量均衡，而且用户不必担心手机病毒的困扰。这一点，就归功于App Store严格的审核制度。</p>
<a id="more"></a>
<p>在iOS App的研发流程中，提审iOS包的环节，一般由运营组完成。在正式提审至App Store前，运营组可能会对研发交付iOS包做人工/静态扫描检查，从而识别并修复提审包存在的违规情况。由于iOS审核规则严厉，周期较长，如果被一次打回的话，后面再等上架成功可就耽误时间了。因此对iOS应用上架而言，预审步骤是非常有必要的。</p>
<p>测试（质量保障）的工作之一便是保证研发交付的效率。由于iOS审核打回对交付流程的阻塞较大，因此实施测试左移，将部分iOS预审流程移至交付运营前实现，这样便能够增加更早发现自家产品违规的概率。苹果的审核流程通常会包括机审与人审两大块，为了减少工作成本，引入模拟机审流程——ipa包静态扫描，是最为常见的做法。</p>
<p>静态扫描的目的是检测提审包资源的完整性与合法性。<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2NuL2FwcC1zdG9yZS9yZXZpZXcvZ3VpZGVsaW5lcy8=" title="https://developer.apple.com/cn/app-store/review/guidelines/">App Store审核指南<i class="fa fa-external-link"></i></span>为iOS开发者们提供了App审核的参考，而静态扫描这一块，则主要关心第二类（性能）以及第四类（设计）等相关准则，其它的模块要预审的话，需要加持人力得以确认。</p>
<p>ipa包本质是一个zip包。如果有同学好奇拆过的话，可以看到ipa包包含了许多内容：</p>
<ul>
<li>Info.plist 元数据</li>
<li>_CodeSignature 数字签名</li>
<li>AppIcon 图标</li>
<li>二进制可执行文件</li>
<li>et cetera</li>
</ul>
<p>对于静态扫描，则至少需要检查以下的点：</p>
<ul>
<li>元数据：元数据的条例繁多，需要参考<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL0dlbmVyYWwvUmVmZXJlbmNlL0luZm9QbGlzdEtleVJlZmVyZW5jZS9BcnRpY2xlcy9BYm91dEluZm9ybWF0aW9uUHJvcGVydHlMaXN0RmlsZXMuaHRtbCMvL2FwcGxlX3JlZi9kb2MvdWlkL1RQNDAwMDkyNTQtU1cx" title="https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/AboutInformationPropertyListFiles.html#//apple_ref/doc/uid/TP40009254-SW1">About Information Property List Files<i class="fa fa-external-link"></i></span>逐项检查</li>
<li>证书：需要结合元数据检查，保证证书有效期，并且为是App Store的发布版本</li>
<li>图片：需要保证有特定规格的图片存在，参考<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2Rlc2lnbi9odW1hbi1pbnRlcmZhY2UtZ3VpZGVsaW5lcy9pb3Mvb3ZlcnZpZXcvdGhlbWVzLw==" title="https://developer.apple.com/design/human-interface-guidelines/ios/overview/themes/">Human Interface Guidelines<i class="fa fa-external-link"></i></span></li>
<li>二进制文件：需要保证<span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFwcGxlLmNvbS9hcHAtc3RvcmUtY29ubmVjdC8/bGFuZz16aC1jbiMvZGV2NjExZTBhMjFm" title="https://help.apple.com/app-store-connect/?lang=zh-cn#/dev611e0a21f">规格<i class="fa fa-external-link"></i></span>，以及不得包含官方禁止开发者直接使用的api。二进制文件的扫描，相当于对iOS可执行文件的逆向。因此，需要对可执行文件<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8yZWIzNTFiMGNlNTc=" title="https://www.jianshu.com/p/2eb351b0ce57">mach-o<i class="fa fa-external-link"></i></span>的结构以及相关逆向工具（比如<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmVjaHJpczAwL2FydGljbGUvZGV0YWlscy84MTU2MTYyNw==" title="https://blog.csdn.net/lovechris00/article/details/81561627">otool<i class="fa fa-external-link"></i></span>）的使用进行熟悉</li>
</ul>
<p>从整个App的审核来看，相对于人工检查，静态扫描的审核点覆盖度相对较低，但却可以对直接对某些审核痛点（比如禁止api）进行检测。因此，聪明的你，也一起来和苹果斗智斗勇吧~</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>iOS</tag>
        <tag>App Store</tag>
        <tag>静态扫描</tag>
        <tag>iOS审核</tag>
      </tags>
  </entry>
  <entry>
    <title>【GitHub探索】安卓自动化测试工具SoloPi</title>
    <url>/2019/08/11/githubdiscovery/solopi/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着MTSC2019的召开，八月份各种测试工具相继开源，其中一款名为<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaXBheS9Tb2xvUGk=" title="https://github.com/alipay/SoloPi">SoloPi<i class="fa fa-external-link"></i></span>的安卓自动化测试在月trending榜中排位靠前。移动App自动化测试是当前测试领域的风口之一，并且要开发一款兼容性好、需求适应多样的App，也并非三日之寒。为此，欢迎本期GitHub探索的主角——SoloPi！</p>
<p>测试环境为华为P20Pro，安卓版本8.1.0，SoloPi版本为0.9.1，下载地址可进入<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaXBheS9Tb2xvUGkvcmVsZWFzZXM=" title="https://github.com/alipay/SoloPi/releases">GitHub Release<i class="fa fa-external-link"></i></span>查看。由于只有一个测试机，所以本次仅测试SoloPi的性能测试以及录制回放功能。下面，让我们开始试水吧~</p>
<a id="more"></a>
<p><img src="/uploads/githubdiscovery/solopi/main.png" alt="SoloPi主界面"></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先需要准备adb，在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vc3R1ZGlvL3JlbGVhc2VzL3BsYXRmb3JtLXRvb2xz" title="https://developer.android.com/studio/releases/platform-tools">官网SDK Platform Tools<i class="fa fa-external-link"></i></span>即可下载到。下载后解压，把<code>platform-tools</code>目录设置为环境变量<code>ANDROID_SDK</code>，然后再加到<code>PATH</code>中，这样一方面可以被SoloPi识别，另一方面可以直接cmd adb了。</p>
<p>手机USB接通后，通过<code>adb devices</code>可以看到已经连接上的终端。而后按照SoloPi的指示开启权限or开启adb的WIFI调试即可</p>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>不同于传统的通过native导出性能数据到PC端的方式，SoloPi在移动端内部提供图层查看各项性能数据。SoloPi支持的性能指标极其完善，并且提供加压的操作以模拟弱网等场景，非常fit各类测试的需求。</p>
<p><img src="/uploads/githubdiscovery/solopi/profile.png" alt="SoloPi性能测试"></p>
<p>以皇室战争为例，我们可以在游戏过程中即时地查看性能数据：</p>
<p><img src="/uploads/githubdiscovery/solopi/profile_cr.png" alt="皇室战争性能"></p>
<p>如果需要有记录性能数据的需求，也可以利用SoloPi提供的录制功能。录制完成后，可以在SoloPi界面里查看录制数据：</p>
<p><img src="/uploads/githubdiscovery/solopi/profile_cr_record.png" alt="皇室战争性能录制"></p>
<p>由于移动App的限制，在性能数据曲线与实际操作的关联这一块，SoloPi仍然具有局限性。但是我们通过下面的录制回放功能，可以稍微弥补这方面的不足</p>
<h2 id="录制回放"><a href="#录制回放" class="headerlink" title="录制回放"></a>录制回放</h2><p>SoloPi最引人注目的功能当属录制回放。录制回放功能对Native App支持较好，结合安卓控件监测与图像识别技术识别UI从而记录用户操作。</p>
<p>以九游为例，我们的录制界面如下：</p>
<p><img src="/uploads/githubdiscovery/solopi/record_9game.png" alt="九游录制"></p>
<p>录制功能不仅支持基本的用户操作（拖拽、点击、长按、输入）及操作的条件界定（exists？assert？match string？），而且支持系统按键、gc、adb等操作。我们可以把它当做移动端WebDriver来使用，并且在录制过程中我们也可以调用性能录制，从而将性能数据与测试过程关联。</p>
<p>录制功能采用用户指定操作+执行的机制，因此会有一定的局限性，比如对于即时性较强的游戏（CR之类）而言，就不能满足测试的需求。但对于一般的App而言，是绰绰有余的。</p>
<p>录制完毕后，我们可以编辑录制的用例：</p>
<p><img src="/uploads/githubdiscovery/solopi/case_edit.png" alt="用例编辑"></p>
<p>编辑用例的操作，对于不熟悉安卓App的同学来说会有不低的壁垒。如果我们确定用力流程，便可以点击回放。我们可以查看回放的结果以及每个步骤的细节，从而排查用例中存在的问题：</p>
<p><img src="/uploads/githubdiscovery/solopi/case_result.png" alt="回放结果"></p>
<p><img src="/uploads/githubdiscovery/solopi/case_step.png" alt="用例步骤"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SoloPi所支持的功能满足了大量移动端测试的需求，在自动化方面已经打通了用例录制、性能录制以及用例管理三块。实际入手尝试来看，除了在用例管理以及编辑方面会有略微不便捷的地方之外，其它的测试需求都非常顺利，能够减少了业务测试人员自动化编写的成本，是非常有价值的。</p>
<p>由于前述提到移动App的局限性，因此希望SoloPi后续能积极向外打通链路，让业务实现（尤其是录制结果分析）显得更加灵活。</p>
]]></content>
      <categories>
        <category>GitHub探索</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>录制回放</tag>
        <tag>SoloPi</tag>
        <tag>Android</tag>
        <tag>性能测试</tag>
      </tags>
  </entry>
  <entry>
    <title>【从零单排Golang】第二话：初探服务端CRUD，gin+gorm黄金搭档</title>
    <url>/2019/08/04/gofromzero/02_gin_gorm/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9nb2Zyb216ZXJv" title="https://github.com/utmhikari/gofromzero">Github传送门<i class="fa fa-external-link"></i></span></p>
<p>学一门新语言，如果太专注于语法，那肯定学的不够快。如果有一定的需求目标，带着这个目标去学习一门新语言，这样才能学得快。</p>
<p>工作中写后端的时间比例不在少数，而且传闻Go也因其适用于服务端而著名。在Go社区中最为火热的服务端框架跟数据库抽象ORM层当属<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpbi1nb25pYy9naW4=" title="https://github.com/gin-gonic/gin">gin<i class="fa fa-external-link"></i></span>跟<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ppbnpodS9nb3Jt" title="https://github.com/jinzhu/gorm">gorm<i class="fa fa-external-link"></i></span>了，因此本期单排的目标便是用gin+gorm打一个简易的框架，实现基本CRUD的目标。走你~</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在<a href="https://utmhikari.github.io/2019/07/20/gofromzero/01_first_code/">第一话</a>中已经大致了解了Go项目的生成，故本次gin+gorm的搭建也以此为基础。</p>
<p>服务端领域的各种术语在不同的场景跟技术栈下有不同的含义。但总体来讲，一个简单的服务端App都会有以下的层次：</p>
<ul>
<li>校验层：预处理请求，校验请求是否合法（大小、字段、cors、oauth之类），并判断是否拦截。通常也被称作中间层middleware</li>
<li>控制层：处理合法请求的起点——收集整理相应服务模块的结果，判断请求是否合理，决定返回的数据，遵循宽进严出原则。一般叫做Controller，gin里面叫做handler。</li>
<li>业务层：处理真实的业务逻辑，通过和数据层以及各个业务模块的交互从而校验并构建业务数据，交由控制层决策，一般可称之为service</li>
<li>数据层：抽象持久化数据（数据库）到代码层面并提供一系列交互访问的方法，ORM与DAO层都算在内</li>
</ul>
<p>基于以上结构，大致构建了以下的目录结构：</p>
<a id="more"></a>
<ul>
<li>root<ul>
<li>database 数据层<ul>
<li>main.go 封装gorm</li>
<li>xxx.go 表xxx</li>
</ul>
</li>
<li>handler 控制层<ul>
<li>base.go 封装基本返回方法</li>
<li>xxx.go 模块xxx控制器</li>
</ul>
</li>
<li>service 业务层<ul>
<li>xxx 业务模块xxx（防止相互引用，用文件夹隔开）<ul>
<li>abc.go 模块xxx的abc业务</li>
</ul>
</li>
</ul>
</li>
<li>app.go 服务端app</li>
<li>router.go 服务端路由</li>
</ul>
</li>
</ul>
<p>本次demo没有弄校验层(router里设置各种middleware)，直接从handler开始干拉~</p>
<h2 id="gorm封装"><a href="#gorm封装" class="headerlink" title="gorm封装"></a>gorm封装</h2><p>gorm实现了不同数据库对Go对象的映射。gorm本身提供了默认的表Model（id、增删改时间），但实际还是建议自行封装一层，以增加可控性。</p>
<p>这里以mysql交互为例，实现了一个封装例子。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// database/main.go</span></span><br><span class="line"><span class="keyword">package</span> database</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DBModel <span class="keyword">struct</span> &#123;</span><br><span class="line">    *gorm.Model</span><br><span class="line">    <span class="comment">// You can add your own model components here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DB database instance</span></span><br><span class="line"><span class="keyword">var</span> DBInstance *gorm.DB</span><br><span class="line"></span><br><span class="line"><span class="comment">// InitDB initialize DB</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitDB</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Println(<span class="string">"Initializing database..."</span>)</span><br><span class="line">    <span class="comment">// 从docker hub pull下来就好了= =</span></span><br><span class="line">    db, err := gorm.Open(<span class="string">"mysql"</span>, <span class="string">"root:123456@tcp(localhost:32773)/gofromzero?charset=utf8mb4&amp;parseTime=True&amp;loc=Local"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    DBInstance = db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假使我们创建一个User表，我们可以在另一个go文件内引用DBModel跟DBInstance，从而定义数据交互逻辑</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// database/user.go</span></span><br><span class="line"><span class="keyword">package</span> database</span><br><span class="line"></span><br><span class="line"><span class="comment">// User表的结构</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    *DBModel</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">    Age <span class="keyword">uint</span> <span class="string">`json:"age"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> userDAO <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserDAO user dao</span></span><br><span class="line"><span class="keyword">var</span> UserDAO userDAO</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create create a user record</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*userDAO)</span> <span class="title">Create</span><span class="params">(user User)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    DBInstance.AutoMigrate(&amp;User&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> DBInstance.Create(&amp;user).Error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First get the first record of user</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*userDAO)</span> <span class="title">First</span><span class="params">()</span> <span class="params">(User, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user User</span><br><span class="line">    err := DBInstance.First(&amp;user).Error</span><br><span class="line">    <span class="keyword">return</span> user, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update update user record</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*userDAO)</span> <span class="title">Update</span><span class="params">(user User)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> DBInstance.Model(&amp;User&#123;&#125;).Updates(&amp;user).Error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete set all to delete state</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*userDAO)</span> <span class="title">Delete</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> DBInstance.Delete(&amp;User&#123;&#125;).Error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在外部要跟User表交互的话，直接用<code>UserDAO</code>就可以完成需求了</p>
<h2 id="gin服务搭建"><a href="#gin服务搭建" class="headerlink" title="gin服务搭建"></a>gin服务搭建</h2><p>有了对gorm的进一步封装，我们就不需过多担心数据获取的问题。现在我们可以关注gin的写法。</p>
<p>首先建议封装一些常用的返回方法，什么success、error之类，有助于减少码量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handler/base.go</span></span><br><span class="line"><span class="keyword">package</span> handler</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Success</span><span class="params">(c *gin.Context, data <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">        <span class="string">"data"</span>: data,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Error</span><span class="params">(c *gin.Context, err error, code <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    c.JSON(code, gin.H&#123;</span><br><span class="line">        <span class="string">"err"</span>: err.Error(),</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而后在user模块的handler下，实现控制器逻辑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handler/user.go</span></span><br><span class="line"><span class="keyword">package</span> handler</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">    service <span class="string">"github.com/gofromzero/ii/service/user"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// User instance of user controller</span></span><br><span class="line"><span class="keyword">var</span> User user</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create create a user</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*user)</span> <span class="title">Create</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> userForm service.Form</span><br><span class="line">    bindErr := c.ShouldBindJSON(&amp;userForm)</span><br><span class="line">    <span class="keyword">if</span> bindErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        Error(c, bindErr, http.StatusForbidden)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    createErr := service.Create(userForm)</span><br><span class="line">    <span class="keyword">if</span> createErr != <span class="literal">nil</span>&#123;</span><br><span class="line">        Error(c, createErr, http.StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    Success(c, <span class="string">"Create user successfully!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下略，CRUD</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到我们通过一个文件夹定义了user业务层的模块。业务层代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// service/user/crud.go</span></span><br><span class="line"><span class="keyword">package</span> user</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Form <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">    Age <span class="keyword">uint</span> <span class="string">`json:"age"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create create user on form</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(form Form)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> database.UserDAO.Create(database.User&#123;</span><br><span class="line">        Name: form.Name,</span><br><span class="line">        Age: form.Age,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First get first user from database</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">()</span> <span class="params">(database.User, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> database.UserDAO.First()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update update user records</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Update</span><span class="params">(form Form)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> database.UserDAO.Update(database.User&#123;</span><br><span class="line">        Name: form.Name,</span><br><span class="line">        Age: form.Age,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete delete user records</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Delete</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> database.UserDAO.Delete()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个demo中，业务层的代码看起来有点多余，基本是纯粹调用UserDAO的方法。但实际项目写大的话，其实还会涉及到和其它模块的交互。因此，这一层的独立是有必要的。</p>
<p>最后，在路由中调用<code>handler.User</code>，我们就能很轻松地注册user模块的控制器：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Router gin router</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Router</span><span class="params">()</span> *<span class="title">gin</span>.<span class="title">Engine</span></span> &#123;</span><br><span class="line">    log.Println(<span class="string">"Registering routers..."</span>)</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    api := r.Group(<span class="string">"/api"</span>)</span><br><span class="line">    v1 := api.Group(<span class="string">"/v1"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        user := v1.Group(<span class="string">"/user"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            user.POST(<span class="string">""</span>, handler.User.Create)</span><br><span class="line">            user.GET(<span class="string">""</span>, handler.User.Get)</span><br><span class="line">            user.PUT(<span class="string">""</span>, handler.User.Update)</span><br><span class="line">            user.DELETE(<span class="string">""</span>, handler.User.Delete)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动App实例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// StartGin start gin server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartGin</span><span class="params">()</span></span> &#123;</span><br><span class="line">    database.InitDB()</span><br><span class="line">    <span class="keyword">defer</span> database.CloseDB()</span><br><span class="line">    router := Router()</span><br><span class="line">    s := &amp;http.Server&#123;</span><br><span class="line">        Addr:    <span class="string">":8080"</span>,</span><br><span class="line">        Handler: router,</span><br><span class="line">    &#125;</span><br><span class="line">    err := s.ListenAndServe()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>试试看吧~</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go在整体印象上真的很严格，甚至比Java还严格。这part的代码写起来真心不如JS轻松，但通过这些换来代码健壮性与服务性能增益，是很值得的。</p>
<p>这次项目架构的设计也仅是抛砖引玉，对gorm以及gin还没有更加深入的探究。以后可得加油~</p>
]]></content>
      <categories>
        <category>从零单排Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>后端开发</tag>
        <tag>gin</tag>
        <tag>gorm</tag>
        <tag>CRUD</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】一个测试开发的用户思维</title>
    <url>/2019/07/28/testlife/think_as_a_user/</url>
    <content><![CDATA[<p>近几天一直在思考什么是用户思维，决定结合这一年的工作，把自己的想法记录下来。</p>
<p>在这之前，自己一直秉持一种观念——测试开发从工作内容上，更加符合“开（码）发（农）”的定义，因此应当更加着重于技术深耕，并且在业务对接时，也尽可能地从从技术实现的角度去阐述观点与想法。但是在经过同事伙伴们的提点，以及和家中领导激烈讨（吵）论（架）了一番之后，这个观念就慢慢地改变了。</p>
<p>测试，不仅仅是根据需求，利用各种工具，对开发交付的产品进行功能、性能、安全等测试，发现bug而后提交复现/解决方案，从而确保产品稳定（QC）。而另一些方面在于——如何确保研发计划完备进行，预防产品设计缺陷，从而保证产品体验；如何优化产品生命周期流程，从而使产品顺利上线运营（QA）。作为偏中台的测试开发，扮演的角色更像是“优化产品生命周期”的实现者，而前线上的QA与QC，则成为了我们的用户。因此在业务对接时，首先都需要尽可能满足前线同学的需求，让他们引领效率工具/平台的设计。</p>
<a id="more"></a>
<p>以短线的小测试工具为例吧~前线的同学们都希望测试工具学习成本低，因此自己在开发测试工具时，都会时不时想念一下家中领导，希望工具的易用性能让她使用顺畅。但是，<strong>工具的易用性是必要条件，却并不是充分条件</strong>。研发测试工具，不仅仅是显示测试的数据与指标，标识数据异常，而更重要的是让测试人员通过工具，能够迅速定位缺陷的成因并制定报表与解决方案，或是确认测试过程中是否存在额外的因素影响了测试效果。因此，测试开发更要关注的，<strong>一是为什么产生了各种那样的测试需求，前因后果是什么；二是持续交付，跟进工具的使用情况，观察前线同学是如何使用工具测试以及排查问题的，从而挖掘潜在需求，设计工具的优化路线</strong>。这样，测试工具的形态，就逐步显露出来了。从这一点上来看，测试开发所要担任的角色，可能算是<strong>QA中的QA</strong>。</p>
<p>作为开发者，造轮子的人，多多少少都会拥有艺术家般的执念。艺术家失去了灵感，就只剩下一具空壳；而开发者失去了需求，就只能手指顶着键盘发呆。<strong>测试开发，是需要更加主动去获取需求的人</strong>，而灵感的最直接来源，就是前线的测试小伙伴们。优化前线伙伴的工作流程，是测试开发的一项重大任务。因此对于测试开发而言，<strong>切换思维，直接切入测试业务，从前线测试工作的角度进行沟通，从业务上减少了沟通成本，更加明确了需求；从职业成长上也形成了技术设计与实现的经验</strong>。可以说，拥有这一份技能，便是拥有了一笔宝贵的财富。</p>
<p>说到这里，不由得想到了早晨去医院看病观察到的一件事：看完病，微信付款后下楼取药，跟以前相比，现在多了一个报到的步骤——患者在报到处扫描二维码后，才知道自己在何处取药，然后只需坐等名单上有名字出现，就可以去取药了。</p>
<p>对比一下以前取药的流程，报到机的出现显著优化了取药效率。一方面，解决了不付款/付款不取造成的药物滞留问题；另一方面确定了取药顺序，让患者不用担心取药编号加塞导致迟迟拿不到药；再一方面联动自动发药机，使得药师也不必手忙脚乱。药师的工作量减少了，患者体验也起了削峰填谷的效果，总体来讲，两全其美。</p>
<p><strong>开门见山，是每个用户的希冀</strong>。作为开发者，以用户思维为原点去探索技术实现，才会有更加清晰的思路，而不至于盲目。一年来，最大的收获是深刻地了解到技术知识与思维固然重要，但带动技术思维提升的，是用户思维主导的业务需求。因此，希望日后能够培养更敏锐的用户嗅觉，从而支撑自己发展得更远~</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>用户</tag>
        <tag>测试开发</tag>
        <tag>测试</tag>
        <tag>QA</tag>
        <tag>用户思维</tag>
      </tags>
  </entry>
  <entry>
    <title>【从零单排Golang】第一话：Go开发环境搭建——环境变量、依赖与目录结构踩坑</title>
    <url>/2019/07/20/gofromzero/01_first_code/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9nb2Zyb216ZXJv" title="https://github.com/utmhikari/gofromzero">Github传送门<i class="fa fa-external-link"></i></span></p>
<p>当测试开发真不容易，入行第一年，就要在python、NodeJS、lua、C、Java等语言间无缝切换。为了快速响应需求，挺难抽出时间去深耕一门语言的特性（诶羡慕那些只搞Java的人= =）。在<a href="https://utmhikari.github.io/2019/07/01/testlife_mtsc2019/">MTSC2019分享</a>中也谈到，测试开发归属质量保障QA，作为一个中台角色，其终极任务保障研发效能，因此一大需求是打通产品研发运维的生产线。说到生产线就想到上云，说到上云就想到docker跟kube，说到跟容器的交互就想到了Golang。马蛋，又要学一门新语言了。</p>
<p>开这个坑，旨在展现以程序员的视角学习一门新语言的过程。希望大家看得欢乐。如果有启发，那就更棒啦！</p>
<h2 id="安装与环境变量配置"><a href="#安装与环境变量配置" class="headerlink" title="安装与环境变量配置"></a>安装与环境变量配置</h2><p>家里的电脑是Windows，从<span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcub3JnLw==" title="https://golang.org/">官网<i class="fa fa-external-link"></i></span>即可下载Win的安装包。Go的版本为1.12。</p>
<p>下好后安装，安装完毕之后还需要设置环境变量（我的电脑——属性——高级系统设置）。<code>GOROOT</code>设置成Go的安装路径，还有一个关键的<code>GOPATH</code>，它表示你的工作目录，<strong>一般所有的Go项目，甭管第三方的还是你的，都统一放到这个目录下</strong>（从这点可以看出，Go的控制欲还是很强的）。<code>GOPATH</code>的一般结构如下：</p>
<a id="more"></a>
<ul>
<li>GOPATH<ul>
<li>bin 可执行文件目录</li>
<li>src 源码目录</li>
</ul>
</li>
</ul>
<p>一般来讲我们可以在<code>%GOPATH%\src</code>下新开一个自己的文件夹存放我们以后的Go项目源码。而对于可执行文件，我们可以在环境变量<code>PATH</code>中增加<code>%GOPATH%\bin</code>跟<code>%GOROOT%\bin</code>保证在cmd里能直接运行。</p>
<h2 id="配置VSCode环境"><a href="#配置VSCode环境" class="headerlink" title="配置VSCode环境"></a>配置VSCode环境</h2><p>Golang用的IDE的话idea跟VSCode都ok，家里就用VSCode好了。这里直接在<code>GOPATH</code>下建立了一个<code>mytest</code>文件夹当作我们的测试项目，用VSCode打开，然后添加一个Go脚本<code>main.go</code>，内容就是我们见到最多的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"Hell World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候VSCode就会提示下一堆工具依赖了（linter、自动填充之类）。但是VSCode插件默认会从go source下载。由于众所周知的不可抗力一般下载不行，但有其它的解决方法：</p>
<ul>
<li>测一下github网速，实在不行请开启游戏加速器</li>
<li>查看VSCode输出日志——看看哪些依赖安装失败。一般由于不可抗力，<code>golang.org/x/tools/</code>之类的google官方依赖会下不到。这个时候需要在<code>%GOPATH%\src</code>下建立<code>golang.org/x</code>目录，然后再从github上对应的仓库克隆<code>github.com/golang/tools</code>，然后go install。可以参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyOTU1MTgvYXJ0aWNsZS9kZXRhaWxzLzc4NzY2MDg2" title="https://blog.csdn.net/u013295518/article/details/78766086">VSCode + Golang配置<i class="fa fa-external-link"></i></span></li>
<li>像<code>gocode-gomod</code>等binary（exe），可以直接copy gocode改个名字就能用</li>
</ul>
<p>万事开头难，一劳永逸，弄好这些就基本可以直接开搞了。VSCode还是很方便的，比如配合golint优化代码，代码规范的事情就完全不用担心了。</p>
<h2 id="package-import"><a href="#package-import" class="headerlink" title="package import"></a>package import</h2><p>再基于上面的mytest给个例子，文件结构如下：</p>
<ul>
<li>GOPATH<ul>
<li>src<ul>
<li>mytest<ul>
<li>main.go</li>
<li>hello<ul>
<li>hello.go</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在Golang里，<strong>单个目录下的直属go文件（也就是不包括子目录下的go文件），都必须只属于一个package</strong>。Golang在import package时，本质也就是import一个目录啦，它会分别以<code>%GOROOT%\src</code>以及<code>%GOPATH%\src</code>为根目录开始寻找package。像<code>fmt</code>之类的标准库就在<code>%GOROOT%\src</code>中，而我们自己下的依赖就在<code>%GOPATH%\src</code>中。</p>
<p>根据上面的文件结构，我们可以在<code>hello.go</code>中填充内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hell%s World"</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>hello.go</code>属于hello这个package，然后包含一个叫<code>Hello</code>的函数，这个函数具体干了什么相信大家都明白。然而里面其实有几个坑——<strong>Go约定public函数名称开头得大写</strong>，比如这个<code>Hello(s string)</code>写成<code>hello</code>的话，就成了private函数了。</p>
<p>在<code>main.go</code>调用<code>Hello</code>函数的话，可以这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"mytest/hello"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">    s = <span class="string">""</span></span><br><span class="line">    hello.Hello(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们import的是<code>mytest/hello</code>，也就是相对于<code>%GOPATH%\src</code>的文件夹路径，就可以把package hello给引入。要调用的话，只需<code>hello.Hello</code>即可~</p>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>开发期我们常需要引入第三方库。python有virtualenv，Node有npm + package.json + node_modules，Java有Maven，那Golang里用什么解决方案呢？</p>
<p>四处寻觅了一下，目前有许多vender式的方案（类似node_modules），比如<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9kZXA=" title="https://github.com/golang/dep">dep<i class="fa fa-external-link"></i></span>跟<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01hc3Rlcm1pbmRzL2dsaWRl" title="https://github.com/Masterminds/glide">glide<i class="fa fa-external-link"></i></span>，而现今主推的方案是1.11版本后的go mod指令。首先，需要设置环境变量<code>GOMOD111MODULE</code>为<code>on</code>，然后增加一个代理，设置<code>GOPROXY</code>为<code>https://goproxy.io</code>，这样就能便捷下载依赖了。</p>
<p>以安装后端框架<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpbi1nb25pYy9naW4=" title="https://github.com/gin-gonic/gin">gin<i class="fa fa-external-link"></i></span>为例，首先进入刚刚的mytest，直接<code>go mod init</code>，即可将之标为模块。值得注意的是，刚刚环境变量<code>GOMOD111MODULE</code>设为<code>on</code>后需要标识模块，里面的lib才能被import。</p>
<p>而后，copy gin的示例代码到<code>main.go</code>，直接<code>go run main.go</code>，依赖就会自动安装了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>诶，对于开发者来说有一个舒服的开发环境是很重要的。后面再慢慢研究语言跟各种轮子的特性~</p>
]]></content>
      <categories>
        <category>从零单排Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>go mod</tag>
        <tag>环境变量</tag>
        <tag>go目录结构</tag>
        <tag>go依赖</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】安卓FPS测试详解</title>
    <url>/2019/07/13/testlife/android_fps/</url>
    <content><![CDATA[<p>安卓的fps测试，是我打开测试开发大门的一把钥匙。两年前的现在，安卓性能测试的相关资料甚少，以fps为例在网上也只有寥寥几篇文章讲述，但到了今年，已经有许多资料在各大技术论坛上供大家看到了。对于自己，一直想找一个机会把这一段技术探索写出来。所以，心动不如行动。</p>
<p>fps（frames per second），通常表示我们屏幕每秒展现的图片（帧）数，反映了一款应用在当前硬件下的性能消耗。比如我们抽CS的时候，就经常关注fps是否高，在高的情况下，就会有较好的流畅度。因此fps是应用性能测试中一个重要指标。</p>
<p>对于一个安卓app而言，为了测定fps数值，我们需要从安卓图形显示相关的模块入手。一个通用的方式是切入安卓的SurfaceFlinger服务，它是图形显示流程中软件层和硬件层的交互点，是极其关键的一环。SurfaceFlinger则是负责分析&amp;合成各个app中的图层，而后将合成的图像数据交由硬件渲染。硬件渲染的机制复杂，因此安卓系统中，将硬件操作进行了抽象方便调用，我们将这一与SurfaceFlinger对接的层次，称之为硬件抽象层（HAL）。SurfaceFlinger与HAL在功能上有部分的耦合，一些Surface合成的工作，也会委托HAL进行。</p>
<p>那么我们该如何通过SurfaceFlinger获得fps数据呢？大体上，我们可以参考<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Zm9vdGJhbGwvYXJ0aWNsZS9kZXRhaWxzLzQzMDg0NTI3Lw==" title="https://blog.csdn.net/itfootball/article/details/43084527/">《Android性能测试之fps获取》<i class="fa fa-external-link"></i></span>一文。这种方式成功率高（虽然我家手机行不通），且不用root，较为方便</p>
<p>首先，通过adb，我们可以导出SurfaceFlinger服务的运行时信息。</p>
<a id="more"></a>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys SurfaceFlinger</span><br></pre></td></tr></table></figure>
<p>dump出的信息包含了每个图层经过SurfaceFlinger加工后的信息，以及在硬件显示层上的层次，例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ Layer 0x796c18e800 (com.supercell.clashroyale.kunlun/com.supercell.clashroyale.GameAppKunlun#0)</span><br><span class="line">  Region transparentRegion (this=0x796c18eb90, count=1)</span><br><span class="line">    [  0,   0, 1080, 2240]</span><br><span class="line">  Region visibleRegion (this=0x796c18e810, count=1)</span><br><span class="line">    [  0,   0,   0,   0]</span><br><span class="line">  Region surfaceDamageRegion (this=0x796c18e888, count=1)</span><br><span class="line">    [  0,   0,   0,   0]</span><br><span class="line">      layerStack=   0, z=    21015, pos=(0,0), size=(1080,2240), crop=(   0,   0,1080,2240), finalCrop=(   0,   0,  -1,  -1), isOpaque=0, invalidate=0, dataspace=(deprecated) sRGB Linear Full range, pixelformat=RGBA_8888 alpha=1.000, flags=0x00000000, tr=[1.00, 0.00][0.00, 1.00]</span><br><span class="line">      client=0x796fb03ec0</span><br></pre></td></tr></table></figure>
<p>一般来讲，我们会选择前台的app进行fps统计，因此要选择visible region足够大，且z轴为正的层。除了这个筛选点之外，也可在HAL中的硬件合成（HWC）的信息中，筛选我们想要获取数据的图层。</p>
<p>得到图层后，我们可以输入以下命令，导出该图层渲染的时间数据：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys SurfaceFlinger --latency &lt;图层名&gt;</span><br></pre></td></tr></table></figure>
<p>如果成功的话，会显示出三列数据，大概是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 抠图 from chromium android pylib</span><br><span class="line">16954612</span><br><span class="line">...</span><br><span class="line">7657467895508   7657482691352   7657493499756</span><br><span class="line">7657484466553   7657499645964   7657511077881</span><br><span class="line">7657500793457   7657516600576   7657527404780</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>所有数据以纳秒为单位。第一行表示显示器刷新频率（16.95ms），一般为固定值。剩下每一行代表一个帧的时刻数据，三个时刻数据分别表示：</p>
<ul>
<li>app绘图时刻（A）</li>
<li>垂直同步信号来临时刻（B）</li>
<li>SurfaceFlinger把帧全部提交给硬件的时刻（C）</li>
</ul>
<p>所谓<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOUUlODIlRTclOUIlQjQlRTUlOTAlOEMlRTYlQUQlQTU=" title="https://baike.baidu.com/item/%E5%9E%82%E7%9B%B4%E5%90%8C%E6%AD%A5">垂直同步（VSync）<i class="fa fa-external-link"></i></span>，玩竞技游戏的同学应该都非常了解，它是与显示器刷新率挂钩的。通常情况下，显示器有多个缓存，显卡在其中一个缓存绘图，而显示器在另外的缓存读取帧数据显示在屏幕上，然而由于显卡绘图的速度总是会比显示器刷新的速度快，如果显卡实在没地方，最后跑到显示器读取帧的缓存写入数据的话，那显示器可能上半部是一个帧的，下半部分成另一个帧的样子了，造成画面撕裂。因此，显示器通过这个机制阻塞显卡绘图至其它的缓存，从而保证显示画面的流畅运行。</p>
<p>一般安卓的app开启了垂直同步，因此通过<code>数据行数 - 1/ΔB</code>，我们就能轻易地获得fps原始值，其中<code>ΔB</code>指代最后一个垂直同步时刻减去第一个垂直同步时刻的时间差。</p>
<p>但除此之外，我们还要考虑绘图掉帧（jank）的因素。所谓掉帧正好与前面的画面撕裂相反，是由于系统调度问题，导致下一个VSync信号来了时，下一个图片数据没准备好，这样显示器就又把上一帧数据给显示了一次。通过统计<code>ceil((C - A) / refresh-period)</code>，我们就可以看到每一次垂直同步下绘图~硬件显示的标准值（jankflag），理论上这个标准值是定值。而实际情况下，只要这个标准值有变动，就说明有掉帧的情况了。</p>
<p>这样一来，我们通过fps原始值，减去时间差变动的次数（掉帧次数），就能获得真实的fps值了。</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能测试</tag>
        <tag>测试</tag>
        <tag>fps</tag>
        <tag>SurfaceFlinger</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试人生】MTSC2019参会见闻感悟</title>
    <url>/2019/07/01/testlife/mtsc2019/</url>
    <content><![CDATA[<p>“测试人生”第一篇文章，献给2019年的移动测试开发大会MTSC。这一次，非常荣幸能够来到北京国际会议中心参会，一睹国内质量保障工作的现状与未来的发展趋势。</p>
<p>在学校期间，我也参与过一些小型的学术会议，但并不如今年的MTSC这样声势浩大。工作一年以来参与的第一个讨论会，已然是全国顶会。借这个机会，能够了解到业内排头企业在质量保障业务上的解决方案，对于自己在业务理解上会颇有帮助。本次议程中，除了参与第一天主会场之外，第二天游戏测试专场也全程参与，收获颇丰，感悟良多，一言难尽。</p>
<a id="more"></a>
<p>测试流程全自动化是质量管理的终极梦想，但是现实并不完美，比如游戏领域，在交付频繁、以及场景逻辑复杂的限制下，必须要有一定手工测试的成分。所以所谓测试流程自动化，应该怎样界定最为合适？其实我们会发现自动化的一大目标是促进生产力，在必须赋予人力研发的背景下，如何快速验证产品的质量，监控、定位&amp;解决问题，同时预测问题、避免以前的问题产生呢？带着这些有关于生产效率增强方面的问题，我们才会想到以接口自动化、devops为首的一些列测试流程技术。因此追求自动化不是关键，关键是发掘研发过程中的效率痛点。比如百度的自动构建权重量化可以及时评估交付质量，蚂蚁的卡分支管理能够显著避免版本commit/push问题，这些都是非常不错的点子。</p>
<p>从整个产品线跟测试岗位的职责上的关系来看，测试人员在多数情况下会担任一个服务者的角色。比如我自己，作为测试开发，职责不仅是解决技术问题，探究底层疯狂码触之类，还需要推动自己的产品，与业务线沟通跟进，了解业务线使用产品的方式与收益，并借此机会继续挖掘潜在需求。因此我套用了一个缩写，提出TaaS的概念——Test as a Service，来形容测试人员、尤其是测试开发人员的工作。</p>
<p>从TaaS的角度而言，测试开发对于业务线的服务是两个方向的。第一种是由外而内型，较多以平台+插件的方式存在，工作类似外包的性质，比如WeTest跟UWA。这一类测试业务更加关注于已构建/待交付产品的综合质量评估，注重C/S性能、安全、静态扫描，或是针对特定框架/引擎的精准测试方面。第二种是随波逐流型，与业务线耦合度较高，主要针对研发期未交付生产版本前的质量控制，像接口自动化/回归、覆盖率、commit hook、协议测试之类的针对性效率工具，更易在项目研发早期、未交付生产版本时进行推动。不管是哪一种情况，提升研发效率，满足项目需求，优先级一直得排第一。</p>
<p>这一届大会同样涌现了许多智能科技/AI测试方面的主题，狭义地讲，也就是机器学习技术的应用。比如今年的腾讯，在游戏UI自动化测试方面取得了很大的进展，实现了手游CF的Bot。腾讯的这一场演讲吸引了小讲室两倍椅子数的观众，同行们对高新技术应用于质量管理业务颇有兴致，但不可否认的是，腾讯在发展Turing Lab的背后，是其多年的游戏研发管理经验以及质量管理体系/技术基建，才能够支持他们在高新技术方面的研究，并且另一方面，要往AI测试技术进行应用，技术深度是其次，而AI能够解决业务中的哪些痛点，如何获取足量有价值的数据集，如何打通整个AI测试流程，才是真正需要思考的东西。</p>
<p>因此，整个自动化质量管理也是这样——如何让质量把控更恰当地卡住业务点，从而效率反馈，才是我们做自动化测试服务所要留意的地方。</p>
<p>通篇文章仅为个人见解。虽然现在自己的业务经验不够丰富，眼界也不一定够宽广，但希望多年之后，再次看到自己写过的文章，可以温故而知新。</p>
<p>总而言之，开了眼界，涨了见识，就是很爽！</p>
]]></content>
      <categories>
        <category>测试人生</category>
      </categories>
      <tags>
        <tag>质量管理</tag>
        <tag>测试</tag>
        <tag>MTSC</tag>
        <tag>QA</tag>
        <tag>TaaS</tag>
      </tags>
  </entry>
  <entry>
    <title>【GitHub探索】新款命令行工具terminus测试</title>
    <url>/2019/06/22/githubdiscovery/terminus/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>六月的Github趋势榜单上，除去一些文书、教程性质的项目外，大部分项目并非自己所针对的领域。因此，果断试水了一款软件，</p>
<p>Windows系统下的命令行工具配置，一直是开发者们纠结的痛点。在这一块，<span class="exturl" data-url="aHR0cHM6Ly9jbWRlci5uZXQv" title="https://cmder.net/">cmder<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9tb2JheHRlcm0ubW9iYXRlay5uZXQv" title="https://mobaxterm.mobatek.net/">MobaXTerm<i class="fa fa-external-link"></i></span>甚至即将上线的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC90ZXJtaW5hbA==" title="https://github.com/microsoft/terminal">Windows Terminal<i class="fa fa-external-link"></i></span>，都是不错的解决方案。</p>
<p>而今天介绍的这一款软件——<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0V1Z2VueS90ZXJtaW51cw==" title="https://github.com/Eugeny/terminus">terminus<i class="fa fa-external-link"></i></span>，在六月份跻身趋势排行前十，则似乎更加符合我们对命令行工具的影响。作为一个终端模拟器，terminus采用Angular + Electron开发，包含了终端模拟器必备的许多功能，兼具美观与实用性。我们可以首先来看看，terminus的界面长什么样子~</p>
<a id="more"></a>
<p><img src="/uploads/githubdiscovery/terminus/main.PNG" alt="terminus界面"></p>
<p>下面，让我们一起试水一下terminus吧~</p>
<h2 id="terminus特性"><a href="#terminus特性" class="headerlink" title="terminus特性"></a>terminus特性</h2><p>以最新（1.0.82）的Windows版为例，terminus包含的特性如下：</p>
<ul>
<li>多标签终端支持（cmd、powershell、bash）以及额外终端配置</li>
<li>多皮肤/主题配色定制（嵌入终端皮肤数十种）</li>
<li>SSH支持与管理</li>
<li>插件、快捷键、右键菜单支持</li>
</ul>
<p>从功能的覆盖度来讲，作为一个轻量级的终端程序来说，满足多标签、右键菜单以及SSH，已经非常棒了。</p>
<h2 id="terminus测试"><a href="#terminus测试" class="headerlink" title="terminus测试"></a>terminus测试</h2><p>作为一个测试人员，测试一个没有策划文档的成品时，可以遵循以下的测试思路：</p>
<ul>
<li>从普通用户角度而言，最基本的操作是否能够顺利跑通？</li>
<li>从DIY用户角度而言，各种与配置关联的用例操作是否也能顺利？</li>
<li>猜测产品设计的亮点之处，这些亮点之处的操作用例是否能够跑顺利？</li>
</ul>
<p>以及以下的测试策略：</p>
<ul>
<li>测试尽量关注恶性bug，亦即那些显著影响或阻塞用户的软件操作的bug</li>
<li>不刻意关心bug的成因，但要为开发提供足够的信息帮助他们定位bug</li>
</ul>
<p>遵循上述思路与策略，按照测试bug提单的标准，小列自家Windows下1.0.82版本几个测到的恶性bug：</p>
<h3 id="应用设置界面下无法新建终端-SSH连接"><a href="#应用设置界面下无法新建终端-SSH连接" class="headerlink" title="应用设置界面下无法新建终端/SSH连接"></a>应用设置界面下无法新建终端/SSH连接</h3><ul>
<li>缺陷描述：仅当设置界面的Application栏下，新建terminal后不显示终端，并且无法连接SSH</li>
<li>复现过程：点击“设置”按钮进入Application栏，再点击新建终端或SSH按钮均不显示界面，且终端标签页无法关闭</li>
<li>备注信息：切换其它设置项或其它标签页后，阻塞的新建终端/连接SSH操作可以继续</li>
<li>错误输出：angular module有从undefined读取appVersion属性的行为</li>
<li>图片描述：见下= =</li>
</ul>
<p><img src="/uploads/githubdiscovery/terminus/main.PNG" alt="从设置新建终端不显示"></p>
<h3 id="无法再次打开terminus"><a href="#无法再次打开terminus" class="headerlink" title="无法再次打开terminus"></a>无法再次打开terminus</h3><ul>
<li>缺陷描述：当terminus为开启状态时，无法再次打开terminus</li>
<li>复现过程：开启一个terminus程序后，再次打开terminus，原有的terminus关闭，新的程序不开启</li>
<li>备注：原有terminus关闭后，再次打开terminus，原先开启的标签依然存在</li>
</ul>
<h3 id="切回插件设置界面下拉栏不显示"><a href="#切回插件设置界面下拉栏不显示" class="headerlink" title="切回插件设置界面下拉栏不显示"></a>切回插件设置界面下拉栏不显示</h3><ul>
<li>缺陷描述：当有其余终端标签情况下，插件设置页面显示默认插件搜索结果后，切终端再切回，下拉栏不显示</li>
<li>复现过程：首先新建终端，而后新建插件设置标签等待异步插件搜索操作完成，再点击终端标签，再回来点击插件设置标签</li>
<li>备注：需要再一次开启插件设置标签，才可以显示下拉栏</li>
<li>图片描述：见下= =</li>
</ul>
<p><img src="/uploads/githubdiscovery/terminus/plugin.PNG" alt="切回插件设置界面下拉栏不显示"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从开发的角度而言，先确定需求，写模版，后面出了具体bug再迭代，是一个妥善的路子。</p>
<p>从试水结果看来，terminus为我们开发命令行工具开辟了更加精致的思路，作为一个轻量级的软件，从功能的完备性而言，已经能够具备日常使用性。</p>
<p>虽然有些恶性bug，并且也有些GUI渲染上的瑕疵，但并不妨碍整个研发的大方向，因此我们期望开发人员能够后面抽空一个个补正。</p>
<p>故现在这个时段，没有用过terminus的同学们，可以试用一下啦~如果觉得不顺手，也请给予一点耐心——期待terminus后续的版本吧！</p>
]]></content>
      <categories>
        <category>GitHub探索</category>
      </categories>
      <tags>
        <tag>terminus</tag>
        <tag>命令行工具</tag>
        <tag>terminal</tag>
        <tag>shell</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>【Lua杂谈】犹豫就会败北——元表metatable解析</title>
    <url>/2019/06/12/luatalk/metatable/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在lua的学习过程当中，元表metatable的概念及用法是常见的障碍之一</p>
<p>元表，在其它lua杂谈等都提到过，是一种描述lua数据的属性以及行为的表。虽然官方给了set、account等例子详细讲解了metatable，但总还是缺乏些提炼。为了干翻这个痛点，这次，果断强上metatable的精髓。毕竟，犹豫就会败北~</p>
<h2 id="元表有什么"><a href="#元表有什么" class="headerlink" title="元表有什么"></a>元表有什么</h2><p>我们首先就会有疑问：通过哪些属性指标，可以描述lua的数据呢？通过<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVhLm9yZy9tYW51YWwvNS4zL21hbnVhbC5odG1sIzIuNA==" title="https://www.lua.org/manual/5.3/manual.html#2.4">官方手册<i class="fa fa-external-link"></i></span>，我们可以很容易地找到答案。</p>
<p>在lua中，我们把元表中的key，也就是描述数据的属性指标，称之为event</p>
<p>我们可以把所有的event分为两组（括号中代表lua里的语法）：</p>
<ol>
<li><p>描述其基础性质的：</p>
<ul>
<li>属性索引：<code>__index</code>，<code>__newindex</code></li>
<li>长度：<code>__len(#)</code></li>
<li>函数形式：<code>__call</code></li>
<li>字符串形式：<code>__tostring</code></li>
</ul>
</li>
<li><p>描述其运算的：</p>
<ul>
<li>普通运算：<code>__add(加+)</code>，<code>__sub(减-)</code>，<code>__mul(乘*)</code>，<code>__div(除/)</code>，<code>__mod(模%)</code>，<code>__pow(乘方^)</code>，<code>__unm(负-)</code>，<code>__idiv(取整除//)</code></li>
<li>位运算：<code>__band(与&amp;)</code>，<code>__bor(或|)</code>，<code>__bxor(异或~)</code>，<code>__bnot(非~)</code>，<code>__shl(左移&lt;&lt;)</code>，<code>__shr(右移&gt;&gt;)</code></li>
<li>关系运算：<code>__concat(联结..)</code>，<code>__eq(全等==)</code>，<code>__lt(小于&lt;)</code>，<code>__lte(小于等于&lt;=)</code></li>
</ul>
</li>
</ol>
<h2 id="元表怎么用"><a href="#元表怎么用" class="headerlink" title="元表怎么用"></a>元表怎么用</h2><p>先来看一段程序吧~</p>
<a id="more"></a>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;</span><br><span class="line">    __band = <span class="function"><span class="keyword">function</span> <span class="params">(a, b)</span></span></span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">        <span class="built_in">print</span>(b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">12345</span></span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    <span class="built_in">__call</span> = <span class="function"><span class="keyword">function</span> <span class="params">(x)</span></span></span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> t = <span class="built_in">setmetatable</span>(&#123;&#125;, mt)</span><br><span class="line"><span class="keyword">local</span> s = <span class="built_in">debug</span>.<span class="built_in">setmetatable</span>(<span class="string">"666"</span>, mt)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n-------------------------------------------------\n"</span>)</span><br><span class="line"><span class="keyword">local</span> i = <span class="built_in">debug</span>.<span class="built_in">setmetatable</span>(t &amp; s, mt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n-------------------------------------------------\n"</span>)</span><br><span class="line">i()</span><br></pre></td></tr></table></figure>
<p>打印出来什么呢？就是这个~</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-------------------------------------------------</span><br><span class="line"></span><br><span class="line">table: 0000000000dca020</span><br><span class="line">666</span><br><span class="line"></span><br><span class="line">-------------------------------------------------</span><br><span class="line"></span><br><span class="line">12345</span><br></pre></td></tr></table></figure>
<p>这其中如何进行？首先我们看代码，表mt表示元表，定义了以下数据交互行为:</p>
<ul>
<li>“逻辑与”操作band，变成把逻辑与的两边打印出来，不管两边是啥，然后返回数值12345</li>
<li>“函数调用”操作call，变成直接把函数调用者打印出来，不管调用者到底是啥数据类型</li>
</ul>
<p>然后就可以开始骚操作了~在lua中，一般只有table类型的数据可以setmetatable，但是如果我们调用debug库的话，就可以为任意类型的数据设置元表。所以，我们先可以试试字符串与表之间的交互~</p>
<p>新建设置了元表的空表t与”666”字符串s，然后，为它们设置元表。这样它们就可以交互啦~</p>
<p>当执行<code>local i = t &amp; s</code>的时候，在<code>t &amp; s</code>的操作中，根据元表<code>__band</code>定义，会把t跟s都print出来，然后返回12345给i。i是一个数字，但仍然可以被设置上元表。然后再试试看调用i的操作<code>i()</code>，根据元表的<code>__call</code>逻辑，就会打印出i来了。</p>
<p>很黑科技吧~</p>
<h2 id="元表-amp-面向对象"><a href="#元表-amp-面向对象" class="headerlink" title="元表&amp;面向对象"></a>元表&amp;面向对象</h2><p>元表最常见的用途是lua的面向对象编程，具体而言，则是采用原型模式进行。新建的对象实例初始化时继承原型的方法，并且在修改属性的过程中不影响原型的变化。</p>
<p>我们看看原型类的实现：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> prototype = &#123;</span><br><span class="line">    tag = <span class="string">"PROTOTYPE"</span>,</span><br><span class="line">    value = <span class="string">"hello world"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototype:print</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(self) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(k .. <span class="string">": "</span> .. <span class="built_in">tostring</span>(v))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototype:new</span><span class="params">(o)</span></span></span><br><span class="line">    o = o <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setmetatable</span>(o, &#123;</span><br><span class="line">        <span class="built_in">__index</span> = self,</span><br><span class="line">        <span class="comment">-- __newindex = function (t, k, v) rawset(t, k, v) end</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">setmetatable</span>(prototype, &#123; <span class="built_in">__call</span> = prototype.new &#125;)</span><br></pre></td></tr></table></figure>
<p>在原型类的原表中，把<code>__call</code>设置为构造函数new，这也符合我们一贯的调用构造函数的习惯。对于每一个新实例，我们将元表中的<code>__index</code>设置为prototype自己，将<code>__newindex</code>设定为rawset机制。</p>
<p><code>__index</code>表示属性查找索引/方法，可以是一个表，也可以是一个函数。对于一个表而言，如果要查找x属性但在表里没有的话，就会调用元表的<code>__index</code>进行查找。因此，在新实例中，<code>__index</code>理所当然地设置为原型表prototype</p>
<p><code>__newindex</code>表示更新属性的机制，可以是一个另外单独的表，也可以是一个函数。如果设置成另外单独的表，则新的属性跟值都会设到另外的表上；如果是一个函数，对于表实例而言，则默认为触发table本身的rawset逻辑，将新的键值对设到该实例上。table的rawset逻辑不会反过来触发newindex，因此不会造成stack overflow</p>
<p>接下来我们可以看基于原型的实例：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> prototype = <span class="built_in">require</span> <span class="string">"prototype"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n---------------- init table -----------------\n"</span>)</span><br><span class="line"><span class="keyword">local</span> t = prototype(&#123; tag = <span class="string">"TABLE"</span> &#125;)</span><br><span class="line">t:<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n---------------- init prototype -----------------\n"</span>)</span><br><span class="line"><span class="built_in">getmetatable</span>(t).<span class="built_in">__index</span>:<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n--------------  modified table  ---------------\n"</span>)</span><br><span class="line"></span><br><span class="line">t.new_value = <span class="string">"new name"</span></span><br><span class="line">t.value = <span class="string">"jaja"</span></span><br><span class="line">t.tag = <span class="string">"NEWTABLE"</span></span><br><span class="line">t:<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n--------------  modified? prototype  ---------------\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">getmetatable</span>(t).<span class="built_in">__index</span>:<span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<p>我们初始化一个基于prototype的实例，并且修改其中的值，再反过来看原型的值，打印如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---------------- init table -----------------</span><br><span class="line"></span><br><span class="line">tag: TABLE</span><br><span class="line"></span><br><span class="line">---------------- init prototype -----------------</span><br><span class="line"></span><br><span class="line">value: hello world</span><br><span class="line">print: function: 0000000002a60940</span><br><span class="line">new: function: 0000000002a60af0</span><br><span class="line">tag: PROTOTYPE</span><br><span class="line"></span><br><span class="line">--------------  modified table  ---------------</span><br><span class="line"></span><br><span class="line">tag: NEWTABLE</span><br><span class="line">new_value: new name</span><br><span class="line">value: jaja</span><br><span class="line"></span><br><span class="line">--------------  modified? prototype  ---------------</span><br><span class="line"></span><br><span class="line">value: hello world</span><br><span class="line">print: function: 0000000002a60940</span><br><span class="line">new: function: 0000000002a60af0</span><br><span class="line">tag: PROTOTYPE</span><br></pre></td></tr></table></figure>
<p>很幸运，正如我们所期望的那样！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>元表metatable，听起来拗口，但用起来非常灵活~</p>
<p>不仅是lua，像python，也有类似的操作</p>
<p>在实际lua编程的时候，可得多尝试喔~</p>
]]></content>
      <categories>
        <category>Lua杂谈</category>
      </categories>
      <tags>
        <tag>lua</tag>
        <tag>元表</tag>
        <tag>面向对象</tag>
        <tag>继承</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【DIY小记】Win10编程字体&amp;主题设置全攻略</title>
    <url>/2019/06/01/diymemo/font_theme/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>编程需要纠结字体跟皮肤吗？肯定要纠结的啦= = = =</p>
<p>调理字体跟皮肤，就跟打扮房间一样。每当打开编程软件之时，要是看到清亮的字体，爽快的皮肤，心里肯定就特别踏实，码码起来肯定也就特别舒服。</p>
<p>是时候分享一下我的编程字体以及主题设置了！！！</p>
<a id="more"></a>
<h2 id="电脑配置"><a href="#电脑配置" class="headerlink" title="电脑配置"></a>电脑配置</h2><h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><p>显示方面，主机用的最高分辨率1080p的船，接了HDMI到华硕MG248QR显示器，刷新率120hz。</p>
<h3 id="编程软件"><a href="#编程软件" class="headerlink" title="编程软件"></a>编程软件</h3><p>编程软件主要是4个：</p>
<ul>
<li>Visual Studio Code：主力开发&amp;写博客</li>
<li>IntelliJ Idea：写python、java用</li>
<li>Visual Studio：Unity跟Unreal用</li>
<li>Notapad++：日常文本编辑</li>
</ul>
<h2 id="字体-amp-主题配置"><a href="#字体-amp-主题配置" class="headerlink" title="字体&amp;主题配置"></a>字体&amp;主题配置</h2><p>由于Windows天生渲染不咋地，比Mac差了一大截。因此选择字体搭配皮肤，那可得得下一番功夫。</p>
<h3 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h3><p>自己的配置是：Cobalt2主题 + Operator Mono Light字体（大小14），行高22</p>
<p>拿lfunctimer的lua文件做例子，加了lua coder assist、TODO highlight等插件，效果如下：</p>
<p><img src="/uploads/diymemo/font_theme/vscode_cobalt2_operator_mono.PNG" alt="VSCode Cobalt2 + Operator Mono"></p>
<p>主题的选择很多样，官方的Dark+其实已经很不错了。但是推荐的话，One Dark Pro Vivid跟自带的Monokai都是不错的选择。<strong>Material系列主题千万不能选！！！看久了非常伤眼，低对比度不好看，高对比度太伤眼。</strong></p>
<p>图标主题（Icon Theme），可以选Material系列，也可以选VSCode Great Icons之类，比较随意。</p>
<p>字体的话，实测Fantasque Sans Mono与Ubuntu Mono是推荐的选择。Consolas跟Source Code Variable会稍微有点肥的感觉，而Inconsolata跟Monaco系则会有一些渲染上的瑕疵。</p>
<p>我们可以看看Monokai + Fantasque Sans Mono以及One Dark Pro Vivid + Ubuntu Mono的效果：</p>
<p><img src="/uploads/diymemo/font_theme/vscode_monokai_fantasque_sans_mono.PNG" alt="VSCode Monokai + Fantasque Sans Mono"></p>
<p><img src="/uploads/diymemo/font_theme/vscode_one_dark_pro_ubuntu_mono.PNG" alt="VSCode One Dark Pro Vivid + Ubuntu Mono"></p>
<h3 id="IntelliJ-Idea"><a href="#IntelliJ-Idea" class="headerlink" title="IntelliJ Idea"></a>IntelliJ Idea</h3><p>Idea方面，主题首选官方出的新皮肤：Dark purple。<strong>千万不要安装Material皮肤，缺点上面已经说了，而且卸载难，简直是流氓插件。</strong></p>
<p>字体方面，Idea有读取不到Operator Mono的bug。Windows上，首先在Appearance设置里把Editor的抗锯齿设置为Greyscale：</p>
<p><img src="/uploads/diymemo/font_theme/idea_greyscale.PNG" alt="Idea Greyscale"></p>
<p>然后首选Fantasque Sans Mono，中文字体苹方（fallback font设置），极度舒适，效果如下：</p>
<p><img src="/uploads/diymemo/font_theme/idea_fantasque_sans_mono.PNG" alt="Idea Fantasque Sans Mono"></p>
<p>Monaco系也不错，HeyMona或Monaco for Powerline都有不俗的显示效果：</p>
<p><img src="/uploads/diymemo/font_theme/idea_heymona.PNG" alt="Idea HeyMona"></p>
<p>如果是小屏幕，也可以用Source Code Variable，但大屏幕会显胖。有兴趣的同学可以试试~</p>
<h3 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a>Visual Studio</h3><p>Visual Studio的字体渲染是真的辣鸡，能看的字体真的太少了。</p>
<p>可以选择Dark主题 + Inconsolata或Ubuntu Mono字体的配置，字体要设小一点，两个的展现效果都差不多。直接以Inconsolata为例好了= =</p>
<p><img src="/uploads/diymemo/font_theme/vs_inconsolata.PNG" alt="VS Inconsolata"></p>
<h3 id="Notepad"><a href="#Notepad" class="headerlink" title="Notepad++"></a>Notepad++</h3><p>Notepad++跟Visual Studio渲染的效果相似。因此，字体上同样采用Inconsolata或者Ubuntu Mono即可。</p>
<p>主题的选择上，Monokai或者Obsidian都不错。Obsidian的关键字标粗体，由于Inconsolata跟Ubuntu Mono在Notepad++上粗体显示并不算特别完美，所以如果懒得去DIY的话，选Monokai就好了。</p>
<p>我们可以一睹Monokai + Inconsolata以及Obsidian + Ubuntu Mono的效果：</p>
<p><img src="/uploads/diymemo/font_theme/notepad_inconsolata.PNG" alt="Notepad Inconsolata"></p>
<p><img src="/uploads/diymemo/font_theme/notepad_ubuntu_mono.PNG" alt="Notepad Ubuntu Mono"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果想要复古，或者没太多审美需求，Consolas、Courier (New)之类的就可以满足了= =s</p>
<p>像DejaVu Sans Mono、Droid Sans Mono、Fira Code、Hack、Input Mono之流，网上介绍看着还OK，实际效果还是硬伤。</p>
<p>萝卜青菜，各有所爱。以上设置仅供参考！！！实践，是检验真理的唯一标准~</p>
]]></content>
      <categories>
        <category>DIY小记</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Win10</tag>
        <tag>字体</tag>
        <tag>主题</tag>
        <tag>皮肤</tag>
      </tags>
  </entry>
  <entry>
    <title>【GitHub探索】python调试利器——pysnooper源码分析</title>
    <url>/2019/05/25/githubdiscovery/pysnooper/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次又开了个新坑——GitHub探索，主要内容是试水当期GitHub上较火的repo</p>
<p>虽然top榜上各路新手教程跟经典老不死项目占据了大半江山，但清流总是会有的。</p>
<p>第一期就试水一下<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nvb2wtUlIvUHlTbm9vcGVy" title="https://github.com/cool-RR/PySnooper">pysnooper<i class="fa fa-external-link"></i></span>吧，一个新奇实用的python调试器。</p>
<p>顺便源码分析一波，了解下python的debug操作。</p>
<p>废话不多说，进入正题~</p>
<h2 id="pysnooper使用效果"><a href="#pysnooper使用效果" class="headerlink" title="pysnooper使用效果"></a>pysnooper使用效果</h2><p>通常，我们可以在函数上用<code>pysnooper.snoop</code>装饰器，给这个函数包装一个额外功能，实现在标准错误流打印函数debug信息的效果。比如说：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pysnooper.snoop(depth=2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> mul(</span><br><span class="line">        x,</span><br><span class="line">        factorial(x - <span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    factorial(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>执行main的效果就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Starting var:.. x = 2</span><br><span class="line">22:24:25.476753 call         5 def factorial(x):</span><br><span class="line">22:24:25.476753 line         6     if x == 0:</span><br><span class="line">22:24:25.476753 line         8     return mul(</span><br><span class="line">22:24:25.476753 line         9         x,</span><br><span class="line">22:24:25.476753 line        10         factorial(x - 1)</span><br><span class="line">    Starting var:.. x = 1</span><br><span class="line">    22:24:25.477743 call         5 def factorial(x):</span><br><span class="line">    22:24:25.477743 line         6     if x == 0:</span><br><span class="line">    22:24:25.477743 line         8     return mul(</span><br><span class="line">    22:24:25.477743 line         9         x,</span><br><span class="line">    22:24:25.477743 line        10         factorial(x - 1)</span><br><span class="line">        Starting var:.. x = 0</span><br><span class="line">        22:24:25.477743 call         5 def factorial(x):</span><br><span class="line">        22:24:25.477743 line         6     if x == 0:</span><br><span class="line">        22:24:25.477743 line         7         return 1</span><br><span class="line">        22:24:25.477743 return       7         return 1</span><br><span class="line">        Return value:.. 1</span><br><span class="line">        Starting var:.. a = 1</span><br><span class="line">        Starting var:.. b = 1</span><br><span class="line">        22:24:25.477743 call        15 def mul(a, b):</span><br><span class="line">        22:24:25.477743 line        16     return a * b</span><br><span class="line">        22:24:25.477743 return      16     return a * b</span><br><span class="line">        Return value:.. 1</span><br><span class="line">    22:24:25.477743 return      10         factorial(x - 1)</span><br><span class="line">    Return value:.. 1</span><br><span class="line">    Starting var:.. a = 2</span><br><span class="line">    Starting var:.. b = 1</span><br><span class="line">    22:24:25.477743 call        15 def mul(a, b):</span><br><span class="line">    22:24:25.477743 line        16     return a * b</span><br><span class="line">    22:24:25.477743 return      16     return a * b</span><br><span class="line">    Return value:.. 2</span><br><span class="line">22:24:25.477743 return      10         factorial(x - 1)</span><br><span class="line">Return value:.. 2</span><br></pre></td></tr></table></figure>
<p>这样我们就可以trace到整一个函数相关的流程了，非常方便，可以很好地代替print的工作。</p>
<h2 id="pysnooper实现原理"><a href="#pysnooper实现原理" class="headerlink" title="pysnooper实现原理"></a>pysnooper实现原理</h2><p>pysnooper的实现涉及到python底层debug相关的知识。在以前写过的一篇<a href="https://utmhikari.github.io/2019/04/07/luatalk/lfunctimer_capi">lua的debug库源码分析</a>中提到了lua获取debug信息的相关操作，而pysnooper实现上也是通过获取底层信息进行debug trace，从结果上来看，也收集了call、line、return以及变量定义之类的操作事件信息。虽然语言不同，但基本思想都一样滴~</p>
<p>因此，在逆向pyssnooper实现原理之时，也将先入为主地代入一些lua的相关概念。</p>
<p>pysnooper相关的参考资料，基本可以在python标准库中的<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9saWJyYXJ5L2luc3BlY3QuaHRtbA==" title="https://docs.python.org/3/library/inspect.html">inspect库文档<i class="fa fa-external-link"></i></span>中找到~</p>
<p>调用的<code>pysnooper.snoop</code>定义在pysnooper的<code>__init__.py</code>中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .tracer <span class="keyword">import</span> Tracer <span class="keyword">as</span> snoop</span><br></pre></td></tr></table></figure>
<p>因此我们直接转向Tracer类一探究竟</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, function)</span>:</span></span><br><span class="line">    self.target_codes.add(function.__code__)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @functools.wraps(function)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simple_wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self:</span><br><span class="line">            <span class="keyword">return</span> function(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @functools.wraps(function)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generator_wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        gen = function(*args, **kwargs)</span><br><span class="line">        method, incoming = gen.send, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">with</span> self:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    outgoing = method(incoming)</span><br><span class="line">                <span class="keyword">except</span> StopIteration:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                method, incoming = gen.send, (<span class="keyword">yield</span> outgoing)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                method, incoming = gen.throw, e</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pycompat.iscoroutinefunction(function):</span><br><span class="line">        <span class="comment"># return decorate(function, coroutine_wrapper)</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line">    <span class="keyword">elif</span> inspect.isgeneratorfunction(function):</span><br><span class="line">        <span class="keyword">return</span> generator_wrapper</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> simple_wrapper</span><br></pre></td></tr></table></figure>
<p>作为一个装饰器首先要实现的是各类函数的包装。pysnooper首先将该函数编译的代码<code>__code__</code>进行备份，而后根据情况封装函数。pysnooper暂时没有对协程（async def task/coroutine）做封装，但对于一般函数跟generator，都把函数体内所有的操作包裹在了Tracer自己的with作用域中。</p>
<p>在日常码码中，我们写到with的场景一般是文件io操作，或者是tensorflow之类。with作用域提供了<code>__enter__</code>与<code>__exit__</code>两个元方法，定义进出作用域时的相关操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">    calling_frame = inspect.currentframe().f_back</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self._is_internal_frame(calling_frame):</span><br><span class="line">        calling_frame.f_trace = self.trace</span><br><span class="line">        self.target_frames.add(calling_frame)</span><br><span class="line"></span><br><span class="line">    stack = self.thread_local.__dict__.setdefault(<span class="string">'original_trace_functions'</span>, [])</span><br><span class="line">    stack.append(sys.gettrace())</span><br><span class="line">    sys.settrace(self.trace)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_value, exc_traceback)</span>:</span></span><br><span class="line">    stack = self.thread_local.original_trace_functions</span><br><span class="line">    sys.settrace(stack.pop())</span><br><span class="line">    calling_frame = inspect.currentframe().f_back</span><br><span class="line">    self.target_frames.discard(calling_frame)</span><br><span class="line">    self.frame_to_local_reprs.pop(calling_frame, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_is_internal_frame</span><span class="params">(self, frame)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> frame.f_code.co_filename == Tracer.__enter__.__code__.co_filename</span><br></pre></td></tr></table></figure>
<p>可以看到，每当发生进出Tracer作用域的时候（也就是封装function的时候）都会发生一些类似状态管理的操作。因此首先稍微厘清一些概念:</p>
<ul>
<li>frame：相当于lua的callinfo，表示python调用栈上的函数信息</li>
<li>thread_local：当前线程作用域（Java同学应该都明白）</li>
<li>trace：相当于lua的hook</li>
</ul>
<p>可以看到，每次<code>__enter__</code>时，增加统计frame信息，并且在当前线程建立一个trace栈记录每个函数上一个frame（调用该函数的frame）的trace函数。<br>然后反过来，每次<code>__exit__</code>时，trace函数重置为上一个（从trace栈中pop出来），同时移除统计的frame，从而维持原有的状态。</p>
<p>最后我们直接看trace（hook）函数，了解pysnooper打印操作具体实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(self, frame, event, arg)</span>:</span></span><br><span class="line">    <span class="comment">### Checking whether we should trace this line: #######################</span></span><br><span class="line">    <span class="comment">#                                                                     #</span></span><br><span class="line">    <span class="comment"># We should trace this line either if it's in the decorated function,</span></span><br><span class="line">    <span class="comment"># or the user asked to go a few levels deeper and we're within that</span></span><br><span class="line">    <span class="comment"># number of levels deeper.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (frame.f_code <span class="keyword">in</span> self.target_codes <span class="keyword">or</span> frame <span class="keyword">in</span> self.target_frames):</span><br><span class="line">        <span class="keyword">if</span> self.depth == <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># We did the most common and quickest check above, because the</span></span><br><span class="line">            <span class="comment"># trace function runs so incredibly often, therefore it's</span></span><br><span class="line">            <span class="comment"># crucial to hyper-optimize it for the common case.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> self._is_internal_frame(frame):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            _frame_candidate = frame</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, self.depth):</span><br><span class="line">                _frame_candidate = _frame_candidate.f_back</span><br><span class="line">                <span class="keyword">if</span> _frame_candidate <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">                <span class="keyword">elif</span> _frame_candidate.f_code <span class="keyword">in</span> self.target_codes <span class="keyword">or</span> _frame_candidate <span class="keyword">in</span> self.target_frames:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    thread_global.__dict__.setdefault(<span class="string">'depth'</span>, <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'call'</span>:</span><br><span class="line">        thread_global.depth += <span class="number">1</span></span><br><span class="line">    indent = <span class="string">' '</span> * <span class="number">4</span> * thread_global.depth</span><br><span class="line"></span><br><span class="line">    <span class="comment">#                                                                     #</span></span><br><span class="line">    <span class="comment">### Finished checking whether we should trace this line. ##############</span></span><br></pre></td></tr></table></figure>
<p>python规定trace函数包含三个参数：frame、event与arg，frame代表当前调用栈的frame；event是运行时事件，比lua多了exception与opcode两个；arg是受控于event的只读参数。</p>
<p>在pysnooper的trace函数中，首先针对是否记录/打印数据进行判断，只有当前frame或者其上层frame在要测的frames里或者包含要测的代码块，才会被纳入pysnooper记录当中。<br>判断完之后，就规定每一个函数调用事件发生时，打印增加4位缩进。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_local_reprs</span><span class="params">(frame, watch=<span class="params">()</span>)</span>:</span></span><br><span class="line">    code = frame.f_code</span><br><span class="line">    vars_order = code.co_varnames + code.co_cellvars + code.co_freevars + tuple(frame.f_locals.keys())</span><br><span class="line">    result_items = [(key, utils.get_shortish_repr(value)) <span class="keyword">for</span> key, value <span class="keyword">in</span> frame.f_locals.items()]</span><br><span class="line">    result_items.sort(key=<span class="keyword">lambda</span> key_value: vars_order.index(key_value[<span class="number">0</span>]))</span><br><span class="line">    result = collections.OrderedDict(result_items)</span><br><span class="line">    <span class="keyword">for</span> variable <span class="keyword">in</span> watch:</span><br><span class="line">        result.update(sorted(variable.items(frame)))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(...)</span>:</span></span><br><span class="line">    <span class="comment"># 接上</span></span><br><span class="line">    <span class="comment">### Reporting newish and modified variables: ##########################</span></span><br><span class="line">    <span class="comment">#                                                                     #</span></span><br><span class="line">    old_local_reprs = self.frame_to_local_reprs.get(frame, &#123;&#125;)</span><br><span class="line">    self.frame_to_local_reprs[frame] = local_reprs = \</span><br><span class="line">        get_local_reprs(frame, watch=self.watch)</span><br><span class="line">    newish_string = (<span class="string">'Starting var:.. '</span> <span class="keyword">if</span> event == <span class="string">'call'</span> <span class="keyword">else</span></span><br><span class="line">                        <span class="string">'New var:....... '</span>)</span><br><span class="line">    <span class="keyword">for</span> name, value_repr <span class="keyword">in</span> local_reprs.items():</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> old_local_reprs:</span><br><span class="line">            self.write(<span class="string">'&#123;indent&#125;&#123;newish_string&#125;&#123;name&#125; = &#123;value_repr&#125;'</span>.format(</span><br><span class="line">                **locals()))</span><br><span class="line">        <span class="keyword">elif</span> old_local_reprs[name] != value_repr:</span><br><span class="line">            self.write(<span class="string">'&#123;indent&#125;Modified var:.. &#123;name&#125; = &#123;value_repr&#125;'</span>.format(</span><br><span class="line">                **locals()))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#                                                                     #</span></span><br><span class="line">    <span class="comment">### Finished newish and modified variables. ###########################</span></span><br></pre></td></tr></table></figure>
<p>而后，对当前frame的变量状态进行分析。如果有新的变量，则标明新变量或者调用参数；如果有变量跟上一次值不一样，则标明修改了一个变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(...)</span>:</span></span><br><span class="line">    <span class="comment"># 接上</span></span><br><span class="line">    now_string = datetime_module.datetime.now().time().isoformat()</span><br><span class="line">    line_no = frame.f_lineno</span><br><span class="line">    source_line = get_source_from_frame(frame)[line_no - <span class="number">1</span>]</span><br><span class="line">    thread_info = <span class="string">""</span></span><br><span class="line">    <span class="keyword">if</span> self.thread_info:</span><br><span class="line">        current_thread = threading.current_thread()</span><br><span class="line">        thread_info = <span class="string">"&#123;ident&#125;-&#123;name&#125; "</span>.format(</span><br><span class="line">            ident=current_thread.ident, name=current_thread.getName())</span><br><span class="line">    thread_info = self.set_thread_info_padding(thread_info)</span><br><span class="line"></span><br><span class="line">    <span class="comment">### Dealing with misplaced function definition: #######################</span></span><br><span class="line">    <span class="comment">#                                                                     #</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'call'</span> <span class="keyword">and</span> source_line.lstrip().startswith(<span class="string">'@'</span>):</span><br><span class="line">        <span class="comment"># If a function decorator is found, skip lines until an actual</span></span><br><span class="line">        <span class="comment"># function definition is found.</span></span><br><span class="line">        <span class="keyword">for</span> candidate_line_no <span class="keyword">in</span> itertools.count(line_no):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                candidate_source_line = \</span><br><span class="line">                    get_source_from_frame(frame)[candidate_line_no - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">except</span> IndexError:</span><br><span class="line">                <span class="comment"># End of source file reached without finding a function</span></span><br><span class="line">                <span class="comment"># definition. Fall back to original source line.</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> candidate_source_line.lstrip().startswith(<span class="string">'def'</span>):</span><br><span class="line">                <span class="comment"># Found the def line!</span></span><br><span class="line">                line_no = candidate_line_no</span><br><span class="line">                source_line = candidate_source_line</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="comment">#                                                                     #</span></span><br><span class="line">    <span class="comment">### Finished dealing with misplaced function definition. ##############</span></span><br></pre></td></tr></table></figure>
<p>然后，除去新建变量/修改变量之外，其它的日志都打印当前时间、event、源码以及线程信息。</p>
<p>对于装饰器，则暂且跳过，寻找真正的函数声明。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(...)</span>:</span></span><br><span class="line">    <span class="comment"># 接上</span></span><br><span class="line">    <span class="comment"># If a call ends due to an exception, we still get a 'return' event</span></span><br><span class="line">    <span class="comment"># with arg = None. This seems to be the only way to tell the difference</span></span><br><span class="line">    <span class="comment"># https://stackoverflow.com/a/12800909/2482744</span></span><br><span class="line">    code_byte = frame.f_code.co_code[frame.f_lasti]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(code_byte, int):</span><br><span class="line">        code_byte = ord(code_byte)</span><br><span class="line">    ended_by_exception = (</span><br><span class="line">            event == <span class="string">'return'</span></span><br><span class="line">            <span class="keyword">and</span> arg <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">and</span> (opcode.opname[code_byte]</span><br><span class="line">                    <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">'RETURN_VALUE'</span>, <span class="string">'YIELD_VALUE'</span>))</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ended_by_exception:</span><br><span class="line">        self.write(<span class="string">'&#123;indent&#125;Call ended by exception'</span>.</span><br><span class="line">                    format(**locals()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.write(<span class="string">u'&#123;indent&#125;&#123;now_string&#125; &#123;thread_info&#125;&#123;event:9&#125; '</span></span><br><span class="line">                    <span class="string">u'&#123;line_no:4&#125; &#123;source_line&#125;'</span>.format(**locals()))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'return'</span>:</span><br><span class="line">        <span class="keyword">del</span> self.frame_to_local_reprs[frame]</span><br><span class="line">        thread_global.depth -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ended_by_exception:</span><br><span class="line">            return_value_repr = utils.get_shortish_repr(arg)</span><br><span class="line">            self.write(<span class="string">'&#123;indent&#125;Return value:.. &#123;return_value_repr&#125;'</span>.</span><br><span class="line">                        format(**locals()))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'exception'</span>:</span><br><span class="line">        exception = <span class="string">'\n'</span>.join(traceback.format_exception_only(*arg[:<span class="number">2</span>])).strip()</span><br><span class="line">        exception = utils.truncate(exception, utils.MAX_EXCEPTION_LENGTH)</span><br><span class="line">        self.write(<span class="string">'&#123;indent&#125;&#123;exception&#125;'</span>.</span><br><span class="line">                    format(**locals()))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> self.trace</span><br></pre></td></tr></table></figure>
<p>最后就是return跟exception的判定，两者有一定的交集（可见上面注释），因此根据不同情况从当前作用域变量表<code>locals()</code>提取不同变量打印不同信息。这里也不需细述。</p>
<p>总体看来，pysnooper提供的hook还是非常轻量实用的。虽然存在这兼容async task跟自定义hook（trace）的问题，但在平时debug中已经可以满足许多需求了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以前写python的时间算起来应该是最多的，但是python调试相关的工作都没有好好研究过，说来也有点小惭愧。</p>
<p>这次借着试水pysnooper的机会，涨了许多见识，也顺便对python底层有了初步的了解。</p>
<p>虽然自己习惯肉眼debug，但pysnooper作为一个debug黑科技，还是相当给力！！！</p>
]]></content>
      <categories>
        <category>GitHub探索</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>python</tag>
        <tag>pysnooper</tag>
        <tag>逆向</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>【Easy Python】最终话：重回首知识点，让python真正easy！</title>
    <url>/2019/05/19/easypython/vii/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Easy Python终于来到完结，我的领导也夸奖我写作非常的卖力用心。对此，我深表欣慰！</p>
<p>六章Python讲解，并不单纯是切磋代码技艺，而更是注重于每一行代码背后发生的事儿</p>
<p>为此，让我们一起重回首Easy Python系列，光荣收尾吧！</p>
<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><a id="more"></a>
<h3 id="第一话：print-‘HelloWorld’-——输入、输出与函数"><a href="#第一话：print-‘HelloWorld’-——输入、输出与函数" class="headerlink" title="第一话：print(‘HelloWorld’)——输入、输出与函数"></a><a href="https://utmhikari.github.io/2019/03/09/easypython/i">第一话：print(‘HelloWorld’)——输入、输出与函数</a></h3><p>HelloWorld，是代码世界的入口。当我们采用Python语言打下print(‘HelloWorld’)的一刻，是否想过print——这个函数，到底表示什么呢？到底能怎么用呢？</p>
<p>这个话题就可以衍生到“函数”（功能模块）相关的话题。把一个大的程序进行过程解耦，我们可以分解之为小的功能模块。每一个模块都有相应的输入与输出，这样就把整一个程序串起来了。</p>
<p>在第一话，我们提到的知识有：</p>
<ul>
<li>函数与过程（function &amp; process）</li>
<li>输入&amp;参数&amp;关键字/无关键字参数（input, arguments, *args &amp; **kwargs）</li>
<li>输出&amp;返回（output &amp; return）</li>
</ul>
<h3 id="第二话：映射——输入、输出与函数的纽带"><a href="#第二话：映射——输入、输出与函数的纽带" class="headerlink" title="第二话：映射——输入、输出与函数的纽带"></a><a href="https://utmhikari.github.io/2019/03/16/easypython/ii">第二话：映射——输入、输出与函数的纽带</a></h3><p>映射代表了输入与输出的关系，而函数则实现了映射。在我们日常码码中，如果能用映射的方式表示一段程序，能够增强代码的可读性</p>
<p>在第二话，我们提到的知识有：</p>
<ul>
<li>映射（mapping）</li>
<li>字典及其映射实现（dict &amp; hash）</li>
<li>函数式编程&amp;python示例（functional programming with its example）</li>
</ul>
<h3 id="第三话：爬虫初探——玩转豆瓣二百五（上）"><a href="#第三话：爬虫初探——玩转豆瓣二百五（上）" class="headerlink" title="第三话：爬虫初探——玩转豆瓣二百五（上）"></a><a href="https://utmhikari.github.io/2019/03/31/easypython/iii">第三话：爬虫初探——玩转豆瓣二百五（上）</a></h3><p>python在数据分析方面的应用非常广泛。在网上有非常多的爬虫教程，然而爬虫背后到底干了什么，我们却不易知晓。</p>
<p>同样，豆瓣top250电影的信息爬取也是许多同学的入门之径。Easy Python也是一样，采用上下两话介绍豆瓣250的python爬虫——爬什么，怎么爬，为什么这么爬——所有的一切，全部浓缩成精华。</p>
<p>在第三话，我们抓取了top250电影的链接，所涉及到的知识有：</p>
<ul>
<li>网络基础：HTTP、URL、协议、状态码等（HTTP, URL, Protocol, Status Code, Resources, etc）</li>
<li>HTML网页与BeautifulSoup解析（HTML page &amp; BeautifulSoup Parser）</li>
<li>Chrome开发者模式（Chrome Developer Mode）</li>
</ul>
<h3 id="第四话：爬虫初探——玩转豆瓣二百五（下）"><a href="#第四话：爬虫初探——玩转豆瓣二百五（下）" class="headerlink" title="第四话：爬虫初探——玩转豆瓣二百五（下）"></a><a href="https://utmhikari.github.io/2019/03/31/easypython/iv">第四话：爬虫初探——玩转豆瓣二百五（下）</a></h3><p>豆瓣二百五的下篇相对于上篇，爬取了每一个电影链接中的具体电影信息。从编程角度而言，涉及的知识面就更广了：</p>
<ul>
<li>异步并发调度与asyncio库（asynchronous programming &amp; asyncio usage）</li>
<li>阻塞与非阻塞任务（blocking &amp; non-blocking tasks）</li>
<li>爬虫代理池&amp;生产者——消费者调度（proxy pool &amp; producer-consumer model）</li>
<li>条件变量及其等待&amp;唤醒机制（condition variable &amp; wait-notify mechanism）</li>
</ul>
<p>注重代码工程化（强迫症）的同学们，千万不要错过~</p>
<h3 id="第五话：小试scikit-learn数据挖掘——newsgroup数据处理与文本分类"><a href="#第五话：小试scikit-learn数据挖掘——newsgroup数据处理与文本分类" class="headerlink" title="第五话：小试scikit-learn数据挖掘——newsgroup数据处理与文本分类"></a><a href="https://utmhikari.github.io/2019/04/14/easypython/v">第五话：小试scikit-learn数据挖掘——newsgroup数据处理与文本分类</a></h3><p>第五话对数据处理&amp;文本分析的基本操作做了讲解，简要地介绍了文本分类的概念与操作，并且打通了Python的机器学习库与我们自己的数据。</p>
<p>在这一话中，涉及到的知识有：</p>
<ul>
<li>数据挖掘，机器学习&amp;文本分类（data-mining, machine-learning &amp; text-classification）</li>
<li>正则表达式（regular expression）</li>
<li>scikit-learn文本分类流水线（pipeline of text-classification via scikit-learn）</li>
</ul>
<h3 id="第六话：multiprocessing——Python多进程并行"><a href="#第六话：multiprocessing——Python多进程并行" class="headerlink" title="第六话：multiprocessing——Python多进程并行"></a><a href="https://utmhikari.github.io/2019/05/11/easypython/vi">第六话：multiprocessing——Python多进程并行</a></h3><p>第六话，讲述了许多同学所关心，踩坑较多的并发编程，剖析了其中原理，并用python实现多任务并行操作。在这方面有疑惑的同学们，千万不要错过！</p>
<p>在这一话中，涉及到的知识有：</p>
<ul>
<li>并发&amp;并行任务（concurrent &amp; parallel tasks）</li>
<li>线程、进程的特性与关系（features &amp; relations of thread &amp; process）</li>
<li>多线程&amp;多进程（multi-threading &amp; multi-processing）</li>
<li>python进程资源共享（shared data on pythonic-multi-processing）</li>
<li>客户端/服务器模式与tornado框架（C/S model &amp; tornado framework）</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从编程爱好者们的角度评价python的话，就好比CSGO玩家评价P90这把武器——“noob gun”，是个人都能上手用起来，太TM简单了。</p>
<p>但是，python的easy仅限于上手容易吗？相对于python，lua对新人那是更加友好，就连我家那笨笨的领导，都说lua看的比python容易。</p>
<p>python简单的意义在于背后强大的社区一直不断地推动着python的轮子，使得我们在各个场景都有轻松驰骋的可能。大多数情况下，我们并不追求完美的质量，但求快速实现基本的操作，那就选择python吧！</p>
<p>Easy Python, lemon squeezy~</p>
]]></content>
      <categories>
        <category>Easy Python</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>教程</tag>
        <tag>python</tag>
        <tag>知识总结</tag>
        <tag>easy python</tag>
      </tags>
  </entry>
  <entry>
    <title>【Easy Python】第六话：multiprocessing——Python多进程并行</title>
    <url>/2019/05/11/easypython/vi/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，我和我的领导回到了母校，和我的师父师母聚餐。聚餐点了很多东西，大碗宽面，牛肉炒饭，韩国烤肉，吃都吃不完。虽然我的领导最近长得比以前p了些，但是吃饭速度还是慢悠悠。唉，要是我的领导能有个三头六臂，每个手都夹菜，每个头都去啃，那吃饭速度可就蹭蹭地涨上去了啊！</p>
<p>人无法三头六臂，但在Python里，我们可以做到。</p>
<h2 id="并发-amp-并行实验"><a href="#并发-amp-并行实验" class="headerlink" title="并发&amp;并行实验"></a>并发&amp;并行实验</h2><p>要想实现三头六臂的效率，不走单一顺序流，我们不仅需要让多个任务能够并发（Concurrent），还能够并行（Parallel）运作。</p>
<p>假使吃饭吃到一半，人有三急，摘花回来继续用膳，那么如果把“吃饭”与“解手”当作两个任务，那么它们便是便是并发运作，但不并行。如果太追求效率，蹲坑恰饭，那便即是并发，也是并行了。</p>
<p>在Python中，我们可以用三种方式实现并发。但是并不是所有的方法，都支持并行。</p>
<p>这三种方法是：</p>
<a id="more"></a>
<ul>
<li>多线程 Multi Threading</li>
<li>多进程 Multi Processing</li>
<li>异步IO Async IO</li>
</ul>
<p>其中，异步IO的实现方法，我们在第四章<a href="https://utmhikari.github.io/2019/03/31/easypython/iv">《玩转豆瓣二百五：下》</a>中已经介绍过。多线程和多进程的实现方法，可以参考<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvemgtY24vMy8=" title="https://docs.python.org/zh-cn/3/">Python官方文档<i class="fa fa-external-link"></i></span>，或者干脆直接看下面的实例。</p>
<p>通过一个简单的运行时间测试我们就可以发现，这三种方法中，哪些方法是能够真正利用并行的效率：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line">TOTAL = <span class="number">20000</span>  <span class="comment"># 子任务执行次数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(n)</span>:</span>  <span class="comment"># 每个子任务，从n减到-n</span></span><br><span class="line">    end = -n</span><br><span class="line">    <span class="keyword">while</span> n &gt; end:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequential</span><span class="params">()</span>:</span>  <span class="comment"># 一般的顺序执行</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(TOTAL):</span><br><span class="line">        task(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_process</span><span class="params">()</span>:</span>  <span class="comment"># 多进程，设定最大进程数为10，放到一个池里调度</span></span><br><span class="line">    pool = Pool(<span class="number">10</span>)</span><br><span class="line">    pool.map(task, range(TOTAL))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">async_io</span><span class="params">()</span>:</span>  <span class="comment"># 异步IO，详见Easy Python第四章</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">async_task</span><span class="params">(n)</span>:</span></span><br><span class="line">        task(n)</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*[async_task(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(TOTAL)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_thread</span><span class="params">()</span>:</span>  <span class="comment"># 多线程，设定10个线程，每个线程执行2000个task</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tasks</span><span class="params">(ns)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> ns:</span><br><span class="line">            task(n)</span><br><span class="line">    threads = []</span><br><span class="line">    inputs = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(TOTAL):</span><br><span class="line">        inputs[(i % <span class="number">10</span>)].append(i)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        threads.append(Thread(target=functools.partial(tasks, inputs[i])))</span><br><span class="line">        threads[<span class="number">-1</span>].start()</span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># sequential</span></span><br><span class="line">    start = datetime.datetime.now()</span><br><span class="line">    sequential()</span><br><span class="line">    print(<span class="string">"Sequential: %s"</span> % (datetime.datetime.now() - start).total_seconds())</span><br><span class="line">    <span class="comment"># multi-process</span></span><br><span class="line">    start = datetime.datetime.now()</span><br><span class="line">    multi_process()</span><br><span class="line">    print(<span class="string">"Multi-Process: %s"</span> % (datetime.datetime.now() - start).total_seconds())</span><br><span class="line">    <span class="comment"># asyncio</span></span><br><span class="line">    start = datetime.datetime.now()</span><br><span class="line">    asyncio.run(async_io())</span><br><span class="line">    print(<span class="string">"Async-IO: %s"</span> % (datetime.datetime.now() - start).total_seconds())</span><br><span class="line">    <span class="comment"># multi-thread</span></span><br><span class="line">    start = datetime.datetime.now()</span><br><span class="line">    multi_thread()</span><br><span class="line">    print(<span class="string">"Multi-Thread: %s"</span> % (datetime.datetime.now() - start).total_seconds())</span><br></pre></td></tr></table></figure>
<p>结果出炉！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sequential: 18.116519</span><br><span class="line">Multi-Process: 3.879628</span><br><span class="line">Async-IO: 18.225281</span><br><span class="line">Multi-Thread: 18.119936</span><br></pre></td></tr></table></figure>
<p>我们发现，只有采用多进程的方式，能够符合我们的并行猜测。其它方式，甚至比顺序执行还要慢一些，应当不是并行运行。</p>
<h2 id="为什么是多进程？"><a href="#为什么是多进程？" class="headerlink" title="为什么是多进程？"></a>为什么是多进程？</h2><h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><p>首先，我们简要介绍一下<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGhyZWFkXyUyOGNvbXB1dGluZyUyOQ==" title="https://en.wikipedia.org/wiki/Thread_%28computing%29">线程<i class="fa fa-external-link"></i></span>与<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHJvY2Vzc18lMjhjb21wdXRpbmclMjk=" title="https://en.wikipedia.org/wiki/Process_%28computing%29">进程<i class="fa fa-external-link"></i></span>。</p>
<ul>
<li>线程（Thread）：操作系统调度最小单位，顺序执行的程序流</li>
<li>进程（Process）：计算机程序的实例，线程的容器</li>
</ul>
<p>进程，好比是一个特定工作的流程，是相对宏观的；线程，则是一个个子任务的流程，是相对微观的。一个进程中，可以容纳多个不同的线程以执行不同类型的工作。同一个进程的不同线程之间，共享了许多当前进程信息，相互独立性较弱；而同一个操作系统的进程之间，共享信息较少，相互独立性强。</p>
<p>在实际执行程序的时候，对于单个（核）CPU而言，同一时刻只能跑一个特定的线程。CPU通过不停地切换不同线程实现各个线程任务的并发，并且由于CPU手速太快，造成了我们一按<code>ctrl + alt + del</code>所看到的，同一时刻几十个进程都在同时跑的假象。但是，对于多核CPU而言，我们就可以做到在多个CPU上，并发并且并行多个线程，增加执行效率。但即便如此，Python的多线程，却无法做到这一点。</p>
<h3 id="全局解释器锁GIL"><a href="#全局解释器锁GIL" class="headerlink" title="全局解释器锁GIL"></a>全局解释器锁GIL</h3><p>Python多线程无法利用多核CPU的优势，其罪魁祸首，在于全局解释器锁（GIL，Global Interpreter Lock）</p>
<p>了解GIL，可以看这个资料：<span class="exturl" data-url="aHR0cDovL3d3dy5kYWJlYXouY29tL3B5dGhvbi9VbmRlcnN0YW5kaW5nR0lMLnBkZg==" title="http://www.dabeaz.com/python/UnderstandingGIL.pdf">UnderstandingGIL<i class="fa fa-external-link"></i></span></p>
<p>运行Python代码，需要通过解释器（Intepreter）进行。Python解释器在读取了一行Python代码后，就会将其执行，执行完后，再读取下一行代码，以此类推。</p>
<p>GIL能够使得同一时刻，只有一个线程能在执行。Python的官方实现Cython就采用了这种机制，保证Python进程中资源的状态能够同步（synchronize）到各个线程中。可以看到，GIL简单粗暴，让我们省去了资源同步的担忧，但相对地，造成了一种同一时刻一个线程包场的景象，不能满足细粒度的资源同步操作。</p>
<p>因此，解决这个问题的办法就是开启多个进程，让每一个进程都有自己的解释器跟GIL。这样，就能实现多任务的并行了。</p>
<h2 id="多进程资源共享——TornadoCenter"><a href="#多进程资源共享——TornadoCenter" class="headerlink" title="多进程资源共享——TornadoCenter"></a>多进程资源共享——TornadoCenter</h2><p>进程之间的资源信息通常是不共享的，因此要借由系统自身的机制。比如说内存信息共享，在Python的多进程模块<code>multiprocessing</code>中，就提供了<code>Pipe（管道）</code>、<code>Queue（队列）</code>等方式，使得不同进程之间的数据可以共享。</p>
<p>在我的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9Ub3JuYWRvQ2VudGVy" title="https://github.com/utmhikari/TornadoCenter">TornadoCenter<i class="fa fa-external-link"></i></span>小项目中，就有这样的一个实例——主进程是cmd小黑框命令行程序，通过规定的指令可以开启服务器进程与客户端进程。客户端进程通过网络读写往服务器进程发送数据，而服务器进程则通过<code>Queue</code>队列发送数据给主进程。Tornado是一个著名的Python网络框架，因此能满足这方面的需求。</p>
<p>主进程大概设计如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    忽略其它初始化</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self._cmd_state = &#123;</span><br><span class="line">        <span class="string">'exit'</span>: self._exit,</span><br><span class="line">        <span class="string">'help'</span>: self._help,</span><br><span class="line">        <span class="string">'server'</span>: &#123;</span><br><span class="line">            <span class="string">'start'</span>: self._start_server,</span><br><span class="line">            <span class="string">'stop'</span>: self._stop_server,</span><br><span class="line">            <span class="string">'params'</span>: self._show_server_params,</span><br><span class="line">            <span class="string">'status'</span>: self._show_server_status</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'client'</span>: &#123;</span><br><span class="line">            <span class="string">'start'</span>: self._start_client,</span><br><span class="line">            <span class="string">'stop'</span>: self._stop_client,</span><br><span class="line">            <span class="string">'status'</span>: self._show_client_status</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    self._server_holder = TornadoTCPServerHolder()</span><br><span class="line">    self._client_holder = TornadoTCPClientHolder()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_dispatch</span><span class="params">(self, cmds, cmd_state)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    dispatch cmds on cmd state machine</span></span><br><span class="line"><span class="string">    :param cmds: cmd.split(' ')</span></span><br><span class="line"><span class="string">    :param cmd_state: the current state of cmd</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    len_cmd = len(cmds)</span><br><span class="line">    <span class="keyword">if</span> len_cmd == <span class="number">0</span> <span class="keyword">or</span> cmds[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> cmd_state.keys():</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    state = cmd_state[cmds[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">if</span> callable(state):</span><br><span class="line">        sig = signature(state)</span><br><span class="line">        len_pars = len(sig.parameters)</span><br><span class="line">        <span class="keyword">if</span> len_pars == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> state() <span class="keyword">if</span> len_cmd == <span class="number">1</span> <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> functools.partial(state, cmds[<span class="number">1</span>:])() <span class="keyword">if</span> len_cmd &gt; <span class="number">1</span> <span class="keyword">else</span> state()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> self._dispatch(cmds[<span class="number">1</span>:], state) <span class="keyword">if</span> len_cmd &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Main loop of TornadoCenter</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self._log(<span class="string">'Start main loop!!!'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cmd = input(<span class="string">'\n$ '</span>).strip()</span><br><span class="line">        <span class="keyword">if</span> len(cmd) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        cmds = cmd.split(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._dispatch(cmds, self._cmd_state):</span><br><span class="line">            self._exception(<span class="string">'Invalid command: %s!'</span> % cmd)</span><br><span class="line">            self._help()</span><br></pre></td></tr></table></figure>
<p>我们来拆解一下业务：</p>
<ul>
<li>初始化变量<ul>
<li>cmd_state: 根据指令查找对应执行函数的reference</li>
<li>server_holder: 管理服务器进程</li>
<li>client_holder: 管理客户端进程</li>
</ul>
</li>
<li>函数<ul>
<li>loop：主循环，使得我们在cmd界面上能一直输入指令，输错了则显示帮助</li>
<li>dispatch: 根据指令与cmd_state，查找&amp;执行对应函数</li>
</ul>
</li>
</ul>
<p>对于管理服务器进程的<code>server_holder</code>，我们需要让其持有服务器进程的实例<code>process</code>，互通服务器进程数据的通道<code>queue</code>，以及查询服务器进程状态的一些接口。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TornadoTCPServerHolder</span><span class="params">(BaseCSHolder)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Tornado TCPServer Holder</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialization</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        BaseCSHolder.__init__(self, <span class="string">'TCPServerHolder'</span>)</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Server Info</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self._process = <span class="literal">None</span></span><br><span class="line">        self._queue = Queue()</span><br><span class="line">        self._params = &#123;</span><br><span class="line">            <span class="string">'host'</span>: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">            <span class="string">'port'</span>: <span class="number">5000</span>,</span><br><span class="line">            <span class="string">'num_processes'</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Monitor Thread</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self._monitor = <span class="literal">None</span></span><br><span class="line">        self._is_monitor_stop = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_monitor_loop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Monitor thread, print the data received by the server</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._log(<span class="string">'Starting Monitor...'</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> self._is_monitor_stop:</span><br><span class="line">                self._is_monitor_stop = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self._queue.empty():</span><br><span class="line">                data = self._queue.get()</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">if</span> data.startswith(<span class="string">'JSON|'</span>):</span><br><span class="line">                        json_data = json.loads(data[<span class="number">5</span>:])</span><br><span class="line">                        self._log(<span class="string">'Received JSON data: %s\n%s'</span> % (</span><br><span class="line">                            type(json_data), json.dumps(json_data, indent=<span class="number">2</span>)</span><br><span class="line">                        ))</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        self._log(<span class="string">'Received String: %s'</span> % data)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    self._exception(e)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Start Tornado TCPServer Process</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._log(<span class="string">'Starting Tornado TCPServer...'</span>)</span><br><span class="line">        <span class="keyword">if</span> self.is_server_active():</span><br><span class="line">            self._exception(<span class="string">'Cannot start server! The TCPServer is still active!'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._process = TornadoTCPServerProcess(queue=self._queue, params=self._params)</span><br><span class="line">            self._process.start()</span><br><span class="line">            self._monitor = Thread(target=self._monitor_loop)</span><br><span class="line">            self._monitor.start()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>物以类聚，我们可以将服务器进程的管理抽象到一个类中。这个类继承了另外一个叫<code>BaseCSHolder</code>的类，具备打印日志以及编辑参数的功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseCSHolder</span><span class="params">(Logger)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Client and Server Holder Class</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, tag=<span class="string">'BaseCSHolder'</span>)</span>:</span></span><br><span class="line">        Logger.__init__(self, tag)</span><br><span class="line">        self._params = dict()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_param_keys</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        get the keys of params</span></span><br><span class="line"><span class="string">        :return: sorted param keys</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> sorted(self._params.keys())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_params</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        get the params</span></span><br><span class="line"><span class="string">        :return: params dict</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self._params</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_params</span><span class="params">(self, params)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        set the params of the server</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span>  <span class="comment"># 此处省略</span></span><br></pre></td></tr></table></figure>
<p>总的来看，在启动服务器进程之后，同时也起一个线程执行<code>monitor_loop</code>的逻辑，监控<code>Queue</code>里的数据。每当<code>Queue</code>里有数据的时候，就取出来数据，打印出来。</p>
<p>对于服务器进程的实例（Server Process Instance），我们可以让其持有服务器实例（Server Instance）、主线程传递的信息（比如服务器参数与<code>Queue</code>）以及其它自身信息。服务器进程实例相当于是服务器实例的容器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TornadoTCPServerProcess</span><span class="params">(Process, Logger)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    TCPServer Process</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, queue=None, params=None)</span>:</span></span><br><span class="line">        Process.__init__(self, daemon=<span class="literal">True</span>)</span><br><span class="line">        Logger.__init__(self, <span class="string">'TCPServerProcess'</span>)</span><br><span class="line">        self._queue = queue</span><br><span class="line">        self._params = params</span><br><span class="line">        self._server = <span class="literal">None</span>  <span class="comment"># 运行该进程（run）后，会开启服务器实例</span></span><br></pre></td></tr></table></figure>
<p>而最后，对于服务器实例，就是实实在在地继承服务器框架了。</p>
<p>Tornado框架的用法，可以参考<span class="exturl" data-url="aHR0cDovL3d3dy50b3JuYWRvd2ViLm9yZy9lbi9zdGFibGUvZ3VpZGUuaHRtbA==" title="http://www.tornadoweb.org/en/stable/guide.html">官方文档<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TornadoTCPServer</span><span class="params">(TCPServer, Logger)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    TCPServer instance of tornado</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, queue=None)</span>:</span></span><br><span class="line">        TCPServer.__init__(self)</span><br><span class="line">        Logger.__init__(self, <span class="string">'TCPServer'</span>)</span><br><span class="line">        self._queue = queue</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handle_stream</span><span class="params">(self, stream, address)</span>:</span></span><br><span class="line">        host, port = address</span><br><span class="line">        addr = <span class="string">'%s:%s'</span> % (host, port)</span><br><span class="line">        self._log(<span class="string">'Handling stream at %s'</span> % addr)</span><br><span class="line">        proto_cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">await</span> stream.write(<span class="string">'Welcome to tornado server!'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                data = <span class="keyword">await</span> stream.read_bytes(<span class="number">4096</span>, partial=<span class="literal">True</span>)</span><br><span class="line">                decode_data = data.decode().strip()</span><br><span class="line">                self._queue.put(decode_data)</span><br><span class="line">                proto_cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> proto_cnt % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">                    self._log(<span class="string">'Received %d protos from %s!'</span> % (proto_cnt, addr))</span><br><span class="line">            <span class="keyword">except</span> StreamClosedError:</span><br><span class="line">                self._log(<span class="string">'Stream at %s:%s is closed!'</span> % (host, port))</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>可以看到，每次服务器实例在收到数据后，就会把数据解码放到<code>Queue</code>队列头里。这样在主线程那一端，就可以实时在队列尾取出数据打印了。</p>
<p>这样，我们就实现了多进程之间的资源共享。怎么样，要不要试试“千手观音”~</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有了多进程与异步的支持，Python在基础任务调度上，更是增强了一个层次</p>
<p>Easy Python第六章——多进程并行，也标志着Easy Python系列进入尾声</p>
<p>第七章，会对Easy Python系列做最终的整理</p>
<p>See ya~</p>
]]></content>
      <categories>
        <category>Easy Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>GIL</tag>
        <tag>并行</tag>
        <tag>并发</tag>
        <tag>multiprocessing</tag>
      </tags>
  </entry>
  <entry>
    <title>【DIY小记】踏平Win10升级之坑——我们无法更新系统保留的分区</title>
    <url>/2019/05/01/diymemo/msr/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天心血来潮，想把自己船上的Win10更新到18年10月的版本（1809），结果易升下载了更新之后，安装时提示“我们无法更新系统保留的分区”，于是一脸懵逼。</p>
<p><img src="/uploads/diymemo/msr/nomsr.png" alt="我们无法更新系统保留的分区" title="&#39;我们无法更新系统保留的分区&#39;"></p>
<p>坑也是要慢慢踩的。熬了两夜，终于成功解决了这个问题，将Win10升级到了最新版本。</p>
<h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>遇到这个问题后，笔者第一时间google百度了下解决方案，看到了以下几条：</p>
<a id="more"></a>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9hbnN3ZXJzLm1pY3Jvc29mdC5jb20vemgtaGFucy93aW5kb3dzL2ZvcnVtL3dpbmRvd3M4XzEtdXBkYXRlLyVFNSVBRSU4OSVFOCVBMyU4NXdpbjEwJUU2JTgwJUJCJUU2JTk4JUFGJUU2JThGJTkwLzJmN2JiZGI0LTMzYmQtNGE3Yy1iZDg1LTU3NzFhNWFmMTZjZQ==" title="https://answers.microsoft.com/zh-hans/windows/forum/windows8_1-update/%E5%AE%89%E8%A3%85win10%E6%80%BB%E6%98%AF%E6%8F%90/2f7bbdb4-33bd-4a7c-bd85-5771a5af16ce">安装win10总是提示：我们无法更新系统保留的分区<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL21vczg2LmNvbS80MTE1Mi5odG1s" title="http://mos86.com/41152.html">此PC不能运行Windows 10 – 我们无法更新系统保留分区<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jicy5wY2JldGEuY29tL2ZvcnVtLnBocD9tb2Q9dmlld3RocmVhZCZhbXA7dGlkPTE3MzU5MjM=" title="http://bbs.pcbeta.com/forum.php?mod=viewthread&amp;tid=1735923">win10.15063更新出错”我们无法更新系统保留的分区”<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jicy5wY2JldGEuY29tL2ZvcnVtLnBocD9tb2Q9dmlld3RocmVhZCZhbXA7dGlkPTE2MjA5NzA=" title="http://bbs.pcbeta.com/forum.php?mod=viewthread&amp;tid=1620970">求助，无法更新windows10!!!问题“我们无法更新系统保留的分区”！！！！！！！！！！<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3RpZWJhLmJhaWR1LmNvbS9wLzQ0MDAxNTU5OTc=" title="http://tieba.baidu.com/p/4400155997">求助，我们无法更新系统保留的分区<i class="fa fa-external-link"></i></span></li>
<li>and so on…</li>
</ul>
<p>总的来看，应该是先前装Windows系统时，安装程序会自动创建一个保留分区，但是由于分区不够大，导致无法安装新版本的系统。</p>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>为了解决这个问题，笔者果断打开祖传的<span class="exturl" data-url="aHR0cDovL3d3dy5kaXNrZ2VuaXVzLmNuLw==" title="http://www.diskgenius.cn/">DiskGenius<i class="fa fa-external-link"></i></span>，查看了下硬盘分区</p>
<p><img src="/uploads/diymemo/msr/efi.jpg" alt="引导分区" title="&#39;引导分区&#39;"></p>
<p><img src="/uploads/diymemo/msr/msr.jpg" alt="MSR" title="&#39;MSR&#39;"></p>
<p>上图是引导分区（Boot），里边的记录着整个电脑的引导信息。我们常说的启动、重启，其实也就是引导、重引导（Boot&amp;Reboot）。在咱们电脑刚开机的时候，就是利用这个分区的文件来启动操作系统的。</p>
<p>下图是MSR分区（Microsoft Reserved Partition）是Windows装机时候自动会开的预留分区，也就正好对应着提示里的“保留分区”了。我们的工作主要针对这个进行。</p>
<p>如果要扩容MSR分区的话，只能用这个分区相邻的空间。从DiskGenius界面上部分的硬盘条来看，MSR分区的左边是引导分区，存放着启动系统的文件，不好清掉；MSR分区的右边刚上船就自带的恢复分区（Microsoft Recovery Partition），大概500M大小。从网上搜到的资料来看，更新Win10大概需要用到预留分区空间500M左右，原来的MSR加上Recovery的空间加起来也是500M左右，其实是不保险的。再往右的话，就是C盘空间，可以看到那一块空间已经被C盘文件占用了，没法分给MSR分区。</p>
<p>为此，采取以下方案解决问题:</p>
<ul>
<li>删除原先的MSR与恢复分区，将这些空间暂时分给引导分区</li>
<li>C盘抽出3G，新建MSR与恢复分区</li>
</ul>
<h3 id="修复工作"><a href="#修复工作" class="headerlink" title="修复工作"></a>修复工作</h3><p>实现修复操作步骤如下：</p>
<h4 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h4><ol>
<li>备份引导文件——用DiskGenius把引导分区的文件拷贝出来。由于笔者装了Win10跟Linux Mint双系统，因此引导文件缺失的话代价就很大了</li>
<li>制作进入WinPE环境（Windows Preinstall Environment）的U盘启动盘（带各类装机工具）。平时我们做一些装系统跟系统修复操作，就是在在WinPE环境下进行的。具体方式，比如可以下一个<span class="exturl" data-url="aHR0cHM6Ly93d3cubGFvbWFvdGFvLm5ldC9kb3duLw==" title="https://www.laomaotao.net/down/">老毛桃<i class="fa fa-external-link"></i></span>就可以将空的U盘制作成启动盘。制作成启动盘的U盘放其它文件也并不影响其功能。</li>
<li>重启电脑，进入BIOS界面，在启动/引导相关的选项中，将U盘启动优先级调到最高。进入BIOS界面的方法要根据主板/电脑厂家来定。要调整优先级的话，就找Boot之类的选项然后调整顺序。这一步骤基本只需要懂点英文。调好之后再重启，这时候应该就可以进到U盘里老毛桃设置的PE系统了。</li>
<li>进入老毛桃系统后，打开里面自带的DiskGenius（分区工具），记录一下原先MSR与恢复分区的规格（格式、是否隐藏、是否点选厂家OEM之类），然后删除原先的MSR与恢复分区，将这些空间分给引导分区</li>
<li>改变C盘大小，抽出3G空间。1G新建分区，格式为Microsoft Reserved Partition，另外2G新建分区，格式为Microsoft Recovery Partition。两者具体的规格，最好跟步骤4记录的一样。</li>
<li>重启进入BIOS界面，把Windows启动优先级调到最高。</li>
<li>再重启，就能进Windows啦~拔掉U盘，试试升级吧！</li>
</ol>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>改变分区涉及到的所有文件，最好都备份。虽然C盘文件不备份也可，但如果想要备份，也无所谓= =</li>
<li>每进行一次改变分区操作之前，都要仔细看说明！操作之后，保存分区表</li>
<li>不要怕，但一定要冷静</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>装机坑多，但更重要的是有一颗主动查资料，敢于踩坑解决问题的决心。</p>
<p>说到这里，我就想到了我家领导，电脑一出bug，就想着重装系统，毫无志气。</p>
<ul>
<li>都9012年了，系统出bug，第一感怎么还是重装系统？？？笨笨！！！</li>
<li>你连问题的严重程度都没调研过，怎么能强行付出重装系统的代价呢？？？小傻瓜！！！</li>
<li>你要重装，你自己重装啊！！！劳资免费帮你无痛修电脑还不愿意！！！唔QAQ</li>
<li>没电脑知识不是借口，要善于求助，多给点儿信息，才能更好地解决问题啊= =</li>
</ul>
<p>唉，训归训，啥时候才能长点威风唔</p>
]]></content>
      <categories>
        <category>DIY小记</category>
      </categories>
      <tags>
        <tag>Win10</tag>
        <tag>DiskGenius</tag>
        <tag>MSR</tag>
        <tag>保留分区</tag>
        <tag>WinPE</tag>
      </tags>
  </entry>
  <entry>
    <title>【Lua杂谈】探索C API，开坑lnodelist</title>
    <url>/2019/04/20/luatalk/lnodelist/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近一直在探索Lua的C API编程部分，上次实现了一个函数执行时间统计库：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9sZnVuY3RpbWVy" title="https://github.com/utmhikari/lfunctimer">lfunctimer<i class="fa fa-external-link"></i></span>，这次就果断写了一个<code>lnodelist</code>来玩玩。在这期间，遇到了许多纠结的问题，因此果断做下分享~</p>
<p>测试用例现在贼少= =想要试用的同学可以走<code>lnodelist</code>的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9sbm9kZWxpc3Q=" title="https://github.com/utmhikari/lnodelist">Github传送门<i class="fa fa-external-link"></i></span>，或者<code>luarocks install lnodelist</code>，就可以开始干起~</p>
<p>在Lua里，table充当着array以及hashmap两个角色，提供了简单的insert、remove、concat等功能。<code>lnodelist</code>则是独立于table之外建立一个崭新的<code>list/array</code>数据结构，暂时是一个双向链表。API的需求上，则兼并java的LinkedList跟js的array两种体系，列表如下：</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> luaL_Reg lnodelist_f[] = &#123;</span><br><span class="line">  &#123;<span class="string">"new"</span>, list_new&#125;,  <span class="comment">// local l = list.new()</span></span><br><span class="line">  &#123;<span class="string">"size"</span>, list_size&#125;,  <span class="comment">// list.size(l) or #l</span></span><br><span class="line">  &#123;<span class="string">"push"</span>, list_push&#125;,  <span class="comment">// list.push(l, val)</span></span><br><span class="line">  &#123;<span class="string">"pushleft"</span>, list_pushleft&#125;,  <span class="comment">// list.pushleft(l, val)</span></span><br><span class="line">  &#123;<span class="string">"pop"</span>, list_pop&#125;,  <span class="comment">// list.pop(l) -&gt; last val</span></span><br><span class="line">  &#123;<span class="string">"popleft"</span>, list_popleft&#125;,  <span class="comment">// list.popleft(l) -&gt; first val</span></span><br><span class="line">  &#123;<span class="string">"remove"</span>, list_remove&#125;,  <span class="comment">// list.remove(l)</span></span><br><span class="line">  &#123;<span class="string">"removeleft"</span>, list_removeleft&#125;,  <span class="comment">// list.removeleft(l)</span></span><br><span class="line">  &#123;<span class="string">"set"</span>, list_set&#125;,  <span class="comment">// list.set(l, idx, val)</span></span><br><span class="line">  &#123;<span class="string">"get"</span>, list_get&#125;,  <span class="comment">// list.get(l, idx) -&gt; l[idx]</span></span><br><span class="line">  &#123;<span class="string">"insert"</span>, list_insert&#125;,  <span class="comment">// list.insert(l, idx, val)</span></span><br><span class="line">  &#123;<span class="string">"delete"</span>, list_delete&#125;,  <span class="comment">// list.delete(l, idx)</span></span><br><span class="line">  &#123;<span class="string">"reverse"</span>, list_reverse&#125;,  <span class="comment">// list.reverse(l)</span></span><br><span class="line">  &#123;<span class="string">"clear"</span>, list_clear&#125;,  <span class="comment">// list.clear(l)</span></span><br><span class="line">  &#123;<span class="string">"extend"</span>, list_extend&#125;,  <span class="comment">// list.extend(l1, l2)</span></span><br><span class="line">  &#123;<span class="string">"slice"</span>, list_slice&#125;,  <span class="comment">// list.slice(l [, start [, end]]) -&gt; sl</span></span><br><span class="line">  &#123;<span class="string">"join"</span>, list_join&#125;,  <span class="comment">// list.join(l, sep [,start [, end]])</span></span><br><span class="line">  &#123;<span class="string">"foreach"</span>, list_foreach&#125;,  <span class="comment">// list.foreach(l, (val, idx) =&gt; &#123;&#125;)</span></span><br><span class="line">  &#123;<span class="string">"map"</span>, list_map&#125;,  <span class="comment">// list.map(l, (val, idx) =&gt; newVal) -&gt; mapl</span></span><br><span class="line">  &#123;<span class="string">"some"</span>, list_some&#125;,  <span class="comment">// list.some(l, (val, idx) =&gt; boolean)</span></span><br><span class="line">  &#123;<span class="string">"find"</span>, list_find&#125;,  <span class="comment">// list.find(l, (val, idx) =&gt; trueVal)</span></span><br><span class="line">  &#123;<span class="string">"__len"</span>, list_size&#125;,  <span class="comment">// same as list.size(l)</span></span><br><span class="line">  &#123;<span class="string">"__gc"</span>, list_clear&#125;,  <span class="comment">// same as list.clear(l)</span></span><br><span class="line">  &#123;<span class="string">"__tostring"</span>, list_tostring&#125;,  <span class="comment">// print list length and lua registry reference</span></span><br><span class="line">  &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><h3 id="数据结构与元表设计"><a href="#数据结构与元表设计" class="headerlink" title="数据结构与元表设计"></a>数据结构与元表设计</h3><p><code>lnodelist</code>本身要实现为一个非lua的自定义的数据结构，在Lua里，这种数据结构属于<code>userdata</code>的类型，是一个可以被lua的GC（garbage collection，倒垃圾）机制检测回收的<code>struct</code>结构体数据块。从双向链表的设计上来看，初始化的<code>userdata</code>可以包含<code>size</code>、<code>*head</code>以及<code>*tail</code>三方面。通过<code>size</code>、<code>*head</code>以及<code>*tail</code>三个信息，我们就可以简单管理一个双向链表。而链表的每个结点内存则需要自己管理，其数据结构包含<code>type</code>、<code>*value</code>、<code>*prev</code>以及<code>*next</code>四个信息，分别是结点数据的类型、值跟链表里边上一个、下一个结点的指针。因此，<code>lnodelist</code>的<code>userdata</code>结构体跟结点结构体定义可以如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* struct of node */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">l_node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> type;</span><br><span class="line">  <span class="keyword">void</span> *value;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">l_node</span> *<span class="title">prev</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">l_node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; l_node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* struct of list */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">l_list</span> &#123;</span></span><br><span class="line">  lua_Integer size;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">l_node</span> *<span class="title">head</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">l_node</span> *<span class="title">tail</span>;</span></span><br><span class="line">&#125; l_list;</span><br></pre></td></tr></table></figure>
<p><code>lnodelist</code>作为一个用户自定义数据，我们需要通过一个叫元表（metatable）的东西对其基本属性以及在lua运行过程中发生特定事件下的行为进行描述。了解过元数据（metadata）的同学都会知道，它是描述数据的数据，其实元表，也不离其宗。在<code>lnodelist</code>的元表中，我们必须得重新定义这个数据树结构被lua标记GC时的行为（事件<code>__gc</code>）。</p>
<p>GC（Garbage Collection）行为可以回收数据的内存，但是我们在lua虚拟机定义<code>lnodelist</code>的过程中，值定义了刚开始的<code>userdata</code>，而后面结点的内存则暂时是一个个自己操作的，并不受lua虚拟机管辖。因此，GC时候，需要注意回收结点内存。</p>
<p><code>lnodelist</code>采用Lua最新版5.3.5的C API编写。相对于某些旧版本（如5.1），其注册lib的方式（luaopen函数里边的逻辑）不一样了。经过一番探究，参考了lua源码某些地方的骚操作，现在的写法可以这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LUAMOD_API <span class="keyword">int</span> <span class="title">luaopen_lnodelist</span><span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  luaL_newmetatable(L, LUA_NODELIST);</span><br><span class="line">  lua_pushvalue(L, <span class="number">-1</span>);</span><br><span class="line">  lua_setfield(L, <span class="number">-2</span>, <span class="string">"__index"</span>);</span><br><span class="line">  luaL_setfuncs(L, lnodelist_f, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而后，每次新建<code>list</code>时，注册一下元表即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* push a new empty list on lua stack */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_list</span><span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  l_list *l = (l_list *)lua_newuserdata(L, <span class="keyword">sizeof</span>(l_list));</span><br><span class="line">  l-&gt;size = <span class="number">0</span>;</span><br><span class="line">  l-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">  l-&gt;tail = l-&gt;head;</span><br><span class="line">  luaL_setmetatable(L, LUA_NODELIST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据存取"><a href="#数据存取" class="headerlink" title="数据存取"></a>数据存取</h3><p>在lua中，采用<code>TValue</code>表示lua的数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lobject.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Union of all Lua values</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> Value &#123;</span><br><span class="line">  GCObject *gc;    <span class="comment">/* collectable objects */</span></span><br><span class="line">  <span class="keyword">void</span> *p;         <span class="comment">/* light userdata */</span></span><br><span class="line">  <span class="keyword">int</span> b;           <span class="comment">/* booleans */</span></span><br><span class="line">  lua_CFunction f; <span class="comment">/* light C functions */</span></span><br><span class="line">  lua_Integer i;   <span class="comment">/* integer numbers */</span></span><br><span class="line">  lua_Number n;    <span class="comment">/* float numbers */</span></span><br><span class="line">&#125; Value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TValuefields Value value_; int tt_</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lua_TValue</span> &#123;</span></span><br><span class="line">  TValuefields;</span><br><span class="line">&#125; TValue;</span><br></pre></td></tr></table></figure>
<p>为此，在结点<code>l_node</code>中，也同样采用<code>type</code>加<code>value</code>的形式，表示每一个存到链表的数据。</p>
<p>获取数据的类型可以通过<code>lua_type</code>函数获得，根据数据的类型，我们可以做switch跳表去走相应的分支存数据。</p>
<p>值得一提的是，部分数据类型（比如函数、table），在API里我们无法直接获得相应数据结构的struct定义，因此只能通过lua的注册表Registry找到这些数据唯一索引，然后把索引值存在<code>value</code>中，这样通过<code>type</code>跟<code>value</code>就能找到对应的数据了。</p>
<p>数据存储的逻辑如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* assign value to value pointer, may modify type */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign_val</span><span class="params">(lua_State *L, l_node* node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> type = lua_type(L, arg);</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_TNUMBER:</span><br><span class="line">      <span class="keyword">if</span> (lua_isinteger(L, arg)) &#123;</span><br><span class="line">        node-&gt;value = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lua_Integer));</span><br><span class="line">        *(lua_Integer *)node-&gt;value = lua_tointeger(L, arg);</span><br><span class="line">        node-&gt;type = LUA_TINTEGER;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...  <span class="comment">// lua_Number</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LUA_TSTRING:</span><br><span class="line">      ...  <span class="comment">// const char*</span></span><br><span class="line">    <span class="keyword">case</span> LUA_TBOOLEAN:</span><br><span class="line">      ...  <span class="comment">// int (bool)</span></span><br><span class="line">    <span class="keyword">case</span> LUA_TNIL:</span><br><span class="line">    <span class="keyword">case</span> LUA_TNONE:</span><br><span class="line">      ...  <span class="comment">// nil</span></span><br><span class="line">    <span class="keyword">default</span>:  <span class="comment">// store in registry index</span></span><br><span class="line">      lua_pushvalue(L, arg);</span><br><span class="line">      node-&gt;value = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">      *(<span class="keyword">int</span> *)node-&gt;value = luaL_ref(L, LUA_REGISTRYINDEX);</span><br><span class="line">      node-&gt;type = type;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>反过来，取数据push到lua栈上的逻辑如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* get value of node and push to lua stack */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_val</span><span class="params">(lua_State *L, l_node *node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (node-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_TINTEGER:</span><br><span class="line">      lua_pushinteger(L, *(lua_Integer *)(node-&gt;value));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LUA_TNUMBER:</span><br><span class="line">      lua_pushnumber(L, *(lua_Number *)(node-&gt;value));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LUA_TSTRING:</span><br><span class="line">      lua_pushstring(L, *(<span class="keyword">const</span> <span class="keyword">char</span> **)(node-&gt;value));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LUA_TBOOLEAN:</span><br><span class="line">      lua_pushstring(L, (<span class="keyword">int</span> *)node-&gt;value ? <span class="string">"true"</span> : <span class="string">"false"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LUA_TNIL:  <span class="comment">// nil or none</span></span><br><span class="line">    <span class="keyword">case</span> LUA_TNONE:</span><br><span class="line">      lua_pushnil(L);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:  <span class="comment">// get from registry index</span></span><br><span class="line">      lua_rawgeti(L, LUA_REGISTRYINDEX, *(<span class="keyword">int</span> *)node-&gt;value);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁数据（free）时，特殊的数据结构暂时需要在lua注册表里<code>unref</code>来取消索引。其中的优化方案，还要后续有空探究。</p>
<h3 id="遍历数据"><a href="#遍历数据" class="headerlink" title="遍历数据"></a>遍历数据</h3><p>lua本身遍历数据采用<code>pairs</code>与<code>ipairs</code>两种方式，但是对于<code>lnodelist</code>的链表来说，存在两个问题——首先，<code>pairs</code>跟<code>ipairs</code>是无状态的。对于列表类型，我们采用<code>ipairs</code>遍历时，通常为索引自增后再调用<code>ipair</code>函数执行，但对于链表，根据索引寻找会增加性能开销，并且<code>l_node</code>结点本身并非lua原生的数据类型。因此，现在暂时的解决方案是采用<code>Javascript</code>的模式call回调函数进行遍历。比如<code>foreach</code>的实现，可以如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* foreach loop for stateful iteration */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">list_foreach</span><span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  l_list *l = check_list(L, <span class="number">1</span>);</span><br><span class="line">  luaL_checktype(L, <span class="number">2</span>, LUA_TFUNCTION);</span><br><span class="line">  l_node *node = l-&gt;head;</span><br><span class="line">  lua_Integer idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    lua_pushvalue(L, <span class="number">2</span>);</span><br><span class="line">    push_val(L, node);</span><br><span class="line">    lua_pushinteger(L, ++idx);</span><br><span class="line">    lua_call(L, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    node = node-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以实现一次遍历，<code>map</code>等方法同理</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>近期刷题少了，在写<code>lnodelist</code>的过程中也渐渐找回了一点感觉。总的来说能有个小demo也不错，要把它做得更好的话，还有很多方面需要调研与改进：</p>
<ul>
<li>内存管理：应当兼容lua的内存管理，并且配合lua的GC机制</li>
<li>错误控制：应当有更细的错误声明跟回滚机制</li>
<li>功能改进：完善功能，进一步兼容lua内置数据结构，比如table</li>
<li>协程支持：既然要JS Style，那还是得增加对coroutine的支持</li>
</ul>
<p>要解决这些问题，还得再深入去研究呀！</p>
]]></content>
      <categories>
        <category>Lua杂谈</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>Lua</tag>
        <tag>C API</tag>
        <tag>lnodelist</tag>
        <tag>双向链表</tag>
      </tags>
  </entry>
  <entry>
    <title>【Easy Python】第五话：小试scikit-learn数据挖掘——newsgroup数据处理与文本分类</title>
    <url>/2019/04/14/easypython/v/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数据挖掘（Data Mining），一般指从海量抓取的数据中经过一定的数据处理、算法，从而提取出有价值的信息的过程。它大体基于统计学、机器学习（Machine Learning）等原理，辅佐了人类的信息处理工作，为人工智能（AI）铺下道路。</p>
<p>幸运的是，似乎正是因数据挖掘而生的那样，Python社区中有各种数据挖掘相关的package，能够满足各种数据处理与算法模型构建需求。我们只需要<code>pip/conda install 包名</code>，然后查查api文档，熬几十行代码，就能玩一玩数据挖掘。</p>
<p>为此，在这一话，我们以自然语言处理（NLP）的文本分类（Text Classification）为例，设计一个最simple的，最old school的，以Python为例的，从数据获取到产生数据挖掘结果的流程。</p>
<h2 id="文本分类是什么？"><a href="#文本分类是什么？" class="headerlink" title="文本分类是什么？"></a>文本分类是什么？</h2><a id="more"></a>
<p>文本分类，更通常的理解，叫文本自动分类（auto-classification），是文本数据挖掘最普通不过的方法了。文本分类应用的例子比比皆是，比如某个新闻网站，爬到了海量外部的新闻文本，当人力不足以将其一个个归类时，就需要借助计算机的力量，将那些没有标注类别（category labelling）新闻自动归类到已有的类别当中。所以，我们的问题就是——怎样像人一样，去识别那些没有归类的新闻的类别呢？</p>
<p>俗话说的好，只要功夫深，铁杵磨成针。我们在孩提时代，是父母告诉我们，这只猫，那是狗，我们才能对不同的动物进行分辨。在数据挖掘领域，我们可以利用分类器（classifier），满足自动分类的需求。分类器就像我们的大脑一样，可以通过吸收不同知识，调整自己的决策，但其本质上，却是一个夹杂了繁复数学计算的计算机程序而已。我们要做的，则是把已有的资源，也就是归类好的那些新闻文本，去告诉分类器，这篇是A类，这篇是B类，从而训练（train）它的新闻类别识别能力。这样，面对各种未归类新闻的考验（test），分类器就可以争取像人那样，把新闻的类别识别出来了。</p>
<p>为此，要保证计算机的识别效果，完备优良的训练材料（training set）和精致缜密的训练方法（algorithm model）都必不可少。</p>
<h2 id="简单的例子——newsgroup文本分类"><a href="#简单的例子——newsgroup文本分类" class="headerlink" title="简单的例子——newsgroup文本分类"></a>简单的例子——newsgroup文本分类</h2><p>以下，我们就开始最简单的文本分类流程示例啦！我们采用<span class="exturl" data-url="aHR0cHM6Ly9zY2lraXQtbGVhcm4ub3JnL3N0YWJsZS8=" title="https://scikit-learn.org/stable/">scikit-learn<i class="fa fa-external-link"></i></span>提供的工具进行文本分类流程模拟。</p>
<h3 id="newsgroup数据集下载"><a href="#newsgroup数据集下载" class="headerlink" title="newsgroup数据集下载"></a>newsgroup数据集下载</h3><p>文本分类数据集，我们采用最经典的新闻数据集：<span class="exturl" data-url="aHR0cDovL3F3b25lLmNvbS9+amFzb24vMjBOZXdzZ3JvdXBzLw==" title="http://qwone.com/~jason/20Newsgroups/">20 newsgroup数据集<i class="fa fa-external-link"></i></span>进行模拟，使用的版本为<span class="exturl" data-url="aHR0cDovL3F3b25lLmNvbS9+amFzb24vMjBOZXdzZ3JvdXBzLzIwbmV3cy0xODgyOC50YXIuZ3o=" title="http://qwone.com/~jason/20Newsgroups/20news-18828.tar.gz">18828版<i class="fa fa-external-link"></i></span>，记录了18828篇不重复的英文新闻。虽然<code>scikit-learn</code>库默认提供该数据集的下载处理，但是在这一话，我们就自己实现一遍吧~</p>
<p>下载，解压，总共有<code>alt.atheism</code>到<code>talk.religion.misc</code>20个类别的文本。打开每一个类别文件夹，能看到以新闻编号为文件名（没有后缀名）的新闻文件。用记事本打开，就能够看到里面的新闻内容啦。</p>
<h3 id="新闻数据读取-amp-预处理"><a href="#新闻数据读取-amp-预处理" class="headerlink" title="新闻数据读取&amp;预处理"></a>新闻数据读取&amp;预处理</h3><p>要模拟文本分类，需要把每一个新闻跟它们的类别一一对应。在<code>scikit-learn</code>中，要实现newsgroup新闻内容与类别的对应，需要建立两个列表：</p>
<ul>
<li>所有新闻的列表</li>
<li>所有新闻归属类别编号的列表（1~n）</li>
</ul>
<p>因此，我们在读取新闻文件内容的时候，也要做一个类别标签的列表。具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># out directory to store newsgroup datasset</span></span><br><span class="line">directory = <span class="string">'./20news-18828'</span></span><br><span class="line"><span class="comment"># category_names[label_number - 1] = category name</span></span><br><span class="line">category_names = os.listdir(directory)</span><br><span class="line"><span class="comment"># sequence of news contents --- X</span></span><br><span class="line">news_contents = list()</span><br><span class="line"><span class="comment"># sequence of news labels  --- Y</span></span><br><span class="line">news_labels = list()</span><br><span class="line"><span class="comment"># traverse into directories</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(category_names)):</span><br><span class="line">    category = category_names[i]</span><br><span class="line">    category_dir = os.path.join(directory, category)</span><br><span class="line">    <span class="keyword">for</span> file_name <span class="keyword">in</span> os.listdir(category_dir):</span><br><span class="line">        file_path = os.path.join(category_dir, file_name)</span><br><span class="line">        <span class="comment"># get the word list of a single news file</span></span><br><span class="line">        raw_content = open(file_path, encoding=<span class="string">'latin1'</span>).read().strip()</span><br><span class="line">        <span class="comment"># preprocess data</span></span><br><span class="line">        news_content = preprocess_content(raw_content)</span><br><span class="line">        <span class="comment"># append news labels and news contents</span></span><br><span class="line">        news_labels.append(i + <span class="number">1</span>)</span><br><span class="line">        news_contents.append(news_content)</span><br></pre></td></tr></table></figure>
<p>其中，<code>news_contents</code>是我们的新闻内容；<code>news_labels</code>是我们每个新闻内容对应类别的编号的列表，跟<code>news_contents</code>一样长；而<code>category_names</code>则是类别名的列表了。我们遍历每个类别目录去读取新闻文件内容，文件编码经查证是<code>latin1</code>。没读到一个文件，我们都去用一个<code>preprocess_content</code>函数预处理（preprocessing）这个文件的内容，然后把文件内容加到<code>news_contents</code>中，把这个新闻对应的类别编号，此处设为<code>索引i + 1</code>，加到<code>news_labels</code>中。</p>
<p>预处理文本方便了我们后续对文本数据的操作。那么，如何预处理newsgroup文本数据呢？这就和新闻文本的数学模型表示方法有关了。把文字堆砌文本变成数学模型，分类器才能够学习不同类别的文本是这样那样的。这个过程，我们叫做拟合（fit）。对于新闻类的长文本来说，最简单粗暴oldschool的方法，就是用词频、关键词之类的信息来表示文本内容。虽然这种方法忽略了词与词之间的上下文关系，但从实践效果来看，已经很ok了。</p>
<p>要获取文本的词频、关键词等信息，就涉及到文本的分词。newsgroup手机的是英文新闻，因此为了让后续的分词更加方便，我们希望在预处理的过程中，<strong>过滤掉新闻文本标点符号之类的干扰字符，把所有单词都以空格相连</strong>，这样就完成了文本的与处理了。</p>
<p>完成这个需求，就需要一个文本预处理的强大武器——<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9saWJyYXJ5L3JlLmh0bWw=" title="https://docs.python.org/3/library/re.html">正则表达式<i class="fa fa-external-link"></i></span>（Regular Expression）。通过正则表达式，我们可以匹配一个样式（pattern）的文本，并对它进行操作。</p>
<p>那么我们的<code>preprocess_content</code>预处理函数，就可以这样写啦：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># replace any character that is not digit or letter or space with empty string</span></span><br><span class="line">replace_with_empty_pattern = re.compile(<span class="string">r'[^A-Za-z0-9\s]'</span>)</span><br><span class="line"><span class="comment"># replace consecutive spaces and enters(\n) with a single space</span></span><br><span class="line">replace_with_single_space_pattern = re.compile(<span class="string">r'\s&#123;2,&#125;|[^\S ]'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess_content</span><span class="params">(content)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> re.sub(</span><br><span class="line">        replace_with_single_space_pattern, <span class="string">' '</span>,</span><br><span class="line">        re.sub(replace_with_empty_pattern, <span class="string">''</span>, content)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>我们首先去掉标点符号之类的干扰字符，然后把所有的单词都以一个空格相隔。为此，我们做两个正则表达式，完成这个需求吧~</p>
<ul>
<li><code>[^A-Za-z0-9\s]</code>  — 首先，<code>[^嘻哈嘿]</code>代表不匹配<code>嘻哈嘿</code>之类的字符；然后，<code>A-Za-z0-9</code>就顾名思义，代表数字跟字母；最后，<code>\s</code>代表空白字符，包括比如空格(space)啊、回车(enter)啊、制表符（tab）之类。连起来，就是<strong>不匹配数字、字母跟空白字符的那些文本</strong>的意思，也就正好对应我们的干扰字符。我们用<code>re.sub</code>方法，就可以把这些干扰字符替换成空字符串<code>&#39;&#39;</code>，从而去掉它们。</li>
<li><code>\s{2,}|[^\S ]</code> — 首先，<code>\s{2,}</code>表示连续出现两次或以上的空白字符；其次，<code>|</code>代表“或者”的意思，最后，<code>[^\S ]</code>中的<code>\S</code>，代表非空白字符，整一下就表示空白字符里除去空格外（里边多<code>^</code>了一个空格喔）其它所有的空白字符。这样，整个正则表达式就表示——<strong>除了单个空格外，所有空白字符组合成字符串</strong>的情况了。我们把出现这些情况的字符串都用单个空格<code>&#39; &#39;</code>代替，这样所有的单词都以空格相隔了。（诶，其实嫌麻烦的话，直接<code>\s+</code>也成= =）</li>
</ul>
<p><code>print</code>一下试试看吧~</p>
<h3 id="新闻文本分类"><a href="#新闻文本分类" class="headerlink" title="新闻文本分类"></a>新闻文本分类</h3><p>如上所说，要实现一个简单的文本分类流程，就需要准备好训练计算机的数据和用于测试计算机的数据。我们可以把刚刚处理好的新闻内容跟类别标签列表洗刷刷（shuffle），然后分隔一部分用于训练，一部分用于测试。这里，我们把训练跟测试数据集的比重设成1：1先啦~</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">train_contents, test_contents, train_labels, test_labels = \</span><br><span class="line">    train_test_split(news_contents, news_labels, shuffle=<span class="literal">True</span>, test_size=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<p>然后，我们需要把我们的新闻，转化成数学模型，从而被分类器识别。按照最简单粗暴的方法，我们可以把整个数据集所有出现过的不同词语整合成一个词表（vocabulary）。然后，针对每一篇文章，都计算<strong>词表里每个词在这篇文章的关键程度</strong>，再一整合，就成了这篇文章的数学模型表示了。</p>
<p>怎样计算词表里每个词在单篇文章的关键程度呢？最老掉牙但又有效的方法，就是通过<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWhhbnMvVGYtaWRm" title="https://zh.wikipedia.org/zh-hans/Tf-idf">TF-IDF<i class="fa fa-external-link"></i></span>计算了。TF（Term Frequency）代表这个词在该篇文章出现的频率，IDF（Inverse Document Frequency）代表这个词在整个数据集中地低频程度。一个词，出现在该篇文章次数多，出现在整个数据集次数少，就表示这个词语能够更加突出该篇文章的语义。</p>
<p>为此，我们可以通过<code>scikit-learn</code>内置的<code>TfidfVectorizer</code>，把文章的文本转化为所有词语在该篇文章关键程度的集合，也就是个向量啦~</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"></span><br><span class="line">tfidf_vectorizer = TfidfVectorizer()</span><br></pre></td></tr></table></figure>
<p>为了把每篇文章的数学模型进行训练，我们就需要一个分类器。常用的分类器有许多，这里，我们就以SVM（Support Vector Machine，支持向量机）为例啦- -</p>
<p>SVM的分类原理可以用切西瓜来比喻——西瓜里有白的黑的籽，现在不管你刀的形状，怎样来一刀，使得刀两边能够尽量分别是白籽跟黑籽，然后刀到白籽黑籽两者距离的最小值能尽量大呢？比喻说的简单，实际计算还是复杂的（数学渣TAT）。但我们若是单纯引用，则不需要管这些数学问题，直接import就好啦~</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line"></span><br><span class="line"><span class="comment"># LinearSVC：线性支持向量分类器</span></span><br><span class="line">svm_classifier = LinearSVC(verbose=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>在前面的<code>TfidfVectorizer</code>中，我们会先对训练集操作，最后对于每一个新闻生成的数学模型，都是一个维度很高的向量（词表长度= =）。为了能够让我们的SVM分类器训练更加效率，我们可以采用特征选择（feature selection）的方法，在词表中挑选少量来作为每个新闻数学模型的维度就好啦。</p>
<p>卡方统计量（chi2）是常用的特征选择指标。卡方统计量能够衡量词语跟类别的相关性，因此通过卡方指标打分筛选词表中的词语，我们就可以剔除许多影响分类效果的常见词了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest, chi2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选10000个词语作为文档特征词</span></span><br><span class="line">chi2_feature_selector = SelectKBest(chi2, k=<span class="number">10000</span>)</span><br></pre></td></tr></table></figure>
<p>最后，我们需要一个流水线（pipeline），把整个流程串起来——</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"></span><br><span class="line">pipeline = Pipeline(memory=<span class="literal">None</span>, steps=[</span><br><span class="line">    (<span class="string">'tfidf'</span>, tfidf_vectorizer),</span><br><span class="line">    (<span class="string">'chi2'</span>, chi2_feature_selector),</span><br><span class="line">    (<span class="string">'svm'</span>, svm_classifier),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>对于训练数据，我们先把其转化为以TF-IDF为基础的数学模型，然后通过chi2方法选择特定数量的词语从而剔除干扰词，最后把它输入到SVM分类器中进行训练。</p>
<p>对于测试数据，我们同样先将其转化为TF-IDF为基础的数据，然后在chi2流程时，把训练数据选出的词语应用到测试数据中作为每一个测试文档的特征词（feature），最后再将其输入到SVM分类器中，进行类别预测（predict），也就是“分类”啦。</p>
<p>得到预测结果后，我们可以通过<code>classification_report</code>模块，去展现我们的测试报告。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"></span><br><span class="line">pipeline.fit(train_contents, train_labels)</span><br><span class="line">result = pipeline.predict(test_contents)</span><br><span class="line">report = classification_report(test_labels, result, target_names=category_names)</span><br></pre></td></tr></table></figure>
<p>试试看吧~</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用python进行newsgroup文本分类，不过是小菜花生。在数据挖掘、机器学习领域，更多的是数学的扎实程度，代码能力并非最为重要。</p>
<p>newsgroup的数据，总共不到两万，算是少之又少。更为海量的数据，要进行数据处理挖掘，光靠个默认的SVM之类也是徒劳，需要更为复杂、更加深层次的模型，好比说神经网络，才能硬刚。</p>
<p>但是很庆幸，我们拥有python，和背后强大的社区。</p>
<p>我想反复说，为什么叫easy python？比python更容易上手的语言很多，lua就是其中一个。但是，lua现在支持那么多数据挖掘需求吗？并没有。</p>
<p>easy python，因为它就如电子琴，能够让我们随心所欲，天马行空。</p>
]]></content>
      <categories>
        <category>Easy Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据挖掘</tag>
        <tag>文本分类</tag>
        <tag>scikit-learn</tag>
        <tag>newsgroup</tag>
      </tags>
  </entry>
  <entry>
    <title>【Lua杂谈】debug.getinfo源码分析——使用C API重写lfunctimer</title>
    <url>/2019/04/07/luatalk/lfunctimer_capi/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天更新了一下<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9sZnVuY3RpbWVy" title="https://github.com/utmhikari/lfunctimer">lfunctimer<i class="fa fa-external-link"></i></span>，主要把hook更改为c api的形式，并且初步加了util和config的扩展</p>
<p>想要试用的同学的话可以点击上面clone下来，或者安装<span class="exturl" data-url="aHR0cHM6Ly9sdWFyb2Nrcy5vcmcv" title="https://luarocks.org/">luarocks<i class="fa fa-external-link"></i></span>后执行下面命令安装~</p>
<p><code>luarocks install --server=http://luarocks.org/manifests/utmhikari lfunctimer</code></p>
<p>言归正传，利用lua原生的c api做debug相关操作会比lua自带的<code>debug.getinfo</code>来的快许多，我们可以来一探究竟</p>
<h2 id="debug-getinfo源码分析"><a href="#debug-getinfo源码分析" class="headerlink" title="debug.getinfo源码分析"></a>debug.getinfo源码分析</h2><p>我们可以从官方下载源码搜索<code>debug.getinfo</code>的实现，此处以版本5.3.5为例。</p>
<p><code>debug.getinfo</code>对应的源码是<code>ldblib.c</code>的<code>db_getinfo</code>函数，我们可以简单在<code>ldblib.c</code>的末尾中查到~</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> luaL_Reg dblib[] = &#123;</span><br><span class="line">  <span class="comment">// 略过前面</span></span><br><span class="line">  &#123;<span class="string">"getinfo"</span>, db_getinfo&#125;,</span><br><span class="line">  <span class="comment">// 略过后面</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LUAMOD_API <span class="keyword">int</span> <span class="title">luaopen_debug</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  luaL_newlib(L, dblib);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lua提供一个注册表（Registry）机制去把我们的函数名跟函数对应起来，然后最后要让lua识别这个模块的话，就定义一个函数，名称为<code>luaopen_模块名</code>，然后通过<code>luaL_newlib</code>方法读取前面的<code>luaL_Reg</code>注册表数据变成一个函数名——函数的table就ok了。</p>
<p>像<code>debug</code>之类的lua内置库，则在起lua的时候就调用<code>linit.c</code>里的<code>luaL_openlibs</code>方法就载入；而如果是第三方库，你在require的时候，则会通过<code>loadlib.c</code>中的方法去寻找模块有无载入过，如果载入过则用载入过的模块(<code>package.loaded</code>)，如果没载入过就载入，并且加到载入过模块中。这部分不再细究啦，有兴趣的同学可以自行发掘，我有空的话也会自己再踩踩坑~</p>
<p>我们再回头看<code>ldblib.c</code>的<code>db_getinfo</code>函数，也就是<code>debug.getinfo</code>对应的实现，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// debug.getinfo([thread,] f [,what]): 获取当前运行函数的信息</span></span><br><span class="line"><span class="comment">// thread (optional): 要获取函数所在的lua state（默认当前lua state）</span></span><br><span class="line"><span class="comment">// f: 调用栈层次（0是当前函数，1是当前函数caller，往上类推）</span></span><br><span class="line"><span class="comment">// what (optional)：获取的信息有哪些（默认全部）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">db_getinfo</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  lua_Debug ar;</span><br><span class="line">  <span class="keyword">int</span> arg;</span><br><span class="line">  <span class="comment">// 参数检验部分</span></span><br><span class="line">  lua_State *L1 = getthread(L, &amp;arg);  <span class="comment">// 读取thread参数</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *options = luaL_optstring(L, arg+<span class="number">2</span>, <span class="string">"flnStu"</span>);</span><br><span class="line">  checkstack(L, L1, <span class="number">3</span>);</span><br><span class="line">  <span class="comment">// 获取func本身/CallInfo</span></span><br><span class="line">  <span class="keyword">if</span> (lua_isfunction(L, arg + <span class="number">1</span>)) &#123;  <span class="comment">/* info about a function? */</span></span><br><span class="line">    options = lua_pushfstring(L, <span class="string">"&gt;%s"</span>, options);  <span class="comment">/* add '&gt;' to 'options' */</span></span><br><span class="line">    lua_pushvalue(L, arg + <span class="number">1</span>);  <span class="comment">/* move function to 'L1' stack */</span></span><br><span class="line">    lua_xmove(L, L1, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;  <span class="comment">/* stack level */</span></span><br><span class="line">    <span class="keyword">if</span> (!lua_getstack(L1, (<span class="keyword">int</span>)luaL_checkinteger(L, arg + <span class="number">1</span>), &amp;ar)) &#123;</span><br><span class="line">      lua_pushnil(L);  <span class="comment">/* level out of range */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取附加信息flnStu之类的</span></span><br><span class="line">  <span class="keyword">if</span> (!lua_getinfo(L1, options, &amp;ar))</span><br><span class="line">    <span class="keyword">return</span> luaL_argerror(L, arg+<span class="number">2</span>, <span class="string">"invalid option"</span>);</span><br><span class="line">  <span class="comment">// push table，作为最后结果</span></span><br><span class="line">  lua_newtable(L);  <span class="comment">/* table to collect results */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strchr</span>(options, <span class="string">'S'</span>)) &#123;</span><br><span class="line">    settabss(L, <span class="string">"source"</span>, ar.source);</span><br><span class="line">    settabss(L, <span class="string">"short_src"</span>, ar.short_src);</span><br><span class="line">    settabsi(L, <span class="string">"linedefined"</span>, ar.linedefined);</span><br><span class="line">    settabsi(L, <span class="string">"lastlinedefined"</span>, ar.lastlinedefined);</span><br><span class="line">    settabss(L, <span class="string">"what"</span>, ar.what);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strchr</span>(options, <span class="string">'l'</span>))</span><br><span class="line">    settabsi(L, <span class="string">"currentline"</span>, ar.currentline);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strchr</span>(options, <span class="string">'u'</span>)) &#123;</span><br><span class="line">    settabsi(L, <span class="string">"nups"</span>, ar.nups);</span><br><span class="line">    settabsi(L, <span class="string">"nparams"</span>, ar.nparams);</span><br><span class="line">    settabsb(L, <span class="string">"isvararg"</span>, ar.isvararg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strchr</span>(options, <span class="string">'n'</span>)) &#123;</span><br><span class="line">    settabss(L, <span class="string">"name"</span>, ar.name);</span><br><span class="line">    settabss(L, <span class="string">"namewhat"</span>, ar.namewhat);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strchr</span>(options, <span class="string">'t'</span>))</span><br><span class="line">    settabsb(L, <span class="string">"istailcall"</span>, ar.istailcall);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strchr</span>(options, <span class="string">'L'</span>))</span><br><span class="line">    treatstackoption(L, L1, <span class="string">"activelines"</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strchr</span>(options, <span class="string">'f'</span>))</span><br><span class="line">    treatstackoption(L, L1, <span class="string">"func"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">/* return table */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到如果在每次调用<code>debug.getinfo</code>会经历<code>参数检验——获取func或CallInfo信息——获取附加信息（what）</code>的过程，每次都会创建一个<code>lua_Debug</code>结构体，在lua中返回的是一个table，相对繁琐一些。为了提高效率，我们可以直接用<code>db_getinfo</code>中的<code>lua_getstack</code>跟<code>lua_getinfo</code>方法去在我们的c hook中获取函数信息。</p>
<h2 id="用C-API重写lfunctimer的hook"><a href="#用C-API重写lfunctimer的hook" class="headerlink" title="用C API重写lfunctimer的hook"></a>用C API重写lfunctimer的hook</h2><p>在新版lfunctimer中，第一版C Hook实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LFUNCTIMER_UPVAL_IDX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LFUNCTIMER_UPVAL_IDX 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LFUNCTIMER_FUNCMAP_UPVAL_IDX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LFUNCTIMER_FUNCMAP_UPVAL_IDX 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// push function name to top of stack</span></span><br><span class="line"><span class="comment">// not the same as builtin "getfuncname" method</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lfunctimer_getfuncname</span><span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    lua_Debug ar;</span><br><span class="line">    <span class="keyword">if</span> (!lua_getstack(L,  LFUNCTIMER_STKLVL, &amp;ar)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check if function name already exists</span></span><br><span class="line">    lua_getinfo(L, <span class="string">"f"</span>, &amp;ar);</span><br><span class="line">    lua_pushvalue(L, <span class="number">-1</span>);</span><br><span class="line">    lua_gettable(L, lua_upvalueindex(LFUNCTIMER_FUNCMAP_UPVAL_IDX));</span><br><span class="line">    <span class="keyword">if</span> (lua_toboolean(L, <span class="number">-1</span>)) &#123;</span><br><span class="line">        lua_remove(L, <span class="number">1</span>);  <span class="comment">// remove funcinfo</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lua_pop(L, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// check if it's a builtin function</span></span><br><span class="line">    lua_getinfo(L, <span class="string">"Sn"</span>, &amp;ar);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *what = ar.what;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(what, <span class="string">"C"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        lua_pushfstring(L, <span class="string">"&lt;Builtin&gt; %s"</span>, ar.name);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ar.namewhat[<span class="number">0</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">        lua_pushfstring(L, <span class="string">"&lt;%s:%d&gt; ::UNKNOWN::"</span>, ar.short_src, ar.linedefined);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lua_pushfstring(L, <span class="string">"&lt;%s:%d&gt; %s"</span>, ar.short_src, ar.linedefined, ar.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// save function name to function map</span></span><br><span class="line">    lua_pushvalue(L, <span class="number">1</span>);</span><br><span class="line">    lua_pushstring(L, lua_tostring(L, <span class="number">-2</span>));</span><br><span class="line">    lua_settable(L, lua_upvalueindex(LFUNCTIMER_FUNCMAP_UPVAL_IDX));</span><br><span class="line">    <span class="comment">// remove funcinfo</span></span><br><span class="line">    lua_remove(L, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在某些情况下（比如loadstring）时，我们希望能够不侵入lua原生api去获取函数名称信息。因此可以这样操作——在hook函数中去上一个栈层次（level=1）的caller，我们就可以<code>getstack</code>后把函数信息暂存在一个<code>lua_Debug</code>结构体中，并在后续依据需求<code>getinfo</code>相应的内容。</p>
<p>获取函数名称的总体逻辑和上一版的lfunctimer（lua hook）基本类似，如果能获取到好书名称，就把函数名称push到<code>lua_State</code>的栈上。在后边的逻辑中，call跟return事件的handler都被分离了出来，这样就显得更加模块化了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// debug hook of lfunctimer</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lfunctimer_debug_hook</span><span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *evt = lua_tostring(L, <span class="number">1</span>);</span><br><span class="line">    lua_settop(L, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// get function name</span></span><br><span class="line">    <span class="keyword">if</span> (lfunctimer_getfuncname(L) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// print log</span></span><br><span class="line">    lua_getfield(L, lua_upvalueindex(LFUNCTIMER_CFG_UPVAL_IDX), <span class="string">"verbose"</span>);</span><br><span class="line">    <span class="keyword">if</span> (lua_toboolean(L, <span class="number">-1</span>)) &#123;</span><br><span class="line">        lua_getfield(L, lua_upvalueindex(LFUNCTIMER_UPVAL_IDX), <span class="string">"log"</span>);</span><br><span class="line">        lua_pushfstring(L, <span class="string">"%s: %s"</span>, lua_tostring(L, <span class="number">1</span>), evt);</span><br><span class="line">        lua_call(L, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    lua_pop(L, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// dispatch events</span></span><br><span class="line">    <span class="keyword">if</span> (evt[<span class="number">0</span>] == <span class="string">'c'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> handle_call(L);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (evt[<span class="number">0</span>] == <span class="string">'r'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> handle_return(L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>过后真的要多抽空研读下各种源码，打好基础= =mlgb的，最近为了领导毕业论文的事情，都憔悴了。</p>
]]></content>
      <categories>
        <category>Lua杂谈</category>
      </categories>
      <tags>
        <tag>lua</tag>
        <tag>debug</tag>
        <tag>测试</tag>
        <tag>lfunctimer</tag>
        <tag>lua C API</tag>
      </tags>
  </entry>
  <entry>
    <title>【Easy Python】第四话：爬虫初探——玩转豆瓣二百五（下）</title>
    <url>/2019/03/31/easypython/iv/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上篇，我们获得了豆瓣二百五的电影URL，然后存储在了一个文件里。接下来，我们要访问每一个电影URL，深入敌后，获取情报~</p>
<p>所有的代码都已存储在我的Github仓库：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9Eb3ViYW5fMjUw" title="https://github.com/utmhikari/Douban_250">Douban_250<i class="fa fa-external-link"></i></span>当中~</p>
<h2 id="设置爬取规则"><a href="#设置爬取规则" class="headerlink" title="设置爬取规则"></a>设置爬取规则</h2><p>对于每一个电影，我们选择爬取如下内容（虽然电影列表页就能爬得到= =）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标题（title）、年份（year）、时长（time）、</span><br><span class="line">导演（director）、类型（genre）、评分（score）</span><br></pre></td></tr></table></figure>
<p>随意点击一个电影页面，用上篇所说的提取CSS选择器的方法，我们可以制作出每一种内容与内容提取规则的映射。如下所示：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sp就是上篇所说的soup解析器</span></span><br><span class="line"><span class="comment"># 每一种内容都可以在解析器中按特定的规则提取加工得到</span></span><br><span class="line">content_func_map = &#123;</span><br><span class="line">    <span class="string">'title'</span>: <span class="keyword">lambda</span> sp: sp.select_one(<span class="string">'#content &gt; h1 &gt; span:nth-child(1)'</span>).get_text(),</span><br><span class="line">    <span class="string">'year'</span>: <span class="keyword">lambda</span> sp: sp.select_one(<span class="string">'#content &gt; h1 &gt; span.year'</span>).get_text().replace(<span class="string">'('</span>, <span class="string">''</span>).replace(<span class="string">')'</span>, <span class="string">''</span>),</span><br><span class="line">    <span class="string">'time'</span>: <span class="keyword">lambda</span> sp: sp.select_one(<span class="string">'#info &gt; span[property="v:runtime"]'</span>).get_text(),</span><br><span class="line">    <span class="string">'director'</span>: <span class="keyword">lambda</span> sp: sp.select_one(<span class="string">'#info &gt; span:nth-child(1) &gt; span.attrs &gt; a'</span>).get_text(),</span><br><span class="line">    <span class="string">'genre'</span>: <span class="keyword">lambda</span> sp: list(map(<span class="keyword">lambda</span> item: item.get_text(), sp.select(<span class="string">'#info &gt; span[property="v:genre"]'</span>))),</span><br><span class="line">    <span class="string">'score'</span>: <span class="keyword">lambda</span> sp: sp.select_one(<span class="string">'#interest_sectl &gt; div.rating_wrap.clearbox &gt; div.rating_self.clearfix &gt; strong'</span>).get_text()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置完规则，大问题来了= =250个链接，一个个访问，应该会很慢吧！而且，豆瓣还有反爬虫机制，如果访问间隔太快，就会暂时封ip——这，这可怎么办呀！</p>
<h2 id="人海战术，代理爬虫"><a href="#人海战术，代理爬虫" class="headerlink" title="人海战术，代理爬虫"></a>人海战术，代理爬虫</h2><p>一个个访问慢的话，一起访问，似乎会更快的吧= =<br>豆瓣封ip的话，如果有多个ip，效率也会增加的吧= =</p>
<h3 id="效率调度"><a href="#效率调度" class="headerlink" title="效率调度"></a>效率调度</h3><p>理想状态下，我们希望爬取每一个url的过程，都能够被当作是一个任务（task）。就像在M记一样，前台每收到一个客人的订单，都会把订单任务直接扔给厨师们，然后处理下一个客人的请求。那么，我们的厨师在哪里？</p>
<p>得益于python内置的<code>asyncio</code>库，我们可以模拟厨师们的工作，调度每一个爬虫任务。</p>
<p>然而，即使有了<code>asyncio</code>库，我们也只是通过其中的调度机制，重构了CPU指令而已，对于某些阻塞（block）任务进度的过程，并不能妥善解决。在爬取url内容的过程中，最阻碍我们任务进度的，当属请求——响应的阶段。对于调度器来讲，一个任务发送请求出去，调度器并不需要让它傻等响应回来，而是可以让这个任务歇一下，把执行权让（yield）给其它任务，直到响应回来后，再通知这个任务继续原来的工作，这样才够效率。上一章我们用的<code>requests</code>库不支持这一种机制，没关系，我们可以利用第三方的<code>aiohttp</code>库，完成这个需求。</p>
<h3 id="获取代理池"><a href="#获取代理池" class="headerlink" title="获取代理池"></a>获取代理池</h3><p>HTTP请求支持我们通过代理发送数据，使得目标识别发送源为代理服务器。要短时间获取大量的代理服务器地址，很简单，随便找个比如<span class="exturl" data-url="aHR0cHM6Ly93d3cueGljaWRhaWxpLmNvbS8=" title="https://www.xicidaili.com/">西刺代理<i class="fa fa-external-link"></i></span>或者<span class="exturl" data-url="aHR0cDovL3d3dy42NmlwLmNuL3B0Lmh0bWw=" title="http://www.66ip.cn/pt.html">66代理<i class="fa fa-external-link"></i></span>，利用内置查询，或者HTML解析爬取一堆，搞个一两千个就好。</p>
<h3 id="代理服务器分配"><a href="#代理服务器分配" class="headerlink" title="代理服务器分配"></a>代理服务器分配</h3><p>在我们的人海战术里，每一个爬虫任务开始前，都需要分配到一个代理服务器。所以问题来了——代理服务器，该怎么分配给每一个任务呢？我们希望，每一个任务都像被等待点名一样，如果有可用的代理服务器就挑几个任务去用，如果暂时能用的代理服务器都在用的话，就歇一会儿。</p>
<p>当然，如果没有代理服务器能用，就凉凉了= =</p>
<p>得益于<code>asyncio</code>库提供条件变量（Condition Variable）的机制，可以满足我们的需求。需要获得资源的任务，就去等待（wait）资源分配器的通知，资源分配器发现资源可用，则去通知（notify）那些迫不及待的任务，叫他们赶紧获取资源去。具体如何操作？且让我徐徐道来~</p>
<p>首先，在爬虫任务开始之前，我们得把“获取代理池”一步拿到的代理服务器列表，放到咱们内存里。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 初始化条件变量</span></span><br><span class="line">cond = <span class="literal">None</span></span><br><span class="line"><span class="comment"># 代理队列采用deque()数据结构，头尾都可以添加/删除，便于代理重复利用</span></span><br><span class="line">proxies = deque()</span><br><span class="line"><span class="comment"># 存放当前正在使用的代理，如果同时被多个任务用的话，小心被豆瓣封= =</span></span><br><span class="line">proxies_used = set()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_proxies</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    获取存好的代理服务器列表</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    contents = open(<span class="string">'proxies.txt'</span>, encoding=<span class="string">'utf-8'</span>).read().splitlines()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(contents)):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> contents[i].startswith(<span class="string">'http'</span>):</span><br><span class="line">            contents[i] = <span class="string">'http://'</span> + contents[i]</span><br><span class="line">    proxies.extend(set(contents))</span><br></pre></td></tr></table></figure>
<p>然后，开始添加我们的任务啦</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建用于发送HTTP请求的客户端</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">    <span class="comment"># 电影数量</span></span><br><span class="line">    num_urls = len(movie_urls)</span><br><span class="line">    <span class="comment"># 初始化条件变量Condition Variable</span></span><br><span class="line">    <span class="keyword">global</span> cond</span><br><span class="line">    cond = asyncio.Condition()</span><br><span class="line">    <span class="comment"># 添加任务啦~</span></span><br><span class="line">    tasks = list()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_urls):</span><br><span class="line">        <span class="comment"># crawl_movie_url就是我们爬虫任务的模版啦，具体见下面</span></span><br><span class="line">        tasks.append(crawl_movie_url(session, movie_urls[i], i + <span class="number">1</span>))</span><br><span class="line">    <span class="comment"># 最后一个启动的任务是咱们的代理分配模块：allocate_proxy</span></span><br><span class="line">    tasks.append(allocate_proxy(len(tasks)))</span><br><span class="line">    <span class="comment"># 开始把这堆任务跑起来，走你~</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*tasks)</span><br></pre></td></tr></table></figure>
<p>对于每一个任务，我们都做成一个循环（loop），直到任务完成或者没有代理服务器可用，才退出不干。因此，爬虫任务的初始逻辑如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加了async，表示这个函数上升为一个可被asyncio模块调度的任务</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">crawl_movie_url</span><span class="params">(session, url, movie_num)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 加了await，该任务就歇了，保存该任务状态，CPU执行权交给其它任务</span></span><br><span class="line">        <span class="comment"># 直到get_proxy有结果才被asyncio调度器唤醒</span></span><br><span class="line">        proxy = <span class="keyword">await</span> get_proxy()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> proxy:</span><br><span class="line">            log(movie_num, <span class="string">'TMD代理全部挂了，凉凉= ='</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 开始执行爬虫任务啦，具体后面说= =</span></span><br><span class="line">        <span class="keyword">await</span> set_proxy_in_use(proxy)</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>对于每一个任务来讲，该如何获取代理服务器呢？咱们的<code>get_proxy</code>任务代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_proxy</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># cond.acquire()跟cond.release()，可以实现对一段命令的加解锁（Lock）</span></span><br><span class="line">    <span class="comment"># 就如同上厕所一样，一个任务执行到加锁的一段，如果另一个任务也执行到这一段，就会暂停挂起，等待排队</span></span><br><span class="line">    <span class="comment"># proxies跟proxies_used是每个任务共享的全局变量（Global Variable），对于共享变量的操作，是要加锁的</span></span><br><span class="line">    <span class="comment"># 如果代理就剩一个，然后两个任务都跑到这一段，那就出事了= =</span></span><br><span class="line">    <span class="keyword">await</span> cond.acquire()</span><br><span class="line">    proxy = <span class="string">''</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 等待代理分配器通知= =</span></span><br><span class="line">        <span class="comment"># 代理分配器会在有可用代理，或者代理全部凉凉的时候唤醒这些等待者</span></span><br><span class="line">        <span class="keyword">await</span> cond.wait()</span><br><span class="line">        <span class="comment"># 如果有可用代理，就挑一个，没有就直接返回空字符串</span></span><br><span class="line">        <span class="comment"># 可以看上面的crawl_movie_url任务，直接凉凉= =</span></span><br><span class="line">        <span class="keyword">if</span> len(proxies) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 从代理队列头部取出一个代理</span></span><br><span class="line">            proxy = proxies.popleft()</span><br><span class="line">            <span class="comment"># 把这个代理加到正在使用的代理集合中</span></span><br><span class="line">            proxies_used.add(proxy)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        cond.release()</span><br><span class="line">    <span class="keyword">return</span> proxy</span><br></pre></td></tr></table></figure>
<p>面对这群嗷嗷待哺的任务们，我们的代理服务器分配任务<code>allocate_proxy</code>，就可以这样设计了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">allocate_proxy</span><span class="params">(max_tasks)</span>:</span></span><br><span class="line">    <span class="comment"># 代理分配任务，本身就相当于一个服务，因此这里采用循环的方式来设计</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 上锁，劳资要给别的任务分配代理了</span></span><br><span class="line">        <span class="comment"># 而且还得看代理队列呢，其他任务先别着急= =</span></span><br><span class="line">        <span class="keyword">await</span> cond.acquire()</span><br><span class="line">        will_break = <span class="literal">False</span>  <span class="comment"># 是否退出代理分配任务</span></span><br><span class="line">        will_delay = <span class="literal">False</span>  <span class="comment"># 下一个循环是否要延迟长一点</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> task_count == max_tasks:</span><br><span class="line">                <span class="comment"># task_count指当前完成的爬虫任务数</span></span><br><span class="line">                <span class="comment"># 如果到了最大值，说明全部任务都结束了</span></span><br><span class="line">                <span class="comment"># 这个时候代理分配任务也就完成任务了</span></span><br><span class="line">                will_break = <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 看代理队列还有木有可用的</span></span><br><span class="line">            len_proxies = len(proxies)</span><br><span class="line">            <span class="keyword">if</span> len_proxies == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> len(proxies_used) == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 代理队列没代理，连tm正在用的代理也是空的，岂不是凉凉= =</span></span><br><span class="line">                    <span class="comment"># 把这个可怕的信息告诉给所有任务吧= =然后劳资也跑路= =</span></span><br><span class="line">                    cond.notify_all()</span><br><span class="line">                    will_break = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 代理都在用着呢，等多一会儿再给大家分配吧= =</span></span><br><span class="line">                    will_delay = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 代理队列有多少代理，最多通知多少个任务去拿代理去</span></span><br><span class="line">                cond.notify(len_proxies)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            cond.release()</span><br><span class="line">            <span class="keyword">if</span> will_break:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> will_delay:</span><br><span class="line">                <span class="comment"># 歇多几秒，再分配代理给其它嗷嗷待哺的任务</span></span><br><span class="line">                <span class="comment"># 相当于爬虫访问网页的时间间隔设置</span></span><br><span class="line">                <span class="comment"># 豆瓣白天2s左右晚上3~4s左右差不多</span></span><br><span class="line">                <span class="keyword">await</span> asyncio.sleep(get_proxy_delay_time())</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 歇一丢丢时间，把自己排在任务调度后面</span></span><br><span class="line">                <span class="comment"># 不然while True死循环，别的任务就跑不了了</span></span><br><span class="line">                <span class="keyword">await</span> asyncio.sleep(proxy_search_period)</span><br></pre></td></tr></table></figure>
<h2 id="爬虫主任务"><a href="#爬虫主任务" class="headerlink" title="爬虫主任务"></a>爬虫主任务</h2><p>有了代理分配这个强劲的后盾，我们的爬虫任务就可以顺利进行啦！</p>
<p>免费的代理好多都没法用的，需要在爬虫的过程中不断舍弃。废话不多说，直接上代码！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">crawl_movie_url</span><span class="params">(session, url, movie_num)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 这段上面讲了= =</span></span><br><span class="line">        proxy = <span class="keyword">await</span> get_proxy()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> proxy:</span><br><span class="line">            log(movie_num, <span class="string">'TMD代理全部挂了，凉凉= ='</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># result存储爬取的数据，log函数打印日志（得自定义实现= =）</span></span><br><span class="line">        result = &#123;<span class="string">'number'</span>: movie_num, <span class="string">'url'</span>: url, <span class="string">'proxy'</span>: proxy&#125;</span><br><span class="line">        log(movie_num, <span class="string">'代理%s正在访问%s...'</span> % (proxy, url))</span><br><span class="line">        success = <span class="literal">True</span>  <span class="comment"># 是否爬取成功的标志</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 用get获取数据，判断状态码，而后解析数据</span></span><br><span class="line">            response = <span class="keyword">await</span> session.get(url, proxy=proxy, headers=headers, timeout=proxy_connection_timeout)</span><br><span class="line">            status_code = response.status</span><br><span class="line">            <span class="keyword">if</span> status_code == <span class="number">200</span>:</span><br><span class="line">                html = <span class="keyword">await</span> response.text()</span><br><span class="line">                soup = BeautifulSoup(html, html_parser)</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> content_func_map.keys():</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        <span class="comment"># 按最开始设的爬取规则抓数据，存到result里</span></span><br><span class="line">                        content = content_func_map[k](soup)</span><br><span class="line">                        result[k] = content</span><br><span class="line">                    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                        <span class="comment"># 如果爬不了，很有可能get到的网页变了！</span></span><br><span class="line">                        <span class="comment"># 比如叫你登录啥啥的，这说明代理被豆瓣临时小黑屋了，果断放弃这个代理</span></span><br><span class="line">                        log(movie_num, <span class="string">'代理%s爬取%s信息失败！果断放弃掉！错误信息：%s\n'</span> % (proxy, k, e))</span><br><span class="line">                        success = <span class="literal">False</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                   <span class="comment"># 如果状态码不对，很有可能是400啥的，说明也被豆瓣小黑屋了，果断放弃掉这个代理</span></span><br><span class="line">                log(movie_num, <span class="string">'代理%s获取数据失败！果断放弃掉！状态码: %d！'</span> % (proxy, status_code))</span><br><span class="line">                success = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment"># 代理链接或者代理发送请求都有问题，果断不要了</span></span><br><span class="line">            log(movie_num, <span class="string">'代理%s连接出错，果断放弃掉！！！错误信息：%s！'</span> % (proxy, e))</span><br><span class="line">            success = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="keyword">if</span> success:</span><br><span class="line">                <span class="comment"># 成功爬取数据，把爬取结果加上，把任务完成数加上</span></span><br><span class="line">                <span class="keyword">global</span> results</span><br><span class="line">                <span class="keyword">global</span> task_count</span><br><span class="line">                results.append(result)</span><br><span class="line">                task_count = task_count + <span class="number">1</span></span><br><span class="line">                log(movie_num, <span class="string">'当前爬到信息的电影数: %d，爬到信息：%s'</span> % (task_count, str(result)))</span><br><span class="line">                <span class="comment"># 这个代理还能用，给力！proxies_used里删掉它</span></span><br><span class="line">                <span class="comment"># 然后把它放到proxies的尾部（append）</span></span><br><span class="line">                <span class="keyword">await</span> recycle_proxy(proxy)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 这个代理不给力，直接从proxies_used删掉吧~</span></span><br><span class="line">                <span class="keyword">await</span> remove_proxy(proxy)</span><br></pre></td></tr></table></figure>
<p>试试看吧~</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>豆瓣Top 250爬虫，其实更多的难点，在于如何组织、调度你的资源，更有效率地处理数据。爬虫的工具、软件，其实都已经烂大街</p>
<p>对于软件，集搜客、八爪鱼之类的就能完成需求</p>
<p>对于代理池，github上就有许多项目可以clone下来去获得</p>
<p>对于爬虫框架，其实可以踩踩<code>scrapy</code>库的坑，这是一个非常成熟的爬虫框架</p>
<p>对于获取异步加载（不是当即就在response里，而是后面才加载到）的数据，可以使用<span class="exturl" data-url="aHR0cDovL3BoYW50b21qcy5vcmcv" title="http://phantomjs.org/">PhantomJS<i class="fa fa-external-link"></i></span>一类的工具，或者利用Chrome开发者工具，采用抓包+模拟HTTP请求的方式，获取相应数据。</p>
<p>最后介绍一个大杀器——<span class="exturl" data-url="aHR0cHM6Ly9zZWxlbml1bS1weXRob24ucmVhZHRoZWRvY3MuaW8v" title="https://selenium-python.readthedocs.io/">Selenium<i class="fa fa-external-link"></i></span>，作为一款浏览器测试驱动，selenium甚至可以模拟浏览器操作，百试不爽，谁用谁知道！</p>
]]></content>
      <categories>
        <category>Easy Python</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>异步</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>【Easy Python】第三话：爬虫初探——玩转豆瓣二百五（上）</title>
    <url>/2019/03/31/easypython/iii/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直以来，爬虫都是许多同学学Python的目的之一，就连我敬爱的领导，也经常不耻下问一些爬虫方面的问题。因此，我们开始实战——以<span class="exturl" data-url="aHR0cHM6Ly9tb3ZpZS5kb3ViYW4uY29tL3RvcDI1MA==" title="https://movie.douban.com/top250">豆瓣Top 250<i class="fa fa-external-link"></i></span>为例，试水一下基础的爬虫。</p>
<p>“玩转豆瓣二百五”系列分为上下两部，所有代码，可以在我的Github里<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9Eb3ViYW5fMjUw" title="https://github.com/utmhikari/Douban_250">Douban_250<i class="fa fa-external-link"></i></span>找到~</p>
<p>工欲善其事，必先利其器。以下浏览器操作，都基于最新版Chrome~</p>
<h2 id="获取电影列表网页数据"><a href="#获取电影列表网页数据" class="headerlink" title="获取电影列表网页数据"></a>获取电影列表网页数据</h2><p>爬虫爬虫，实质还是抓取网络数据= =爬虫不得急，可要一步步来——首先，我们希望获得每一个电影的链接，把它们存起来，留着后续爬取具体内容备用。</p>
<p>打开<span class="exturl" data-url="aHR0cHM6Ly9tb3ZpZS5kb3ViYW4uY29tL3RvcDI1MA==" title="https://movie.douban.com/top250">豆瓣Top 250首页<i class="fa fa-external-link"></i></span>，会看到电影列表的页面，往下翻，会看到总共有10页，每页25个电影。打开第二页，可以看到浏览器的地址变成了<code>https://movie.douban.com/top250?start=25&amp;filter=</code>，咱们观察一下链接——链接有一部分，<code>start=25</code>，是不是很突兀？按这样推算，第三页应该是<code>start=50</code>，第一页就是<code>start=0</code>嘛= =试了一下，果真是的= =</p>
<p>因此，爬取250个电影链接，不难规划。具体如下：</p>
<a id="more"></a>
<ul>
<li>打开10个电影列表页面——<code>https://movie.douban.com/top250?start=$movie_num&amp;filter=</code>，其中<code>$movie_num</code>是<code>25 * (页数 - 1)</code></li>
<li>获取10个页面的网页内容——我们都知道点击电影名就能进到电影链接里，那么电影链接在网页内容的概率就很大</li>
<li>解析网页内容，提取链接信息</li>
</ul>
<p>因此，每一页的链接，可以如下表示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_start_url</span><span class="params">(page)</span>:</span></span><br><span class="line">    <span class="comment"># page = 0 相当于第一页</span></span><br><span class="line">    start_num = <span class="number">25</span> * page</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'https://movie.douban.com/top250?start=%d&amp;filter='</span> % start_num</span><br></pre></td></tr></table></figure>
<p>然后，我们需要获取这些每一页的网页信息了——要获取信息，就涉及到交流，要交流，就要有共同的语言，约定俗成的数据格式——我们可称之为协议（Protocol）。获取网页信息，我们就常用超文本传输协议（HTTP），如果需要进一步保证传输数据的安全性，就采用超文本传输安全协议（HTTPS），是HTTP的扩展。豆瓣的链接以https开头，可见是采用了HTTPS作为数据传输的协议。</p>
<p>对于一个网站来说，每一个网页，都只是一种资源（Resource）。资源的链接，不论是所谓的网页，还是什么种子下载地址，都归属于一个概念——统一资源定位符（URL）。通常来讲，如果服务器允许的话，我们采用HTTP或者HTTPS的数据格式，采用协议约定的GET请求方式（Request Method）访问一个URL，就可以获取该URL下相应的资源。相应地，对豆瓣二百五每一页的URL发出GET请求，就应当可以获取到网页的内容。</p>
<p>因此首先，我们去给上述所有电影列表页面发请求，获取所有网页数据。在python3里，我们可以通过requests库发送http/https请求，获得请求的响应（Response）数据，提取网页信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    url = get_start_url(i)  <span class="comment"># 就用上面说的get_start_url函数</span></span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    <span class="comment"># HTTP/HTTPS协议里，response数据的不同状态码（status code）有不同含义</span></span><br><span class="line">    <span class="comment"># 一般2字头表示整个请求&amp;响应数据过程成功进行，200最常见</span></span><br><span class="line">    <span class="comment"># 4字头表示请求有问题，无法获得想要的数据，也有可能是你被服务器小黑屋了</span></span><br><span class="line">    <span class="comment"># 5字头表示服务器背锅，处理你的请求过程中bug了，或者是根本没法处理请求</span></span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        html = response.text  <span class="comment"># 提取相应的文本信息，在此为网页数据</span></span><br><span class="line">        解析(html)</span><br><span class="line">        存储数据()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Error at page %d with status %d!'</span> %</span><br><span class="line">              (i + <span class="number">1</span>, response.status_code))</span><br></pre></td></tr></table></figure>
<h2 id="解析提取电影URL"><a href="#解析提取电影URL" class="headerlink" title="解析提取电影URL"></a>解析提取电影URL</h2><h3 id="HTML解析"><a href="#HTML解析" class="headerlink" title="HTML解析"></a>HTML解析</h3><p>获得了电影列表网页数据之后，我们需要通过某种规则，获取网页里边的电影链接。网页数据文本一般遵从HTML（超文本标记语言）格式，我们可以通过右键网页查看源代码看到，每一个网页的元素（Element），都被标签（Tag）包裹着，形式类似于这样——<code>&lt;tag1&gt;&lt;tag2&gt;...&lt;/tag2&gt;...&lt;/tag1&gt;</code>，标签层层相扣，而最外层有一个<code>&lt;html&gt;</code>标签包裹着所有的内容，因此整一个网页数据类似于由标签、元素组成，以<code>&lt;html&gt;</code>标签为根的树状结构。在Python中，有许多第三方库（需要额外安装~）可以满足解析HTML的需求，这里以<code>bs4</code>的<code>BeautifulSoup</code>解析库以及<code>lxml</code>解析引擎为例，尝试提取豆瓣电影的链接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">html = response.text  <span class="comment"># 接上</span></span><br><span class="line">html_parser = <span class="string">'lxml'</span>  <span class="comment"># 指定解析引擎为lxml</span></span><br><span class="line">soup = BeautifulSoup(html, html_parser)  <span class="comment"># 基于网页数据构建一个解析器</span></span><br></pre></td></tr></table></figure>
<p>接下来，随便在哪一个电影列表页面打开Chrome开发者工具，选择Elements一栏，点击开发者工具左上角的鼠标，再点一个电影标题，就可以<br>在开发者工具中定位到该标题所在的元素。</p>
<p>所以，看到有个标签，<code>&lt;a href=&quot;啥啥啥&quot;&gt;...&lt;/a&gt;</code>了吗？点击那个href里的内容，是不是进到了每部电影的页面？试试看吧~</p>
<h3 id="定位标签"><a href="#定位标签" class="headerlink" title="定位标签"></a>定位标签</h3><p>要定位这个<code>&lt;a href=&quot;啥啥啥&quot;&gt;...&lt;/a&gt;</code>元素的位置，我们可以在开发者工具的Elements界面中右键点击标签头部，也就是<code>&lt;a href=&quot;啥啥啥&quot;&gt;</code>这一部分，然后，选择copy -&gt; selector，获取该元素CSS选择器的代码。选择器（Selector），可以满足定位一组或是一个特定HTML元素的需求。而BeautifulSoup，则对CSS选择器（CSS Selector）有着较好的支持。</p>
<p>以第一页的《肖申克的救赎》为例操作，copy出来的选择器的代码是——<code>#content &gt; div &gt; div.article &gt; ol &gt; li:nth-child(1) &gt; div &gt; div.info &gt; div.hd &gt; a</code>，看起来很长，那有没有简单的版本呢？仔细观察，我们可以发现：标签的属性（比如<code>&lt;a href=&quot;啥啥啥&quot;&gt;</code>里，<code>href</code>就是标签的属性）里，<code>class</code>跟<code>id</code>是较为常见的两个。标签属性<code>class</code>一般指代一类特定的网页元素排版样式，而<code>id</code>则一般用于指代一个特定的元素。每一个电影链接的上层，都有一个<code>&lt;div class=&quot;hd&quot;&gt;</code>的标签，为此，我们可以通过这个标签下层的<code>&lt;a&gt;</code>标签，寻找对应的电影链接，并存储起来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">movie_url_file = open(<span class="string">'movie_urls.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="keyword">for</span> movies <span class="keyword">in</span> soup.find_all(<span class="string">'div'</span>, class_=<span class="string">'hd'</span>):</span><br><span class="line">    <span class="comment"># movies表示网页中每一个&lt;div class="hd"&gt;标签下的元素</span></span><br><span class="line">    movie_url = movies.find(<span class="string">'a'</span>)[<span class="string">'href'</span>]  <span class="comment"># 提取该元素下层&lt;a&gt;标签的href属性</span></span><br><span class="line">    movie_url_file.write(movie_url + <span class="string">'\n'</span>)  <span class="comment"># 把链接写入文件</span></span><br><span class="line">movie_url_file.close()</span><br></pre></td></tr></table></figure>
<p>通过这样的操作，我们就可以获得250个电影的url了。试试看吧~</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上半部分，初试爬虫，我们抓到了豆瓣250个电影的链接。</p>
<p>下半部分，我们就在这250个电影的链接中，一探究竟吧~</p>
]]></content>
      <categories>
        <category>Easy Python</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>BeautifulSoup</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>【Lua杂谈】Lua性能测试：函数执行时间统计</title>
    <url>/2019/03/25/luatalk/lfunctimer/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在白盒性能测试（profiling）中，函数时间统计是一项重要的指标。对于整个以lua为基础的系统架构而言，函数时间统计数据是性能优化的直接参照。</p>
<p>因此，本次Lua杂谈，将会分享一种函数执行时间统计的实现~</p>
<h2 id="函数执行时间获取"><a href="#函数执行时间获取" class="headerlink" title="函数执行时间获取"></a>函数执行时间获取</h2><p>单个函数执行时间的获取相对较为简单，例子如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> start = <span class="built_in">os</span>.<span class="built_in">clock</span>()</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">local</span> <span class="keyword">end</span> = <span class="built_in">os</span>.<span class="built_in">clock</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">tostring</span>(<span class="keyword">end</span> - start))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在函数的开头与结尾调用lua内置的os.clock（内核实现为time.h的中<code>clock()</code>时间戳除以<code>CLOCKS_PER_SEC</code>统计量，单位为秒），可以轻而易举地获得该函数的执行时间</p>
<h2 id="hook实现"><a href="#hook实现" class="headerlink" title="hook实现"></a>hook实现</h2><a id="more"></a>
<p>在lua的debug库中，hook掩码包括line、call、return等几种，易知在call与return事件打hook，可以更精确地对函数时间进行统计。</p>
<p>函数执行时间的hook可以参考笔者的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V0bWhpa2FyaS9sZnVuY3RpbWVy" title="https://github.com/utmhikari/lfunctimer">lfunctimer<i class="fa fa-external-link"></i></span>，在实现上参考了<span class="exturl" data-url="aHR0cHM6Ly9rZXBsZXJwcm9qZWN0LmdpdGh1Yi5pby9sdWFjb3YvaW5kZXguaHRtbA==" title="https://keplerproject.github.io/luacov/index.html">luacov<i class="fa fa-external-link"></i></span>以及lua官网的<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVhLm9yZy9waWwvMjMuMy5odG1s" title="https://www.lua.org/pil/23.3.html">函数统计样例<i class="fa fa-external-link"></i></span>。</p>
<p>函数时间统计中有一个核心的问题就是递归调用自身情况，对与这个问题的处理方案是——以最早call至最晚return的时间为准。为此，对于每一个函数，设立一个stack记录时间点，每call一次push时间点，每return一次pop时间点，如果剩最后一个，就增加时间量。代码参考如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> evt == <span class="string">"call"</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> functimestack[f] <span class="keyword">then</span></span><br><span class="line">        functimestack[f] = &#123;&#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(functimestack[f], <span class="built_in">os</span>.<span class="built_in">clock</span>())</span><br><span class="line"><span class="keyword">elseif</span> evt == <span class="string">"return"</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> functimestack[f] <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> #functimestack[f] == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> exec_time = <span class="built_in">os</span>.<span class="built_in">clock</span>() - functimestack[f][<span class="number">1</span>]</span><br><span class="line">            lfunctimer.save(funcnames[f], exec_time)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">remove</span>(functimestack[f])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>lua函数执行时间的统计从实现原理上并不难，甚至可以与曾经所提到的覆盖率统计模块精密结合</p>
<p>因此，又是一个扩展性非常强的测试需求啦~</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>其实进行函数执行时间的统计的话，单纯去hook这俩call、return事件，有的时候还会hook到一些不必要记录的函数，还有可能引发性能问题。还有一种好的方法是：在每个tick里（比如针对游戏客户端/服务端，在update函数里）去打印函数调用栈上所有的函数，这样可能会更加有效。</p>
]]></content>
      <categories>
        <category>Lua杂谈</category>
      </categories>
      <tags>
        <tag>lua</tag>
        <tag>debug</tag>
        <tag>性能测试</tag>
        <tag>测试</tag>
        <tag>lfunctimer</tag>
      </tags>
  </entry>
  <entry>
    <title>【Easy Python】第二话：映射——输入、输出与函数的纽带</title>
    <url>/2019/03/16/easypython/ii/</url>
    <content><![CDATA[<h2 id="从dict开始说起"><a href="#从dict开始说起" class="headerlink" title="从dict开始说起"></a>从dict开始说起</h2><p>学python的时候，我们一定会接触到dict（字典）这个数据结构。</p>
<p>dict结构展示了数据间（key与value）一一对应的关系，key作为一个查询索引，是不允许有重复的，而不同key所对应的value，则允许重复值的存在。</p>
<p>比如说，我们定义一群boys&amp;girls，打出整个dict，再打出girls有哪些，可以这样操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line">d = dict()</span><br><span class="line">d[<span class="string">'girl'</span>] = [<span class="string">'迪丽热巴'</span>, <span class="string">'王鸥'</span>, <span class="string">'鬼鬼'</span>]</span><br><span class="line">d[<span class="string">'boy'</span>] = [<span class="string">'大碗宽面'</span>]</span><br><span class="line"><span class="comment"># 用pprint.pprint函数打印数据结构，使得其排版更加pretty~</span></span><br><span class="line">pprint.pprint(d, indent=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 单用pprint.pformat，可以返回一个排版过后的字符串，打印出来要额外print操作~</span></span><br><span class="line">print(<span class="string">'Girls are: %s'</span> % pprint.pformat(d[<span class="string">'girl'</span>]))</span><br></pre></td></tr></table></figure>
<p>打出来的效果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&apos;boy&apos;: [&apos;大碗宽面&apos;], &apos;girl&apos;: [&apos;迪丽热巴&apos;, &apos;王鸥&apos;, &apos;鬼鬼&apos;]&#125;</span><br><span class="line">Girls are: [&apos;迪丽热巴&apos;, &apos;王鸥&apos;, &apos;鬼鬼&apos;]</span><br></pre></td></tr></table></figure>
<p>我们可以很直观地看到这种对应关系</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>像dict数据结构给我们展现的一样，数据间的对应关系，我们可以统称为：映射（Mapping）</p>
<p>如同第一话所说，程序的本质即为输入-&gt;函数-&gt;输出。输入和输出，就是一种映射关系，而实现这种映射的规则，就是函数。在dict里面，实现映射的函数，可以简化如下：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_value</span><span class="params">(key)</span>:</span></span><br><span class="line">    memory_address_of_value = hash(key)</span><br><span class="line">    <span class="keyword">return</span> get_data_from_address(memory_address_of_value)</span><br></pre></td></tr></table></figure>
<p>为了让我们便捷地从一个key访问到对应的value，dict不可能把所有的key都过一遍找，那样费时费力。</p>
<p>取而代之，dict可以直接通过一种算法函数，称之为hash，就可以把key计算（映射）为一个数值，即value的内存地址。我们通过这个内存地址，就可以取出对应的value数据了，非常简单粗暴。</p>
<h2 id="数据处理小需求"><a href="#数据处理小需求" class="headerlink" title="数据处理小需求"></a>数据处理小需求</h2><p>现在，让我们看这样一个需求。我们的输入是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input_list = [<span class="number">11</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>也就是1~15的乱序。现在我们想输出这样的结果：</p>
<ul>
<li>如果大于10， 输出字符串——这个数字大于10</li>
<li>如果小于等于10，输出字符串——这个数字小于等于10</li>
<li>被3整除的奇数不录入</li>
</ul>
<p>这个需求并不难，我们可以轻易地打出以下的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">output_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> input_list:</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> i % <span class="number">3</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">10</span>:</span><br><span class="line">            output_list.append(<span class="string">'%d: 大于10！'</span> % i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output_list.append(<span class="string">'%d: 小于等于10！'</span> % i)</span><br></pre></td></tr></table></figure>
<p>打出来的结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11: 大于10！</span><br><span class="line">2: 小于等于10！</span><br><span class="line">12: 大于10！</span><br><span class="line">5: 小于等于10！</span><br><span class="line">10: 小于等于10！</span><br><span class="line">7: 小于等于10！</span><br><span class="line">14: 大于10！</span><br><span class="line">6: 小于等于10！</span><br><span class="line">1: 小于等于10！</span><br><span class="line">13: 大于10！</span><br><span class="line">8: 小于等于10！</span><br><span class="line">4: 小于等于10！</span><br></pre></td></tr></table></figure>
<p>但是我把这个代码给我敬爱的领导看了之后，领导居然看不懂，觉得我的层次不够清晰。唔妈呀，代码都这么短了，那该怎么办呀</p>
<p>于是，只好改成了一个逻辑层次清晰一点的结构，顺带给排了个序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">output = map(</span><br><span class="line">    <span class="keyword">lambda</span> x: <span class="string">'%d: 大于10！'</span> % x <span class="keyword">if</span> x &gt; <span class="number">10</span> <span class="keyword">else</span> <span class="string">'%d: 小于等于10！'</span> % x,</span><br><span class="line">    filter(</span><br><span class="line">        <span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> x % <span class="number">3</span> != <span class="number">0</span>,</span><br><span class="line">        sorted(input_list),</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>打出来这个结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: 小于等于10！</span><br><span class="line">2: 小于等于10！</span><br><span class="line">4: 小于等于10！</span><br><span class="line">5: 小于等于10！</span><br><span class="line">6: 小于等于10！</span><br><span class="line">7: 小于等于10！</span><br><span class="line">8: 小于等于10！</span><br><span class="line">10: 小于等于10！</span><br><span class="line">11: 大于10！</span><br><span class="line">12: 大于10！</span><br><span class="line">13: 大于10！</span><br><span class="line">14: 大于10！</span><br></pre></td></tr></table></figure>
<p>这回领导终于满意啦~~</p>
<h2 id="分解过程，持续映射"><a href="#分解过程，持续映射" class="headerlink" title="分解过程，持续映射"></a>分解过程，持续映射</h2><p>让一个普通的数据处理过程变得层次清晰，其实是有方法的，得益于python内置的高阶函数，如果你写过js，玩转es6或者lodash，绝对章口就莱。</p>
<p>上一段代码中，不难发现多了3个新函数：map、filter跟sorted。我们这就一一来看：</p>
<p>map，就是映射啦~它的输入参数是一个函数（映射规则）以及我们的一堆输入值，只要给定函数跟相应的一堆输入值，我们就可以构建映射输出。</p>
<p>然而，map的却并不是返回所有映射输出结果，而是单纯的一个可迭代（Iterable）的对象，这个对象具有一个叫迭代器（Iterator）的东东可以让我们访问输出的结果。迭代器，就像我敬爱的领导懒洋洋的那样，不去理它，它啥都不干，只有调用它，它才会屁颠屁颠地把下一个map输出值给取出来。这种“懒人操作”，其实是很有必要的。如果输入数据量大，我们需要的输出数据量小的话，先把所有输出都给出来，再过一遍输出数据，那要猴年马月呀！</p>
<p>filter，跟map一样，输入也是一个函数跟一堆输入值，基本机制都差不多，勉强算是一种映射的形式，但输出总有差别——顾名思义，filter是过滤、筛选之意，满足条件的选择，不满足条件的抛弃。因此，输入函数（规则）的返回值，应当是True或者False</p>
<p>sorted，顾名思义，就“排序”之意，其输入是任意可迭代的对象，以及每个元素要拿来比较的值（key），还有是否逆序（reverse）的选项。清晰易懂。</p>
<p>说完这些，回到我们的需求：</p>
<ul>
<li>如果大于10， 输出字符串——这个数字大于10</li>
<li>如果小于等于10，输出字符串——这个数字小于等于10</li>
<li>被3整除的奇数不录入</li>
</ul>
<p>要解决这个需求，我们应当：</p>
<ol>
<li>先排个序，好看点——<code>sorted(input_list)</code></li>
<li>筛选数字——<code>filter(函数：输入值-&gt;是or不是被3整除奇数-&gt; False or True, 一堆输入值：第一步的输出)</code></li>
<li>根据大小输出字符串——<code>map(函数：输入值-&gt;大于10 | 小于10 -&gt; 输出啥啥啥, 一堆输入值：第二步的输出)</code></li>
</ol>
<p>然后串起来，就是这些啦：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">output = map(</span><br><span class="line">    <span class="keyword">lambda</span> x: <span class="string">'%d: 大于10！'</span> % x <span class="keyword">if</span> x &gt; <span class="number">10</span> <span class="keyword">else</span> <span class="string">'%d: 小于等于10！'</span> % x,</span><br><span class="line">    filter(</span><br><span class="line">        <span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> x % <span class="number">3</span> != <span class="number">0</span>,</span><br><span class="line">        sorted(input_list),</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>是不是很清晰？那就在以后码码的时候，多试试看这种style吧~</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>接触编程的同学们，总会听过两个词：面向对象编程（Object Oriented Programming）与函数式编程（Functional Programming），甚至有许多人鼓吹函数式编程，贬低面向对象云云，引起一番争论。</p>
<p>面向对象旨在把代码世界打造成我们熟悉的物以类（class）聚的现实世界。这样，整个代码架构就更容易被人理解，可维护性就更强了。因此，面向对象，是一个相对宏观的概念。</p>
<p>函数式编程，顾名思义，函数即为程序的基础。正如第一话所说的那样，函数，不仅是输入到输出的映射规则，而且就像活字印刷一样，是一个可复现的过程。因此，不管多长多短、多大多小的程序，都可以看做是一个或是多个函数的繁复联系，就比如说，咱们吃火龙果之后……采用函数式编程，能够极大增强程序的条理性，因此可以说，相对于面向对象，函数式编程是一个微观的概念。</p>
<p>面向对象与函数式编程，是你中有我、我中有你的关系，并不存在所谓的对立面。作为一个既支持面向对象又支持函数式编程的语言，Python还是很人性化滴！第二话虽然讲述的多是函数式编程相关的概念，但实际使用时，尤其代码量增大时，就需要应用面向对象的方法与设计模式，收拾一下你的项目啦~</p>
<p>实践出真知，希望咱们一起进步~</p>
]]></content>
      <categories>
        <category>Easy Python</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>python</tag>
        <tag>函数式编程</tag>
        <tag>高阶函数</tag>
        <tag>映射</tag>
      </tags>
  </entry>
  <entry>
    <title>【Lua杂谈】解锁lua代码覆盖率测试：luacov源码分析</title>
    <url>/2019/03/10/luatalk/luacov/</url>
    <content><![CDATA[<p>Lua 杂谈系列，就以代码覆盖率测试的 luacov 开头吧</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>说到 lua 的覆盖率测试，我们一般都会想到用<span class="exturl" data-url="aHR0cHM6LS1rZXBsZXJwcm9qZWN0LmdpdGh1Yi5pby9sdWFjb3YvaW5kZXguaHRtbA==" title="https:--keplerproject.github.io/luacov/index.html">luacov<i class="fa fa-external-link"></i></span>做代码覆盖率测试<br>在<span class="exturl" data-url="aHR0cHM6LS1ibG9nLmNzZG4ubmV0L080ZEM4T2pPN1pMNi9hcnRpY2xlL2RldGFpbHMvNzgzNzMxMTc=" title="https:--blog.csdn.net/O4dC8OjO7ZL6/article/details/78373117">干货｜使用 luacov 统计 lua 代码覆盖率<i class="fa fa-external-link"></i></span>一文中，介绍了基本的 luacov 用法，但是缺少对 luacov 深入挖掘的相关内容。并且同时，原生的 luacov 提供了一套简洁的覆盖率测试实现以及报告输出形式，但是在实际许多场景中，采用原生 luacov 还是远远满足不了需求的<br>因此，本文旨在通过分析 luacov 的实现，帮助希望了解 lua 代码覆盖率测试或是使用、二次开发 luacov 的同学尽快上手</p>
<h2 id="获取代码覆盖率数据"><a href="#获取代码覆盖率数据" class="headerlink" title="获取代码覆盖率数据"></a>获取代码覆盖率数据</h2><p>luacov 获取代码覆盖率数据，得益于 lua 自带的 debug 库。我们从 luacov 的主类 runner 中，可以一探究竟</p>
<a id="more"></a>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 初始化runner</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runner.init</span><span class="params">(configuration)</span></span></span><br><span class="line">    <span class="comment">-- 读取设置</span></span><br><span class="line">    runner.configuration = runner.load_config(configuration)</span><br><span class="line">    <span class="comment">-- 重载os.exit，在原生os.exit()前把剩下数据存掉，或者输出报告之类</span></span><br><span class="line">    <span class="built_in">os</span>.<span class="built_in">exit</span> = <span class="function"><span class="keyword">function</span><span class="params">(...)</span></span></span><br><span class="line">        on_exit()</span><br><span class="line">        raw_os_exit(...)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 在'l'事件加debug hook</span></span><br><span class="line">    <span class="built_in">debug</span>.<span class="built_in">sethook</span>(runner.debug_hook, <span class="string">"l"</span>)</span><br><span class="line">    <span class="comment">-- 如果每个thread都有独立的hook</span></span><br><span class="line">    <span class="keyword">if</span> has_hook_per_thread() <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 重载coroutine.create，打包函数之前先在'l'事件sethook</span></span><br><span class="line">        <span class="keyword">local</span> rawcoroutinecreate = coroutine.<span class="built_in">create</span></span><br><span class="line">        coroutine.<span class="built_in">create</span> = <span class="function"><span class="keyword">function</span><span class="params">(...)</span></span></span><br><span class="line">            <span class="keyword">local</span> co = rawcoroutinecreate(...)</span><br><span class="line">            <span class="built_in">debug</span>.<span class="built_in">sethook</span>(co, runner.debug_hook, <span class="string">"l"</span>)</span><br><span class="line">            <span class="keyword">return</span> co</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">-- coroutine.wrap用的error handler</span></span><br><span class="line">        <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">safeassert</span><span class="params">(ok, ...)</span></span></span><br><span class="line">            <span class="keyword">if</span> ok <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">return</span> ...</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">error</span>(..., <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">-- 重载coroutine.wrap，打包函数之前先在'l'事件sethook</span></span><br><span class="line">        coroutine.<span class="built_in">wrap</span> = <span class="function"><span class="keyword">function</span><span class="params">(...)</span></span></span><br><span class="line">            <span class="keyword">local</span> co = rawcoroutinecreate(...)</span><br><span class="line">            <span class="built_in">debug</span>.<span class="built_in">sethook</span>(co, runner.debug_hook, <span class="string">"l"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(...)</span></span></span><br><span class="line">                <span class="keyword">return</span> safeassert(coroutine.<span class="built_in">resume</span>(co, ...))</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>lua 的<code>debug.sethook([thread], hook, mask)</code>函数可以使得我们的 lua 脚本在运行过程中，遇到特定的条件（mask）时执行相应的函数（hook）。当 mask 为<code>&#39;l&#39;</code>时，表示 lua 脚本已经执行到了新的一行。因此，为了统计覆盖率，只需要在我们 hook<code>&#39;l&#39;</code>事件的函数中，寻找执行的文件和行号就好了</p>
<h2 id="hook-函数"><a href="#hook-函数" class="headerlink" title="hook 函数"></a>hook 函数</h2><p>在 luacov.runner 中，定义的 debug hook 为：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">runner.debug_hook = <span class="built_in">require</span>(cluacov_ok <span class="keyword">and</span> <span class="string">"cluacov.hook"</span> <span class="keyword">or</span> <span class="string">"luacov.hook"</span>).new(runner)</span><br></pre></td></tr></table></figure>
<p>因此我们可以以 luacov.hook 模块为例观察具体实现：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook.new</span><span class="params">(runner)</span></span></span><br><span class="line">    <span class="comment">-- 忽略的文件列表</span></span><br><span class="line">    <span class="keyword">local</span> ignored_files = &#123;&#125;</span><br><span class="line">    <span class="comment">-- hook执行的次数count</span></span><br><span class="line">    <span class="keyword">local</span> steps_after_save = <span class="number">0</span></span><br><span class="line">    <span class="comment">-- hook函数参数为(事件evt, 行数line_nr, 栈层次level)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(_, line_nr, level)</span></span></span><br><span class="line">        <span class="comment">-- level默认值为2</span></span><br><span class="line">        <span class="comment">-- 栈层次为1位调用hook的luacov，栈层次为2即为待测覆盖率的文件</span></span><br><span class="line">        level = level <span class="keyword">or</span> <span class="number">2</span></span><br><span class="line">        <span class="comment">-- 判断runner是否初始化</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> runner.initialized <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">-- 获取栈层次level的source源文件信息，即文件名</span></span><br><span class="line">        <span class="comment">-- 这个时候，我们就已经获得了想要的信息：文件名name与行数line_nr</span></span><br><span class="line">        <span class="keyword">local</span> name = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(level, <span class="string">"S"</span>).source</span><br><span class="line">        <span class="comment">-- 判断文件名前面有没@，以及是不是loadstring读取的（不然就不是文件名）</span></span><br><span class="line">        <span class="keyword">local</span> prefixed_name = <span class="built_in">string</span>.<span class="built_in">match</span>(name, <span class="string">"^@(.*)"</span>)</span><br><span class="line">        <span class="keyword">if</span> prefixed_name <span class="keyword">then</span></span><br><span class="line">            name = prefixed_name</span><br><span class="line">        <span class="keyword">elseif</span> <span class="keyword">not</span> runner.configuration.codefromstrings <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">-- 读取临时缓存runner.data里边的数据</span></span><br><span class="line">        <span class="keyword">local</span> data = runner.data</span><br><span class="line">        <span class="keyword">local</span> file = data[name]</span><br><span class="line">        <span class="comment">-- 判断该文件的数据是否要存储</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> file <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">if</span> ignored_files[name] <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">elseif</span> runner.file_included(name) <span class="keyword">then</span></span><br><span class="line">                file = &#123;<span class="built_in">max</span> = <span class="number">0</span>, max_hits = <span class="number">0</span>&#125;</span><br><span class="line">                data[name] = file</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ignored_files[name] = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">-- 修正该文件最大hit到的行数</span></span><br><span class="line">        <span class="keyword">if</span> line_nr &gt; file.<span class="built_in">max</span> <span class="keyword">then</span></span><br><span class="line">            file.<span class="built_in">max</span> = line_nr</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">-- 更新该文件行的hit数</span></span><br><span class="line">        <span class="keyword">local</span> hits = (file[line_nr] <span class="keyword">or</span> <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        file[line_nr] = hits</span><br><span class="line">        <span class="keyword">if</span> hits &gt; file.max_hits <span class="keyword">then</span></span><br><span class="line">            file.max_hits = hits</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">-- 判断tick步长，决定是否存储数据</span></span><br><span class="line">        <span class="keyword">if</span> runner.tick <span class="keyword">then</span></span><br><span class="line">            steps_after_save = steps_after_save + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> steps_after_save == runner.configuration.savestepsize <span class="keyword">then</span></span><br><span class="line">                steps_after_save = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> runner.paused <span class="keyword">then</span></span><br><span class="line">                    runner.save_stats()</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>可以看到整一个 hook 中最有价值的部分还是<code>local name = debug.getinfo(level, &quot;S&quot;).source</code>。lua 原生的 debug.getinfo 相较于 c api 的性能差，因此建议实际需求使用中引入<span class="exturl" data-url="aHR0cHM6LS1naXRodWIuY29tL0x1YURpc3QtdGVzdGluZy9jbHVhY292" title="https:--github.com/LuaDist-testing/cluacov">cluacov<i class="fa fa-external-link"></i></span>的 hook 模块作为 hook 函数</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>lua 覆盖率信息的收集，总体无非如我们在 luacov 所看到的：在<code>&#39;l&#39;</code>事件的 hook 函数中获取文件名与相应行数，然后保证每一个 lua 线程（协程）都能打上 hook。<br>luacov 实现总体而言也并不复杂，优化空间非常多，比如 save_stats()可以修改为 socket、websocket 一类实时传送数据，从而避免原生 luacov 设置 step 过小时导致报告文件 io 频繁，造成数据丢失。当然，有了网络传输，原配的很多参数都不需要了。<br>再深入一点，代码文件翻译成机器码，毕竟是状态机使然。如果细心观察 luacov 覆盖率的结果的话，会发现有很多该 hit 的行会 hit 不到。这些种种，就留待后续发掘啦~</p>
]]></content>
      <categories>
        <category>Lua杂谈</category>
      </categories>
      <tags>
        <tag>lua</tag>
        <tag>debug</tag>
        <tag>测试</tag>
        <tag>代码覆盖率</tag>
        <tag>luacov</tag>
      </tags>
  </entry>
  <entry>
    <title>【Easy Python】第一话：print(&#39;HelloWorld&#39;)——输入、输出与函数</title>
    <url>/2019/03/09/easypython/i/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个年代，连小学生都会Python了，我家领导还是一行代码都打不出。<br>网上的Python教程一抓一大把，但出于让人更加深刻理解以及实用的目的（尤其是我家领导），Easy Python，开始挖坑！</p>
<h2 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h2><p>这个没有教程= =，请安装3.*最新版Python<br>编辑器建议为vscode 、sublime之类（记得装插件），如若觉得装插件烦可直接上pycharm<br>Easy Python系列不展现实时交互式命令~</p>
<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>学程序的第一行代码，大概都是Hello World吧！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Hello World!'</span>)</span><br></pre></td></tr></table></figure>
<p>然后命令行里，就会输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
<p>那如果要打出1行100个Hello World的话，该怎么办呢？<br>如果这样的话：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    print(<span class="string">'Hello World'</span>)</span><br></pre></td></tr></table></figure>
<p>试试看，会打出100行HelloWorld，不符合我们的需求<br>这个时候，该怎么办？</p>
<a id="more"></a>
<h3 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h3><p>程序本质就是：输入 -&gt; 函数（function）-&gt;输出。输入的raw data，经由一个叫函数的东西处理，就能输出我们想要的数据。<br>如果一个函数，没有输入输出，也没关系。这样，函数就单纯是一个数据处理过程而已了。</p>
<p>在先前的HelloWorld，就似乎是这么一个结构：</p>
<ul>
<li>输入：Hello World</li>
<li>函数：print</li>
<li>输出：命令行中打出Hello World</li>
</ul>
<p>所以，咱们可以从函数入手：可不可以定制一下print，让咱们的Hello World能够打出来不换行呢？<br>看一看print这个函数（function）的源码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print</span><span class="params">(self, *args, sep=<span class="string">' '</span>, end=<span class="string">'\n'</span>, file=None)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>可以看到，print函数有个end=’\n’的参数。顾名思义，每次print一下，输出的字符串结尾都有一个’\n’。’\n’是换行符，那么就说明，单纯的print100下，就会出100行HelloWorld嘞<br>因此，要解决咱们的需求也很简单，指定end为不换行，覆盖掉默认参数就好了~</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    print(<span class="string">'Hello World'</span>, end=<span class="string">'; '</span>)</span><br></pre></td></tr></table></figure>
<p>试试看吧~</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数，function，就像活字印刷的活字跟流水线上的机械处理器一样，是可以复用的处理过程，是通用的功能。<br>函数的输入叫做<strong>参数</strong>（arguments, args）；函数的输出可称作<strong>返回</strong>（return）。<br>print就是一个最典型的函数，我们写代码时常常print数据出来调试。print函数，就是这么实用。<br>现在让我们再次回顾一下print的函数怎么定义的（def），这回，咱们把注释也给打出来~</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print</span><span class="params">(self, *args, sep=<span class="string">' '</span>, end=<span class="string">'\n'</span>, file=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)</span></span><br><span class="line"><span class="string">    Prints the values to a stream, or to sys.stdout by default.</span></span><br><span class="line"><span class="string">    Optional keyword arguments:</span></span><br><span class="line"><span class="string">    file:  a file-like object (stream); defaults to the current sys.stdout.</span></span><br><span class="line"><span class="string">    sep:   string inserted between values, default a space.</span></span><br><span class="line"><span class="string">    end:   string appended after the last value, default a newline.</span></span><br><span class="line"><span class="string">    flush: whether to forcibly flush the stream.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>我们可以看到，print函数中，规定了这么些参数：*args, sep, end, file</p>
<p>首先咱们来看第一个参数——*args。顾名思义，就是一堆参数（arguments）的称呼。参数开头为单星号*，就代表这是一堆<strong>无关键字参数</strong>，就叫“无名参数”好啦<br>而像sep=xxx, end=xxx之类的，都是<strong>参数名=参数值</strong>的结构，它们就叫——<strong>关键字参数</strong>（keyword arguments, kwargs），如果要表示一堆关键字参数，我们可以用：**kwargs</p>
<p>说了这么些，不如咱们来试试输入：我爱你</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Wo'</span>, <span class="string">'Ai'</span>, <span class="string">'Ni'</span>)</span><br></pre></td></tr></table></figure>
<p>输入了三个无名参数，结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Wo Ai Ni</span><br></pre></td></tr></table></figure>
<p>可以看到，三个无名参数都被打出来了，都被空格分隔。这个时候，我们就知道sep参数（separator）的作用了。所以，让我爱你不分隔的方法是~</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Wo'</span>, <span class="string">'Ai'</span>, <span class="string">'Ni'</span>, sep=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WoAiNi</span><br></pre></td></tr></table></figure>
<p>最后一个file参数，指定了我们在哪里print出结果。默认值是sys.stdout，标准输出流，咱们在cmd小黑框里常看见的那些白字就是里边出来的啦。<br>不如，咱们试试把WoAiNi打进文件里？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认file=sys.stdout，系统标准输出流</span></span><br><span class="line"><span class="comment"># 因此要自定义file，则应当要赋予同类型的参数</span></span><br><span class="line"><span class="comment"># file应该指定成一个输出流，类似一个数据写入通道</span></span><br><span class="line"><span class="comment"># python内置了open('文件名', 'w')的方法，可以创造一个文件的写入流</span></span><br><span class="line"><span class="comment"># 其中'w'代表write，即写入模式</span></span><br><span class="line"><span class="comment"># 可不能单纯file='woaini.txt'喔，怎么能赋一个字符串上去惹</span></span><br><span class="line">print(<span class="string">'Wo'</span>, <span class="string">'Ai'</span>, <span class="string">'Ni'</span>, sep=<span class="string">''</span>, file=open(<span class="string">'woaini.txt'</span>, <span class="string">'w'</span>))</span><br></pre></td></tr></table></figure>
<p>打开python文件同目录下，是不是多了一个woaini.txt啦~快去瞧瞧吧！</p>
<h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><p>说到这么多，print的返回值，真的是上面所说的”命令行中打出Hello World”嘛<br>当然不是拉= =<br>我们其实可以用print打一下print的返回值，了解一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = print(<span class="string">'woaini'</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">woaini</span><br><span class="line">None</span><br></pre></td></tr></table></figure>
<p>在python里，None是一个抽象的符号，是python内置的关键字（不是函数的关键字！），代表无，没有数据。<br>也就是说，print，返回了None。<br>so，命令行的输出算什么呢？<br>我们再拿个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    print(<span class="string">'woaini'</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">print(func(a, b))</span><br></pre></td></tr></table></figure>
<p>打出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">woaini</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>可以看到，最下边的print，要打出函数func(a, b)的结果，因此先执行func。在执行func的期间，打出了woaini。然后才返回了x + y的结果。之后，才打出来1+1的结果，等于2。<br>可以看到，我们要根据return才知道函数返回什么，其它部分的输出都只是函数过程的副产物。没有return，就默认返回None。<br>因此整个print的过程，我们可以总结为：</p>
<ul>
<li>参数：自定义参数（*args, sep之类）、print的默认参数</li>
<li>函数：print</li>
<li>过程：打出Hello World到标准输出流中，使得我们在命令行看到</li>
<li>返回：None</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>函数无处不在，不仅是print，就连你执行的python脚本，本身也可以当做一个函数。<br>我们建一个文件：1.py，里面内容为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入内置的“系统功能”模块：sys</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># print出执行1.py的参数</span></span><br><span class="line">print(sys.argv)</span><br></pre></td></tr></table></figure>
<p>然后，cmd命令行里进到1.py目录下，输入python 1.py 123 abc qwer gogo aini看看结果吧~</p>
<hr>
<p>至于第一话的意识流——输入、输出与函数，其实是个超级大坑，不是三言两语能够说清楚的。但是，我希望能够创造这样一个效果，让我们阅读代码跟阅读普通英文文章一样顺畅，让我亲爱的领导在参阅我的文章之后，能对码代码有新的认知与想法！</p>
<p>通篇文章，暂且一气呵成，有叙述不妥之处，欢迎指正！</p>
]]></content>
      <categories>
        <category>Easy Python</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>python</tag>
        <tag>函数</tag>
        <tag>输入</tag>
        <tag>输出</tag>
      </tags>
  </entry>
</search>
